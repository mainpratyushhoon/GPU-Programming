#pragma section("__nv_managed_data__")
static char __nv_inited_managed_rt = 0; static void **__nv_fatbinhandle_for_managed_rt; static void __nv_save_fatbinhandle_for_managed_rt(void **in){__nv_fatbinhandle_for_managed_rt = in;} static char __nv_init_managed_rt_with_module(void **); static inline void __nv_init_managed_rt(void) { __nv_inited_managed_rt = (__nv_inited_managed_rt ? __nv_inited_managed_rt                 : __nv_init_managed_rt_with_module(__nv_fatbinhandle_for_managed_rt));}
#line 1 "main.cu"
#define __nv_is_extended_device_lambda_closure_type(X) false
#define __nv_is_extended_host_device_lambda_closure_type(X) false
#define __nv_is_extended_device_lambda_with_preserved_return_type(X) false
#if defined(__nv_is_extended_device_lambda_closure_type) && defined(__nv_is_extended_host_device_lambda_closure_type)&& defined(__nv_is_extended_device_lambda_with_preserved_return_type)
#endif

#line 1
#line 67 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\bin/../include\\cuda_runtime.h"
#pragma warning(push)
#pragma warning(disable: 4820)
#line 708 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"
#pragma region Input Buffer SAL 1 compatibility macros
#line 1472
#pragma endregion Input Buffer SAL 1 compatibility macros
#line 2361 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"
extern "C" {
#line 2971 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"
}
#line 22 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\concurrencysal.h"
extern "C" {
#line 391 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\concurrencysal.h"
}
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"
#pragma pack ( push, 8 )
#line 47 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 51
extern "C" {
#line 61 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"
typedef unsigned __int64 uintptr_t; 
#line 72 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"
typedef char *va_list; 
#line 155 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"
void __cdecl __va_start(va_list *, ...); 
#line 167 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"
}
#line 171 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"
extern "C++" {
#line 173
template< class _Ty> 
#line 174
struct __vcrt_va_list_is_reference { 
#line 176
enum: bool { __the_value}; 
#line 177
}; 
#line 179
template< class _Ty> 
#line 180
struct __vcrt_va_list_is_reference< _Ty &>  { 
#line 182
enum: bool { __the_value = '\001'}; 
#line 183
}; 
#line 185
template< class _Ty> 
#line 186
struct __vcrt_va_list_is_reference< _Ty &&>  { 
#line 188
enum: bool { __the_value = '\001'}; 
#line 189
}; 
#line 191
template< class _Ty> 
#line 192
struct __vcrt_assert_va_start_is_not_reference { 
#line 194
static_assert((!__vcrt_va_list_is_reference< _Ty> ::__the_value), "va_start argument must not have reference type and must not be parenthesized");
#line 196
}; 
#line 197
}
#line 207 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"
#pragma warning(pop)
#pragma pack ( pop )
#line 60 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 96 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 188 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
typedef unsigned __int64 size_t; 
#if !defined(__CUDA_INCLUDE_COMPILER_INTERNAL_HEADERS__)
#define __CUDA_INCLUDE_COMPILER_INTERNAL_HEADERS__
#endif
#include "crt/host_runtime.h"
#line 189
typedef __int64 ptrdiff_t; 
#line 190
typedef __int64 intptr_t; 
#line 198 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
typedef bool __vcrt_bool; 
#line 245 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
extern "C++" {
#line 247
template< class _CountofType, size_t _SizeOfArray> char (*__countof_helper(__unaligned _CountofType (& _Array)[_SizeOfArray]))[_SizeOfArray]; 
#line 251
}
#line 390 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
void __cdecl __security_init_cookie(); 
#line 399 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
void __cdecl __security_check_cookie(uintptr_t _StackCookie); 
#line 400
__declspec(noreturn) void __cdecl __report_gsfailure(uintptr_t _StackCookie); 
#line 404 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
extern uintptr_t __security_cookie; 
#line 412 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
}__pragma( pack ( pop )) 
#line 414
#pragma warning(pop)
#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 125
__pragma( pack ( push, 8 )) extern "C" {
#line 254 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt.h"
extern "C++" {
#line 256
template< bool _Enable, class _Ty> struct _CrtEnableIf; 
#line 259
template< class _Ty> 
#line 260
struct _CrtEnableIf< true, _Ty>  { 
#line 262
typedef _Ty _Type; 
#line 263
}; 
#line 264
}
#line 268 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt.h"
typedef bool __crt_bool; 
#line 371 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt.h"
void __cdecl _invalid_parameter_noinfo(); 
#line 372
__declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(); 
#line 374
__declspec(noreturn) void __cdecl 
#line 375
_invoke_watson(const __wchar_t * _Expression, const __wchar_t * _FunctionName, const __wchar_t * _FileName, unsigned _LineNo, uintptr_t _Reserved); 
#line 604 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt.h"
typedef int errno_t; 
#line 605
typedef unsigned short wint_t; 
#line 606
typedef unsigned short wctype_t; 
#line 607
typedef long __time32_t; 
#line 608
typedef __int64 __time64_t; 
#line 615
typedef 
#line 610
struct __crt_locale_data_public { 
#line 612
const unsigned short *_locale_pctype; 
#line 613
int _locale_mb_cur_max; 
#line 614
unsigned _locale_lc_codepage; 
#line 615
} __crt_locale_data_public; 
#line 621
typedef 
#line 617
struct __crt_locale_pointers { 
#line 619
struct __crt_locale_data *locinfo; 
#line 620
struct __crt_multibyte_data *mbcinfo; 
#line 621
} __crt_locale_pointers; 
#line 623
typedef __crt_locale_pointers *_locale_t; 
#line 629
typedef 
#line 625
struct _Mbstatet { 
#line 627
unsigned long _Wchar; 
#line 628
unsigned short _Byte, _State; 
#line 629
} _Mbstatet; 
#line 631
typedef _Mbstatet mbstate_t; 
#line 645 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt.h"
typedef __time64_t time_t; 
#line 655 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt.h"
typedef size_t rsize_t; 
#line 2072 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt.h"
}__pragma( pack ( pop )) 
#line 2075
#pragma warning(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wctype.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 17
__pragma( pack ( push, 8 )) extern "C" {
#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wctype.h"
const unsigned short *__cdecl __pctype_func(); 
#line 36
const wctype_t *__cdecl __pwctype_func(); 
#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wctype.h"
int __cdecl iswalnum(wint_t _C); 
#line 68
int __cdecl iswalpha(wint_t _C); 
#line 69
int __cdecl iswascii(wint_t _C); 
#line 70
int __cdecl iswblank(wint_t _C); 
#line 71
int __cdecl iswcntrl(wint_t _C); 
#line 74
int __cdecl iswdigit(wint_t _C); 
#line 76
int __cdecl iswgraph(wint_t _C); 
#line 77
int __cdecl iswlower(wint_t _C); 
#line 78
int __cdecl iswprint(wint_t _C); 
#line 79
int __cdecl iswpunct(wint_t _C); 
#line 80
int __cdecl iswspace(wint_t _C); 
#line 81
int __cdecl iswupper(wint_t _C); 
#line 82
int __cdecl iswxdigit(wint_t _C); 
#line 83
int __cdecl __iswcsymf(wint_t _C); 
#line 84
int __cdecl __iswcsym(wint_t _C); 
#line 86
int __cdecl _iswalnum_l(wint_t _C, _locale_t _Locale); 
#line 87
int __cdecl _iswalpha_l(wint_t _C, _locale_t _Locale); 
#line 88
int __cdecl _iswblank_l(wint_t _C, _locale_t _Locale); 
#line 89
int __cdecl _iswcntrl_l(wint_t _C, _locale_t _Locale); 
#line 90
int __cdecl _iswdigit_l(wint_t _C, _locale_t _Locale); 
#line 91
int __cdecl _iswgraph_l(wint_t _C, _locale_t _Locale); 
#line 92
int __cdecl _iswlower_l(wint_t _C, _locale_t _Locale); 
#line 93
int __cdecl _iswprint_l(wint_t _C, _locale_t _Locale); 
#line 94
int __cdecl _iswpunct_l(wint_t _C, _locale_t _Locale); 
#line 95
int __cdecl _iswspace_l(wint_t _C, _locale_t _Locale); 
#line 96
int __cdecl _iswupper_l(wint_t _C, _locale_t _Locale); 
#line 97
int __cdecl _iswxdigit_l(wint_t _C, _locale_t _Locale); 
#line 98
int __cdecl _iswcsymf_l(wint_t _C, _locale_t _Locale); 
#line 99
int __cdecl _iswcsym_l(wint_t _C, _locale_t _Locale); 
#line 102
wint_t __cdecl towupper(wint_t _C); 
#line 103
wint_t __cdecl towlower(wint_t _C); 
#line 104
int __cdecl iswctype(wint_t _C, wctype_t _Type); 
#line 106
wint_t __cdecl _towupper_l(wint_t _C, _locale_t _Locale); 
#line 107
wint_t __cdecl _towlower_l(wint_t _C, _locale_t _Locale); 
#line 108
int __cdecl _iswctype_l(wint_t _C, wctype_t _Type, _locale_t _Locale); 
#line 112
int __cdecl isleadbyte(int _C); 
#line 113
int __cdecl _isleadbyte_l(int _C, _locale_t _Locale); 
#line 115
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using iswctype instea" "d. See online help for details.")) int __cdecl is_wctype(wint_t _C, wctype_t _Type); 
#line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wctype.h"
}__pragma( pack ( pop )) 
#line 205
#pragma warning(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\ctype.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 19
__pragma( pack ( push, 8 )) extern "C" {
#line 29
int __cdecl _isctype(int _C, int _Type); 
#line 30
int __cdecl _isctype_l(int _C, int _Type, _locale_t _Locale); 
#line 31
int __cdecl isalpha(int _C); 
#line 32
int __cdecl _isalpha_l(int _C, _locale_t _Locale); 
#line 33
int __cdecl isupper(int _C); 
#line 34
int __cdecl _isupper_l(int _C, _locale_t _Locale); 
#line 35
int __cdecl islower(int _C); 
#line 36
int __cdecl _islower_l(int _C, _locale_t _Locale); 
#line 39
int __cdecl isdigit(int _C); 
#line 41
int __cdecl _isdigit_l(int _C, _locale_t _Locale); 
#line 42
int __cdecl isxdigit(int _C); 
#line 43
int __cdecl _isxdigit_l(int _C, _locale_t _Locale); 
#line 46
int __cdecl isspace(int _C); 
#line 48
int __cdecl _isspace_l(int _C, _locale_t _Locale); 
#line 49
int __cdecl ispunct(int _C); 
#line 50
int __cdecl _ispunct_l(int _C, _locale_t _Locale); 
#line 51
int __cdecl isblank(int _C); 
#line 52
int __cdecl _isblank_l(int _C, _locale_t _Locale); 
#line 53
int __cdecl isalnum(int _C); 
#line 54
int __cdecl _isalnum_l(int _C, _locale_t _Locale); 
#line 55
int __cdecl isprint(int _C); 
#line 56
int __cdecl _isprint_l(int _C, _locale_t _Locale); 
#line 57
int __cdecl isgraph(int _C); 
#line 58
int __cdecl _isgraph_l(int _C, _locale_t _Locale); 
#line 59
int __cdecl iscntrl(int _C); 
#line 60
int __cdecl _iscntrl_l(int _C, _locale_t _Locale); 
#line 63
int __cdecl toupper(int _C); 
#line 66
int __cdecl tolower(int _C); 
#line 68
int __cdecl _tolower(int _C); 
#line 69
int __cdecl _tolower_l(int _C, _locale_t _Locale); 
#line 70
int __cdecl _toupper(int _C); 
#line 71
int __cdecl _toupper_l(int _C, _locale_t _Locale); 
#line 73
int __cdecl __isascii(int _C); 
#line 74
int __cdecl __toascii(int _C); 
#line 75
int __cdecl __iscsymf(int _C); 
#line 76
int __cdecl __iscsym(int _C); 
#line 85
__inline int __cdecl __acrt_locale_get_ctype_array_value(const unsigned short *const 
#line 86
_Locale_pctype_array, const int 
#line 87
_Char_value, const int 
#line 88
_Mask) 
#line 90
{ 
#line 96
if ((_Char_value >= (-1)) && (_Char_value <= 255)) 
#line 97
{ 
#line 98
return (_Locale_pctype_array[_Char_value]) & _Mask; 
#line 99
}  
#line 101
return 0; 
#line 102
} 
#line 124 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\ctype.h"
int __cdecl ___mb_cur_max_func(); 
#line 126
int __cdecl ___mb_cur_max_l_func(_locale_t _Locale); 
#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\ctype.h"
__forceinline int __cdecl __ascii_tolower(const int _C) 
#line 153
{ 
#line 154
if ((_C >= ('A')) && (_C <= ('Z'))) 
#line 155
{ 
#line 156
return _C - (('A') - ('a')); 
#line 157
}  
#line 158
return _C; 
#line 159
} 
#line 161
__forceinline int __cdecl __ascii_toupper(const int _C) 
#line 162
{ 
#line 163
if ((_C >= ('a')) && (_C <= ('z'))) 
#line 164
{ 
#line 165
return _C - (('a') - ('A')); 
#line 166
}  
#line 167
return _C; 
#line 168
} 
#line 170
__forceinline int __cdecl __ascii_iswalpha(const int _C) 
#line 171
{ 
#line 172
return ((_C >= ('A')) && (_C <= ('Z'))) || ((_C >= ('a')) && (_C <= ('z'))); 
#line 173
} 
#line 175
__forceinline int __cdecl __ascii_iswdigit(const int _C) 
#line 176
{ 
#line 177
return (_C >= ('0')) && (_C <= ('9')); 
#line 178
} 
#line 180
__forceinline int __cdecl __ascii_towlower(const int _C) 
#line 181
{ 
#line 182
return __ascii_tolower(_C); 
#line 183
} 
#line 185
__forceinline int __cdecl __ascii_towupper(const int _C) 
#line 186
{ 
#line 187
return __ascii_toupper(_C); 
#line 188
} 
#line 208 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\ctype.h"
__inline __crt_locale_data_public *__cdecl __acrt_get_locale_data_prefix(const volatile void *const _LocalePointers) 
#line 209
{ 
#line 210
const _locale_t _TypedLocalePointers = (_locale_t)_LocalePointers; 
#line 211
return (__crt_locale_data_public *)(_TypedLocalePointers->locinfo); 
#line 212
} 
#line 218
__inline int __cdecl _chvalidchk_l(const int 
#line 219
_C, const int 
#line 220
_Mask, const _locale_t 
#line 221
_Locale) 
#line 223
{ 
#line 227
if (!_Locale) 
#line 228
{ 
#line 229
return __acrt_locale_get_ctype_array_value(__pctype_func(), _C, _Mask); 
#line 230
}  
#line 232
return __acrt_locale_get_ctype_array_value(__acrt_get_locale_data_prefix(_Locale)->_locale_pctype, _C, _Mask); 
#line 234 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\ctype.h"
} 
#line 239
__inline int __cdecl _ischartype_l(const int 
#line 240
_C, const int 
#line 241
_Mask, const _locale_t 
#line 242
_Locale) 
#line 244
{ 
#line 245
if (!_Locale) 
#line 246
{ 
#line 247
return _chvalidchk_l(_C, _Mask, 0); 
#line 248
}  
#line 250
if ((_C >= (-1)) && (_C <= 255)) 
#line 251
{ 
#line 252
return ((__acrt_get_locale_data_prefix(_Locale)->_locale_pctype)[_C]) & _Mask; 
#line 253
}  
#line 255
if ((__acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max) > 1) 
#line 256
{ 
#line 257
return _isctype_l(_C, _Mask, _Locale); 
#line 258
}  
#line 260
return 0; 
#line 261
} 
#line 307 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\ctype.h"
}__pragma( pack ( pop )) 
#line 309
#pragma warning(pop)
#line 68 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_types.h"
#if 0
#line 68
enum cudaRoundMode { 
#line 70
cudaRoundNearest, 
#line 71
cudaRoundZero, 
#line 72
cudaRoundPosInf, 
#line 73
cudaRoundMinInf
#line 74
}; 
#endif
#line 104 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 104
struct char1 { 
#line 106
signed char x; 
#line 107
}; 
#endif
#line 109 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 109
struct uchar1 { 
#line 111
unsigned char x; 
#line 112
}; 
#endif
#line 115 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 115
struct __declspec(align(2)) char2 { 
#line 117
signed char x, y; 
#line 118
}; 
#endif
#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 120
struct __declspec(align(2)) uchar2 { 
#line 122
unsigned char x, y; 
#line 123
}; 
#endif
#line 125 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 125
struct char3 { 
#line 127
signed char x, y, z; 
#line 128
}; 
#endif
#line 130 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 130
struct uchar3 { 
#line 132
unsigned char x, y, z; 
#line 133
}; 
#endif
#line 135 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 135
struct __declspec(align(4)) char4 { 
#line 137
signed char x, y, z, w; 
#line 138
}; 
#endif
#line 140 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 140
struct __declspec(align(4)) uchar4 { 
#line 142
unsigned char x, y, z, w; 
#line 143
}; 
#endif
#line 145 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 145
struct short1 { 
#line 147
short x; 
#line 148
}; 
#endif
#line 150 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 150
struct ushort1 { 
#line 152
unsigned short x; 
#line 153
}; 
#endif
#line 155 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 155
struct __declspec(align(4)) short2 { 
#line 157
short x, y; 
#line 158
}; 
#endif
#line 160 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 160
struct __declspec(align(4)) ushort2 { 
#line 162
unsigned short x, y; 
#line 163
}; 
#endif
#line 165 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 165
struct short3 { 
#line 167
short x, y, z; 
#line 168
}; 
#endif
#line 170 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 170
struct ushort3 { 
#line 172
unsigned short x, y, z; 
#line 173
}; 
#endif
#line 175 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 175
struct __declspec(align(8)) short4 { short x; short y; short z; short w; }; 
#endif
#line 176 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 176
struct __declspec(align(8)) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; }; 
#endif
#line 178 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 178
struct int1 { 
#line 180
int x; 
#line 181
}; 
#endif
#line 183 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 183
struct uint1 { 
#line 185
unsigned x; 
#line 186
}; 
#endif
#line 188 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 188
struct __declspec(align(8)) int2 { int x; int y; }; 
#endif
#line 189 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 189
struct __declspec(align(8)) uint2 { unsigned x; unsigned y; }; 
#endif
#line 191 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 191
struct int3 { 
#line 193
int x, y, z; 
#line 194
}; 
#endif
#line 196 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 196
struct uint3 { 
#line 198
unsigned x, y, z; 
#line 199
}; 
#endif
#line 201 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 201
struct __declspec(align(16)) int4 { 
#line 203
int x, y, z, w; 
#line 204
}; 
#endif
#line 206 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 206
struct __declspec(align(16)) uint4 { 
#line 208
unsigned x, y, z, w; 
#line 209
}; 
#endif
#line 211 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 211
struct long1 { 
#line 213
long x; 
#line 214
}; 
#endif
#line 216 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 216
struct ulong1 { 
#line 218
unsigned long x; 
#line 219
}; 
#endif
#line 222 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 222
struct __declspec(align(8)) long2 { long x; long y; }; 
#endif
#line 223 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 223
struct __declspec(align(8)) ulong2 { unsigned long x; unsigned long y; }; 
#endif
#line 238 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 238
struct long3 { 
#line 240
long x, y, z; 
#line 241
}; 
#endif
#line 243 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 243
struct ulong3 { 
#line 245
unsigned long x, y, z; 
#line 246
}; 
#endif
#line 248 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 248
struct __declspec(align(16)) long4 { 
#line 250
long x, y, z, w; 
#line 251
}; 
#endif
#line 253 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 253
struct __declspec(align(16)) ulong4 { 
#line 255
unsigned long x, y, z, w; 
#line 256
}; 
#endif
#line 258 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 258
struct float1 { 
#line 260
float x; 
#line 261
}; 
#endif
#line 280 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 280
struct __declspec(align(8)) float2 { float x; float y; }; 
#endif
#line 285 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 285
struct float3 { 
#line 287
float x, y, z; 
#line 288
}; 
#endif
#line 290 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 290
struct __declspec(align(16)) float4 { 
#line 292
float x, y, z, w; 
#line 293
}; 
#endif
#line 295 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 295
struct longlong1 { 
#line 297
__int64 x; 
#line 298
}; 
#endif
#line 300 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 300
struct ulonglong1 { 
#line 302
unsigned __int64 x; 
#line 303
}; 
#endif
#line 305 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 305
struct __declspec(align(16)) longlong2 { 
#line 307
__int64 x, y; 
#line 308
}; 
#endif
#line 310 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 310
struct __declspec(align(16)) ulonglong2 { 
#line 312
unsigned __int64 x, y; 
#line 313
}; 
#endif
#line 315 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 315
struct longlong3 { 
#line 317
__int64 x, y, z; 
#line 318
}; 
#endif
#line 320 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 320
struct ulonglong3 { 
#line 322
unsigned __int64 x, y, z; 
#line 323
}; 
#endif
#line 325 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 325
struct __declspec(align(16)) longlong4 { 
#line 327
__int64 x, y, z, w; 
#line 328
}; 
#endif
#line 330 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 330
struct __declspec(align(16)) ulonglong4 { 
#line 332
unsigned __int64 x, y, z, w; 
#line 333
}; 
#endif
#line 335 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 335
struct double1 { 
#line 337
double x; 
#line 338
}; 
#endif
#line 340 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 340
struct __declspec(align(16)) double2 { 
#line 342
double x, y; 
#line 343
}; 
#endif
#line 345 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 345
struct double3 { 
#line 347
double x, y, z; 
#line 348
}; 
#endif
#line 350 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 350
struct __declspec(align(16)) double4 { 
#line 352
double x, y, z, w; 
#line 353
}; 
#endif
#line 367 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef char1 
#line 367
char1; 
#endif
#line 368 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef uchar1 
#line 368
uchar1; 
#endif
#line 369 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef char2 
#line 369
char2; 
#endif
#line 370 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef uchar2 
#line 370
uchar2; 
#endif
#line 371 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef char3 
#line 371
char3; 
#endif
#line 372 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef uchar3 
#line 372
uchar3; 
#endif
#line 373 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef char4 
#line 373
char4; 
#endif
#line 374 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef uchar4 
#line 374
uchar4; 
#endif
#line 375 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef short1 
#line 375
short1; 
#endif
#line 376 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef ushort1 
#line 376
ushort1; 
#endif
#line 377 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef short2 
#line 377
short2; 
#endif
#line 378 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef ushort2 
#line 378
ushort2; 
#endif
#line 379 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef short3 
#line 379
short3; 
#endif
#line 380 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef ushort3 
#line 380
ushort3; 
#endif
#line 381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef short4 
#line 381
short4; 
#endif
#line 382 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef ushort4 
#line 382
ushort4; 
#endif
#line 383 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef int1 
#line 383
int1; 
#endif
#line 384 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef uint1 
#line 384
uint1; 
#endif
#line 385 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef int2 
#line 385
int2; 
#endif
#line 386 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef uint2 
#line 386
uint2; 
#endif
#line 387 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef int3 
#line 387
int3; 
#endif
#line 388 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef uint3 
#line 388
uint3; 
#endif
#line 389 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef int4 
#line 389
int4; 
#endif
#line 390 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef uint4 
#line 390
uint4; 
#endif
#line 391 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef long1 
#line 391
long1; 
#endif
#line 392 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef ulong1 
#line 392
ulong1; 
#endif
#line 393 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef long2 
#line 393
long2; 
#endif
#line 394 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef ulong2 
#line 394
ulong2; 
#endif
#line 395 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef long3 
#line 395
long3; 
#endif
#line 396 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef ulong3 
#line 396
ulong3; 
#endif
#line 397 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef long4 
#line 397
long4; 
#endif
#line 398 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef ulong4 
#line 398
ulong4; 
#endif
#line 399 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef float1 
#line 399
float1; 
#endif
#line 400 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef float2 
#line 400
float2; 
#endif
#line 401 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef float3 
#line 401
float3; 
#endif
#line 402 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef float4 
#line 402
float4; 
#endif
#line 403 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef longlong1 
#line 403
longlong1; 
#endif
#line 404 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef ulonglong1 
#line 404
ulonglong1; 
#endif
#line 405 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef longlong2 
#line 405
longlong2; 
#endif
#line 406 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef ulonglong2 
#line 406
ulonglong2; 
#endif
#line 407 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef longlong3 
#line 407
longlong3; 
#endif
#line 408 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef ulonglong3 
#line 408
ulonglong3; 
#endif
#line 409 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef longlong4 
#line 409
longlong4; 
#endif
#line 410 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef ulonglong4 
#line 410
ulonglong4; 
#endif
#line 411 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef double1 
#line 411
double1; 
#endif
#line 412 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef double2 
#line 412
double2; 
#endif
#line 413 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef double3 
#line 413
double3; 
#endif
#line 414 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef double4 
#line 414
double4; 
#endif
#line 426 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
#line 426
struct dim3 { 
#line 428
unsigned x, y, z; 
#line 443 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
}; 
#endif
#line 445 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_types.h"
#if 0
typedef dim3 
#line 445
dim3; 
#endif
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\limits.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 16
__pragma( pack ( push, 8 )) extern "C" {
#line 74 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\limits.h"
}__pragma( pack ( pop )) 
#line 76
#pragma warning(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stddef.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 18
__pragma( pack ( push, 8 )) extern "C" {
#line 23
namespace std { 
#line 25
typedef decltype(nullptr) nullptr_t; 
#line 26
}
#line 28
using std::nullptr_t;
#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stddef.h"
int *__cdecl _errno(); 
#line 38
errno_t __cdecl _set_errno(int _Value); 
#line 39
errno_t __cdecl _get_errno(int * _Value); 
#line 55 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stddef.h"
extern unsigned long __cdecl __threadid(); 
#line 57
extern uintptr_t __cdecl __threadhandle(); 
#line 61
}__pragma( pack ( pop )) 
#line 63
#pragma warning(pop)
#line 205 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 205
enum cudaError { 
#line 212
cudaSuccess, 
#line 218
cudaErrorInvalidValue, 
#line 224
cudaErrorMemoryAllocation, 
#line 230
cudaErrorInitializationError, 
#line 237
cudaErrorCudartUnloading, 
#line 244
cudaErrorProfilerDisabled, 
#line 252
cudaErrorProfilerNotInitialized, 
#line 259
cudaErrorProfilerAlreadyStarted, 
#line 266
cudaErrorProfilerAlreadyStopped, 
#line 274
cudaErrorInvalidConfiguration, 
#line 280
cudaErrorInvalidPitchValue = 12, 
#line 286
cudaErrorInvalidSymbol, 
#line 294
cudaErrorInvalidHostPointer = 16, 
#line 302
cudaErrorInvalidDevicePointer, 
#line 307
cudaErrorInvalidTexture, 
#line 313
cudaErrorInvalidTextureBinding, 
#line 320
cudaErrorInvalidChannelDescriptor, 
#line 326
cudaErrorInvalidMemcpyDirection, 
#line 336
cudaErrorAddressOfConstant, 
#line 345
cudaErrorTextureFetchFailed, 
#line 354
cudaErrorTextureNotBound, 
#line 363
cudaErrorSynchronizationError, 
#line 368
cudaErrorInvalidFilterSetting, 
#line 374
cudaErrorInvalidNormSetting, 
#line 382
cudaErrorMixedDeviceExecution, 
#line 390
cudaErrorNotYetImplemented = 31, 
#line 399
cudaErrorMemoryValueTooLarge, 
#line 405
cudaErrorStubLibrary = 34, 
#line 412
cudaErrorInsufficientDriver, 
#line 419
cudaErrorCallRequiresNewerDriver, 
#line 425
cudaErrorInvalidSurface, 
#line 431
cudaErrorDuplicateVariableName = 43, 
#line 437
cudaErrorDuplicateTextureName, 
#line 443
cudaErrorDuplicateSurfaceName, 
#line 453
cudaErrorDevicesUnavailable, 
#line 466
cudaErrorIncompatibleDriverContext = 49, 
#line 472
cudaErrorMissingConfiguration = 52, 
#line 481
cudaErrorPriorLaunchFailure, 
#line 487
cudaErrorLaunchMaxDepthExceeded = 65, 
#line 495
cudaErrorLaunchFileScopedTex, 
#line 503
cudaErrorLaunchFileScopedSurf, 
#line 519
cudaErrorSyncDepthExceeded, 
#line 531
cudaErrorLaunchPendingCountExceeded, 
#line 537
cudaErrorInvalidDeviceFunction = 98, 
#line 543
cudaErrorNoDevice = 100, 
#line 550
cudaErrorInvalidDevice, 
#line 555
cudaErrorDeviceNotLicensed, 
#line 564
cudaErrorSoftwareValidityNotEstablished, 
#line 569
cudaErrorStartupFailure = 127, 
#line 574
cudaErrorInvalidKernelImage = 200, 
#line 584
cudaErrorDeviceUninitialized, 
#line 589
cudaErrorMapBufferObjectFailed = 205, 
#line 594
cudaErrorUnmapBufferObjectFailed, 
#line 600
cudaErrorArrayIsMapped, 
#line 605
cudaErrorAlreadyMapped, 
#line 613
cudaErrorNoKernelImageForDevice, 
#line 618
cudaErrorAlreadyAcquired, 
#line 623
cudaErrorNotMapped, 
#line 629
cudaErrorNotMappedAsArray, 
#line 635
cudaErrorNotMappedAsPointer, 
#line 641
cudaErrorECCUncorrectable, 
#line 647
cudaErrorUnsupportedLimit, 
#line 653
cudaErrorDeviceAlreadyInUse, 
#line 659
cudaErrorPeerAccessUnsupported, 
#line 665
cudaErrorInvalidPtx, 
#line 670
cudaErrorInvalidGraphicsContext, 
#line 676
cudaErrorNvlinkUncorrectable, 
#line 683
cudaErrorJitCompilerNotFound, 
#line 690
cudaErrorUnsupportedPtxVersion, 
#line 697
cudaErrorJitCompilationDisabled, 
#line 702
cudaErrorUnsupportedExecAffinity, 
#line 708
cudaErrorUnsupportedDevSideSync, 
#line 719
cudaErrorContained, 
#line 724
cudaErrorInvalidSource = 300, 
#line 729
cudaErrorFileNotFound, 
#line 734
cudaErrorSharedObjectSymbolNotFound, 
#line 739
cudaErrorSharedObjectInitFailed, 
#line 744
cudaErrorOperatingSystem, 
#line 751
cudaErrorInvalidResourceHandle = 400, 
#line 757
cudaErrorIllegalState, 
#line 765
cudaErrorLossyQuery, 
#line 772
cudaErrorSymbolNotFound = 500, 
#line 780
cudaErrorNotReady = 600, 
#line 788
cudaErrorIllegalAddress = 700, 
#line 797
cudaErrorLaunchOutOfResources, 
#line 808
cudaErrorLaunchTimeout, 
#line 814
cudaErrorLaunchIncompatibleTexturing, 
#line 821
cudaErrorPeerAccessAlreadyEnabled, 
#line 828
cudaErrorPeerAccessNotEnabled, 
#line 841
cudaErrorSetOnActiveProcess = 708, 
#line 848
cudaErrorContextIsDestroyed, 
#line 855
cudaErrorAssert, 
#line 862
cudaErrorTooManyPeers, 
#line 868
cudaErrorHostMemoryAlreadyRegistered, 
#line 874
cudaErrorHostMemoryNotRegistered, 
#line 883
cudaErrorHardwareStackError, 
#line 891
cudaErrorIllegalInstruction, 
#line 900
cudaErrorMisalignedAddress, 
#line 911
cudaErrorInvalidAddressSpace, 
#line 919
cudaErrorInvalidPc, 
#line 930
cudaErrorLaunchFailure, 
#line 939
cudaErrorCooperativeLaunchTooLarge, 
#line 947
cudaErrorTensorMemoryLeak, 
#line 952
cudaErrorNotPermitted = 800, 
#line 958
cudaErrorNotSupported, 
#line 967
cudaErrorSystemNotReady, 
#line 974
cudaErrorSystemDriverMismatch, 
#line 983
cudaErrorCompatNotSupportedOnDevice, 
#line 988
cudaErrorMpsConnectionFailed, 
#line 993
cudaErrorMpsRpcFailure, 
#line 999
cudaErrorMpsServerNotReady, 
#line 1004
cudaErrorMpsMaxClientsReached, 
#line 1009
cudaErrorMpsMaxConnectionsReached, 
#line 1014
cudaErrorMpsClientTerminated, 
#line 1019
cudaErrorCdpNotSupported, 
#line 1024
cudaErrorCdpVersionMismatch, 
#line 1029
cudaErrorStreamCaptureUnsupported = 900, 
#line 1035
cudaErrorStreamCaptureInvalidated, 
#line 1041
cudaErrorStreamCaptureMerge, 
#line 1046
cudaErrorStreamCaptureUnmatched, 
#line 1052
cudaErrorStreamCaptureUnjoined, 
#line 1059
cudaErrorStreamCaptureIsolation, 
#line 1065
cudaErrorStreamCaptureImplicit, 
#line 1071
cudaErrorCapturedEvent, 
#line 1078
cudaErrorStreamCaptureWrongThread, 
#line 1083
cudaErrorTimeout, 
#line 1089
cudaErrorGraphExecUpdateFailure, 
#line 1099
cudaErrorExternalDevice, 
#line 1105
cudaErrorInvalidClusterSize, 
#line 1111
cudaErrorFunctionNotLoaded, 
#line 1117
cudaErrorInvalidResourceType, 
#line 1123
cudaErrorInvalidResourceConfiguration, 
#line 1128
cudaErrorUnknown = 999, 
#line 1136
cudaErrorApiFailureBase = 10000
#line 1137
}; 
#endif
#line 1142 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1142
enum cudaChannelFormatKind { 
#line 1144
cudaChannelFormatKindSigned, 
#line 1145
cudaChannelFormatKindUnsigned, 
#line 1146
cudaChannelFormatKindFloat, 
#line 1147
cudaChannelFormatKindNone, 
#line 1148
cudaChannelFormatKindNV12, 
#line 1149
cudaChannelFormatKindUnsignedNormalized8X1, 
#line 1150
cudaChannelFormatKindUnsignedNormalized8X2, 
#line 1151
cudaChannelFormatKindUnsignedNormalized8X4, 
#line 1152
cudaChannelFormatKindUnsignedNormalized16X1, 
#line 1153
cudaChannelFormatKindUnsignedNormalized16X2, 
#line 1154
cudaChannelFormatKindUnsignedNormalized16X4, 
#line 1155
cudaChannelFormatKindSignedNormalized8X1, 
#line 1156
cudaChannelFormatKindSignedNormalized8X2, 
#line 1157
cudaChannelFormatKindSignedNormalized8X4, 
#line 1158
cudaChannelFormatKindSignedNormalized16X1, 
#line 1159
cudaChannelFormatKindSignedNormalized16X2, 
#line 1160
cudaChannelFormatKindSignedNormalized16X4, 
#line 1161
cudaChannelFormatKindUnsignedBlockCompressed1, 
#line 1162
cudaChannelFormatKindUnsignedBlockCompressed1SRGB, 
#line 1163
cudaChannelFormatKindUnsignedBlockCompressed2, 
#line 1164
cudaChannelFormatKindUnsignedBlockCompressed2SRGB, 
#line 1165
cudaChannelFormatKindUnsignedBlockCompressed3, 
#line 1166
cudaChannelFormatKindUnsignedBlockCompressed3SRGB, 
#line 1167
cudaChannelFormatKindUnsignedBlockCompressed4, 
#line 1168
cudaChannelFormatKindSignedBlockCompressed4, 
#line 1169
cudaChannelFormatKindUnsignedBlockCompressed5, 
#line 1170
cudaChannelFormatKindSignedBlockCompressed5, 
#line 1171
cudaChannelFormatKindUnsignedBlockCompressed6H, 
#line 1172
cudaChannelFormatKindSignedBlockCompressed6H, 
#line 1173
cudaChannelFormatKindUnsignedBlockCompressed7, 
#line 1174
cudaChannelFormatKindUnsignedBlockCompressed7SRGB, 
#line 1175
cudaChannelFormatKindUnsignedNormalized1010102
#line 1177
}; 
#endif
#line 1182 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1182
struct cudaChannelFormatDesc { 
#line 1184
int x; 
#line 1185
int y; 
#line 1186
int z; 
#line 1187
int w; 
#line 1188
cudaChannelFormatKind f; 
#line 1189
}; 
#endif
#line 1194 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
typedef struct cudaArray *cudaArray_t; 
#line 1199
typedef const cudaArray *cudaArray_const_t; 
#line 1201
struct cudaArray; 
#line 1206
typedef struct cudaMipmappedArray *cudaMipmappedArray_t; 
#line 1211
typedef const cudaMipmappedArray *cudaMipmappedArray_const_t; 
#line 1213
struct cudaMipmappedArray; 
#line 1223
#if 0
#line 1223
struct cudaArraySparseProperties { 
#line 1224
struct { 
#line 1225
unsigned width; 
#line 1226
unsigned height; 
#line 1227
unsigned depth; 
#line 1228
} tileExtent; 
#line 1229
unsigned miptailFirstLevel; 
#line 1230
unsigned __int64 miptailSize; 
#line 1231
unsigned flags; 
#line 1232
unsigned reserved[4]; 
#line 1233
}; 
#endif
#line 1238 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1238
struct cudaArrayMemoryRequirements { 
#line 1239
size_t size; 
#line 1240
size_t alignment; 
#line 1241
unsigned reserved[4]; 
#line 1242
}; 
#endif
#line 1247 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1247
enum cudaMemoryType { 
#line 1249
cudaMemoryTypeUnregistered, 
#line 1250
cudaMemoryTypeHost, 
#line 1251
cudaMemoryTypeDevice, 
#line 1252
cudaMemoryTypeManaged
#line 1253
}; 
#endif
#line 1258 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1258
enum cudaMemcpyKind { 
#line 1260
cudaMemcpyHostToHost, 
#line 1261
cudaMemcpyHostToDevice, 
#line 1262
cudaMemcpyDeviceToHost, 
#line 1263
cudaMemcpyDeviceToDevice, 
#line 1264
cudaMemcpyDefault
#line 1265
}; 
#endif
#line 1272 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1272
struct cudaPitchedPtr { 
#line 1274
void *ptr; 
#line 1275
size_t pitch; 
#line 1276
size_t xsize; 
#line 1277
size_t ysize; 
#line 1278
}; 
#endif
#line 1285 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1285
struct cudaExtent { 
#line 1287
size_t width; 
#line 1288
size_t height; 
#line 1289
size_t depth; 
#line 1290
}; 
#endif
#line 1297 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1297
struct cudaPos { 
#line 1299
size_t x; 
#line 1300
size_t y; 
#line 1301
size_t z; 
#line 1302
}; 
#endif
#line 1307 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1307
struct cudaMemcpy3DParms { 
#line 1309
cudaArray_t srcArray; 
#line 1310
cudaPos srcPos; 
#line 1311
cudaPitchedPtr srcPtr; 
#line 1313
cudaArray_t dstArray; 
#line 1314
cudaPos dstPos; 
#line 1315
cudaPitchedPtr dstPtr; 
#line 1317
cudaExtent extent; 
#line 1318
cudaMemcpyKind kind; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 1319
}; 
#endif
#line 1324 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1324
struct cudaMemcpyNodeParams { 
#line 1325
int flags; 
#line 1326
int reserved[3]; 
#line 1327
cudaMemcpy3DParms copyParams; 
#line 1328
}; 
#endif
#line 1333 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1333
struct cudaMemcpy3DPeerParms { 
#line 1335
cudaArray_t srcArray; 
#line 1336
cudaPos srcPos; 
#line 1337
cudaPitchedPtr srcPtr; 
#line 1338
int srcDevice; 
#line 1340
cudaArray_t dstArray; 
#line 1341
cudaPos dstPos; 
#line 1342
cudaPitchedPtr dstPtr; 
#line 1343
int dstDevice; 
#line 1345
cudaExtent extent; 
#line 1346
}; 
#endif
#line 1351 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1351
struct cudaMemsetParams { 
#line 1352
void *dst; 
#line 1353
size_t pitch; 
#line 1354
unsigned value; 
#line 1355
unsigned elementSize; 
#line 1356
size_t width; 
#line 1357
size_t height; 
#line 1358
}; 
#endif
#line 1363 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1363
struct cudaMemsetParamsV2 { 
#line 1364
void *dst; 
#line 1365
size_t pitch; 
#line 1366
unsigned value; 
#line 1367
unsigned elementSize; 
#line 1368
size_t width; 
#line 1369
size_t height; 
#line 1370
}; 
#endif
#line 1375 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1375
enum cudaAccessProperty { 
#line 1376
cudaAccessPropertyNormal, 
#line 1377
cudaAccessPropertyStreaming, 
#line 1378
cudaAccessPropertyPersisting
#line 1379
}; 
#endif
#line 1392 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1392
struct cudaAccessPolicyWindow { 
#line 1393
void *base_ptr; 
#line 1394
size_t num_bytes; 
#line 1395
float hitRatio; 
#line 1396
cudaAccessProperty hitProp; 
#line 1397
cudaAccessProperty missProp; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 1398
}; 
#endif
#line 1410 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
typedef void (__stdcall *cudaHostFn_t)(void * userData); 
#line 1415
#if 0
#line 1415
struct cudaHostNodeParams { 
#line 1416
cudaHostFn_t fn; 
#line 1417
void *userData; 
#line 1418
}; 
#endif
#line 1423 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1423
struct cudaHostNodeParamsV2 { 
#line 1424
cudaHostFn_t fn; 
#line 1425
void *userData; 
#line 1426
}; 
#endif
#line 1431 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1431
enum cudaStreamCaptureStatus { 
#line 1432
cudaStreamCaptureStatusNone, 
#line 1433
cudaStreamCaptureStatusActive, 
#line 1434
cudaStreamCaptureStatusInvalidated
#line 1436
}; 
#endif
#line 1442 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1442
enum cudaStreamCaptureMode { 
#line 1443
cudaStreamCaptureModeGlobal, 
#line 1444
cudaStreamCaptureModeThreadLocal, 
#line 1445
cudaStreamCaptureModeRelaxed
#line 1446
}; 
#endif
#line 1448 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1448
enum cudaSynchronizationPolicy { 
#line 1449
cudaSyncPolicyAuto = 1, 
#line 1450
cudaSyncPolicySpin, 
#line 1451
cudaSyncPolicyYield, 
#line 1452
cudaSyncPolicyBlockingSync
#line 1453
}; 
#endif
#line 1458 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1458
enum cudaClusterSchedulingPolicy { 
#line 1459
cudaClusterSchedulingPolicyDefault, 
#line 1460
cudaClusterSchedulingPolicySpread, 
#line 1461
cudaClusterSchedulingPolicyLoadBalancing
#line 1462
}; 
#endif
#line 1467 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1467
enum cudaStreamUpdateCaptureDependenciesFlags { 
#line 1468
cudaStreamAddCaptureDependencies, 
#line 1469
cudaStreamSetCaptureDependencies
#line 1470
}; 
#endif
#line 1475 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1475
enum cudaUserObjectFlags { 
#line 1476
cudaUserObjectNoDestructorSync = 1
#line 1477
}; 
#endif
#line 1482 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1482
enum cudaUserObjectRetainFlags { 
#line 1483
cudaGraphUserObjectMove = 1
#line 1484
}; 
#endif
#line 1489 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
struct cudaGraphicsResource; 
#line 1494
#if 0
#line 1494
enum cudaGraphicsRegisterFlags { 
#line 1496
cudaGraphicsRegisterFlagsNone, 
#line 1497
cudaGraphicsRegisterFlagsReadOnly, 
#line 1498
cudaGraphicsRegisterFlagsWriteDiscard, 
#line 1499
cudaGraphicsRegisterFlagsSurfaceLoadStore = 4, 
#line 1500
cudaGraphicsRegisterFlagsTextureGather = 8
#line 1501
}; 
#endif
#line 1506 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1506
enum cudaGraphicsMapFlags { 
#line 1508
cudaGraphicsMapFlagsNone, 
#line 1509
cudaGraphicsMapFlagsReadOnly, 
#line 1510
cudaGraphicsMapFlagsWriteDiscard
#line 1511
}; 
#endif
#line 1516 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1516
enum cudaGraphicsCubeFace { 
#line 1518
cudaGraphicsCubeFacePositiveX, 
#line 1519
cudaGraphicsCubeFaceNegativeX, 
#line 1520
cudaGraphicsCubeFacePositiveY, 
#line 1521
cudaGraphicsCubeFaceNegativeY, 
#line 1522
cudaGraphicsCubeFacePositiveZ, 
#line 1523
cudaGraphicsCubeFaceNegativeZ
#line 1524
}; 
#endif
#line 1529 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1529
enum cudaResourceType { 
#line 1531
cudaResourceTypeArray, 
#line 1532
cudaResourceTypeMipmappedArray, 
#line 1533
cudaResourceTypeLinear, 
#line 1534
cudaResourceTypePitch2D
#line 1535
}; 
#endif
#line 1540 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1540
enum cudaResourceViewFormat { 
#line 1542
cudaResViewFormatNone, 
#line 1543
cudaResViewFormatUnsignedChar1, 
#line 1544
cudaResViewFormatUnsignedChar2, 
#line 1545
cudaResViewFormatUnsignedChar4, 
#line 1546
cudaResViewFormatSignedChar1, 
#line 1547
cudaResViewFormatSignedChar2, 
#line 1548
cudaResViewFormatSignedChar4, 
#line 1549
cudaResViewFormatUnsignedShort1, 
#line 1550
cudaResViewFormatUnsignedShort2, 
#line 1551
cudaResViewFormatUnsignedShort4, 
#line 1552
cudaResViewFormatSignedShort1, 
#line 1553
cudaResViewFormatSignedShort2, 
#line 1554
cudaResViewFormatSignedShort4, 
#line 1555
cudaResViewFormatUnsignedInt1, 
#line 1556
cudaResViewFormatUnsignedInt2, 
#line 1557
cudaResViewFormatUnsignedInt4, 
#line 1558
cudaResViewFormatSignedInt1, 
#line 1559
cudaResViewFormatSignedInt2, 
#line 1560
cudaResViewFormatSignedInt4, 
#line 1561
cudaResViewFormatHalf1, 
#line 1562
cudaResViewFormatHalf2, 
#line 1563
cudaResViewFormatHalf4, 
#line 1564
cudaResViewFormatFloat1, 
#line 1565
cudaResViewFormatFloat2, 
#line 1566
cudaResViewFormatFloat4, 
#line 1567
cudaResViewFormatUnsignedBlockCompressed1, 
#line 1568
cudaResViewFormatUnsignedBlockCompressed2, 
#line 1569
cudaResViewFormatUnsignedBlockCompressed3, 
#line 1570
cudaResViewFormatUnsignedBlockCompressed4, 
#line 1571
cudaResViewFormatSignedBlockCompressed4, 
#line 1572
cudaResViewFormatUnsignedBlockCompressed5, 
#line 1573
cudaResViewFormatSignedBlockCompressed5, 
#line 1574
cudaResViewFormatUnsignedBlockCompressed6H, 
#line 1575
cudaResViewFormatSignedBlockCompressed6H, 
#line 1576
cudaResViewFormatUnsignedBlockCompressed7
#line 1577
}; 
#endif
#line 1582 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1582
struct cudaResourceDesc { 
#line 1583
cudaResourceType resType; 
#line 1585
union { 
#line 1586
struct { 
#line 1587
cudaArray_t array; 
#line 1588
} array; 
#line 1589
struct { 
#line 1590
cudaMipmappedArray_t mipmap; 
#line 1591
} mipmap; 
#line 1592
struct { 
#line 1593
void *devPtr; 
#line 1594
cudaChannelFormatDesc desc; 
#line 1595
size_t sizeInBytes; 
#line 1596
} linear; 
#line 1597
struct { 
#line 1598
void *devPtr; 
#line 1599
cudaChannelFormatDesc desc; 
#line 1600
size_t width; 
#line 1601
size_t height; 
#line 1602
size_t pitchInBytes; 
#line 1603
} pitch2D; 
#line 1604
} res; 
#line 1605
}; 
#endif
#line 1610 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1610
struct cudaResourceViewDesc { 
#line 1612
cudaResourceViewFormat format; 
#line 1613
size_t width; 
#line 1614
size_t height; 
#line 1615
size_t depth; 
#line 1616
unsigned firstMipmapLevel; 
#line 1617
unsigned lastMipmapLevel; 
#line 1618
unsigned firstLayer; 
#line 1619
unsigned lastLayer; 
#line 1620
}; 
#endif
#line 1625 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1625
struct cudaPointerAttributes { 
#line 1631
cudaMemoryType type; 
#line 1642
int device; 
#line 1648
void *devicePointer; 
#line 1657
void *hostPointer; 
#line 1658
}; 
#endif
#line 1663 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1663
struct cudaFuncAttributes { 
#line 1670
size_t sharedSizeBytes; 
#line 1676
size_t constSizeBytes; 
#line 1681
size_t localSizeBytes; 
#line 1688
int maxThreadsPerBlock; 
#line 1693
int numRegs; 
#line 1700
int ptxVersion; 
#line 1707
int binaryVersion; 
#line 1713
int cacheModeCA; 
#line 1720
int maxDynamicSharedSizeBytes; 
#line 1729
int preferredShmemCarveout; 
#line 1735
int clusterDimMustBeSet; 
#line 1746
int requiredClusterWidth; 
#line 1747
int requiredClusterHeight; 
#line 1748
int requiredClusterDepth; 
#line 1754
int clusterSchedulingPolicyPreference; 
#line 1776
int nonPortableClusterSizeAllowed; 
#line 1781
int reserved[16]; 
#line 1782
}; 
#endif
#line 1787 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1787
enum cudaFuncAttribute { 
#line 1789
cudaFuncAttributeMaxDynamicSharedMemorySize = 8, 
#line 1790
cudaFuncAttributePreferredSharedMemoryCarveout, 
#line 1791
cudaFuncAttributeClusterDimMustBeSet, 
#line 1792
cudaFuncAttributeRequiredClusterWidth, 
#line 1793
cudaFuncAttributeRequiredClusterHeight, 
#line 1794
cudaFuncAttributeRequiredClusterDepth, 
#line 1795
cudaFuncAttributeNonPortableClusterSizeAllowed, 
#line 1796
cudaFuncAttributeClusterSchedulingPolicyPreference, 
#line 1797
cudaFuncAttributeMax
#line 1798
}; 
#endif
#line 1803 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1803
enum cudaFuncCache { 
#line 1805
cudaFuncCachePreferNone, 
#line 1806
cudaFuncCachePreferShared, 
#line 1807
cudaFuncCachePreferL1, 
#line 1808
cudaFuncCachePreferEqual
#line 1809
}; 
#endif
#line 1815 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1815
enum cudaSharedMemConfig { 
#line 1817
cudaSharedMemBankSizeDefault, 
#line 1818
cudaSharedMemBankSizeFourByte, 
#line 1819
cudaSharedMemBankSizeEightByte
#line 1820
}; 
#endif
#line 1825 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1825
enum cudaSharedCarveout { 
#line 1826
cudaSharedmemCarveoutDefault = (-1), 
#line 1827
cudaSharedmemCarveoutMaxShared = 100, 
#line 1828
cudaSharedmemCarveoutMaxL1 = 0
#line 1829
}; 
#endif
#line 1834 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1834
enum cudaComputeMode { 
#line 1836
cudaComputeModeDefault, 
#line 1837
cudaComputeModeExclusive, 
#line 1838
cudaComputeModeProhibited, 
#line 1839
cudaComputeModeExclusiveProcess
#line 1840
}; 
#endif
#line 1845 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1845
enum cudaLimit { 
#line 1847
cudaLimitStackSize, 
#line 1848
cudaLimitPrintfFifoSize, 
#line 1849
cudaLimitMallocHeapSize, 
#line 1850
cudaLimitDevRuntimeSyncDepth, 
#line 1851
cudaLimitDevRuntimePendingLaunchCount, 
#line 1852
cudaLimitMaxL2FetchGranularity, 
#line 1853
cudaLimitPersistingL2CacheSize
#line 1854
}; 
#endif
#line 1859 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1859
enum cudaMemoryAdvise { 
#line 1861
cudaMemAdviseSetReadMostly = 1, 
#line 1862
cudaMemAdviseUnsetReadMostly, 
#line 1863
cudaMemAdviseSetPreferredLocation, 
#line 1864
cudaMemAdviseUnsetPreferredLocation, 
#line 1865
cudaMemAdviseSetAccessedBy, 
#line 1866
cudaMemAdviseUnsetAccessedBy
#line 1867
}; 
#endif
#line 1872 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1872
enum cudaMemRangeAttribute { 
#line 1874
cudaMemRangeAttributeReadMostly = 1, 
#line 1875
cudaMemRangeAttributePreferredLocation, 
#line 1876
cudaMemRangeAttributeAccessedBy, 
#line 1877
cudaMemRangeAttributeLastPrefetchLocation, 
#line 1878
cudaMemRangeAttributePreferredLocationType, 
#line 1879
cudaMemRangeAttributePreferredLocationId, 
#line 1880
cudaMemRangeAttributeLastPrefetchLocationType, 
#line 1881
cudaMemRangeAttributeLastPrefetchLocationId
#line 1882
}; 
#endif
#line 1887 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1887
enum cudaFlushGPUDirectRDMAWritesOptions { 
#line 1888
cudaFlushGPUDirectRDMAWritesOptionHost = (1 << 0), 
#line 1889
cudaFlushGPUDirectRDMAWritesOptionMemOps
#line 1890
}; 
#endif
#line 1895 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1895
enum cudaGPUDirectRDMAWritesOrdering { 
#line 1896
cudaGPUDirectRDMAWritesOrderingNone, 
#line 1897
cudaGPUDirectRDMAWritesOrderingOwner = 100, 
#line 1898
cudaGPUDirectRDMAWritesOrderingAllDevices = 200
#line 1899
}; 
#endif
#line 1904 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1904
enum cudaFlushGPUDirectRDMAWritesScope { 
#line 1905
cudaFlushGPUDirectRDMAWritesToOwner = 100, 
#line 1906
cudaFlushGPUDirectRDMAWritesToAllDevices = 200
#line 1907
}; 
#endif
#line 1912 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1912
enum cudaFlushGPUDirectRDMAWritesTarget { 
#line 1913
cudaFlushGPUDirectRDMAWritesTargetCurrentDevice
#line 1914
}; 
#endif
#line 1920 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 1920
enum cudaDeviceAttr { 
#line 1922
cudaDevAttrMaxThreadsPerBlock = 1, 
#line 1923
cudaDevAttrMaxBlockDimX, 
#line 1924
cudaDevAttrMaxBlockDimY, 
#line 1925
cudaDevAttrMaxBlockDimZ, 
#line 1926
cudaDevAttrMaxGridDimX, 
#line 1927
cudaDevAttrMaxGridDimY, 
#line 1928
cudaDevAttrMaxGridDimZ, 
#line 1929
cudaDevAttrMaxSharedMemoryPerBlock, 
#line 1930
cudaDevAttrTotalConstantMemory, 
#line 1931
cudaDevAttrWarpSize, 
#line 1932
cudaDevAttrMaxPitch, 
#line 1933
cudaDevAttrMaxRegistersPerBlock, 
#line 1934
cudaDevAttrClockRate, 
#line 1935
cudaDevAttrTextureAlignment, 
#line 1936
cudaDevAttrGpuOverlap, 
#line 1937
cudaDevAttrMultiProcessorCount, 
#line 1938
cudaDevAttrKernelExecTimeout, 
#line 1939
cudaDevAttrIntegrated, 
#line 1940
cudaDevAttrCanMapHostMemory, 
#line 1941
cudaDevAttrComputeMode, 
#line 1942
cudaDevAttrMaxTexture1DWidth, 
#line 1943
cudaDevAttrMaxTexture2DWidth, 
#line 1944
cudaDevAttrMaxTexture2DHeight, 
#line 1945
cudaDevAttrMaxTexture3DWidth, 
#line 1946
cudaDevAttrMaxTexture3DHeight, 
#line 1947
cudaDevAttrMaxTexture3DDepth, 
#line 1948
cudaDevAttrMaxTexture2DLayeredWidth, 
#line 1949
cudaDevAttrMaxTexture2DLayeredHeight, 
#line 1950
cudaDevAttrMaxTexture2DLayeredLayers, 
#line 1951
cudaDevAttrSurfaceAlignment, 
#line 1952
cudaDevAttrConcurrentKernels, 
#line 1953
cudaDevAttrEccEnabled, 
#line 1954
cudaDevAttrPciBusId, 
#line 1955
cudaDevAttrPciDeviceId, 
#line 1956
cudaDevAttrTccDriver, 
#line 1957
cudaDevAttrMemoryClockRate, 
#line 1958
cudaDevAttrGlobalMemoryBusWidth, 
#line 1959
cudaDevAttrL2CacheSize, 
#line 1960
cudaDevAttrMaxThreadsPerMultiProcessor, 
#line 1961
cudaDevAttrAsyncEngineCount, 
#line 1962
cudaDevAttrUnifiedAddressing, 
#line 1963
cudaDevAttrMaxTexture1DLayeredWidth, 
#line 1964
cudaDevAttrMaxTexture1DLayeredLayers, 
#line 1965
cudaDevAttrMaxTexture2DGatherWidth = 45, 
#line 1966
cudaDevAttrMaxTexture2DGatherHeight, 
#line 1967
cudaDevAttrMaxTexture3DWidthAlt, 
#line 1968
cudaDevAttrMaxTexture3DHeightAlt, 
#line 1969
cudaDevAttrMaxTexture3DDepthAlt, 
#line 1970
cudaDevAttrPciDomainId, 
#line 1971
cudaDevAttrTexturePitchAlignment, 
#line 1972
cudaDevAttrMaxTextureCubemapWidth, 
#line 1973
cudaDevAttrMaxTextureCubemapLayeredWidth, 
#line 1974
cudaDevAttrMaxTextureCubemapLayeredLayers, 
#line 1975
cudaDevAttrMaxSurface1DWidth, 
#line 1976
cudaDevAttrMaxSurface2DWidth, 
#line 1977
cudaDevAttrMaxSurface2DHeight, 
#line 1978
cudaDevAttrMaxSurface3DWidth, 
#line 1979
cudaDevAttrMaxSurface3DHeight, 
#line 1980
cudaDevAttrMaxSurface3DDepth, 
#line 1981
cudaDevAttrMaxSurface1DLayeredWidth, 
#line 1982
cudaDevAttrMaxSurface1DLayeredLayers, 
#line 1983
cudaDevAttrMaxSurface2DLayeredWidth, 
#line 1984
cudaDevAttrMaxSurface2DLayeredHeight, 
#line 1985
cudaDevAttrMaxSurface2DLayeredLayers, 
#line 1986
cudaDevAttrMaxSurfaceCubemapWidth, 
#line 1987
cudaDevAttrMaxSurfaceCubemapLayeredWidth, 
#line 1988
cudaDevAttrMaxSurfaceCubemapLayeredLayers, 
#line 1989
cudaDevAttrMaxTexture1DLinearWidth, 
#line 1990
cudaDevAttrMaxTexture2DLinearWidth, 
#line 1991
cudaDevAttrMaxTexture2DLinearHeight, 
#line 1992
cudaDevAttrMaxTexture2DLinearPitch, 
#line 1993
cudaDevAttrMaxTexture2DMipmappedWidth, 
#line 1994
cudaDevAttrMaxTexture2DMipmappedHeight, 
#line 1995
cudaDevAttrComputeCapabilityMajor, 
#line 1996
cudaDevAttrComputeCapabilityMinor, 
#line 1997
cudaDevAttrMaxTexture1DMipmappedWidth, 
#line 1998
cudaDevAttrStreamPrioritiesSupported, 
#line 1999
cudaDevAttrGlobalL1CacheSupported, 
#line 2000
cudaDevAttrLocalL1CacheSupported, 
#line 2001
cudaDevAttrMaxSharedMemoryPerMultiprocessor, 
#line 2002
cudaDevAttrMaxRegistersPerMultiprocessor, 
#line 2003
cudaDevAttrManagedMemory, 
#line 2004
cudaDevAttrIsMultiGpuBoard, 
#line 2005
cudaDevAttrMultiGpuBoardGroupID, 
#line 2006
cudaDevAttrHostNativeAtomicSupported, 
#line 2007
cudaDevAttrSingleToDoublePrecisionPerfRatio, 
#line 2008
cudaDevAttrPageableMemoryAccess, 
#line 2009
cudaDevAttrConcurrentManagedAccess, 
#line 2010
cudaDevAttrComputePreemptionSupported, 
#line 2011
cudaDevAttrCanUseHostPointerForRegisteredMem, 
#line 2012
cudaDevAttrReserved92, 
#line 2013
cudaDevAttrReserved93, 
#line 2014
cudaDevAttrReserved94, 
#line 2015
cudaDevAttrCooperativeLaunch, 
#line 2016
cudaDevAttrCooperativeMultiDeviceLaunch, 
#line 2017
cudaDevAttrMaxSharedMemoryPerBlockOptin, 
#line 2018
cudaDevAttrCanFlushRemoteWrites, 
#line 2019
cudaDevAttrHostRegisterSupported, 
#line 2020
cudaDevAttrPageableMemoryAccessUsesHostPageTables, 
#line 2021
cudaDevAttrDirectManagedMemAccessFromHost, 
#line 2022
cudaDevAttrMaxBlocksPerMultiprocessor = 106, 
#line 2023
cudaDevAttrMaxPersistingL2CacheSize = 108, 
#line 2024
cudaDevAttrMaxAccessPolicyWindowSize, 
#line 2025
cudaDevAttrReservedSharedMemoryPerBlock = 111, 
#line 2026
cudaDevAttrSparseCudaArraySupported, 
#line 2027
cudaDevAttrHostRegisterReadOnlySupported, 
#line 2028
cudaDevAttrTimelineSemaphoreInteropSupported, 
#line 2029
cudaDevAttrMaxTimelineSemaphoreInteropSupported = 114, 
#line 2030
cudaDevAttrMemoryPoolsSupported, 
#line 2031
cudaDevAttrGPUDirectRDMASupported, 
#line 2032
cudaDevAttrGPUDirectRDMAFlushWritesOptions, 
#line 2033
cudaDevAttrGPUDirectRDMAWritesOrdering, 
#line 2034
cudaDevAttrMemoryPoolSupportedHandleTypes, 
#line 2035
cudaDevAttrClusterLaunch, 
#line 2036
cudaDevAttrDeferredMappingCudaArraySupported, 
#line 2037
cudaDevAttrReserved122, 
#line 2038
cudaDevAttrReserved123, 
#line 2039
cudaDevAttrReserved124, 
#line 2040
cudaDevAttrIpcEventSupport, 
#line 2041
cudaDevAttrMemSyncDomainCount, 
#line 2042
cudaDevAttrReserved127, 
#line 2043
cudaDevAttrReserved128, 
#line 2044
cudaDevAttrReserved129, 
#line 2045
cudaDevAttrNumaConfig, 
#line 2046
cudaDevAttrNumaId, 
#line 2047
cudaDevAttrReserved132, 
#line 2048
cudaDevAttrMpsEnabled, 
#line 2049
cudaDevAttrHostNumaId, 
#line 2050
cudaDevAttrD3D12CigSupported, 
#line 2051
cudaDevAttrVulkanCigSupported = 138, 
#line 2052
cudaDevAttrGpuPciDeviceId, 
#line 2053
cudaDevAttrGpuPciSubsystemId, 
#line 2054
cudaDevAttrReserved141, 
#line 2055
cudaDevAttrHostNumaMemoryPoolsSupported, 
#line 2056
cudaDevAttrHostNumaMultinodeIpcSupported, 
#line 2057
cudaDevAttrMax
#line 2058
}; 
#endif
#line 2063 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2063
enum cudaMemPoolAttr { 
#line 2073
cudaMemPoolReuseFollowEventDependencies = 1, 
#line 2080
cudaMemPoolReuseAllowOpportunistic, 
#line 2088
cudaMemPoolReuseAllowInternalDependencies, 
#line 2099
cudaMemPoolAttrReleaseThreshold, 
#line 2105
cudaMemPoolAttrReservedMemCurrent, 
#line 2112
cudaMemPoolAttrReservedMemHigh, 
#line 2118
cudaMemPoolAttrUsedMemCurrent, 
#line 2125
cudaMemPoolAttrUsedMemHigh
#line 2126
}; 
#endif
#line 2131 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2131
enum cudaMemLocationType { 
#line 2132
cudaMemLocationTypeInvalid, 
#line 2133
cudaMemLocationTypeDevice, 
#line 2134
cudaMemLocationTypeHost, 
#line 2135
cudaMemLocationTypeHostNuma, 
#line 2136
cudaMemLocationTypeHostNumaCurrent
#line 2137
}; 
#endif
#line 2145 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2145
struct cudaMemLocation { 
#line 2146
cudaMemLocationType type; 
#line 2147
int id; 
#line 2148
}; 
#endif
#line 2153 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2153
enum cudaMemAccessFlags { 
#line 2154
cudaMemAccessFlagsProtNone, 
#line 2155
cudaMemAccessFlagsProtRead, 
#line 2156
cudaMemAccessFlagsProtReadWrite = 3
#line 2157
}; 
#endif
#line 2162 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2162
struct cudaMemAccessDesc { 
#line 2163
cudaMemLocation location; 
#line 2164
cudaMemAccessFlags flags; 
#line 2165
}; 
#endif
#line 2170 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2170
enum cudaMemAllocationType { 
#line 2171
cudaMemAllocationTypeInvalid, 
#line 2175
cudaMemAllocationTypePinned, 
#line 2176
cudaMemAllocationTypeMax = 2147483647
#line 2177
}; 
#endif
#line 2182 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2182
enum cudaMemAllocationHandleType { 
#line 2183
cudaMemHandleTypeNone, 
#line 2184
cudaMemHandleTypePosixFileDescriptor, 
#line 2185
cudaMemHandleTypeWin32, 
#line 2186
cudaMemHandleTypeWin32Kmt = 4, 
#line 2187
cudaMemHandleTypeFabric = 8
#line 2188
}; 
#endif
#line 2199 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2199
struct cudaMemPoolProps { 
#line 2200
cudaMemAllocationType allocType; 
#line 2201
cudaMemAllocationHandleType handleTypes; 
#line 2202
cudaMemLocation location; 
#line 2209
void *win32SecurityAttributes; 
#line 2210
size_t maxSize; 
#line 2211
unsigned short usage; 
#line 2212
unsigned char reserved[54]; 
#line 2213
}; 
#endif
#line 2218 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2218
struct cudaMemPoolPtrExportData { 
#line 2219
unsigned char reserved[64]; 
#line 2220
}; 
#endif
#line 2225 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2225
struct cudaMemAllocNodeParams { 
#line 2230
cudaMemPoolProps poolProps; 
#line 2231
const cudaMemAccessDesc *accessDescs; 
#line 2232
size_t accessDescCount; 
#line 2233
size_t bytesize; 
#line 2234
void *dptr; 
#line 2235
}; 
#endif
#line 2240 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2240
struct cudaMemAllocNodeParamsV2 { 
#line 2245
cudaMemPoolProps poolProps; 
#line 2246
const cudaMemAccessDesc *accessDescs; 
#line 2247
size_t accessDescCount; 
#line 2248
size_t bytesize; 
#line 2249
void *dptr; 
#line 2250
}; 
#endif
#line 2255 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2255
struct cudaMemFreeNodeParams { 
#line 2256
void *dptr; 
#line 2257
}; 
#endif
#line 2262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2262
enum cudaGraphMemAttributeType { 
#line 2267
cudaGraphMemAttrUsedMemCurrent, 
#line 2274
cudaGraphMemAttrUsedMemHigh, 
#line 2281
cudaGraphMemAttrReservedMemCurrent, 
#line 2288
cudaGraphMemAttrReservedMemHigh
#line 2289
}; 
#endif
#line 2294 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2294
enum cudaMemcpyFlags { 
#line 2295
cudaMemcpyFlagDefault, 
#line 2300
cudaMemcpyFlagPreferOverlapWithCompute
#line 2301
}; 
#endif
#line 2303 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2303
enum cudaMemcpySrcAccessOrder { 
#line 2307
cudaMemcpySrcAccessOrderInvalid, 
#line 2312
cudaMemcpySrcAccessOrderStream, 
#line 2323
cudaMemcpySrcAccessOrderDuringApiCall, 
#line 2332
cudaMemcpySrcAccessOrderAny, 
#line 2334
cudaMemcpySrcAccessOrderMax = 2147483647
#line 2335
}; 
#endif
#line 2340 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2340
struct cudaMemcpyAttributes { 
#line 2341
cudaMemcpySrcAccessOrder srcAccessOrder; 
#line 2342
cudaMemLocation srcLocHint; 
#line 2343
cudaMemLocation dstLocHint; 
#line 2344
unsigned flags; 
#line 2345
}; 
#endif
#line 2350 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2350
enum cudaMemcpy3DOperandType { 
#line 2351
cudaMemcpyOperandTypePointer = 1, 
#line 2352
cudaMemcpyOperandTypeArray, 
#line 2353
cudaMemcpyOperandTypeMax = 2147483647
#line 2354
}; 
#endif
#line 2359 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2359
struct cudaOffset3D { 
#line 2360
size_t x; 
#line 2361
size_t y; 
#line 2362
size_t z; 
#line 2363
}; 
#endif
#line 2368 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2368
struct cudaMemcpy3DOperand { 
#line 2369
cudaMemcpy3DOperandType type; 
#line 2370
union { 
#line 2374
struct { 
#line 2375
void *ptr; 
#line 2376
size_t rowLength; 
#line 2377
size_t layerHeight; 
#line 2378
cudaMemLocation locHint; 
#line 2379
} ptr; 
#line 2384
struct { 
#line 2385
cudaArray_t array; 
#line 2386
cudaOffset3D offset; 
#line 2387
} array; 
#line 2388
} op; 
#line 2389
}; 
#endif
#line 2391 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2391
struct cudaMemcpy3DBatchOp { 
#line 2392
cudaMemcpy3DOperand src; 
#line 2393
cudaMemcpy3DOperand dst; 
#line 2394
cudaExtent extent; 
#line 2395
cudaMemcpySrcAccessOrder srcAccessOrder; 
#line 2396
unsigned flags; 
#line 2397
}; 
#endif
#line 2403 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2403
enum cudaDeviceP2PAttr { 
#line 2404
cudaDevP2PAttrPerformanceRank = 1, 
#line 2405
cudaDevP2PAttrAccessSupported, 
#line 2406
cudaDevP2PAttrNativeAtomicSupported, 
#line 2407
cudaDevP2PAttrCudaArrayAccessSupported
#line 2408
}; 
#endif
#line 2415 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2415
struct CUuuid_st { 
#line 2416
char bytes[16]; 
#line 2417
}; 
#endif
#line 2418 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef CUuuid_st 
#line 2418
CUuuid; 
#endif
#line 2420 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef CUuuid_st 
#line 2420
cudaUUID_t; 
#endif
#line 2425 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2425
struct cudaDeviceProp { 
#line 2427
char name[256]; 
#line 2428
cudaUUID_t uuid; 
#line 2429
char luid[8]; 
#line 2430
unsigned luidDeviceNodeMask; 
#line 2431
size_t totalGlobalMem; 
#line 2432
size_t sharedMemPerBlock; 
#line 2433
int regsPerBlock; 
#line 2434
int warpSize; 
#line 2435
size_t memPitch; 
#line 2436
int maxThreadsPerBlock; 
#line 2437
int maxThreadsDim[3]; 
#line 2438
int maxGridSize[3]; 
#line 2439
int clockRate; 
#line 2440
size_t totalConstMem; 
#line 2441
int major; 
#line 2442
int minor; 
#line 2443
size_t textureAlignment; 
#line 2444
size_t texturePitchAlignment; 
#line 2445
int deviceOverlap; 
#line 2446
int multiProcessorCount; 
#line 2447
int kernelExecTimeoutEnabled; 
#line 2448
int integrated; 
#line 2449
int canMapHostMemory; 
#line 2450
int computeMode; 
#line 2451
int maxTexture1D; 
#line 2452
int maxTexture1DMipmap; 
#line 2453
int maxTexture1DLinear; 
#line 2454
int maxTexture2D[2]; 
#line 2455
int maxTexture2DMipmap[2]; 
#line 2456
int maxTexture2DLinear[3]; 
#line 2457
int maxTexture2DGather[2]; 
#line 2458
int maxTexture3D[3]; 
#line 2459
int maxTexture3DAlt[3]; 
#line 2460
int maxTextureCubemap; 
#line 2461
int maxTexture1DLayered[2]; 
#line 2462
int maxTexture2DLayered[3]; 
#line 2463
int maxTextureCubemapLayered[2]; 
#line 2464
int maxSurface1D; 
#line 2465
int maxSurface2D[2]; 
#line 2466
int maxSurface3D[3]; 
#line 2467
int maxSurface1DLayered[2]; 
#line 2468
int maxSurface2DLayered[3]; 
#line 2469
int maxSurfaceCubemap; 
#line 2470
int maxSurfaceCubemapLayered[2]; 
#line 2471
size_t surfaceAlignment; 
#line 2472
int concurrentKernels; 
#line 2473
int ECCEnabled; 
#line 2474
int pciBusID; 
#line 2475
int pciDeviceID; 
#line 2476
int pciDomainID; 
#line 2477
int tccDriver; 
#line 2478
int asyncEngineCount; 
#line 2479
int unifiedAddressing; 
#line 2480
int memoryClockRate; 
#line 2481
int memoryBusWidth; 
#line 2482
int l2CacheSize; 
#line 2483
int persistingL2CacheMaxSize; 
#line 2484
int maxThreadsPerMultiProcessor; 
#line 2485
int streamPrioritiesSupported; 
#line 2486
int globalL1CacheSupported; 
#line 2487
int localL1CacheSupported; 
#line 2488
size_t sharedMemPerMultiprocessor; 
#line 2489
int regsPerMultiprocessor; 
#line 2490
int managedMemory; 
#line 2491
int isMultiGpuBoard; 
#line 2492
int multiGpuBoardGroupID; 
#line 2493
int hostNativeAtomicSupported; 
#line 2494
int singleToDoublePrecisionPerfRatio; 
#line 2495
int pageableMemoryAccess; 
#line 2496
int concurrentManagedAccess; 
#line 2497
int computePreemptionSupported; 
#line 2498
int canUseHostPointerForRegisteredMem; 
#line 2499
int cooperativeLaunch; 
#line 2500
int cooperativeMultiDeviceLaunch; 
#line 2501
size_t sharedMemPerBlockOptin; 
#line 2502
int pageableMemoryAccessUsesHostPageTables; 
#line 2503
int directManagedMemAccessFromHost; 
#line 2504
int maxBlocksPerMultiProcessor; 
#line 2505
int accessPolicyMaxWindowSize; 
#line 2506
size_t reservedSharedMemPerBlock; 
#line 2507
int hostRegisterSupported; 
#line 2508
int sparseCudaArraySupported; 
#line 2509
int hostRegisterReadOnlySupported; 
#line 2510
int timelineSemaphoreInteropSupported; 
#line 2511
int memoryPoolsSupported; 
#line 2512
int gpuDirectRDMASupported; 
#line 2513
unsigned gpuDirectRDMAFlushWritesOptions; 
#line 2514
int gpuDirectRDMAWritesOrdering; 
#line 2515
unsigned memoryPoolSupportedHandleTypes; 
#line 2516
int deferredMappingCudaArraySupported; 
#line 2517
int ipcEventSupported; 
#line 2518
int clusterLaunch; 
#line 2519
int unifiedFunctionPointers; 
#line 2520
int reserved[63]; 
#line 2521
}; 
#endif
#line 2534 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef 
#line 2531
struct cudaIpcEventHandle_st { 
#line 2533
char reserved[64]; 
#line 2534
} cudaIpcEventHandle_t; 
#endif
#line 2542 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef 
#line 2539
struct cudaIpcMemHandle_st { 
#line 2541
char reserved[64]; 
#line 2542
} cudaIpcMemHandle_t; 
#endif
#line 2550 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef 
#line 2547
struct cudaMemFabricHandle_st { 
#line 2549
char reserved[64]; 
#line 2550
} cudaMemFabricHandle_t; 
#endif
#line 2555 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2555
enum cudaExternalMemoryHandleType { 
#line 2559
cudaExternalMemoryHandleTypeOpaqueFd = 1, 
#line 2563
cudaExternalMemoryHandleTypeOpaqueWin32, 
#line 2567
cudaExternalMemoryHandleTypeOpaqueWin32Kmt, 
#line 2571
cudaExternalMemoryHandleTypeD3D12Heap, 
#line 2575
cudaExternalMemoryHandleTypeD3D12Resource, 
#line 2579
cudaExternalMemoryHandleTypeD3D11Resource, 
#line 2583
cudaExternalMemoryHandleTypeD3D11ResourceKmt, 
#line 2587
cudaExternalMemoryHandleTypeNvSciBuf
#line 2588
}; 
#endif
#line 2630 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2630
struct cudaExternalMemoryHandleDesc { 
#line 2634
cudaExternalMemoryHandleType type; 
#line 2635
union { 
#line 2641
int fd; 
#line 2657
struct { 
#line 2661
void *handle; 
#line 2666
const void *name; 
#line 2667
} win32; 
#line 2672
const void *nvSciBufObject; 
#line 2673
} handle; 
#line 2677
unsigned __int64 size; 
#line 2681
unsigned flags; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 2682
}; 
#endif
#line 2687 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2687
struct cudaExternalMemoryBufferDesc { 
#line 2691
unsigned __int64 offset; 
#line 2695
unsigned __int64 size; 
#line 2699
unsigned flags; 
#line 2700
}; 
#endif
#line 2705 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2705
struct cudaExternalMemoryMipmappedArrayDesc { 
#line 2710
unsigned __int64 offset; 
#line 2714
cudaChannelFormatDesc formatDesc; 
#line 2718
cudaExtent extent; 
#line 2723
unsigned flags; 
#line 2727
unsigned numLevels; 
#line 2728
}; 
#endif
#line 2733 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2733
enum cudaExternalSemaphoreHandleType { 
#line 2737
cudaExternalSemaphoreHandleTypeOpaqueFd = 1, 
#line 2741
cudaExternalSemaphoreHandleTypeOpaqueWin32, 
#line 2745
cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt, 
#line 2749
cudaExternalSemaphoreHandleTypeD3D12Fence, 
#line 2753
cudaExternalSemaphoreHandleTypeD3D11Fence, 
#line 2757
cudaExternalSemaphoreHandleTypeNvSciSync, 
#line 2761
cudaExternalSemaphoreHandleTypeKeyedMutex, 
#line 2765
cudaExternalSemaphoreHandleTypeKeyedMutexKmt, 
#line 2769
cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd, 
#line 2773
cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32
#line 2774
}; 
#endif
#line 2779 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2779
struct cudaExternalSemaphoreHandleDesc { 
#line 2783
cudaExternalSemaphoreHandleType type; 
#line 2784
union { 
#line 2791
int fd; 
#line 2807
struct { 
#line 2811
void *handle; 
#line 2816
const void *name; 
#line 2817
} win32; 
#line 2821
const void *nvSciSyncObj; 
#line 2822
} handle; 
#line 2826
unsigned flags; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 2827
}; 
#endif
#line 2832 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2832
struct cudaExternalSemaphoreSignalParams_v1 { 
#line 2833
struct { 
#line 2837
struct { 
#line 2841
unsigned __int64 value; 
#line 2842
} fence; 
#line 2843
union { 
#line 2848
void *fence; 
#line 2849
unsigned __int64 reserved; 
#line 2850
} nvSciSync; 
#line 2854
struct { 
#line 2858
unsigned __int64 key; 
#line 2859
} keyedMutex; 
#line 2860
} params; 
#line 2871
unsigned flags; 
#line 2872
}; 
#endif
#line 2877 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2877
struct cudaExternalSemaphoreWaitParams_v1 { 
#line 2878
struct { 
#line 2882
struct { 
#line 2886
unsigned __int64 value; 
#line 2887
} fence; 
#line 2888
union { 
#line 2893
void *fence; 
#line 2894
unsigned __int64 reserved; 
#line 2895
} nvSciSync; 
#line 2899
struct { 
#line 2903
unsigned __int64 key; 
#line 2907
unsigned timeoutMs; 
#line 2908
} keyedMutex; 
#line 2909
} params; 
#line 2920
unsigned flags; 
#line 2921
}; 
#endif
#line 2926 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2926
struct cudaExternalSemaphoreSignalParams { 
#line 2927
struct { 
#line 2931
struct { 
#line 2935
unsigned __int64 value; 
#line 2936
} fence; 
#line 2937
union { 
#line 2942
void *fence; 
#line 2943
unsigned __int64 reserved; 
#line 2944
} nvSciSync; 
#line 2948
struct { 
#line 2952
unsigned __int64 key; 
#line 2953
} keyedMutex; 
#line 2954
unsigned reserved[12]; 
#line 2955
} params; 
#line 2966
unsigned flags; 
#line 2967
unsigned reserved[16]; 
#line 2968
}; 
#endif
#line 2973 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 2973
struct cudaExternalSemaphoreWaitParams { 
#line 2974
struct { 
#line 2978
struct { 
#line 2982
unsigned __int64 value; 
#line 2983
} fence; 
#line 2984
union { 
#line 2989
void *fence; 
#line 2990
unsigned __int64 reserved; 
#line 2991
} nvSciSync; 
#line 2995
struct { 
#line 2999
unsigned __int64 key; 
#line 3003
unsigned timeoutMs; 
#line 3004
} keyedMutex; 
#line 3005
unsigned reserved[10]; 
#line 3006
} params; 
#line 3017
unsigned flags; 
#line 3018
unsigned reserved[16]; 
#line 3019
}; 
#endif
#line 3030 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef cudaError 
#line 3030
cudaError_t; 
#endif
#line 3035 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef struct CUstream_st *
#line 3035
cudaStream_t; 
#endif
#line 3040 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef struct CUevent_st *
#line 3040
cudaEvent_t; 
#endif
#line 3045 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef cudaGraphicsResource *
#line 3045
cudaGraphicsResource_t; 
#endif
#line 3050 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef struct CUexternalMemory_st *
#line 3050
cudaExternalMemory_t; 
#endif
#line 3055 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef struct CUexternalSemaphore_st *
#line 3055
cudaExternalSemaphore_t; 
#endif
#line 3060 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef struct CUgraph_st *
#line 3060
cudaGraph_t; 
#endif
#line 3065 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef struct CUgraphNode_st *
#line 3065
cudaGraphNode_t; 
#endif
#line 3070 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef struct CUuserObject_st *
#line 3070
cudaUserObject_t; 
#endif
#line 3075 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef unsigned __int64 
#line 3075
cudaGraphConditionalHandle; 
#endif
#line 3080 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef struct CUfunc_st *
#line 3080
cudaFunction_t; 
#endif
#line 3085 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef struct CUkern_st *
#line 3085
cudaKernel_t; 
#endif
#line 3090 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3090
enum cudaJitOption { 
#line 3097
cudaJitMaxRegisters, 
#line 3111
cudaJitThreadsPerBlock, 
#line 3119
cudaJitWallTime, 
#line 3128
cudaJitInfoLogBuffer, 
#line 3137
cudaJitInfoLogBufferSizeBytes, 
#line 3146
cudaJitErrorLogBuffer, 
#line 3155
cudaJitErrorLogBufferSizeBytes, 
#line 3163
cudaJitOptimizationLevel, 
#line 3171
cudaJitFallbackStrategy = 10, 
#line 3179
cudaJitGenerateDebugInfo, 
#line 3186
cudaJitLogVerbose, 
#line 3193
cudaJitGenerateLineInfo, 
#line 3201
cudaJitCacheMode, 
#line 3208
cudaJitPositionIndependentCode = 30, 
#line 3221
cudaJitMinCtaPerSm, 
#line 3234
cudaJitMaxThreadsPerBlock, 
#line 3244
cudaJitOverrideDirectiveValues
#line 3245
}; 
#endif
#line 3251 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3251
enum cudaLibraryOption { 
#line 3253
cudaLibraryHostUniversalFunctionAndDataTable, 
#line 3264
cudaLibraryBinaryIsPreserved
#line 3265
}; 
#endif
#line 3267 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3267
struct cudalibraryHostUniversalFunctionAndDataTable { 
#line 3269
void *functionTable; 
#line 3270
size_t functionWindowSize; 
#line 3271
void *dataTable; 
#line 3272
size_t dataWindowSize; 
#line 3273
}; 
#endif
#line 3278 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3278
enum cudaJit_CacheMode { 
#line 3280
cudaJitCacheOptionNone, 
#line 3281
cudaJitCacheOptionCG, 
#line 3282
cudaJitCacheOptionCA
#line 3283
}; 
#endif
#line 3288 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3288
enum cudaJit_Fallback { 
#line 3290
cudaPreferPtx, 
#line 3292
cudaPreferBinary
#line 3293
}; 
#endif
#line 3298 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef struct CUlib_st *
#line 3298
cudaLibrary_t; 
#endif
#line 3303 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef struct CUmemPoolHandle_st *
#line 3303
cudaMemPool_t; 
#endif
#line 3308 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3308
enum cudaCGScope { 
#line 3309
cudaCGScopeInvalid, 
#line 3310
cudaCGScopeGrid, 
#line 3311
cudaCGScopeMultiGrid
#line 3312
}; 
#endif
#line 3317 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3317
struct cudaLaunchParams { 
#line 3319
void *func; 
#line 3320
dim3 gridDim; 
#line 3321
dim3 blockDim; 
#line 3322
void **args; 
#line 3323
size_t sharedMem; 
#line 3324
cudaStream_t stream; 
#line 3325
}; 
#endif
#line 3330 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3330
struct cudaKernelNodeParams { 
#line 3331
void *func; 
#line 3332
dim3 gridDim; 
#line 3333
dim3 blockDim; 
#line 3334
unsigned sharedMemBytes; 
#line 3335
void **kernelParams; 
#line 3336
void **extra; 
#line 3337
}; 
#endif
#line 3342 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3342
struct cudaKernelNodeParamsV2 { 
#line 3343
void *func; 
#line 3349 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
uint3 gridDim; 
#line 3350
uint3 blockDim; 
#line 3352 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
unsigned sharedMemBytes; 
#line 3353
void **kernelParams; 
#line 3354
void **extra; 
#line 3355
}; 
#endif
#line 3360 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3360
struct cudaExternalSemaphoreSignalNodeParams { 
#line 3361
cudaExternalSemaphore_t *extSemArray; 
#line 3362
const cudaExternalSemaphoreSignalParams *paramsArray; 
#line 3363
unsigned numExtSems; 
#line 3364
}; 
#endif
#line 3369 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3369
struct cudaExternalSemaphoreSignalNodeParamsV2 { 
#line 3370
cudaExternalSemaphore_t *extSemArray; 
#line 3371
const cudaExternalSemaphoreSignalParams *paramsArray; 
#line 3372
unsigned numExtSems; 
#line 3373
}; 
#endif
#line 3378 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3378
struct cudaExternalSemaphoreWaitNodeParams { 
#line 3379
cudaExternalSemaphore_t *extSemArray; 
#line 3380
const cudaExternalSemaphoreWaitParams *paramsArray; 
#line 3381
unsigned numExtSems; 
#line 3382
}; 
#endif
#line 3387 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3387
struct cudaExternalSemaphoreWaitNodeParamsV2 { 
#line 3388
cudaExternalSemaphore_t *extSemArray; 
#line 3389
const cudaExternalSemaphoreWaitParams *paramsArray; 
#line 3390
unsigned numExtSems; 
#line 3391
}; 
#endif
#line 3393 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3393
enum cudaGraphConditionalHandleFlags { 
#line 3394
cudaGraphCondAssignDefault = 1
#line 3395
}; 
#endif
#line 3400 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3400
enum cudaGraphConditionalNodeType { 
#line 3401
cudaGraphCondTypeIf, 
#line 3402
cudaGraphCondTypeWhile, 
#line 3403
cudaGraphCondTypeSwitch
#line 3404
}; 
#endif
#line 3409 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3409
struct cudaConditionalNodeParams { 
#line 3410
cudaGraphConditionalHandle handle; 
#line 3413
cudaGraphConditionalNodeType type; 
#line 3414
unsigned size; 
#line 3416
cudaGraph_t *phGraph_out; 
#line 3435
}; 
#endif
#line 3440 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3440
enum cudaGraphNodeType { 
#line 3441
cudaGraphNodeTypeKernel, 
#line 3442
cudaGraphNodeTypeMemcpy, 
#line 3443
cudaGraphNodeTypeMemset, 
#line 3444
cudaGraphNodeTypeHost, 
#line 3445
cudaGraphNodeTypeGraph, 
#line 3446
cudaGraphNodeTypeEmpty, 
#line 3447
cudaGraphNodeTypeWaitEvent, 
#line 3448
cudaGraphNodeTypeEventRecord, 
#line 3449
cudaGraphNodeTypeExtSemaphoreSignal, 
#line 3450
cudaGraphNodeTypeExtSemaphoreWait, 
#line 3451
cudaGraphNodeTypeMemAlloc, 
#line 3452
cudaGraphNodeTypeMemFree, 
#line 3453
cudaGraphNodeTypeConditional = 13, 
#line 3470
cudaGraphNodeTypeCount
#line 3471
}; 
#endif
#line 3476 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3476
enum cudaGraphChildGraphNodeOwnership { 
#line 3477
cudaGraphChildGraphOwnershipClone, 
#line 3480
cudaGraphChildGraphOwnershipMove
#line 3489
}; 
#endif
#line 3494 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3494
struct cudaChildGraphNodeParams { 
#line 3495
cudaGraph_t graph; 
#line 3501
cudaGraphChildGraphNodeOwnership ownership; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 3502
}; 
#endif
#line 3507 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3507
struct cudaEventRecordNodeParams { 
#line 3508
cudaEvent_t event; 
#line 3509
}; 
#endif
#line 3514 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3514
struct cudaEventWaitNodeParams { 
#line 3515
cudaEvent_t event; 
#line 3516
}; 
#endif
#line 3521 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3521
struct cudaGraphNodeParams { 
#line 3522
cudaGraphNodeType type; 
#line 3523
int reserved0[3]; 
#line 3525
union { 
#line 3526
__int64 reserved1[29]; 
#line 3527
cudaKernelNodeParamsV2 kernel; 
#line 3528
cudaMemcpyNodeParams memcpy; 
#line 3529
cudaMemsetParamsV2 memset; 
#line 3530
cudaHostNodeParamsV2 host; 
#line 3531
cudaChildGraphNodeParams graph; 
#line 3532
cudaEventWaitNodeParams eventWait; 
#line 3533
cudaEventRecordNodeParams eventRecord; 
#line 3534
cudaExternalSemaphoreSignalNodeParamsV2 extSemSignal; 
#line 3535
cudaExternalSemaphoreWaitNodeParamsV2 extSemWait; 
#line 3536
cudaMemAllocNodeParamsV2 alloc; 
#line 3537
cudaMemFreeNodeParams free; 
#line 3538
cudaConditionalNodeParams conditional; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 3539
}; 
#line 3541
__int64 reserved2; 
#line 3542
}; 
#endif
#line 3554 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef 
#line 3547
enum cudaGraphDependencyType_enum { 
#line 3548
cudaGraphDependencyTypeDefault, 
#line 3549
cudaGraphDependencyTypeProgrammatic
#line 3554
} cudaGraphDependencyType; 
#endif
#line 3584 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef 
#line 3561
struct cudaGraphEdgeData_st { 
#line 3562
unsigned char from_port; 
#line 3572
unsigned char to_port; 
#line 3579
unsigned char type; 
#line 3582
unsigned char reserved[5]; 
#line 3584
} cudaGraphEdgeData; 
#endif
#line 3605 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
typedef struct CUgraphExec_st *cudaGraphExec_t; 
#line 3610
#if 0
#line 3610
enum cudaGraphExecUpdateResult { 
#line 3611
cudaGraphExecUpdateSuccess, 
#line 3612
cudaGraphExecUpdateError, 
#line 3613
cudaGraphExecUpdateErrorTopologyChanged, 
#line 3614
cudaGraphExecUpdateErrorNodeTypeChanged, 
#line 3615
cudaGraphExecUpdateErrorFunctionChanged, 
#line 3616
cudaGraphExecUpdateErrorParametersChanged, 
#line 3617
cudaGraphExecUpdateErrorNotSupported, 
#line 3618
cudaGraphExecUpdateErrorUnsupportedFunctionChange, 
#line 3619
cudaGraphExecUpdateErrorAttributesChanged
#line 3620
}; 
#endif
#line 3632 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef 
#line 3625
enum cudaGraphInstantiateResult { 
#line 3626
cudaGraphInstantiateSuccess, 
#line 3627
cudaGraphInstantiateError, 
#line 3628
cudaGraphInstantiateInvalidStructure, 
#line 3629
cudaGraphInstantiateNodeOperationNotSupported, 
#line 3630
cudaGraphInstantiateMultipleDevicesNotSupported, 
#line 3631
cudaGraphInstantiateConditionalHandleUnused
#line 3632
} cudaGraphInstantiateResult; 
#endif
#line 3643 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef 
#line 3637
struct cudaGraphInstantiateParams_st { 
#line 3639
unsigned __int64 flags; 
#line 3640
cudaStream_t uploadStream; 
#line 3641
cudaGraphNode_t errNode_out; 
#line 3642
cudaGraphInstantiateResult result_out; 
#line 3643
} cudaGraphInstantiateParams; 
#endif
#line 3665 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef 
#line 3648
struct cudaGraphExecUpdateResultInfo_st { 
#line 3652
cudaGraphExecUpdateResult result; 
#line 3659
cudaGraphNode_t errorNode; 
#line 3664
cudaGraphNode_t errorFromNode; 
#line 3665
} cudaGraphExecUpdateResultInfo; 
#endif
#line 3670 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
typedef struct CUgraphDeviceUpdatableNode_st *cudaGraphDeviceNode_t; 
#line 3675
#if 0
#line 3675
enum cudaGraphKernelNodeField { 
#line 3677
cudaGraphKernelNodeFieldInvalid, 
#line 3678
cudaGraphKernelNodeFieldGridDim, 
#line 3679
cudaGraphKernelNodeFieldParam, 
#line 3680
cudaGraphKernelNodeFieldEnabled
#line 3681
}; 
#endif
#line 3686 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3686
struct cudaGraphKernelNodeUpdate { 
#line 3687
cudaGraphDeviceNode_t node; 
#line 3688
cudaGraphKernelNodeField field; 
#line 3689
union { 
#line 3694 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
uint3 gridDim; 
#line 3696 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
struct { 
#line 3697
const void *pValue; 
#line 3698
size_t offset; 
#line 3699
size_t size; 
#line 3700
} param; 
#line 3701
unsigned isEnabled; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 3702
} updateData; 
#line 3703
}; 
#endif
#line 3709 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3709
enum cudaGetDriverEntryPointFlags { 
#line 3710
cudaEnableDefault, 
#line 3711
cudaEnableLegacyStream, 
#line 3712
cudaEnablePerThreadDefaultStream
#line 3713
}; 
#endif
#line 3718 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3718
enum cudaDriverEntryPointQueryResult { 
#line 3719
cudaDriverEntryPointSuccess, 
#line 3720
cudaDriverEntryPointSymbolNotFound, 
#line 3721
cudaDriverEntryPointVersionNotSufficent
#line 3722
}; 
#endif
#line 3727 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3727
enum cudaGraphDebugDotFlags { 
#line 3728
cudaGraphDebugDotFlagsVerbose = (1 << 0), 
#line 3729
cudaGraphDebugDotFlagsKernelNodeParams = (1 << 2), 
#line 3730
cudaGraphDebugDotFlagsMemcpyNodeParams = (1 << 3), 
#line 3731
cudaGraphDebugDotFlagsMemsetNodeParams = (1 << 4), 
#line 3732
cudaGraphDebugDotFlagsHostNodeParams = (1 << 5), 
#line 3733
cudaGraphDebugDotFlagsEventNodeParams = (1 << 6), 
#line 3734
cudaGraphDebugDotFlagsExtSemasSignalNodeParams = (1 << 7), 
#line 3735
cudaGraphDebugDotFlagsExtSemasWaitNodeParams = (1 << 8), 
#line 3736
cudaGraphDebugDotFlagsKernelNodeAttributes = (1 << 9), 
#line 3737
cudaGraphDebugDotFlagsHandles = (1 << 10), 
#line 3738
cudaGraphDebugDotFlagsConditionalNodeParams = (1 << 15)
#line 3739
}; 
#endif
#line 3744 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 3744
enum cudaGraphInstantiateFlags { 
#line 3745
cudaGraphInstantiateFlagAutoFreeOnLaunch = 1, 
#line 3746
cudaGraphInstantiateFlagUpload, 
#line 3749
cudaGraphInstantiateFlagDeviceLaunch = 4, 
#line 3752
cudaGraphInstantiateFlagUseNodePriority = 8
#line 3754
}; 
#endif
#line 3775 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef 
#line 3772
enum cudaLaunchMemSyncDomain { 
#line 3773
cudaLaunchMemSyncDomainDefault, 
#line 3774
cudaLaunchMemSyncDomainRemote
#line 3775
} cudaLaunchMemSyncDomain; 
#endif
#line 3791 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef 
#line 3788
struct cudaLaunchMemSyncDomainMap_st { 
#line 3789
unsigned char default_; 
#line 3790
unsigned char remote; 
#line 3791
} cudaLaunchMemSyncDomainMap; 
#endif
#line 3943 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef 
#line 3796
enum cudaLaunchAttributeID { 
#line 3797
cudaLaunchAttributeIgnore, 
#line 3798
cudaLaunchAttributeAccessPolicyWindow, 
#line 3800
cudaLaunchAttributeCooperative, 
#line 3802
cudaLaunchAttributeSynchronizationPolicy, 
#line 3803
cudaLaunchAttributeClusterDimension, 
#line 3805
cudaLaunchAttributeClusterSchedulingPolicyPreference, 
#line 3807
cudaLaunchAttributeProgrammaticStreamSerialization, 
#line 3818
cudaLaunchAttributeProgrammaticEvent, 
#line 3844
cudaLaunchAttributePriority, 
#line 3846
cudaLaunchAttributeMemSyncDomainMap, 
#line 3848
cudaLaunchAttributeMemSyncDomain, 
#line 3850
cudaLaunchAttributePreferredClusterDimension, 
#line 3886
cudaLaunchAttributeLaunchCompletionEvent, 
#line 3908
cudaLaunchAttributeDeviceUpdatableKernelNode, 
#line 3936
cudaLaunchAttributePreferredSharedMemoryCarveout
#line 3943
} cudaLaunchAttributeID; 
#endif
#line 4039 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef 
#line 3948
union cudaLaunchAttributeValue { 
#line 3949
char pad[64]; 
#line 3950
cudaAccessPolicyWindow accessPolicyWindow; 
#line 3951
int cooperative; 
#line 3953
cudaSynchronizationPolicy syncPolicy; 
#line 3967
struct { 
#line 3968
unsigned x; 
#line 3969
unsigned y; 
#line 3970
unsigned z; 
#line 3971
} clusterDim; 
#line 3972
cudaClusterSchedulingPolicy clusterSchedulingPolicyPreference; 
#line 3975
int programmaticStreamSerializationAllowed; 
#line 3986
struct { 
#line 3987
cudaEvent_t event; 
#line 3988
int flags; 
#line 3989
int triggerAtBlockStart; 
#line 3990
} programmaticEvent; 
#line 3991
int priority; 
#line 3992
cudaLaunchMemSyncDomainMap memSyncDomainMap; 
#line 3995
cudaLaunchMemSyncDomain memSyncDomain; 
#line 4010
struct { 
#line 4011
unsigned x; 
#line 4012
unsigned y; 
#line 4013
unsigned z; 
#line 4014
} preferredClusterDim; 
#line 4023
struct { 
#line 4024
cudaEvent_t event; 
#line 4025
int flags; 
#line 4026
} launchCompletionEvent; 
#line 4034
struct { 
#line 4035
int deviceUpdatable; 
#line 4036
cudaGraphDeviceNode_t devNode; 
#line 4037
} deviceUpdatableKernelNode; 
#line 4038
unsigned sharedMemCarveout; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 4039
} cudaLaunchAttributeValue; 
#endif
#line 4048 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef 
#line 4044
struct cudaLaunchAttribute_st { 
#line 4045
cudaLaunchAttributeID id; 
#line 4046
char pad[(8) - sizeof(cudaLaunchAttributeID)]; 
#line 4047
cudaLaunchAttributeValue val; 
#line 4048
} cudaLaunchAttribute; 
#endif
#line 4060 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef 
#line 4053
struct cudaLaunchConfig_st { 
#line 4054
dim3 gridDim; 
#line 4055
dim3 blockDim; 
#line 4056
size_t dynamicSmemBytes; 
#line 4057
cudaStream_t stream; 
#line 4058
cudaLaunchAttribute *attrs; 
#line 4059
unsigned numAttrs; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 4060
} cudaLaunchConfig_t; 
#endif
#line 4087 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
#line 4087
enum cudaDeviceNumaConfig { 
#line 4088
cudaDeviceNumaConfigNone, 
#line 4089
cudaDeviceNumaConfigNumaNode
#line 4090
}; 
#endif
#line 4095 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
typedef struct cudaAsyncCallbackEntry *cudaAsyncCallbackHandle_t; 
#line 4097
struct cudaAsyncCallbackEntry; 
#line 4104
#if 0
typedef 
#line 4102
enum cudaAsyncNotificationType_enum { 
#line 4103
cudaAsyncNotificationTypeOverBudget = 1
#line 4104
} cudaAsyncNotificationType; 
#endif
#line 4117 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
#if 0
typedef 
#line 4109
struct cudaAsyncNotificationInfo { 
#line 4111
cudaAsyncNotificationType type; 
#line 4112
union { 
#line 4113
struct { 
#line 4114
unsigned __int64 bytesOverBudget; 
#line 4115
} overBudget; 
#line 4116
} info; 
#line 4117
} cudaAsyncNotificationInfo_t; 
#endif
#line 4119 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_types.h"
typedef void (*cudaAsyncCallback)(cudaAsyncNotificationInfo_t *, void *, cudaAsyncCallbackHandle_t); 
#line 86 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_types.h"
#if 0
#line 86
enum cudaSurfaceBoundaryMode { 
#line 88
cudaBoundaryModeZero, 
#line 89
cudaBoundaryModeClamp, 
#line 90
cudaBoundaryModeTrap
#line 91
}; 
#endif
#line 96 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_types.h"
#if 0
#line 96
enum cudaSurfaceFormatMode { 
#line 98
cudaFormatModeForced, 
#line 99
cudaFormatModeAuto
#line 100
}; 
#endif
#line 105 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_types.h"
#if 0
typedef unsigned __int64 
#line 105
cudaSurfaceObject_t; 
#endif
#line 86 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_types.h"
#if 0
#line 86
enum cudaTextureAddressMode { 
#line 88
cudaAddressModeWrap, 
#line 89
cudaAddressModeClamp, 
#line 90
cudaAddressModeMirror, 
#line 91
cudaAddressModeBorder
#line 92
}; 
#endif
#line 97 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_types.h"
#if 0
#line 97
enum cudaTextureFilterMode { 
#line 99
cudaFilterModePoint, 
#line 100
cudaFilterModeLinear
#line 101
}; 
#endif
#line 106 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_types.h"
#if 0
#line 106
enum cudaTextureReadMode { 
#line 108
cudaReadModeElementType, 
#line 109
cudaReadModeNormalizedFloat
#line 110
}; 
#endif
#line 115 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_types.h"
#if 0
#line 115
struct cudaTextureDesc { 
#line 120
cudaTextureAddressMode addressMode[3]; 
#line 124
cudaTextureFilterMode filterMode; 
#line 128
cudaTextureReadMode readMode; 
#line 132
int sRGB; 
#line 136
float borderColor[4]; 
#line 140
int normalizedCoords; 
#line 144
unsigned maxAnisotropy; 
#line 148
cudaTextureFilterMode mipmapFilterMode; 
#line 152
float mipmapLevelBias; 
#line 156
float minMipmapLevelClamp; 
#line 160
float maxMipmapLevelClamp; 
#line 164
int disableTrilinearOptimization; 
#line 168
int seamlessCubemap; 
#line 169
}; 
#endif
#line 174 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_types.h"
#if 0
typedef unsigned __int64 
#line 174
cudaTextureObject_t; 
#endif
#line 94 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\library_types.h"
typedef 
#line 57
enum cudaDataType_t { 
#line 59
CUDA_R_16F = 2, 
#line 60
CUDA_C_16F = 6, 
#line 61
CUDA_R_16BF = 14, 
#line 62
CUDA_C_16BF, 
#line 63
CUDA_R_32F = 0, 
#line 64
CUDA_C_32F = 4, 
#line 65
CUDA_R_64F = 1, 
#line 66
CUDA_C_64F = 5, 
#line 67
CUDA_R_4I = 16, 
#line 68
CUDA_C_4I, 
#line 69
CUDA_R_4U, 
#line 70
CUDA_C_4U, 
#line 71
CUDA_R_8I = 3, 
#line 72
CUDA_C_8I = 7, 
#line 73
CUDA_R_8U, 
#line 74
CUDA_C_8U, 
#line 75
CUDA_R_16I = 20, 
#line 76
CUDA_C_16I, 
#line 77
CUDA_R_16U, 
#line 78
CUDA_C_16U, 
#line 79
CUDA_R_32I = 10, 
#line 80
CUDA_C_32I, 
#line 81
CUDA_R_32U, 
#line 82
CUDA_C_32U, 
#line 83
CUDA_R_64I = 24, 
#line 84
CUDA_C_64I, 
#line 85
CUDA_R_64U, 
#line 86
CUDA_C_64U, 
#line 87
CUDA_R_8F_E4M3, 
#line 88
CUDA_R_8F_UE4M3 = CUDA_R_8F_E4M3, 
#line 89
CUDA_R_8F_E5M2, 
#line 90
CUDA_R_8F_UE8M0, 
#line 91
CUDA_R_6F_E2M3, 
#line 92
CUDA_R_6F_E3M2, 
#line 93
CUDA_R_4F_E2M1
#line 94
} cudaDataType; 
#line 102
typedef 
#line 97
enum libraryPropertyType_t { 
#line 99
MAJOR_VERSION, 
#line 100
MINOR_VERSION, 
#line 101
PATCH_LEVEL
#line 102
} libraryPropertyType; 
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_malloc.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 17
__pragma( pack ( push, 8 )) extern "C" {
#line 58 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_malloc.h"
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 59
_calloc_base(size_t _Count, size_t _Size); 
#line 65
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 66
calloc(size_t _Count, size_t _Size); 
#line 72
int __cdecl _callnewh(size_t _Size); 
#line 77
__declspec(allocator) void *__cdecl 
#line 78
_expand(void * _Block, size_t _Size); 
#line 84
void __cdecl _free_base(void * _Block); 
#line 89
void __cdecl free(void * _Block); 
#line 94
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 95
_malloc_base(size_t _Size); 
#line 100
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 101
malloc(size_t _Size); 
#line 107
size_t __cdecl _msize_base(void * _Block) noexcept; 
#line 113
size_t __cdecl _msize(void * _Block); 
#line 118
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 119
_realloc_base(void * _Block, size_t _Size); 
#line 125
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 126
realloc(void * _Block, size_t _Size); 
#line 132
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 133
_recalloc_base(void * _Block, size_t _Count, size_t _Size); 
#line 140
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 141
_recalloc(void * _Block, size_t _Count, size_t _Size); 
#line 148
void __cdecl _aligned_free(void * _Block); 
#line 153
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 154
_aligned_malloc(size_t _Size, size_t _Alignment); 
#line 160
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 161
_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset); 
#line 169
size_t __cdecl _aligned_msize(void * _Block, size_t _Alignment, size_t _Offset); 
#line 176
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 177
_aligned_offset_realloc(void * _Block, size_t _Size, size_t _Alignment, size_t _Offset); 
#line 185
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 186
_aligned_offset_recalloc(void * _Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset); 
#line 195
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 196
_aligned_realloc(void * _Block, size_t _Size, size_t _Alignment); 
#line 203
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 204
_aligned_recalloc(void * _Block, size_t _Count, size_t _Size, size_t _Alignment); 
#line 232 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_malloc.h"
}__pragma( pack ( pop )) 
#line 234
#pragma warning(pop)
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_search.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 20
__pragma( pack ( push, 8 )) extern "C" {
#line 23
typedef int (__cdecl *_CoreCrtSecureSearchSortCompareFunction)(void *, const void *, const void *); 
#line 24
typedef int (__cdecl *_CoreCrtNonSecureSearchSortCompareFunction)(const void *, const void *); 
#line 30
void *__cdecl bsearch_s(const void * _Key, const void * _Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void * _Context); 
#line 39
void __cdecl qsort_s(void * _Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void * _Context); 
#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_search.h"
void *__cdecl bsearch(const void * _Key, const void * _Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 60
void __cdecl qsort(void * _Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 68
void *__cdecl _lfind_s(const void * _Key, const void * _Base, unsigned * _NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void * _Context); 
#line 78
void *__cdecl _lfind(const void * _Key, const void * _Base, unsigned * _NumOfElements, unsigned _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 87
void *__cdecl _lsearch_s(const void * _Key, void * _Base, unsigned * _NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void * _Context); 
#line 97
void *__cdecl _lsearch(const void * _Key, void * _Base, unsigned * _NumOfElements, unsigned _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 195 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_search.h"
void *__cdecl lfind(const void * _Key, const void * _Base, unsigned * _NumOfElements, unsigned _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 204
void *__cdecl lsearch(const void * _Key, void * _Base, unsigned * _NumOfElements, unsigned _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 216 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_search.h"
}__pragma( pack ( pop )) 
#line 218
#pragma warning(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 17
__pragma( pack ( push, 8 )) extern "C" {
#line 54
errno_t __cdecl _itow_s(int _Value, __wchar_t * _Buffer, size_t _BufferCount, int _Radix); 
#line 61
extern "C++" {template < size_t _Size > inline errno_t __cdecl _itow_s ( int _Value, wchar_t ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _itow_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 68 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"
__wchar_t *__cdecl _itow(int _Value, __wchar_t * _Buffer, int _Radix); 
#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"
errno_t __cdecl _ltow_s(long _Value, __wchar_t * _Buffer, size_t _BufferCount, int _Radix); 
#line 84
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ltow_s ( long _Value, wchar_t ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _ltow_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 91 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"
__wchar_t *__cdecl _ltow(long _Value, __wchar_t * _Buffer, int _Radix); 
#line 99 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"
errno_t __cdecl _ultow_s(unsigned long _Value, __wchar_t * _Buffer, size_t _BufferCount, int _Radix); 
#line 106
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ultow_s ( unsigned long _Value, wchar_t ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _ultow_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"
__wchar_t *__cdecl _ultow(unsigned long _Value, __wchar_t * _Buffer, int _Radix); 
#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"
double __cdecl wcstod(const __wchar_t * _String, __wchar_t ** _EndPtr); 
#line 127
double __cdecl _wcstod_l(const __wchar_t * _String, __wchar_t ** _EndPtr, _locale_t _Locale); 
#line 134
long __cdecl wcstol(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 141
long __cdecl _wcstol_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 149
__int64 __cdecl wcstoll(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 156
__int64 __cdecl _wcstoll_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 164
unsigned long __cdecl wcstoul(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 171
unsigned long __cdecl _wcstoul_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 179
unsigned __int64 __cdecl wcstoull(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 186
unsigned __int64 __cdecl _wcstoull_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 194
long double __cdecl wcstold(const __wchar_t * _String, __wchar_t ** _EndPtr); 
#line 200
long double __cdecl _wcstold_l(const __wchar_t * _String, __wchar_t ** _EndPtr, _locale_t _Locale); 
#line 207
float __cdecl wcstof(const __wchar_t * _String, __wchar_t ** _EndPtr); 
#line 213
float __cdecl _wcstof_l(const __wchar_t * _String, __wchar_t ** _EndPtr, _locale_t _Locale); 
#line 220
double __cdecl _wtof(const __wchar_t * _String); 
#line 225
double __cdecl _wtof_l(const __wchar_t * _String, _locale_t _Locale); 
#line 231
int __cdecl _wtoi(const __wchar_t * _String); 
#line 236
int __cdecl _wtoi_l(const __wchar_t * _String, _locale_t _Locale); 
#line 242
long __cdecl _wtol(const __wchar_t * _String); 
#line 247
long __cdecl _wtol_l(const __wchar_t * _String, _locale_t _Locale); 
#line 253
__int64 __cdecl _wtoll(const __wchar_t * _String); 
#line 258
__int64 __cdecl _wtoll_l(const __wchar_t * _String, _locale_t _Locale); 
#line 264
errno_t __cdecl _i64tow_s(__int64 _Value, __wchar_t * _Buffer, size_t _BufferCount, int _Radix); 
#line 272
__wchar_t *__cdecl _i64tow(__int64 _Value, __wchar_t * _Buffer, int _Radix); 
#line 279
errno_t __cdecl _ui64tow_s(unsigned __int64 _Value, __wchar_t * _Buffer, size_t _BufferCount, int _Radix); 
#line 287
__wchar_t *__cdecl _ui64tow(unsigned __int64 _Value, __wchar_t * _Buffer, int _Radix); 
#line 294
__int64 __cdecl _wtoi64(const __wchar_t * _String); 
#line 299
__int64 __cdecl _wtoi64_l(const __wchar_t * _String, _locale_t _Locale); 
#line 305
__int64 __cdecl _wcstoi64(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 312
__int64 __cdecl _wcstoi64_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 320
unsigned __int64 __cdecl _wcstoui64(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 327
unsigned __int64 __cdecl _wcstoui64_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 339
__declspec(allocator) __wchar_t *__cdecl _wfullpath(__wchar_t * _Buffer, const __wchar_t * _Path, size_t _BufferCount); 
#line 348
errno_t __cdecl _wmakepath_s(__wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Drive, const __wchar_t * _Dir, const __wchar_t * _Filename, const __wchar_t * _Ext); 
#line 357
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wmakepath_s ( wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _Drive, wchar_t const * _Dir, wchar_t const * _Filename, wchar_t const * _Ext ) throw ( ) { return _wmakepath_s ( _Buffer, _Size, _Drive, _Dir, _Filename, _Ext ); }}
#line 366 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"
void __cdecl _wmakepath(__wchar_t * _Buffer, const __wchar_t * _Drive, const __wchar_t * _Dir, const __wchar_t * _Filename, const __wchar_t * _Ext); 
#line 375 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"
void __cdecl _wperror(const __wchar_t * _ErrorMessage); 
#line 380
void __cdecl _wsplitpath(const __wchar_t * _FullPath, __wchar_t * _Drive, __wchar_t * _Dir, __wchar_t * _Filename, __wchar_t * _Ext); 
#line 388
errno_t __cdecl _wsplitpath_s(const __wchar_t * _FullPath, __wchar_t * _Drive, size_t _DriveCount, __wchar_t * _Dir, size_t _DirCount, __wchar_t * _Filename, size_t _FilenameCount, __wchar_t * _Ext, size_t _ExtCount); 
#line 400
extern "C++" {template < size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize > inline errno_t __cdecl _wsplitpath_s ( wchar_t const * _Path, wchar_t ( & _Drive ) [ _DriveSize ], wchar_t ( & _Dir ) [ _DirSize ], wchar_t ( & _Name ) [ _NameSize ], wchar_t ( & _Ext ) [ _ExtSize ] ) throw ( ) { return _wsplitpath_s ( _Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize ); }}
#line 409 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"
errno_t __cdecl _wdupenv_s(__wchar_t ** _Buffer, size_t * _BufferCount, const __wchar_t * _VarName); 
#line 418
__wchar_t *__cdecl _wgetenv(const __wchar_t * _VarName); 
#line 424
errno_t __cdecl _wgetenv_s(size_t * _RequiredCount, __wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _VarName); 
#line 431
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wgetenv_s ( size_t * _RequiredCount, wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _VarName ) throw ( ) { return _wgetenv_s ( _RequiredCount, _Buffer, _Size, _VarName ); }}
#line 440 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"
int __cdecl _wputenv(const __wchar_t * _EnvString); 
#line 445
errno_t __cdecl _wputenv_s(const __wchar_t * _Name, const __wchar_t * _Value); 
#line 450
errno_t __cdecl _wsearchenv_s(const __wchar_t * _Filename, const __wchar_t * _VarName, __wchar_t * _Buffer, size_t _BufferCount); 
#line 457
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wsearchenv_s ( wchar_t const * _Filename, wchar_t const * _VarName, wchar_t ( & _ResultPath ) [ _Size ] ) throw ( ) { return _wsearchenv_s ( _Filename, _VarName, _ResultPath, _Size ); }}
#line 464 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"
void __cdecl _wsearchenv(const __wchar_t * _Filename, const __wchar_t * _VarName, __wchar_t * _ResultPath); 
#line 471 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"
int __cdecl _wsystem(const __wchar_t * _Command); 
#line 479 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"
}__pragma( pack ( pop )) 
#line 481
#pragma warning(pop)
#line 18 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 22
__pragma( pack ( push, 8 )) extern "C" {
#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
void __cdecl _swab(char * _Buf1, char * _Buf2, int _SizeInBytes); 
#line 56
__declspec(noreturn) void __cdecl exit(int _Code); 
#line 57
__declspec(noreturn) void __cdecl _exit(int _Code); 
#line 58
__declspec(noreturn) void __cdecl _Exit(int _Code); 
#line 59
__declspec(noreturn) void __cdecl quick_exit(int _Code); 
#line 60
__declspec(noreturn) void __cdecl abort(); 
#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
unsigned __cdecl _set_abort_behavior(unsigned _Flags, unsigned _Mask); 
#line 77
typedef int (__cdecl *_onexit_t)(void); 
#line 144 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
int __cdecl atexit(void (__cdecl *)(void)); 
#line 145
_onexit_t __cdecl _onexit(_onexit_t _Func); 
#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
int __cdecl at_quick_exit(void (__cdecl *)(void)); 
#line 159
typedef void (__cdecl *_purecall_handler)(void); 
#line 162
typedef void (__cdecl *_invalid_parameter_handler)(const __wchar_t *, const __wchar_t *, const __wchar_t *, unsigned, uintptr_t); 
#line 171
_purecall_handler __cdecl _set_purecall_handler(_purecall_handler _Handler); 
#line 175
_purecall_handler __cdecl _get_purecall_handler(); 
#line 178
_invalid_parameter_handler __cdecl _set_invalid_parameter_handler(_invalid_parameter_handler _Handler); 
#line 182
_invalid_parameter_handler __cdecl _get_invalid_parameter_handler(); 
#line 184
_invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler); 
#line 188
_invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(); 
#line 212 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
int __cdecl _set_error_mode(int _Mode); 
#line 217
int *__cdecl _errno(); 
#line 220
errno_t __cdecl _set_errno(int _Value); 
#line 221
errno_t __cdecl _get_errno(int * _Value); 
#line 223
unsigned long *__cdecl __doserrno(); 
#line 226
errno_t __cdecl _set_doserrno(unsigned long _Value); 
#line 227
errno_t __cdecl _get_doserrno(unsigned long * _Value); 
#line 230
char **__cdecl __sys_errlist(); 
#line 233
int *__cdecl __sys_nerr(); 
#line 236
void __cdecl perror(const char * _ErrMsg); 
#line 242 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
char **__cdecl __p__pgmptr(); 
#line 243
__wchar_t **__cdecl __p__wpgmptr(); 
#line 244
int *__cdecl __p__fmode(); 
#line 259 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
errno_t __cdecl _get_pgmptr(char ** _Value); 
#line 262
errno_t __cdecl _get_wpgmptr(__wchar_t ** _Value); 
#line 264
errno_t __cdecl _set_fmode(int _Mode); 
#line 266
errno_t __cdecl _get_fmode(int * _PMode); 
#line 279
typedef 
#line 275
struct _div_t { 
#line 277
int quot; 
#line 278
int rem; 
#line 279
} div_t; 
#line 285
typedef 
#line 281
struct _ldiv_t { 
#line 283
long quot; 
#line 284
long rem; 
#line 285
} ldiv_t; 
#line 291
typedef 
#line 287
struct _lldiv_t { 
#line 289
__int64 quot; 
#line 290
__int64 rem; 
#line 291
} lldiv_t; 
#line 293
int __cdecl abs(int _Number); 
#line 294
long __cdecl labs(long _Number); 
#line 295
__int64 __cdecl llabs(__int64 _Number); 
#line 296
__int64 __cdecl _abs64(__int64 _Number); 
#line 298
unsigned short __cdecl _byteswap_ushort(unsigned short _Number); 
#line 299
unsigned long __cdecl _byteswap_ulong(unsigned long _Number); 
#line 300
unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64 _Number); 
#line 302
div_t __cdecl div(int _Numerator, int _Denominator); 
#line 303
ldiv_t __cdecl ldiv(long _Numerator, long _Denominator); 
#line 304
lldiv_t __cdecl lldiv(__int64 _Numerator, __int64 _Denominator); 
#line 308
#pragma warning(push)
#pragma warning(disable: 6540)
#line 311
unsigned __cdecl _rotl(unsigned _Value, int _Shift); 
#line 317
unsigned long __cdecl _lrotl(unsigned long _Value, int _Shift); 
#line 322
unsigned __int64 __cdecl _rotl64(unsigned __int64 _Value, int _Shift); 
#line 327
unsigned __cdecl _rotr(unsigned _Value, int _Shift); 
#line 333
unsigned long __cdecl _lrotr(unsigned long _Value, int _Shift); 
#line 338
unsigned __int64 __cdecl _rotr64(unsigned __int64 _Value, int _Shift); 
#line 343
#pragma warning(pop)
#line 350
void __cdecl srand(unsigned _Seed); 
#line 352
int __cdecl rand(); 
#line 361 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
extern "C++" {
#line 363
inline long abs(const long _X) throw() 
#line 364
{ 
#line 365
return labs(_X); 
#line 366
} 
#line 368
inline __int64 abs(const __int64 _X) throw() 
#line 369
{ 
#line 370
return llabs(_X); 
#line 371
} 
#line 373
inline ldiv_t div(const long _A1, const long _A2) throw() 
#line 374
{ 
#line 375
return ldiv(_A1, _A2); 
#line 376
} 
#line 378
inline lldiv_t div(const __int64 _A1, const __int64 _A2) throw() 
#line 379
{ 
#line 380
return lldiv(_A1, _A2); 
#line 381
} 
#line 382
}
#line 394 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
#pragma pack ( push, 4 )
#line 398
typedef 
#line 396
struct { 
#line 397
unsigned char ld[10]; 
#line 398
} _LDOUBLE; 
#pragma pack ( pop )
#line 418 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
typedef 
#line 416
struct { 
#line 417
double x; 
#line 418
} _CRT_DOUBLE; 
#line 423
typedef 
#line 421
struct { 
#line 422
float f; 
#line 423
} _CRT_FLOAT; 
#line 432
typedef 
#line 430
struct { 
#line 431
long double x; 
#line 432
} _LONGDOUBLE; 
#line 436
#pragma pack ( push, 4 )
#line 440
typedef 
#line 438
struct { 
#line 439
unsigned char ld12[12]; 
#line 440
} _LDBL12; 
#pragma pack ( pop )
#line 450
double __cdecl atof(const char * _String); 
#line 451
int __cdecl atoi(const char * _String); 
#line 452
long __cdecl atol(const char * _String); 
#line 453
__int64 __cdecl atoll(const char * _String); 
#line 454
__int64 __cdecl _atoi64(const char * _String); 
#line 456
double __cdecl _atof_l(const char * _String, _locale_t _Locale); 
#line 457
int __cdecl _atoi_l(const char * _String, _locale_t _Locale); 
#line 458
long __cdecl _atol_l(const char * _String, _locale_t _Locale); 
#line 459
__int64 __cdecl _atoll_l(const char * _String, _locale_t _Locale); 
#line 460
__int64 __cdecl _atoi64_l(const char * _String, _locale_t _Locale); 
#line 462
int __cdecl _atoflt(_CRT_FLOAT * _Result, const char * _String); 
#line 463
int __cdecl _atodbl(_CRT_DOUBLE * _Result, char * _String); 
#line 464
int __cdecl _atoldbl(_LDOUBLE * _Result, char * _String); 
#line 467
int __cdecl _atoflt_l(_CRT_FLOAT * _Result, const char * _String, _locale_t _Locale); 
#line 474
int __cdecl _atodbl_l(_CRT_DOUBLE * _Result, char * _String, _locale_t _Locale); 
#line 482
int __cdecl _atoldbl_l(_LDOUBLE * _Result, char * _String, _locale_t _Locale); 
#line 489
float __cdecl strtof(const char * _String, char ** _EndPtr); 
#line 495
float __cdecl _strtof_l(const char * _String, char ** _EndPtr, _locale_t _Locale); 
#line 502
double __cdecl strtod(const char * _String, char ** _EndPtr); 
#line 508
double __cdecl _strtod_l(const char * _String, char ** _EndPtr, _locale_t _Locale); 
#line 515
long double __cdecl strtold(const char * _String, char ** _EndPtr); 
#line 521
long double __cdecl _strtold_l(const char * _String, char ** _EndPtr, _locale_t _Locale); 
#line 528
long __cdecl strtol(const char * _String, char ** _EndPtr, int _Radix); 
#line 535
long __cdecl _strtol_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 543
__int64 __cdecl strtoll(const char * _String, char ** _EndPtr, int _Radix); 
#line 550
__int64 __cdecl _strtoll_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 558
unsigned long __cdecl strtoul(const char * _String, char ** _EndPtr, int _Radix); 
#line 565
unsigned long __cdecl _strtoul_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 573
unsigned __int64 __cdecl strtoull(const char * _String, char ** _EndPtr, int _Radix); 
#line 580
unsigned __int64 __cdecl _strtoull_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 588
__int64 __cdecl _strtoi64(const char * _String, char ** _EndPtr, int _Radix); 
#line 595
__int64 __cdecl _strtoi64_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 603
unsigned __int64 __cdecl _strtoui64(const char * _String, char ** _EndPtr, int _Radix); 
#line 610
unsigned __int64 __cdecl _strtoui64_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 626
errno_t __cdecl _itoa_s(int _Value, char * _Buffer, size_t _BufferCount, int _Radix); 
#line 633
extern "C++" {template < size_t _Size > inline errno_t __cdecl _itoa_s ( int _Value, char ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _itoa_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 641 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
char *__cdecl _itoa(int _Value, char * _Buffer, int _Radix); 
#line 650 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
errno_t __cdecl _ltoa_s(long _Value, char * _Buffer, size_t _BufferCount, int _Radix); 
#line 657
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ltoa_s ( long _Value, char ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _ltoa_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 664 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
char *__cdecl _ltoa(long _Value, char * _Buffer, int _Radix); 
#line 673 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
errno_t __cdecl _ultoa_s(unsigned long _Value, char * _Buffer, size_t _BufferCount, int _Radix); 
#line 680
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ultoa_s ( unsigned long _Value, char ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _ultoa_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 687 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
char *__cdecl _ultoa(unsigned long _Value, char * _Buffer, int _Radix); 
#line 696 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
errno_t __cdecl _i64toa_s(__int64 _Value, char * _Buffer, size_t _BufferCount, int _Radix); 
#line 705
char *__cdecl _i64toa(__int64 _Value, char * _Buffer, int _Radix); 
#line 713
errno_t __cdecl _ui64toa_s(unsigned __int64 _Value, char * _Buffer, size_t _BufferCount, int _Radix); 
#line 721
char *__cdecl _ui64toa(unsigned __int64 _Value, char * _Buffer, int _Radix); 
#line 741
errno_t __cdecl _ecvt_s(char * _Buffer, size_t _BufferCount, double _Value, int _DigitCount, int * _PtDec, int * _PtSign); 
#line 750
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ecvt_s ( char ( & _Buffer ) [ _Size ], double _Value, int _DigitCount, int * _PtDec, int * _PtSign ) throw ( ) { return _ecvt_s ( _Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign ); }}
#line 760 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
char *__cdecl _ecvt(double _Value, int _DigitCount, int * _PtDec, int * _PtSign); 
#line 769
errno_t __cdecl _fcvt_s(char * _Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int * _PtDec, int * _PtSign); 
#line 778
extern "C++" {template < size_t _Size > inline errno_t __cdecl _fcvt_s ( char ( & _Buffer ) [ _Size ], double _Value, int _FractionalDigitCount, int * _PtDec, int * _PtSign ) throw ( ) { return _fcvt_s ( _Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign ); }}
#line 790 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
char *__cdecl _fcvt(double _Value, int _FractionalDigitCount, int * _PtDec, int * _PtSign); 
#line 798
errno_t __cdecl _gcvt_s(char * _Buffer, size_t _BufferCount, double _Value, int _DigitCount); 
#line 805
extern "C++" {template < size_t _Size > inline errno_t __cdecl _gcvt_s ( char ( & _Buffer ) [ _Size ], double _Value, int _DigitCount ) throw ( ) { return _gcvt_s ( _Buffer, _Size, _Value, _DigitCount ); }}
#line 814 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
char *__cdecl _gcvt(double _Value, int _DigitCount, char * _Buffer); 
#line 852
int __cdecl mblen(const char * _Ch, size_t _MaxCount); 
#line 858
int __cdecl _mblen_l(const char * _Ch, size_t _MaxCount, _locale_t _Locale); 
#line 866
size_t __cdecl _mbstrlen(const char * _String); 
#line 872
size_t __cdecl _mbstrlen_l(const char * _String, _locale_t _Locale); 
#line 879
size_t __cdecl _mbstrnlen(const char * _String, size_t _MaxCount); 
#line 886
size_t __cdecl _mbstrnlen_l(const char * _String, size_t _MaxCount, _locale_t _Locale); 
#line 893
int __cdecl mbtowc(__wchar_t * _DstCh, const char * _SrcCh, size_t _SrcSizeInBytes); 
#line 900
int __cdecl _mbtowc_l(__wchar_t * _DstCh, const char * _SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale); 
#line 908
errno_t __cdecl mbstowcs_s(size_t * _PtNumOfCharConverted, __wchar_t * _DstBuf, size_t _SizeInWords, const char * _SrcBuf, size_t _MaxCount); 
#line 916
extern "C++" {template < size_t _Size > inline errno_t __cdecl mbstowcs_s ( size_t * _PtNumOfCharConverted, wchar_t ( & _Dest ) [ _Size ], char const * _Source, size_t _MaxCount ) throw ( ) { return mbstowcs_s ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount ); }}
#line 924 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
size_t __cdecl mbstowcs(__wchar_t * _Dest, const char * _Source, size_t _MaxCount); 
#line 932 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
errno_t __cdecl _mbstowcs_s_l(size_t * _PtNumOfCharConverted, __wchar_t * _DstBuf, size_t _SizeInWords, const char * _SrcBuf, size_t _MaxCount, _locale_t _Locale); 
#line 941
extern "C++" {template < size_t _Size > inline errno_t __cdecl _mbstowcs_s_l ( size_t * _PtNumOfCharConverted, wchar_t ( & _Dest ) [ _Size ], char const * _Source, size_t _MaxCount, _locale_t _Locale ) throw ( ) { return _mbstowcs_s_l ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale ); }}
#line 950 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
size_t __cdecl _mbstowcs_l(__wchar_t * _Dest, const char * _Source, size_t _MaxCount, _locale_t _Locale); 
#line 963 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
int __cdecl wctomb(char * _MbCh, __wchar_t _WCh); 
#line 969
int __cdecl _wctomb_l(char * _MbCh, __wchar_t _WCh, _locale_t _Locale); 
#line 978
errno_t __cdecl wctomb_s(int * _SizeConverted, char * _MbCh, rsize_t _SizeInBytes, __wchar_t _WCh); 
#line 988 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
errno_t __cdecl _wctomb_s_l(int * _SizeConverted, char * _MbCh, size_t _SizeInBytes, __wchar_t _WCh, _locale_t _Locale); 
#line 996
errno_t __cdecl wcstombs_s(size_t * _PtNumOfCharConverted, char * _Dst, size_t _DstSizeInBytes, const __wchar_t * _Src, size_t _MaxCountInBytes); 
#line 1004
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcstombs_s ( size_t * _PtNumOfCharConverted, char ( & _Dest ) [ _Size ], wchar_t const * _Source, size_t _MaxCount ) throw ( ) { return wcstombs_s ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount ); }}
#line 1012 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
size_t __cdecl wcstombs(char * _Dest, const __wchar_t * _Source, size_t _MaxCount); 
#line 1020 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
errno_t __cdecl _wcstombs_s_l(size_t * _PtNumOfCharConverted, char * _Dst, size_t _DstSizeInBytes, const __wchar_t * _Src, size_t _MaxCountInBytes, _locale_t _Locale); 
#line 1029
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcstombs_s_l ( size_t * _PtNumOfCharConverted, char ( & _Dest ) [ _Size ], wchar_t const * _Source, size_t _MaxCount, _locale_t _Locale ) throw ( ) { return _wcstombs_s_l ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale ); }}
#line 1038 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
size_t __cdecl _wcstombs_l(char * _Dest, const __wchar_t * _Source, size_t _MaxCount, _locale_t _Locale); 
#line 1068 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
__declspec(allocator) char *__cdecl _fullpath(char * _Buffer, const char * _Path, size_t _BufferCount); 
#line 1077
errno_t __cdecl _makepath_s(char * _Buffer, size_t _BufferCount, const char * _Drive, const char * _Dir, const char * _Filename, const char * _Ext); 
#line 1086
extern "C++" {template < size_t _Size > inline errno_t __cdecl _makepath_s ( char ( & _Buffer ) [ _Size ], char const * _Drive, char const * _Dir, char const * _Filename, char const * _Ext ) throw ( ) { return _makepath_s ( _Buffer, _Size, _Drive, _Dir, _Filename, _Ext ); }}
#line 1095 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
void __cdecl _makepath(char * _Buffer, const char * _Drive, const char * _Dir, const char * _Filename, const char * _Ext); 
#line 1105 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
void __cdecl _splitpath(const char * _FullPath, char * _Drive, char * _Dir, char * _Filename, char * _Ext); 
#line 1114
errno_t __cdecl _splitpath_s(const char * _FullPath, char * _Drive, size_t _DriveCount, char * _Dir, size_t _DirCount, char * _Filename, size_t _FilenameCount, char * _Ext, size_t _ExtCount); 
#line 1126
extern "C++" {template < size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize > inline errno_t __cdecl _splitpath_s ( char const * _Dest, char ( & _Drive ) [ _DriveSize ], char ( & _Dir ) [ _DirSize ], char ( & _Name ) [ _NameSize ], char ( & _Ext ) [ _ExtSize ] ) throw ( ) { return _splitpath_s ( _Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize ); }}
#line 1132
errno_t __cdecl getenv_s(size_t * _RequiredCount, char * _Buffer, rsize_t _BufferCount, const char * _VarName); 
#line 1144 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
int *__cdecl __p___argc(); 
#line 1145
char ***__cdecl __p___argv(); 
#line 1146
__wchar_t ***__cdecl __p___wargv(); 
#line 1158 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
char ***__cdecl __p__environ(); 
#line 1159
__wchar_t ***__cdecl __p__wenviron(); 
#line 1184 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
char *__cdecl getenv(const char * _VarName); 
#line 1188
extern "C++" {template < size_t _Size > inline errno_t __cdecl getenv_s ( size_t * _RequiredCount, char ( & _Buffer ) [ _Size ], char const * _VarName ) throw ( ) { return getenv_s ( _RequiredCount, _Buffer, _Size, _VarName ); }}
#line 1201 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
errno_t __cdecl _dupenv_s(char ** _Buffer, size_t * _BufferCount, const char * _VarName); 
#line 1211 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
int __cdecl system(const char * _Command); 
#line 1217
#pragma warning(push)
#pragma warning(disable: 6540)
#line 1221
int __cdecl _putenv(const char * _EnvString); 
#line 1226
errno_t __cdecl _putenv_s(const char * _Name, const char * _Value); 
#line 1231
#pragma warning(pop)
#line 1233
errno_t __cdecl _searchenv_s(const char * _Filename, const char * _VarName, char * _Buffer, size_t _BufferCount); 
#line 1240
extern "C++" {template < size_t _Size > inline errno_t __cdecl _searchenv_s ( char const * _Filename, char const * _VarName, char ( & _Buffer ) [ _Size ] ) throw ( ) { return _searchenv_s ( _Filename, _VarName, _Buffer, _Size ); }}
#line 1247 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
void __cdecl _searchenv(const char * _Filename, const char * _VarName, char * _Buffer); 
#line 1255 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetErrorMode in" "stead. See online help for details.")) void __cdecl 
#line 1256
_seterrormode(int _Mode); 
#line 1260
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Beep instead. S" "ee online help for details.")) void __cdecl 
#line 1261
_beep(unsigned _Frequency, unsigned _Duration); 
#line 1266
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Sleep instead. " "See online help for details.")) void __cdecl 
#line 1267
_sleep(unsigned long _Duration); 
#line 1289 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
#pragma warning(push)
#pragma warning(disable: 4141)
#line 1293
char *__cdecl ecvt(double _Value, int _DigitCount, int * _PtDec, int * _PtSign); 
#line 1301
char *__cdecl fcvt(double _Value, int _FractionalDigitCount, int * _PtDec, int * _PtSign); 
#line 1309
char *__cdecl gcvt(double _Value, int _DigitCount, char * _DstBuf); 
#line 1316
char *__cdecl itoa(int _Value, char * _Buffer, int _Radix); 
#line 1323
char *__cdecl ltoa(long _Value, char * _Buffer, int _Radix); 
#line 1331
void __cdecl swab(char * _Buf1, char * _Buf2, int _SizeInBytes); 
#line 1338
char *__cdecl ultoa(unsigned long _Value, char * _Buffer, int _Radix); 
#line 1347
int __cdecl putenv(const char * _EnvString); 
#line 1351
#pragma warning(pop)
#line 1353
_onexit_t __cdecl onexit(_onexit_t _Func); 
#line 1359 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdlib.h"
}__pragma( pack ( pop )) 
#line 1361
#pragma warning(pop)
#line 184 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_device_runtime_api.h"
extern "C" {
#line 191
extern cudaError_t __stdcall __cudaDeviceSynchronizeDeprecationAvoidance(); 
#line 244
extern cudaError_t __stdcall __cudaCDP2DeviceGetAttribute(int * value, cudaDeviceAttr attr, int device); 
#line 245
extern cudaError_t __stdcall __cudaCDP2DeviceGetLimit(size_t * pValue, cudaLimit limit); 
#line 246
extern cudaError_t __stdcall __cudaCDP2DeviceGetCacheConfig(cudaFuncCache * pCacheConfig); 
#line 247
extern cudaError_t __stdcall __cudaCDP2DeviceGetSharedMemConfig(cudaSharedMemConfig * pConfig); 
#line 248
extern cudaError_t __stdcall __cudaCDP2GetLastError(); 
#line 249
extern cudaError_t __stdcall __cudaCDP2PeekAtLastError(); 
#line 250
extern const char *__stdcall __cudaCDP2GetErrorString(cudaError_t error); 
#line 251
extern const char *__stdcall __cudaCDP2GetErrorName(cudaError_t error); 
#line 252
extern cudaError_t __stdcall __cudaCDP2GetDeviceCount(int * count); 
#line 253
extern cudaError_t __stdcall __cudaCDP2GetDevice(int * device); 
#line 254
extern cudaError_t __stdcall __cudaCDP2StreamCreateWithFlags(cudaStream_t * pStream, unsigned flags); 
#line 255
extern cudaError_t __stdcall __cudaCDP2StreamDestroy(cudaStream_t stream); 
#line 256
extern cudaError_t __stdcall __cudaCDP2StreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned flags); 
#line 257
extern cudaError_t __stdcall __cudaCDP2StreamWaitEvent_ptsz(cudaStream_t stream, cudaEvent_t event, unsigned flags); 
#line 258
extern cudaError_t __stdcall __cudaCDP2EventCreateWithFlags(cudaEvent_t * event, unsigned flags); 
#line 259
extern cudaError_t __stdcall __cudaCDP2EventRecord(cudaEvent_t event, cudaStream_t stream); 
#line 260
extern cudaError_t __stdcall __cudaCDP2EventRecord_ptsz(cudaEvent_t event, cudaStream_t stream); 
#line 261
extern cudaError_t __stdcall __cudaCDP2EventRecordWithFlags(cudaEvent_t event, cudaStream_t stream, unsigned flags); 
#line 262
extern cudaError_t __stdcall __cudaCDP2EventRecordWithFlags_ptsz(cudaEvent_t event, cudaStream_t stream, unsigned flags); 
#line 263
extern cudaError_t __stdcall __cudaCDP2EventDestroy(cudaEvent_t event); 
#line 264
extern cudaError_t __stdcall __cudaCDP2FuncGetAttributes(cudaFuncAttributes * attr, const void * func); 
#line 265
extern cudaError_t __stdcall __cudaCDP2Free(void * devPtr); 
#line 266
extern cudaError_t __stdcall __cudaCDP2Malloc(void ** devPtr, size_t size); 
#line 267
extern cudaError_t __stdcall __cudaCDP2MemcpyAsync(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream); 
#line 268
extern cudaError_t __stdcall __cudaCDP2MemcpyAsync_ptsz(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream); 
#line 269
extern cudaError_t __stdcall __cudaCDP2Memcpy2DAsync(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream); 
#line 270
extern cudaError_t __stdcall __cudaCDP2Memcpy2DAsync_ptsz(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream); 
#line 271
extern cudaError_t __stdcall __cudaCDP2Memcpy3DAsync(const cudaMemcpy3DParms * p, cudaStream_t stream); 
#line 272
extern cudaError_t __stdcall __cudaCDP2Memcpy3DAsync_ptsz(const cudaMemcpy3DParms * p, cudaStream_t stream); 
#line 273
extern cudaError_t __stdcall __cudaCDP2MemsetAsync(void * devPtr, int value, size_t count, cudaStream_t stream); 
#line 274
extern cudaError_t __stdcall __cudaCDP2MemsetAsync_ptsz(void * devPtr, int value, size_t count, cudaStream_t stream); 
#line 275
extern cudaError_t __stdcall __cudaCDP2Memset2DAsync(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream); 
#line 276
extern cudaError_t __stdcall __cudaCDP2Memset2DAsync_ptsz(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream); 
#line 277
extern cudaError_t __stdcall __cudaCDP2Memset3DAsync(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream); 
#line 278
extern cudaError_t __stdcall __cudaCDP2Memset3DAsync_ptsz(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream); 
#line 279
extern cudaError_t __stdcall __cudaCDP2RuntimeGetVersion(int * runtimeVersion); 
#line 280
extern void *__stdcall __cudaCDP2GetParameterBuffer(size_t alignment, size_t size); 
#line 281
extern void *__stdcall __cudaCDP2GetParameterBufferV2(void * func, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize); 
#line 282
extern cudaError_t __stdcall __cudaCDP2LaunchDevice_ptsz(void * func, void * parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize, cudaStream_t stream); 
#line 283
extern cudaError_t __stdcall __cudaCDP2LaunchDeviceV2_ptsz(void * parameterBuffer, cudaStream_t stream); 
#line 284
extern cudaError_t __stdcall __cudaCDP2LaunchDevice(void * func, void * parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize, cudaStream_t stream); 
#line 285
extern cudaError_t __stdcall __cudaCDP2LaunchDeviceV2(void * parameterBuffer, cudaStream_t stream); 
#line 286
extern cudaError_t __stdcall __cudaCDP2OccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, const void * func, int blockSize, size_t dynamicSmemSize); 
#line 287
extern cudaError_t __stdcall __cudaCDP2OccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, const void * func, int blockSize, size_t dynamicSmemSize, unsigned flags); 
#line 290
extern cudaError_t __stdcall cudaGraphLaunch(cudaGraphExec_t graphExec, cudaStream_t stream); 
#line 311 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_device_runtime_api.h"
static inline cudaGraphExec_t __stdcall cudaGetCurrentGraphExec() {int volatile ___ = 1;::exit(___);}
#if 0
#line 312
{ 
#line 313
unsigned __int64 current_graph_exec; 
#line 314
__asm mov.u64 %0, %%current_graph_exec;
return (cudaGraphExec_t)current_graph_exec; 
#line 316
} 
#endif
#line 346 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_device_runtime_api.h"
extern cudaError_t __stdcall cudaGraphKernelNodeSetParam(cudaGraphDeviceNode_t node, size_t offset, const void * value, size_t size); 
#line 374
extern cudaError_t __stdcall cudaGraphKernelNodeSetEnabled(cudaGraphDeviceNode_t node, bool enable); 
#line 401
extern cudaError_t __stdcall cudaGraphKernelNodeSetGridDim(cudaGraphDeviceNode_t node, dim3 gridDim); 
#line 430
extern cudaError_t __stdcall cudaGraphKernelNodeUpdatesApply(const cudaGraphKernelNodeUpdate * updates, size_t updateCount); 
#line 448
static inline void __stdcall cudaTriggerProgrammaticLaunchCompletion() {int volatile ___ = 1;::exit(___);}
#if 0
#line 449
{ 
#line 450
__asm griddepcontrol.launch_dependents;
} 
#endif
#line 464 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_device_runtime_api.h"
static inline void __stdcall cudaGridDependencySynchronize() {int volatile ___ = 1;::exit(___);}
#if 0
#line 465
{ 
#line 466
__asm griddepcontrol.wait;
} 
#endif
#line 479 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_device_runtime_api.h"
extern void __stdcall cudaGraphSetConditional(cudaGraphConditionalHandle handle, unsigned value); 
#line 482
extern unsigned __int64 __stdcall cudaCGGetIntrinsicHandle(cudaCGScope scope); 
#line 483
extern cudaError_t __stdcall cudaCGSynchronize(unsigned __int64 handle, unsigned flags); 
#line 484
extern cudaError_t __stdcall cudaCGSynchronizeGrid(unsigned __int64 handle, unsigned flags); 
#line 485
extern cudaError_t __stdcall cudaCGGetSize(unsigned * numThreads, unsigned * numGrids, unsigned __int64 handle); 
#line 486
extern cudaError_t __stdcall cudaCGGetRank(unsigned * threadRank, unsigned * gridRank, unsigned __int64 handle); 
#line 714
static __inline void *__stdcall cudaGetParameterBuffer(size_t alignment, size_t size) {int volatile ___ = 1;(void)alignment;(void)size;::exit(___);}
#if 0
#line 715
{ 
#line 716
return __cudaCDP2GetParameterBuffer(alignment, size); 
#line 717
} 
#endif
#line 724 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_device_runtime_api.h"
static __inline void *__stdcall cudaGetParameterBufferV2(void *func, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize) {int volatile ___ = 1;(void)func;(void)gridDimension;(void)blockDimension;(void)sharedMemSize;::exit(___);}
#if 0
#line 725
{ 
#line 726
return __cudaCDP2GetParameterBufferV2(func, gridDimension, blockDimension, sharedMemSize); 
#line 727
} 
#endif
#line 734 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_device_runtime_api.h"
static __inline cudaError_t __stdcall cudaLaunchDevice_ptsz(void *func, void *parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize, cudaStream_t stream) {int volatile ___ = 1;(void)func;(void)parameterBuffer;(void)gridDimension;(void)blockDimension;(void)sharedMemSize;(void)stream;::exit(___);}
#if 0
#line 735
{ 
#line 736
return __cudaCDP2LaunchDevice_ptsz(func, parameterBuffer, gridDimension, blockDimension, sharedMemSize, stream); 
#line 737
} 
#endif
#line 739 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_device_runtime_api.h"
static __inline cudaError_t __stdcall cudaLaunchDeviceV2_ptsz(void *parameterBuffer, cudaStream_t stream) {int volatile ___ = 1;(void)parameterBuffer;(void)stream;::exit(___);}
#if 0
#line 740
{ 
#line 741
return __cudaCDP2LaunchDeviceV2_ptsz(parameterBuffer, stream); 
#line 742
} 
#endif
#line 800 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_device_runtime_api.h"
static __inline cudaError_t __stdcall cudaLaunchDevice(void *func, void *parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize, cudaStream_t stream) {int volatile ___ = 1;(void)func;(void)parameterBuffer;(void)gridDimension;(void)blockDimension;(void)sharedMemSize;(void)stream;::exit(___);}
#if 0
#line 801
{ 
#line 802
return __cudaCDP2LaunchDevice(func, parameterBuffer, gridDimension, blockDimension, sharedMemSize, stream); 
#line 803
} 
#endif
#line 805 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_device_runtime_api.h"
static __inline cudaError_t __stdcall cudaLaunchDeviceV2(void *parameterBuffer, cudaStream_t stream) {int volatile ___ = 1;(void)parameterBuffer;(void)stream;::exit(___);}
#if 0
#line 806
{ 
#line 807
return __cudaCDP2LaunchDeviceV2(parameterBuffer, stream); 
#line 808
} 
#endif
#line 862 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_device_runtime_api.h"
}
#line 868
template< class T> static __inline cudaError_t cudaMalloc(T ** devPtr, size_t size); 
#line 869
template< class T> static __inline cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * attr, T * entry); 
#line 870
template< class T> static __inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, T func, int blockSize, size_t dynamicSmemSize); 
#line 871
template< class T> static __inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, T func, int blockSize, size_t dynamicSmemSize, unsigned flags); 
#line 901
template< class T> static __inline ::cudaError_t __stdcall 
#line 902
cudaGraphKernelNodeSetParam(::cudaGraphDeviceNode_t node, ::size_t offset, const T &value) {int volatile ___ = 1;(void)node;(void)offset;(void)value;::exit(___);}
#if 0
#line 903
{ 
#line 904
return cudaGraphKernelNodeSetParam(node, offset, &value, sizeof(T)); 
#line 905
} 
#endif
#line 287 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern "C" {
#line 334 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaDeviceReset(); 
#line 356
extern cudaError_t __stdcall cudaDeviceSynchronize(); 
#line 442
extern cudaError_t __stdcall cudaDeviceSetLimit(cudaLimit limit, size_t value); 
#line 478
extern cudaError_t __stdcall cudaDeviceGetLimit(size_t * pValue, cudaLimit limit); 
#line 501
extern cudaError_t __stdcall cudaDeviceGetTexture1DLinearMaxWidth(size_t * maxWidthInElements, const cudaChannelFormatDesc * fmtDesc, int device); 
#line 535 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaDeviceGetCacheConfig(cudaFuncCache * pCacheConfig); 
#line 572
extern cudaError_t __stdcall cudaDeviceGetStreamPriorityRange(int * leastPriority, int * greatestPriority); 
#line 616
extern cudaError_t __stdcall cudaDeviceSetCacheConfig(cudaFuncCache cacheConfig); 
#line 643
extern cudaError_t __stdcall cudaDeviceGetByPCIBusId(int * device, const char * pciBusId); 
#line 673
extern cudaError_t __stdcall cudaDeviceGetPCIBusId(char * pciBusId, int len, int device); 
#line 724
extern cudaError_t __stdcall cudaIpcGetEventHandle(cudaIpcEventHandle_t * handle, cudaEvent_t event); 
#line 768
extern cudaError_t __stdcall cudaIpcOpenEventHandle(cudaEvent_t * event, cudaIpcEventHandle_t handle); 
#line 813
extern cudaError_t __stdcall cudaIpcGetMemHandle(cudaIpcMemHandle_t * handle, void * devPtr); 
#line 880
extern cudaError_t __stdcall cudaIpcOpenMemHandle(void ** devPtr, cudaIpcMemHandle_t handle, unsigned flags); 
#line 919
extern cudaError_t __stdcall cudaIpcCloseMemHandle(void * devPtr); 
#line 951
extern cudaError_t __stdcall cudaDeviceFlushGPUDirectRDMAWrites(cudaFlushGPUDirectRDMAWritesTarget target, cudaFlushGPUDirectRDMAWritesScope scope); 
#line 989 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaDeviceRegisterAsyncNotification(int device, cudaAsyncCallback callbackFunc, void * userData, cudaAsyncCallbackHandle_t * callback); 
#line 1012
extern cudaError_t __stdcall cudaDeviceUnregisterAsyncNotification(int device, cudaAsyncCallbackHandle_t callback); 
#line 1059
__declspec(deprecated) extern cudaError_t __stdcall cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * pConfig); 
#line 1105
__declspec(deprecated) extern cudaError_t __stdcall cudaDeviceSetSharedMemConfig(cudaSharedMemConfig config); 
#line 1146
__declspec(deprecated) extern cudaError_t __stdcall cudaThreadExit(); 
#line 1172
__declspec(deprecated) extern cudaError_t __stdcall cudaThreadSynchronize(); 
#line 1221
__declspec(deprecated) extern cudaError_t __stdcall cudaThreadSetLimit(cudaLimit limit, size_t value); 
#line 1254
__declspec(deprecated) extern cudaError_t __stdcall cudaThreadGetLimit(size_t * pValue, cudaLimit limit); 
#line 1290
__declspec(deprecated) extern cudaError_t __stdcall cudaThreadGetCacheConfig(cudaFuncCache * pCacheConfig); 
#line 1337
__declspec(deprecated) extern cudaError_t __stdcall cudaThreadSetCacheConfig(cudaFuncCache cacheConfig); 
#line 1402
extern cudaError_t __stdcall cudaGetLastError(); 
#line 1453
extern cudaError_t __stdcall cudaPeekAtLastError(); 
#line 1469
extern const char *__stdcall cudaGetErrorName(cudaError_t error); 
#line 1485
extern const char *__stdcall cudaGetErrorString(cudaError_t error); 
#line 1514
extern cudaError_t __stdcall cudaGetDeviceCount(int * count); 
#line 1818
extern cudaError_t __stdcall cudaGetDeviceProperties_v2(cudaDeviceProp * prop, int device); 
#line 2024
extern cudaError_t __stdcall cudaDeviceGetAttribute(int * value, cudaDeviceAttr attr, int device); 
#line 2042
extern cudaError_t __stdcall cudaDeviceGetDefaultMemPool(cudaMemPool_t * memPool, int device); 
#line 2066
extern cudaError_t __stdcall cudaDeviceSetMemPool(int device, cudaMemPool_t memPool); 
#line 2086
extern cudaError_t __stdcall cudaDeviceGetMemPool(cudaMemPool_t * memPool, int device); 
#line 2148
extern cudaError_t __stdcall cudaDeviceGetNvSciSyncAttributes(void * nvSciSyncAttrList, int device, int flags); 
#line 2188
extern cudaError_t __stdcall cudaDeviceGetP2PAttribute(int * value, cudaDeviceP2PAttr attr, int srcDevice, int dstDevice); 
#line 2210
extern cudaError_t __stdcall cudaChooseDevice(int * device, const cudaDeviceProp * prop); 
#line 2239
extern cudaError_t __stdcall cudaInitDevice(int device, unsigned deviceFlags, unsigned flags); 
#line 2285
extern cudaError_t __stdcall cudaSetDevice(int device); 
#line 2307
extern cudaError_t __stdcall cudaGetDevice(int * device); 
#line 2338
extern cudaError_t __stdcall cudaSetValidDevices(int * device_arr, int len); 
#line 2408
extern cudaError_t __stdcall cudaSetDeviceFlags(unsigned flags); 
#line 2453
extern cudaError_t __stdcall cudaGetDeviceFlags(unsigned * flags); 
#line 2497
extern cudaError_t __stdcall cudaStreamCreate(cudaStream_t * pStream); 
#line 2533
extern cudaError_t __stdcall cudaStreamCreateWithFlags(cudaStream_t * pStream, unsigned flags); 
#line 2585
extern cudaError_t __stdcall cudaStreamCreateWithPriority(cudaStream_t * pStream, unsigned flags, int priority); 
#line 2613
extern cudaError_t __stdcall cudaStreamGetPriority(cudaStream_t hStream, int * priority); 
#line 2639
extern cudaError_t __stdcall cudaStreamGetFlags(cudaStream_t hStream, unsigned * flags); 
#line 2676
extern cudaError_t __stdcall cudaStreamGetId(cudaStream_t hStream, unsigned __int64 * streamId); 
#line 2702
extern cudaError_t __stdcall cudaStreamGetDevice(cudaStream_t hStream, int * device); 
#line 2717
extern cudaError_t __stdcall cudaCtxResetPersistingL2Cache(); 
#line 2737
extern cudaError_t __stdcall cudaStreamCopyAttributes(cudaStream_t dst, cudaStream_t src); 
#line 2758
extern cudaError_t __stdcall cudaStreamGetAttribute(cudaStream_t hStream, cudaLaunchAttributeID attr, cudaLaunchAttributeValue * value_out); 
#line 2782
extern cudaError_t __stdcall cudaStreamSetAttribute(cudaStream_t hStream, cudaLaunchAttributeID attr, const cudaLaunchAttributeValue * value); 
#line 2816
extern cudaError_t __stdcall cudaStreamDestroy(cudaStream_t stream); 
#line 2847
extern cudaError_t __stdcall cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned flags = 0); 
#line 2855
typedef void (__stdcall *cudaStreamCallback_t)(cudaStream_t stream, cudaError_t status, void * userData); 
#line 2922
extern cudaError_t __stdcall cudaStreamAddCallback(cudaStream_t stream, cudaStreamCallback_t callback, void * userData, unsigned flags); 
#line 2946
extern cudaError_t __stdcall cudaStreamSynchronize(cudaStream_t stream); 
#line 2971
extern cudaError_t __stdcall cudaStreamQuery(cudaStream_t stream); 
#line 3055
extern cudaError_t __stdcall cudaStreamAttachMemAsync(cudaStream_t stream, void * devPtr, size_t length = 0, unsigned flags = 4); 
#line 3094 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaStreamBeginCapture(cudaStream_t stream, cudaStreamCaptureMode mode); 
#line 3135
extern cudaError_t __stdcall cudaStreamBeginCaptureToGraph(cudaStream_t stream, cudaGraph_t graph, const cudaGraphNode_t * dependencies, const cudaGraphEdgeData * dependencyData, size_t numDependencies, cudaStreamCaptureMode mode); 
#line 3186
extern cudaError_t __stdcall cudaThreadExchangeStreamCaptureMode(cudaStreamCaptureMode * mode); 
#line 3215
extern cudaError_t __stdcall cudaStreamEndCapture(cudaStream_t stream, cudaGraph_t * pGraph); 
#line 3253
extern cudaError_t __stdcall cudaStreamIsCapturing(cudaStream_t stream, cudaStreamCaptureStatus * pCaptureStatus); 
#line 3302
extern cudaError_t __stdcall cudaStreamGetCaptureInfo_v2(cudaStream_t stream, cudaStreamCaptureStatus * captureStatus_out, unsigned __int64 * id_out = 0, cudaGraph_t * graph_out = 0, const cudaGraphNode_t ** dependencies_out = 0, size_t * numDependencies_out = 0); 
#line 3361
extern cudaError_t __stdcall cudaStreamGetCaptureInfo_v3(cudaStream_t stream, cudaStreamCaptureStatus * captureStatus_out, unsigned __int64 * id_out = 0, cudaGraph_t * graph_out = 0, const cudaGraphNode_t ** dependencies_out = 0, const cudaGraphEdgeData ** edgeData_out = 0, size_t * numDependencies_out = 0); 
#line 3401
extern cudaError_t __stdcall cudaStreamUpdateCaptureDependencies(cudaStream_t stream, cudaGraphNode_t * dependencies, size_t numDependencies, unsigned flags = 0); 
#line 3436
extern cudaError_t __stdcall cudaStreamUpdateCaptureDependencies_v2(cudaStream_t stream, cudaGraphNode_t * dependencies, const cudaGraphEdgeData * dependencyData, size_t numDependencies, unsigned flags = 0); 
#line 3473
extern cudaError_t __stdcall cudaEventCreate(cudaEvent_t * event); 
#line 3510
extern cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t * event, unsigned flags); 
#line 3551
extern cudaError_t __stdcall cudaEventRecord(cudaEvent_t event, cudaStream_t stream = 0); 
#line 3599
extern cudaError_t __stdcall cudaEventRecordWithFlags(cudaEvent_t event, cudaStream_t stream = 0, unsigned flags = 0); 
#line 3632 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaEventQuery(cudaEvent_t event); 
#line 3663
extern cudaError_t __stdcall cudaEventSynchronize(cudaEvent_t event); 
#line 3693
extern cudaError_t __stdcall cudaEventDestroy(cudaEvent_t event); 
#line 3738
extern cudaError_t __stdcall cudaEventElapsedTime(float * ms, cudaEvent_t start, cudaEvent_t end); 
#line 3786
extern cudaError_t __stdcall cudaEventElapsedTime_v2(float * ms, cudaEvent_t start, cudaEvent_t end); 
#line 3967
extern cudaError_t __stdcall cudaImportExternalMemory(cudaExternalMemory_t * extMem_out, const cudaExternalMemoryHandleDesc * memHandleDesc); 
#line 4022
extern cudaError_t __stdcall cudaExternalMemoryGetMappedBuffer(void ** devPtr, cudaExternalMemory_t extMem, const cudaExternalMemoryBufferDesc * bufferDesc); 
#line 4082
extern cudaError_t __stdcall cudaExternalMemoryGetMappedMipmappedArray(cudaMipmappedArray_t * mipmap, cudaExternalMemory_t extMem, const cudaExternalMemoryMipmappedArrayDesc * mipmapDesc); 
#line 4106
extern cudaError_t __stdcall cudaDestroyExternalMemory(cudaExternalMemory_t extMem); 
#line 4260
extern cudaError_t __stdcall cudaImportExternalSemaphore(cudaExternalSemaphore_t * extSem_out, const cudaExternalSemaphoreHandleDesc * semHandleDesc); 
#line 4343
extern cudaError_t __stdcall cudaSignalExternalSemaphoresAsync_v2(const cudaExternalSemaphore_t * extSemArray, const cudaExternalSemaphoreSignalParams * paramsArray, unsigned numExtSems, cudaStream_t stream = 0); 
#line 4419
extern cudaError_t __stdcall cudaWaitExternalSemaphoresAsync_v2(const cudaExternalSemaphore_t * extSemArray, const cudaExternalSemaphoreWaitParams * paramsArray, unsigned numExtSems, cudaStream_t stream = 0); 
#line 4442
extern cudaError_t __stdcall cudaDestroyExternalSemaphore(cudaExternalSemaphore_t extSem); 
#line 4510
extern cudaError_t __stdcall cudaLaunchKernel(const void * func, dim3 gridDim, dim3 blockDim, void ** args, size_t sharedMem, cudaStream_t stream); 
#line 4573
extern cudaError_t __stdcall cudaLaunchKernelExC(const cudaLaunchConfig_t * config, const void * func, void ** args); 
#line 4631
extern cudaError_t __stdcall cudaLaunchCooperativeKernel(const void * func, dim3 gridDim, dim3 blockDim, void ** args, size_t sharedMem, cudaStream_t stream); 
#line 4732
__declspec(deprecated) extern cudaError_t __stdcall cudaLaunchCooperativeKernelMultiDevice(cudaLaunchParams * launchParamsList, unsigned numDevices, unsigned flags = 0); 
#line 4782
extern cudaError_t __stdcall cudaFuncSetCacheConfig(const void * func, cudaFuncCache cacheConfig); 
#line 4817
extern cudaError_t __stdcall cudaFuncGetAttributes(cudaFuncAttributes * attr, const void * func); 
#line 4876
extern cudaError_t __stdcall cudaFuncSetAttribute(const void * func, cudaFuncAttribute attr, int value); 
#line 4902
extern cudaError_t __stdcall cudaFuncGetName(const char ** name, const void * func); 
#line 4925
extern cudaError_t __stdcall cudaFuncGetParamInfo(const void * func, size_t paramIndex, size_t * paramOffset, size_t * paramSize); 
#line 4949
__declspec(deprecated) extern cudaError_t __stdcall cudaSetDoubleForDevice(double * d); 
#line 4973
__declspec(deprecated) extern cudaError_t __stdcall cudaSetDoubleForHost(double * d); 
#line 5039
extern cudaError_t __stdcall cudaLaunchHostFunc(cudaStream_t stream, cudaHostFn_t fn, void * userData); 
#line 5113
__declspec(deprecated) extern cudaError_t __stdcall cudaFuncSetSharedMemConfig(const void * func, cudaSharedMemConfig config); 
#line 5170
extern cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, const void * func, int blockSize, size_t dynamicSMemSize); 
#line 5200
extern cudaError_t __stdcall cudaOccupancyAvailableDynamicSMemPerBlock(size_t * dynamicSmemSize, const void * func, int numBlocks, int blockSize); 
#line 5246
extern cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, const void * func, int blockSize, size_t dynamicSMemSize, unsigned flags); 
#line 5282
extern cudaError_t __stdcall cudaOccupancyMaxPotentialClusterSize(int * clusterSize, const void * func, const cudaLaunchConfig_t * launchConfig); 
#line 5322
extern cudaError_t __stdcall cudaOccupancyMaxActiveClusters(int * numClusters, const void * func, const cudaLaunchConfig_t * launchConfig); 
#line 5442
extern cudaError_t __stdcall cudaMallocManaged(void ** devPtr, size_t size, unsigned flags = 1); 
#line 5475 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaMalloc(void ** devPtr, size_t size); 
#line 5512
extern cudaError_t __stdcall cudaMallocHost(void ** ptr, size_t size); 
#line 5555
extern cudaError_t __stdcall cudaMallocPitch(void ** devPtr, size_t * pitch, size_t width, size_t height); 
#line 5607
extern cudaError_t __stdcall cudaMallocArray(cudaArray_t * array, const cudaChannelFormatDesc * desc, size_t width, size_t height = 0, unsigned flags = 0); 
#line 5646
extern cudaError_t __stdcall cudaFree(void * devPtr); 
#line 5669
extern cudaError_t __stdcall cudaFreeHost(void * ptr); 
#line 5692
extern cudaError_t __stdcall cudaFreeArray(cudaArray_t array); 
#line 5715
extern cudaError_t __stdcall cudaFreeMipmappedArray(cudaMipmappedArray_t mipmappedArray); 
#line 5781
extern cudaError_t __stdcall cudaHostAlloc(void ** pHost, size_t size, unsigned flags); 
#line 5878
extern cudaError_t __stdcall cudaHostRegister(void * ptr, size_t size, unsigned flags); 
#line 5901
extern cudaError_t __stdcall cudaHostUnregister(void * ptr); 
#line 5946
extern cudaError_t __stdcall cudaHostGetDevicePointer(void ** pDevice, void * pHost, unsigned flags); 
#line 5968
extern cudaError_t __stdcall cudaHostGetFlags(unsigned * pFlags, void * pHost); 
#line 6007
extern cudaError_t __stdcall cudaMalloc3D(cudaPitchedPtr * pitchedDevPtr, cudaExtent extent); 
#line 6152
extern cudaError_t __stdcall cudaMalloc3DArray(cudaArray_t * array, const cudaChannelFormatDesc * desc, cudaExtent extent, unsigned flags = 0); 
#line 6297
extern cudaError_t __stdcall cudaMallocMipmappedArray(cudaMipmappedArray_t * mipmappedArray, const cudaChannelFormatDesc * desc, cudaExtent extent, unsigned numLevels, unsigned flags = 0); 
#line 6330
extern cudaError_t __stdcall cudaGetMipmappedArrayLevel(cudaArray_t * levelArray, cudaMipmappedArray_const_t mipmappedArray, unsigned level); 
#line 6435
extern cudaError_t __stdcall cudaMemcpy3D(const cudaMemcpy3DParms * p); 
#line 6467
extern cudaError_t __stdcall cudaMemcpy3DPeer(const cudaMemcpy3DPeerParms * p); 
#line 6585
extern cudaError_t __stdcall cudaMemcpy3DAsync(const cudaMemcpy3DParms * p, cudaStream_t stream = 0); 
#line 6612
extern cudaError_t __stdcall cudaMemcpy3DPeerAsync(const cudaMemcpy3DPeerParms * p, cudaStream_t stream = 0); 
#line 6646
extern cudaError_t __stdcall cudaMemGetInfo(size_t * free, size_t * total); 
#line 6672
extern cudaError_t __stdcall cudaArrayGetInfo(cudaChannelFormatDesc * desc, cudaExtent * extent, unsigned * flags, cudaArray_t array); 
#line 6701
extern cudaError_t __stdcall cudaArrayGetPlane(cudaArray_t * pPlaneArray, cudaArray_t hArray, unsigned planeIdx); 
#line 6724
extern cudaError_t __stdcall cudaArrayGetMemoryRequirements(cudaArrayMemoryRequirements * memoryRequirements, cudaArray_t array, int device); 
#line 6748
extern cudaError_t __stdcall cudaMipmappedArrayGetMemoryRequirements(cudaArrayMemoryRequirements * memoryRequirements, cudaMipmappedArray_t mipmap, int device); 
#line 6776
extern cudaError_t __stdcall cudaArrayGetSparseProperties(cudaArraySparseProperties * sparseProperties, cudaArray_t array); 
#line 6806 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaMipmappedArrayGetSparseProperties(cudaArraySparseProperties * sparseProperties, cudaMipmappedArray_t mipmap); 
#line 6851 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaMemcpy(void * dst, const void * src, size_t count, cudaMemcpyKind kind); 
#line 6886
extern cudaError_t __stdcall cudaMemcpyPeer(void * dst, int dstDevice, const void * src, int srcDevice, size_t count); 
#line 6935
extern cudaError_t __stdcall cudaMemcpy2D(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind); 
#line 6985
extern cudaError_t __stdcall cudaMemcpy2DToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind); 
#line 7035
extern cudaError_t __stdcall cudaMemcpy2DFromArray(void * dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, cudaMemcpyKind kind); 
#line 7082
extern cudaError_t __stdcall cudaMemcpy2DArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, cudaMemcpyKind kind = cudaMemcpyDeviceToDevice); 
#line 7125
extern cudaError_t __stdcall cudaMemcpyToSymbol(const void * symbol, const void * src, size_t count, size_t offset = 0, cudaMemcpyKind kind = cudaMemcpyHostToDevice); 
#line 7169
extern cudaError_t __stdcall cudaMemcpyFromSymbol(void * dst, const void * symbol, size_t count, size_t offset = 0, cudaMemcpyKind kind = cudaMemcpyDeviceToHost); 
#line 7226
extern cudaError_t __stdcall cudaMemcpyAsync(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 7261
extern cudaError_t __stdcall cudaMemcpyPeerAsync(void * dst, int dstDevice, const void * src, int srcDevice, size_t count, cudaStream_t stream = 0); 
#line 7333
extern cudaError_t __stdcall cudaMemcpyBatchAsync(void ** dsts, void ** srcs, size_t * sizes, size_t count, cudaMemcpyAttributes * attrs, size_t * attrsIdxs, size_t numAttrs, size_t * failIdx, cudaStream_t stream); 
#line 7401
extern cudaError_t __stdcall cudaMemcpy3DBatchAsync(size_t numOps, cudaMemcpy3DBatchOp * opList, size_t * failIdx, unsigned __int64 flags, cudaStream_t stream); 
#line 7464
extern cudaError_t __stdcall cudaMemcpy2DAsync(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 7522
extern cudaError_t __stdcall cudaMemcpy2DToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 7579
extern cudaError_t __stdcall cudaMemcpy2DFromArrayAsync(void * dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 7630
extern cudaError_t __stdcall cudaMemcpyToSymbolAsync(const void * symbol, const void * src, size_t count, size_t offset, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 7681
extern cudaError_t __stdcall cudaMemcpyFromSymbolAsync(void * dst, const void * symbol, size_t count, size_t offset, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 7710
extern cudaError_t __stdcall cudaMemset(void * devPtr, int value, size_t count); 
#line 7744
extern cudaError_t __stdcall cudaMemset2D(void * devPtr, size_t pitch, int value, size_t width, size_t height); 
#line 7790
extern cudaError_t __stdcall cudaMemset3D(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent); 
#line 7826
extern cudaError_t __stdcall cudaMemsetAsync(void * devPtr, int value, size_t count, cudaStream_t stream = 0); 
#line 7867
extern cudaError_t __stdcall cudaMemset2DAsync(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream = 0); 
#line 7920
extern cudaError_t __stdcall cudaMemset3DAsync(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream = 0); 
#line 7948
extern cudaError_t __stdcall cudaGetSymbolAddress(void ** devPtr, const void * symbol); 
#line 7975
extern cudaError_t __stdcall cudaGetSymbolSize(size_t * size, const void * symbol); 
#line 8047
extern cudaError_t __stdcall cudaMemPrefetchAsync(const void * devPtr, size_t count, int dstDevice, cudaStream_t stream = 0); 
#line 8128
extern cudaError_t __stdcall cudaMemPrefetchAsync_v2(const void * devPtr, size_t count, cudaMemLocation location, unsigned flags, cudaStream_t stream = 0); 
#line 8242
extern cudaError_t __stdcall cudaMemAdvise(const void * devPtr, size_t count, cudaMemoryAdvise advice, int device); 
#line 8365
extern cudaError_t __stdcall cudaMemAdvise_v2(const void * devPtr, size_t count, cudaMemoryAdvise advice, cudaMemLocation location); 
#line 8447
extern cudaError_t __stdcall cudaMemRangeGetAttribute(void * data, size_t dataSize, cudaMemRangeAttribute attribute, const void * devPtr, size_t count); 
#line 8490
extern cudaError_t __stdcall cudaMemRangeGetAttributes(void ** data, size_t * dataSizes, cudaMemRangeAttribute * attributes, size_t numAttributes, const void * devPtr, size_t count); 
#line 8550
__declspec(deprecated) extern cudaError_t __stdcall cudaMemcpyToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t count, cudaMemcpyKind kind); 
#line 8592
__declspec(deprecated) extern cudaError_t __stdcall cudaMemcpyFromArray(void * dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, cudaMemcpyKind kind); 
#line 8635
__declspec(deprecated) extern cudaError_t __stdcall cudaMemcpyArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t count, cudaMemcpyKind kind = cudaMemcpyDeviceToDevice); 
#line 8686
__declspec(deprecated) extern cudaError_t __stdcall cudaMemcpyToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 8736
__declspec(deprecated) extern cudaError_t __stdcall cudaMemcpyFromArrayAsync(void * dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 8805
extern cudaError_t __stdcall cudaMallocAsync(void ** devPtr, size_t size, cudaStream_t hStream); 
#line 8831
extern cudaError_t __stdcall cudaFreeAsync(void * devPtr, cudaStream_t hStream); 
#line 8856
extern cudaError_t __stdcall cudaMemPoolTrimTo(cudaMemPool_t memPool, size_t minBytesToKeep); 
#line 8900
extern cudaError_t __stdcall cudaMemPoolSetAttribute(cudaMemPool_t memPool, cudaMemPoolAttr attr, void * value); 
#line 8948
extern cudaError_t __stdcall cudaMemPoolGetAttribute(cudaMemPool_t memPool, cudaMemPoolAttr attr, void * value); 
#line 8963
extern cudaError_t __stdcall cudaMemPoolSetAccess(cudaMemPool_t memPool, const cudaMemAccessDesc * descList, size_t count); 
#line 8976
extern cudaError_t __stdcall cudaMemPoolGetAccess(cudaMemAccessFlags * flags, cudaMemPool_t memPool, cudaMemLocation * location); 
#line 9020
extern cudaError_t __stdcall cudaMemPoolCreate(cudaMemPool_t * memPool, const cudaMemPoolProps * poolProps); 
#line 9042
extern cudaError_t __stdcall cudaMemPoolDestroy(cudaMemPool_t memPool); 
#line 9078
extern cudaError_t __stdcall cudaMallocFromPoolAsync(void ** ptr, size_t size, cudaMemPool_t memPool, cudaStream_t stream); 
#line 9103
extern cudaError_t __stdcall cudaMemPoolExportToShareableHandle(void * shareableHandle, cudaMemPool_t memPool, cudaMemAllocationHandleType handleType, unsigned flags); 
#line 9130
extern cudaError_t __stdcall cudaMemPoolImportFromShareableHandle(cudaMemPool_t * memPool, void * shareableHandle, cudaMemAllocationHandleType handleType, unsigned flags); 
#line 9153
extern cudaError_t __stdcall cudaMemPoolExportPointer(cudaMemPoolPtrExportData * exportData, void * ptr); 
#line 9182
extern cudaError_t __stdcall cudaMemPoolImportPointer(void ** ptr, cudaMemPool_t memPool, cudaMemPoolPtrExportData * exportData); 
#line 9335
extern cudaError_t __stdcall cudaPointerGetAttributes(cudaPointerAttributes * attributes, const void * ptr); 
#line 9376
extern cudaError_t __stdcall cudaDeviceCanAccessPeer(int * canAccessPeer, int device, int peerDevice); 
#line 9418
extern cudaError_t __stdcall cudaDeviceEnablePeerAccess(int peerDevice, unsigned flags); 
#line 9440
extern cudaError_t __stdcall cudaDeviceDisablePeerAccess(int peerDevice); 
#line 9504
extern cudaError_t __stdcall cudaGraphicsUnregisterResource(cudaGraphicsResource_t resource); 
#line 9539
extern cudaError_t __stdcall cudaGraphicsResourceSetMapFlags(cudaGraphicsResource_t resource, unsigned flags); 
#line 9578
extern cudaError_t __stdcall cudaGraphicsMapResources(int count, cudaGraphicsResource_t * resources, cudaStream_t stream = 0); 
#line 9613
extern cudaError_t __stdcall cudaGraphicsUnmapResources(int count, cudaGraphicsResource_t * resources, cudaStream_t stream = 0); 
#line 9645
extern cudaError_t __stdcall cudaGraphicsResourceGetMappedPointer(void ** devPtr, size_t * size, cudaGraphicsResource_t resource); 
#line 9683
extern cudaError_t __stdcall cudaGraphicsSubResourceGetMappedArray(cudaArray_t * array, cudaGraphicsResource_t resource, unsigned arrayIndex, unsigned mipLevel); 
#line 9712
extern cudaError_t __stdcall cudaGraphicsResourceGetMappedMipmappedArray(cudaMipmappedArray_t * mipmappedArray, cudaGraphicsResource_t resource); 
#line 9747
extern cudaError_t __stdcall cudaGetChannelDesc(cudaChannelFormatDesc * desc, cudaArray_const_t array); 
#line 9777
extern cudaChannelFormatDesc __stdcall cudaCreateChannelDesc(int x, int y, int z, int w, cudaChannelFormatKind f); 
#line 10002
extern cudaError_t __stdcall cudaCreateTextureObject(cudaTextureObject_t * pTexObject, const cudaResourceDesc * pResDesc, const cudaTextureDesc * pTexDesc, const cudaResourceViewDesc * pResViewDesc); 
#line 10022
extern cudaError_t __stdcall cudaDestroyTextureObject(cudaTextureObject_t texObject); 
#line 10042
extern cudaError_t __stdcall cudaGetTextureObjectResourceDesc(cudaResourceDesc * pResDesc, cudaTextureObject_t texObject); 
#line 10062
extern cudaError_t __stdcall cudaGetTextureObjectTextureDesc(cudaTextureDesc * pTexDesc, cudaTextureObject_t texObject); 
#line 10083
extern cudaError_t __stdcall cudaGetTextureObjectResourceViewDesc(cudaResourceViewDesc * pResViewDesc, cudaTextureObject_t texObject); 
#line 10128
extern cudaError_t __stdcall cudaCreateSurfaceObject(cudaSurfaceObject_t * pSurfObject, const cudaResourceDesc * pResDesc); 
#line 10148
extern cudaError_t __stdcall cudaDestroySurfaceObject(cudaSurfaceObject_t surfObject); 
#line 10167
extern cudaError_t __stdcall cudaGetSurfaceObjectResourceDesc(cudaResourceDesc * pResDesc, cudaSurfaceObject_t surfObject); 
#line 10201
extern cudaError_t __stdcall cudaDriverGetVersion(int * driverVersion); 
#line 10230
extern cudaError_t __stdcall cudaRuntimeGetVersion(int * runtimeVersion); 
#line 10277
extern cudaError_t __stdcall cudaGraphCreate(cudaGraph_t * pGraph, unsigned flags); 
#line 10376
extern cudaError_t __stdcall cudaGraphAddKernelNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaKernelNodeParams * pNodeParams); 
#line 10409
extern cudaError_t __stdcall cudaGraphKernelNodeGetParams(cudaGraphNode_t node, cudaKernelNodeParams * pNodeParams); 
#line 10436
extern cudaError_t __stdcall cudaGraphKernelNodeSetParams(cudaGraphNode_t node, const cudaKernelNodeParams * pNodeParams); 
#line 10456
extern cudaError_t __stdcall cudaGraphKernelNodeCopyAttributes(cudaGraphNode_t hSrc, cudaGraphNode_t hDst); 
#line 10479
extern cudaError_t __stdcall cudaGraphKernelNodeGetAttribute(cudaGraphNode_t hNode, cudaLaunchAttributeID attr, cudaLaunchAttributeValue * value_out); 
#line 10503
extern cudaError_t __stdcall cudaGraphKernelNodeSetAttribute(cudaGraphNode_t hNode, cudaLaunchAttributeID attr, const cudaLaunchAttributeValue * value); 
#line 10554
extern cudaError_t __stdcall cudaGraphAddMemcpyNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaMemcpy3DParms * pCopyParams); 
#line 10613
extern cudaError_t __stdcall cudaGraphAddMemcpyNodeToSymbol(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const void * symbol, const void * src, size_t count, size_t offset, cudaMemcpyKind kind); 
#line 10682 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphAddMemcpyNodeFromSymbol(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, void * dst, const void * symbol, size_t count, size_t offset, cudaMemcpyKind kind); 
#line 10750 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphAddMemcpyNode1D(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, void * dst, const void * src, size_t count, cudaMemcpyKind kind); 
#line 10782 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphMemcpyNodeGetParams(cudaGraphNode_t node, cudaMemcpy3DParms * pNodeParams); 
#line 10809
extern cudaError_t __stdcall cudaGraphMemcpyNodeSetParams(cudaGraphNode_t node, const cudaMemcpy3DParms * pNodeParams); 
#line 10848
extern cudaError_t __stdcall cudaGraphMemcpyNodeSetParamsToSymbol(cudaGraphNode_t node, const void * symbol, const void * src, size_t count, size_t offset, cudaMemcpyKind kind); 
#line 10894 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphMemcpyNodeSetParamsFromSymbol(cudaGraphNode_t node, void * dst, const void * symbol, size_t count, size_t offset, cudaMemcpyKind kind); 
#line 10940 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphMemcpyNodeSetParams1D(cudaGraphNode_t node, void * dst, const void * src, size_t count, cudaMemcpyKind kind); 
#line 10988 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphAddMemsetNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaMemsetParams * pMemsetParams); 
#line 11011
extern cudaError_t __stdcall cudaGraphMemsetNodeGetParams(cudaGraphNode_t node, cudaMemsetParams * pNodeParams); 
#line 11035
extern cudaError_t __stdcall cudaGraphMemsetNodeSetParams(cudaGraphNode_t node, const cudaMemsetParams * pNodeParams); 
#line 11077
extern cudaError_t __stdcall cudaGraphAddHostNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaHostNodeParams * pNodeParams); 
#line 11100
extern cudaError_t __stdcall cudaGraphHostNodeGetParams(cudaGraphNode_t node, cudaHostNodeParams * pNodeParams); 
#line 11124
extern cudaError_t __stdcall cudaGraphHostNodeSetParams(cudaGraphNode_t node, const cudaHostNodeParams * pNodeParams); 
#line 11166
extern cudaError_t __stdcall cudaGraphAddChildGraphNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, cudaGraph_t childGraph); 
#line 11193
extern cudaError_t __stdcall cudaGraphChildGraphNodeGetGraph(cudaGraphNode_t node, cudaGraph_t * pGraph); 
#line 11231
extern cudaError_t __stdcall cudaGraphAddEmptyNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies); 
#line 11275
extern cudaError_t __stdcall cudaGraphAddEventRecordNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, cudaEvent_t event); 
#line 11302 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphEventRecordNodeGetEvent(cudaGraphNode_t node, cudaEvent_t * event_out); 
#line 11330 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphEventRecordNodeSetEvent(cudaGraphNode_t node, cudaEvent_t event); 
#line 11377 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphAddEventWaitNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, cudaEvent_t event); 
#line 11404 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphEventWaitNodeGetEvent(cudaGraphNode_t node, cudaEvent_t * event_out); 
#line 11432 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphEventWaitNodeSetEvent(cudaGraphNode_t node, cudaEvent_t event); 
#line 11482 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphAddExternalSemaphoresSignalNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaExternalSemaphoreSignalNodeParams * nodeParams); 
#line 11515 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExternalSemaphoresSignalNodeGetParams(cudaGraphNode_t hNode, cudaExternalSemaphoreSignalNodeParams * params_out); 
#line 11543 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExternalSemaphoresSignalNodeSetParams(cudaGraphNode_t hNode, const cudaExternalSemaphoreSignalNodeParams * nodeParams); 
#line 11593 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphAddExternalSemaphoresWaitNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaExternalSemaphoreWaitNodeParams * nodeParams); 
#line 11626 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExternalSemaphoresWaitNodeGetParams(cudaGraphNode_t hNode, cudaExternalSemaphoreWaitNodeParams * params_out); 
#line 11654 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExternalSemaphoresWaitNodeSetParams(cudaGraphNode_t hNode, const cudaExternalSemaphoreWaitNodeParams * nodeParams); 
#line 11732 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphAddMemAllocNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, cudaMemAllocNodeParams * nodeParams); 
#line 11759 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphMemAllocNodeGetParams(cudaGraphNode_t node, cudaMemAllocNodeParams * params_out); 
#line 11820 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphAddMemFreeNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, void * dptr); 
#line 11844 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphMemFreeNodeGetParams(cudaGraphNode_t node, void * dptr_out); 
#line 11872 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaDeviceGraphMemTrim(int device); 
#line 11909 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaDeviceGetGraphMemAttribute(int device, cudaGraphMemAttributeType attr, void * value); 
#line 11943 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaDeviceSetGraphMemAttribute(int device, cudaGraphMemAttributeType attr, void * value); 
#line 11974 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphClone(cudaGraph_t * pGraphClone, cudaGraph_t originalGraph); 
#line 12002
extern cudaError_t __stdcall cudaGraphNodeFindInClone(cudaGraphNode_t * pNode, cudaGraphNode_t originalNode, cudaGraph_t clonedGraph); 
#line 12033
extern cudaError_t __stdcall cudaGraphNodeGetType(cudaGraphNode_t node, cudaGraphNodeType * pType); 
#line 12064
extern cudaError_t __stdcall cudaGraphGetNodes(cudaGraph_t graph, cudaGraphNode_t * nodes, size_t * numNodes); 
#line 12095
extern cudaError_t __stdcall cudaGraphGetRootNodes(cudaGraph_t graph, cudaGraphNode_t * pRootNodes, size_t * pNumRootNodes); 
#line 12129
extern cudaError_t __stdcall cudaGraphGetEdges(cudaGraph_t graph, cudaGraphNode_t * from, cudaGraphNode_t * to, size_t * numEdges); 
#line 12169
extern cudaError_t __stdcall cudaGraphGetEdges_v2(cudaGraph_t graph, cudaGraphNode_t * from, cudaGraphNode_t * to, cudaGraphEdgeData * edgeData, size_t * numEdges); 
#line 12200
extern cudaError_t __stdcall cudaGraphNodeGetDependencies(cudaGraphNode_t node, cudaGraphNode_t * pDependencies, size_t * pNumDependencies); 
#line 12237
extern cudaError_t __stdcall cudaGraphNodeGetDependencies_v2(cudaGraphNode_t node, cudaGraphNode_t * pDependencies, cudaGraphEdgeData * edgeData, size_t * pNumDependencies); 
#line 12269
extern cudaError_t __stdcall cudaGraphNodeGetDependentNodes(cudaGraphNode_t node, cudaGraphNode_t * pDependentNodes, size_t * pNumDependentNodes); 
#line 12307
extern cudaError_t __stdcall cudaGraphNodeGetDependentNodes_v2(cudaGraphNode_t node, cudaGraphNode_t * pDependentNodes, cudaGraphEdgeData * edgeData, size_t * pNumDependentNodes); 
#line 12338
extern cudaError_t __stdcall cudaGraphAddDependencies(cudaGraph_t graph, const cudaGraphNode_t * from, const cudaGraphNode_t * to, size_t numDependencies); 
#line 12370
extern cudaError_t __stdcall cudaGraphAddDependencies_v2(cudaGraph_t graph, const cudaGraphNode_t * from, const cudaGraphNode_t * to, const cudaGraphEdgeData * edgeData, size_t numDependencies); 
#line 12401
extern cudaError_t __stdcall cudaGraphRemoveDependencies(cudaGraph_t graph, const cudaGraphNode_t * from, const cudaGraphNode_t * to, size_t numDependencies); 
#line 12436
extern cudaError_t __stdcall cudaGraphRemoveDependencies_v2(cudaGraph_t graph, const cudaGraphNode_t * from, const cudaGraphNode_t * to, const cudaGraphEdgeData * edgeData, size_t numDependencies); 
#line 12466
extern cudaError_t __stdcall cudaGraphDestroyNode(cudaGraphNode_t node); 
#line 12537
extern cudaError_t __stdcall cudaGraphInstantiate(cudaGraphExec_t * pGraphExec, cudaGraph_t graph, unsigned __int64 flags = 0); 
#line 12610
extern cudaError_t __stdcall cudaGraphInstantiateWithFlags(cudaGraphExec_t * pGraphExec, cudaGraph_t graph, unsigned __int64 flags = 0); 
#line 12717 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphInstantiateWithParams(cudaGraphExec_t * pGraphExec, cudaGraph_t graph, cudaGraphInstantiateParams * instantiateParams); 
#line 12742
extern cudaError_t __stdcall cudaGraphExecGetFlags(cudaGraphExec_t graphExec, unsigned __int64 * flags); 
#line 12802
extern cudaError_t __stdcall cudaGraphExecKernelNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const cudaKernelNodeParams * pNodeParams); 
#line 12853
extern cudaError_t __stdcall cudaGraphExecMemcpyNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const cudaMemcpy3DParms * pNodeParams); 
#line 12908
extern cudaError_t __stdcall cudaGraphExecMemcpyNodeSetParamsToSymbol(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const void * symbol, const void * src, size_t count, size_t offset, cudaMemcpyKind kind); 
#line 12971 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExecMemcpyNodeSetParamsFromSymbol(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, void * dst, const void * symbol, size_t count, size_t offset, cudaMemcpyKind kind); 
#line 13032 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExecMemcpyNodeSetParams1D(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, void * dst, const void * src, size_t count, cudaMemcpyKind kind); 
#line 13091 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExecMemsetNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const cudaMemsetParams * pNodeParams); 
#line 13131
extern cudaError_t __stdcall cudaGraphExecHostNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const cudaHostNodeParams * pNodeParams); 
#line 13178
extern cudaError_t __stdcall cudaGraphExecChildGraphNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, cudaGraph_t childGraph); 
#line 13223 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExecEventRecordNodeSetEvent(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, cudaEvent_t event); 
#line 13268 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExecEventWaitNodeSetEvent(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, cudaEvent_t event); 
#line 13316 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExecExternalSemaphoresSignalNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, const cudaExternalSemaphoreSignalNodeParams * nodeParams); 
#line 13364 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExecExternalSemaphoresWaitNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, const cudaExternalSemaphoreWaitNodeParams * nodeParams); 
#line 13404 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphNodeSetEnabled(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, unsigned isEnabled); 
#line 13438 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphNodeGetEnabled(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, unsigned * isEnabled); 
#line 13532 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExecUpdate(cudaGraphExec_t hGraphExec, cudaGraph_t hGraph, cudaGraphExecUpdateResultInfo * resultInfo); 
#line 13557
extern cudaError_t __stdcall cudaGraphUpload(cudaGraphExec_t graphExec, cudaStream_t stream); 
#line 13588 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphLaunch(cudaGraphExec_t graphExec, cudaStream_t stream); 
#line 13611
extern cudaError_t __stdcall cudaGraphExecDestroy(cudaGraphExec_t graphExec); 
#line 13632
extern cudaError_t __stdcall cudaGraphDestroy(cudaGraph_t graph); 
#line 13651
extern cudaError_t __stdcall cudaGraphDebugDotPrint(cudaGraph_t graph, const char * path, unsigned flags); 
#line 13687
extern cudaError_t __stdcall cudaUserObjectCreate(cudaUserObject_t * object_out, void * ptr, cudaHostFn_t destroy, unsigned initialRefcount, unsigned flags); 
#line 13711
extern cudaError_t __stdcall cudaUserObjectRetain(cudaUserObject_t object, unsigned count = 1); 
#line 13739
extern cudaError_t __stdcall cudaUserObjectRelease(cudaUserObject_t object, unsigned count = 1); 
#line 13767
extern cudaError_t __stdcall cudaGraphRetainUserObject(cudaGraph_t graph, cudaUserObject_t object, unsigned count = 1, unsigned flags = 0); 
#line 13792
extern cudaError_t __stdcall cudaGraphReleaseUserObject(cudaGraph_t graph, cudaUserObject_t object, unsigned count = 1); 
#line 13834
extern cudaError_t __stdcall cudaGraphAddNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, cudaGraphNodeParams * nodeParams); 
#line 13878
extern cudaError_t __stdcall cudaGraphAddNode_v2(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, const cudaGraphEdgeData * dependencyData, size_t numDependencies, cudaGraphNodeParams * nodeParams); 
#line 13907
extern cudaError_t __stdcall cudaGraphNodeSetParams(cudaGraphNode_t node, cudaGraphNodeParams * nodeParams); 
#line 13956
extern cudaError_t __stdcall cudaGraphExecNodeSetParams(cudaGraphExec_t graphExec, cudaGraphNode_t node, cudaGraphNodeParams * nodeParams); 
#line 13983
extern cudaError_t __stdcall cudaGraphConditionalHandleCreate(cudaGraphConditionalHandle * pHandle_out, cudaGraph_t graph, unsigned defaultLaunchValue = 0, unsigned flags = 0); 
#line 14064
extern cudaError_t __stdcall cudaGetDriverEntryPoint(const char * symbol, void ** funcPtr, unsigned __int64 flags, cudaDriverEntryPointQueryResult * driverStatus = 0); 
#line 14140 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGetDriverEntryPointByVersion(const char * symbol, void ** funcPtr, unsigned cudaVersion, unsigned __int64 flags, cudaDriverEntryPointQueryResult * driverStatus = 0); 
#line 14215 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaLibraryLoadData(cudaLibrary_t * library, const void * code, cudaJitOption * jitOptions, void ** jitOptionsValues, unsigned numJitOptions, cudaLibraryOption * libraryOptions, void ** libraryOptionValues, unsigned numLibraryOptions); 
#line 14275
extern cudaError_t __stdcall cudaLibraryLoadFromFile(cudaLibrary_t * library, const char * fileName, cudaJitOption * jitOptions, void ** jitOptionsValues, unsigned numJitOptions, cudaLibraryOption * libraryOptions, void ** libraryOptionValues, unsigned numLibraryOptions); 
#line 14296
extern cudaError_t __stdcall cudaLibraryUnload(cudaLibrary_t library); 
#line 14321
extern cudaError_t __stdcall cudaLibraryGetKernel(cudaKernel_t * pKernel, cudaLibrary_t library, const char * name); 
#line 14355
extern cudaError_t __stdcall cudaLibraryGetGlobal(void ** dptr, size_t * bytes, cudaLibrary_t library, const char * name); 
#line 14388
extern cudaError_t __stdcall cudaLibraryGetManaged(void ** dptr, size_t * bytes, cudaLibrary_t library, const char * name); 
#line 14415
extern cudaError_t __stdcall cudaLibraryGetUnifiedFunction(void ** fptr, cudaLibrary_t library, const char * symbol); 
#line 14437
extern cudaError_t __stdcall cudaLibraryGetKernelCount(unsigned * count, cudaLibrary_t lib); 
#line 14459
extern cudaError_t __stdcall cudaLibraryEnumerateKernels(cudaKernel_t * kernels, unsigned numKernels, cudaLibrary_t lib); 
#line 14528
extern cudaError_t __stdcall cudaKernelSetAttributeForDevice(cudaKernel_t kernel, cudaFuncAttribute attr, int value, int device); 
#line 14533
extern cudaError_t __stdcall cudaGetExportTable(const void ** ppExportTable, const cudaUUID_t * pExportTableId); 
#line 14719
extern cudaError_t cudaGetFuncBySymbol(cudaFunction_t * functionPtr, const void * symbolPtr); 
#line 14743
extern cudaError_t __stdcall cudaGetKernel(cudaKernel_t * kernelPtr, const void * entryFuncAddr); 
#line 14921 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\cuda_runtime_api.h"
}
#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\channel_descriptor.h"
template< class T> __inline ::cudaChannelFormatDesc cudaCreateChannelDesc() 
#line 121
{ 
#line 122
return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone); 
#line 123
} 
#line 125
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf() 
#line 126
{ 
#line 127
int e = (((int)sizeof(unsigned short)) * 8); 
#line 129
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 130
} 
#line 132
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf1() 
#line 133
{ 
#line 134
int e = (((int)sizeof(unsigned short)) * 8); 
#line 136
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 137
} 
#line 139
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf2() 
#line 140
{ 
#line 141
int e = (((int)sizeof(unsigned short)) * 8); 
#line 143
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
#line 144
} 
#line 146
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf4() 
#line 147
{ 
#line 148
int e = (((int)sizeof(unsigned short)) * 8); 
#line 150
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
#line 151
} 
#line 153
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char> () 
#line 154
{ 
#line 155
int e = (((int)sizeof(char)) * 8); 
#line 160 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\channel_descriptor.h"
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 162 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\channel_descriptor.h"
} 
#line 164
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< signed char> () 
#line 165
{ 
#line 166
int e = (((int)sizeof(signed char)) * 8); 
#line 168
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 169
} 
#line 171
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned char> () 
#line 172
{ 
#line 173
int e = (((int)sizeof(unsigned char)) * 8); 
#line 175
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 176
} 
#line 178
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char1> () 
#line 179
{ 
#line 180
int e = (((int)sizeof(signed char)) * 8); 
#line 182
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 183
} 
#line 185
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar1> () 
#line 186
{ 
#line 187
int e = (((int)sizeof(unsigned char)) * 8); 
#line 189
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 190
} 
#line 192
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char2> () 
#line 193
{ 
#line 194
int e = (((int)sizeof(signed char)) * 8); 
#line 196
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 197
} 
#line 199
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar2> () 
#line 200
{ 
#line 201
int e = (((int)sizeof(unsigned char)) * 8); 
#line 203
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 204
} 
#line 206
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char4> () 
#line 207
{ 
#line 208
int e = (((int)sizeof(signed char)) * 8); 
#line 210
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 211
} 
#line 213
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar4> () 
#line 214
{ 
#line 215
int e = (((int)sizeof(unsigned char)) * 8); 
#line 217
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 218
} 
#line 220
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short> () 
#line 221
{ 
#line 222
int e = (((int)sizeof(short)) * 8); 
#line 224
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 225
} 
#line 227
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned short> () 
#line 228
{ 
#line 229
int e = (((int)sizeof(unsigned short)) * 8); 
#line 231
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 232
} 
#line 234
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short1> () 
#line 235
{ 
#line 236
int e = (((int)sizeof(short)) * 8); 
#line 238
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 239
} 
#line 241
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort1> () 
#line 242
{ 
#line 243
int e = (((int)sizeof(unsigned short)) * 8); 
#line 245
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 246
} 
#line 248
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short2> () 
#line 249
{ 
#line 250
int e = (((int)sizeof(short)) * 8); 
#line 252
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 253
} 
#line 255
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort2> () 
#line 256
{ 
#line 257
int e = (((int)sizeof(unsigned short)) * 8); 
#line 259
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 260
} 
#line 262
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short4> () 
#line 263
{ 
#line 264
int e = (((int)sizeof(short)) * 8); 
#line 266
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 267
} 
#line 269
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort4> () 
#line 270
{ 
#line 271
int e = (((int)sizeof(unsigned short)) * 8); 
#line 273
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 274
} 
#line 276
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int> () 
#line 277
{ 
#line 278
int e = (((int)sizeof(int)) * 8); 
#line 280
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 281
} 
#line 283
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned> () 
#line 284
{ 
#line 285
int e = (((int)sizeof(unsigned)) * 8); 
#line 287
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 288
} 
#line 290
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int1> () 
#line 291
{ 
#line 292
int e = (((int)sizeof(int)) * 8); 
#line 294
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 295
} 
#line 297
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint1> () 
#line 298
{ 
#line 299
int e = (((int)sizeof(unsigned)) * 8); 
#line 301
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 302
} 
#line 304
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int2> () 
#line 305
{ 
#line 306
int e = (((int)sizeof(int)) * 8); 
#line 308
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 309
} 
#line 311
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint2> () 
#line 312
{ 
#line 313
int e = (((int)sizeof(unsigned)) * 8); 
#line 315
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 316
} 
#line 318
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int4> () 
#line 319
{ 
#line 320
int e = (((int)sizeof(int)) * 8); 
#line 322
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 323
} 
#line 325
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint4> () 
#line 326
{ 
#line 327
int e = (((int)sizeof(unsigned)) * 8); 
#line 329
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 330
} 
#line 334
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long> () 
#line 335
{ 
#line 336
int e = (((int)sizeof(long)) * 8); 
#line 338
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 339
} 
#line 341
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned long> () 
#line 342
{ 
#line 343
int e = (((int)sizeof(unsigned long)) * 8); 
#line 345
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 346
} 
#line 348
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long1> () 
#line 349
{ 
#line 350
int e = (((int)sizeof(long)) * 8); 
#line 352
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 353
} 
#line 355
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong1> () 
#line 356
{ 
#line 357
int e = (((int)sizeof(unsigned long)) * 8); 
#line 359
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 360
} 
#line 362
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long2> () 
#line 363
{ 
#line 364
int e = (((int)sizeof(long)) * 8); 
#line 366
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 367
} 
#line 369
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong2> () 
#line 370
{ 
#line 371
int e = (((int)sizeof(unsigned long)) * 8); 
#line 373
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 374
} 
#line 376
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long4> () 
#line 377
{ 
#line 378
int e = (((int)sizeof(long)) * 8); 
#line 380
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 381
} 
#line 383
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong4> () 
#line 384
{ 
#line 385
int e = (((int)sizeof(unsigned long)) * 8); 
#line 387
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 388
} 
#line 392 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\channel_descriptor.h"
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float> () 
#line 393
{ 
#line 394
int e = (((int)sizeof(float)) * 8); 
#line 396
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 397
} 
#line 399
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float1> () 
#line 400
{ 
#line 401
int e = (((int)sizeof(float)) * 8); 
#line 403
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 404
} 
#line 406
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float2> () 
#line 407
{ 
#line 408
int e = (((int)sizeof(float)) * 8); 
#line 410
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
#line 411
} 
#line 413
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float4> () 
#line 414
{ 
#line 415
int e = (((int)sizeof(float)) * 8); 
#line 417
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
#line 418
} 
#line 420
static __inline cudaChannelFormatDesc cudaCreateChannelDescNV12() 
#line 421
{ 
#line 422
int e = (((int)sizeof(char)) * 8); 
#line 424
return cudaCreateChannelDesc(e, e, e, 0, cudaChannelFormatKindNV12); 
#line 425
} 
#line 427
template< cudaChannelFormatKind > __inline ::cudaChannelFormatDesc cudaCreateChannelDesc() 
#line 428
{ 
#line 429
return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone); 
#line 430
} 
#line 433
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedNormalized8X1> () 
#line 434
{ 
#line 435
return cudaCreateChannelDesc(8, 0, 0, 0, cudaChannelFormatKindSignedNormalized8X1); 
#line 436
} 
#line 438
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedNormalized8X2> () 
#line 439
{ 
#line 440
return cudaCreateChannelDesc(8, 8, 0, 0, cudaChannelFormatKindSignedNormalized8X2); 
#line 441
} 
#line 443
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedNormalized8X4> () 
#line 444
{ 
#line 445
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindSignedNormalized8X4); 
#line 446
} 
#line 449
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedNormalized8X1> () 
#line 450
{ 
#line 451
return cudaCreateChannelDesc(8, 0, 0, 0, cudaChannelFormatKindUnsignedNormalized8X1); 
#line 452
} 
#line 454
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedNormalized8X2> () 
#line 455
{ 
#line 456
return cudaCreateChannelDesc(8, 8, 0, 0, cudaChannelFormatKindUnsignedNormalized8X2); 
#line 457
} 
#line 459
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedNormalized8X4> () 
#line 460
{ 
#line 461
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedNormalized8X4); 
#line 462
} 
#line 465
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedNormalized16X1> () 
#line 466
{ 
#line 467
return cudaCreateChannelDesc(16, 0, 0, 0, cudaChannelFormatKindSignedNormalized16X1); 
#line 468
} 
#line 470
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedNormalized16X2> () 
#line 471
{ 
#line 472
return cudaCreateChannelDesc(16, 16, 0, 0, cudaChannelFormatKindSignedNormalized16X2); 
#line 473
} 
#line 475
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedNormalized16X4> () 
#line 476
{ 
#line 477
return cudaCreateChannelDesc(16, 16, 16, 16, cudaChannelFormatKindSignedNormalized16X4); 
#line 478
} 
#line 481
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedNormalized16X1> () 
#line 482
{ 
#line 483
return cudaCreateChannelDesc(16, 0, 0, 0, cudaChannelFormatKindUnsignedNormalized16X1); 
#line 484
} 
#line 486
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedNormalized16X2> () 
#line 487
{ 
#line 488
return cudaCreateChannelDesc(16, 16, 0, 0, cudaChannelFormatKindUnsignedNormalized16X2); 
#line 489
} 
#line 491
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedNormalized16X4> () 
#line 492
{ 
#line 493
return cudaCreateChannelDesc(16, 16, 16, 16, cudaChannelFormatKindUnsignedNormalized16X4); 
#line 494
} 
#line 497
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindNV12> () 
#line 498
{ 
#line 499
return cudaCreateChannelDesc(8, 8, 8, 0, cudaChannelFormatKindNV12); 
#line 500
} 
#line 503
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedNormalized1010102> () 
#line 504
{ 
#line 505
return cudaCreateChannelDesc(10, 10, 10, 2, cudaChannelFormatKindUnsignedNormalized1010102); 
#line 506
} 
#line 509
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed1> () 
#line 510
{ 
#line 511
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed1); 
#line 512
} 
#line 515
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed1SRGB> () 
#line 516
{ 
#line 517
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed1SRGB); 
#line 518
} 
#line 521
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed2> () 
#line 522
{ 
#line 523
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed2); 
#line 524
} 
#line 527
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed2SRGB> () 
#line 528
{ 
#line 529
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed2SRGB); 
#line 530
} 
#line 533
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed3> () 
#line 534
{ 
#line 535
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed3); 
#line 536
} 
#line 539
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed3SRGB> () 
#line 540
{ 
#line 541
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed3SRGB); 
#line 542
} 
#line 545
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed4> () 
#line 546
{ 
#line 547
return cudaCreateChannelDesc(8, 0, 0, 0, cudaChannelFormatKindUnsignedBlockCompressed4); 
#line 548
} 
#line 551
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedBlockCompressed4> () 
#line 552
{ 
#line 553
return cudaCreateChannelDesc(8, 0, 0, 0, cudaChannelFormatKindSignedBlockCompressed4); 
#line 554
} 
#line 557
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed5> () 
#line 558
{ 
#line 559
return cudaCreateChannelDesc(8, 8, 0, 0, cudaChannelFormatKindUnsignedBlockCompressed5); 
#line 560
} 
#line 563
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedBlockCompressed5> () 
#line 564
{ 
#line 565
return cudaCreateChannelDesc(8, 8, 0, 0, cudaChannelFormatKindSignedBlockCompressed5); 
#line 566
} 
#line 569
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed6H> () 
#line 570
{ 
#line 571
return cudaCreateChannelDesc(16, 16, 16, 0, cudaChannelFormatKindUnsignedBlockCompressed6H); 
#line 572
} 
#line 575
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedBlockCompressed6H> () 
#line 576
{ 
#line 577
return cudaCreateChannelDesc(16, 16, 16, 0, cudaChannelFormatKindSignedBlockCompressed6H); 
#line 578
} 
#line 581
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed7> () 
#line 582
{ 
#line 583
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed7); 
#line 584
} 
#line 587
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed7SRGB> () 
#line 588
{ 
#line 589
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed7SRGB); 
#line 590
} 
#line 79 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\driver_functions.h"
static __inline cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz, size_t ysz) 
#line 80
{ 
#line 81
cudaPitchedPtr s; 
#line 83
(s.ptr) = d; 
#line 84
(s.pitch) = p; 
#line 85
(s.xsize) = xsz; 
#line 86
(s.ysize) = ysz; 
#line 88
return s; 
#line 89
} 
#line 106
static __inline cudaPos make_cudaPos(size_t x, size_t y, size_t z) 
#line 107
{ 
#line 108
cudaPos p; 
#line 110
(p.x) = x; 
#line 111
(p.y) = y; 
#line 112
(p.z) = z; 
#line 114
return p; 
#line 115
} 
#line 132
static __inline cudaExtent make_cudaExtent(size_t w, size_t h, size_t d) 
#line 133
{ 
#line 134
cudaExtent e; 
#line 136
(e.width) = w; 
#line 137
(e.height) = h; 
#line 138
(e.depth) = d; 
#line 140
return e; 
#line 141
} 
#line 77 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_functions.h"
static __inline char1 make_char1(signed char x); 
#line 79
static __inline uchar1 make_uchar1(unsigned char x); 
#line 81
static __inline char2 make_char2(signed char x, signed char y); 
#line 83
static __inline uchar2 make_uchar2(unsigned char x, unsigned char y); 
#line 85
static __inline char3 make_char3(signed char x, signed char y, signed char z); 
#line 87
static __inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z); 
#line 89
static __inline char4 make_char4(signed char x, signed char y, signed char z, signed char w); 
#line 91
static __inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w); 
#line 93
static __inline short1 make_short1(short x); 
#line 95
static __inline ushort1 make_ushort1(unsigned short x); 
#line 97
static __inline short2 make_short2(short x, short y); 
#line 99
static __inline ushort2 make_ushort2(unsigned short x, unsigned short y); 
#line 101
static __inline short3 make_short3(short x, short y, short z); 
#line 103
static __inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z); 
#line 105
static __inline short4 make_short4(short x, short y, short z, short w); 
#line 107
static __inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w); 
#line 109
static __inline int1 make_int1(int x); 
#line 111
static __inline uint1 make_uint1(unsigned x); 
#line 113
static __inline int2 make_int2(int x, int y); 
#line 115
static __inline uint2 make_uint2(unsigned x, unsigned y); 
#line 117
static __inline int3 make_int3(int x, int y, int z); 
#line 119
static __inline uint3 make_uint3(unsigned x, unsigned y, unsigned z); 
#line 121
static __inline int4 make_int4(int x, int y, int z, int w); 
#line 123
static __inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w); 
#line 125
static __inline long1 make_long1(long x); 
#line 127
static __inline ulong1 make_ulong1(unsigned long x); 
#line 129
static __inline long2 make_long2(long x, long y); 
#line 131
static __inline ulong2 make_ulong2(unsigned long x, unsigned long y); 
#line 133
static __inline long3 make_long3(long x, long y, long z); 
#line 135
static __inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z); 
#line 137
static __inline long4 make_long4(long x, long y, long z, long w); 
#line 139
static __inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w); 
#line 141
static __inline float1 make_float1(float x); 
#line 143
static __inline float2 make_float2(float x, float y); 
#line 145
static __inline float3 make_float3(float x, float y, float z); 
#line 147
static __inline float4 make_float4(float x, float y, float z, float w); 
#line 149
static __inline longlong1 make_longlong1(__int64 x); 
#line 151
static __inline ulonglong1 make_ulonglong1(unsigned __int64 x); 
#line 153
static __inline longlong2 make_longlong2(__int64 x, __int64 y); 
#line 155
static __inline ulonglong2 make_ulonglong2(unsigned __int64 x, unsigned __int64 y); 
#line 157
static __inline longlong3 make_longlong3(__int64 x, __int64 y, __int64 z); 
#line 159
static __inline ulonglong3 make_ulonglong3(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z); 
#line 161
static __inline longlong4 make_longlong4(__int64 x, __int64 y, __int64 z, __int64 w); 
#line 163
static __inline ulonglong4 make_ulonglong4(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z, unsigned __int64 w); 
#line 165
static __inline double1 make_double1(double x); 
#line 167
static __inline double2 make_double2(double x, double y); 
#line 169
static __inline double3 make_double3(double x, double y, double z); 
#line 171
static __inline double4 make_double4(double x, double y, double z, double w); 
#line 73 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\vector_functions.hpp"
static __inline char1 make_char1(signed char x) 
#line 74
{ 
#line 75
char1 t; (t.x) = x; return t; 
#line 76
} 
#line 78
static __inline uchar1 make_uchar1(unsigned char x) 
#line 79
{ 
#line 80
uchar1 t; (t.x) = x; return t; 
#line 81
} 
#line 83
static __inline char2 make_char2(signed char x, signed char y) 
#line 84
{ 
#line 85
char2 t; (t.x) = x; (t.y) = y; return t; 
#line 86
} 
#line 88
static __inline uchar2 make_uchar2(unsigned char x, unsigned char y) 
#line 89
{ 
#line 90
uchar2 t; (t.x) = x; (t.y) = y; return t; 
#line 91
} 
#line 93
static __inline char3 make_char3(signed char x, signed char y, signed char z) 
#line 94
{ 
#line 95
char3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 96
} 
#line 98
static __inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z) 
#line 99
{ 
#line 100
uchar3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 101
} 
#line 103
static __inline char4 make_char4(signed char x, signed char y, signed char z, signed char w) 
#line 104
{ 
#line 105
char4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 106
} 
#line 108
static __inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w) 
#line 109
{ 
#line 110
uchar4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 111
} 
#line 113
static __inline short1 make_short1(short x) 
#line 114
{ 
#line 115
short1 t; (t.x) = x; return t; 
#line 116
} 
#line 118
static __inline ushort1 make_ushort1(unsigned short x) 
#line 119
{ 
#line 120
ushort1 t; (t.x) = x; return t; 
#line 121
} 
#line 123
static __inline short2 make_short2(short x, short y) 
#line 124
{ 
#line 125
short2 t; (t.x) = x; (t.y) = y; return t; 
#line 126
} 
#line 128
static __inline ushort2 make_ushort2(unsigned short x, unsigned short y) 
#line 129
{ 
#line 130
ushort2 t; (t.x) = x; (t.y) = y; return t; 
#line 131
} 
#line 133
static __inline short3 make_short3(short x, short y, short z) 
#line 134
{ 
#line 135
short3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 136
} 
#line 138
static __inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z) 
#line 139
{ 
#line 140
ushort3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 141
} 
#line 143
static __inline short4 make_short4(short x, short y, short z, short w) 
#line 144
{ 
#line 145
short4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 146
} 
#line 148
static __inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w) 
#line 149
{ 
#line 150
ushort4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 151
} 
#line 153
static __inline int1 make_int1(int x) 
#line 154
{ 
#line 155
int1 t; (t.x) = x; return t; 
#line 156
} 
#line 158
static __inline uint1 make_uint1(unsigned x) 
#line 159
{ 
#line 160
uint1 t; (t.x) = x; return t; 
#line 161
} 
#line 163
static __inline int2 make_int2(int x, int y) 
#line 164
{ 
#line 165
int2 t; (t.x) = x; (t.y) = y; return t; 
#line 166
} 
#line 168
static __inline uint2 make_uint2(unsigned x, unsigned y) 
#line 169
{ 
#line 170
uint2 t; (t.x) = x; (t.y) = y; return t; 
#line 171
} 
#line 173
static __inline int3 make_int3(int x, int y, int z) 
#line 174
{ 
#line 175
int3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 176
} 
#line 178
static __inline uint3 make_uint3(unsigned x, unsigned y, unsigned z) 
#line 179
{ 
#line 180
uint3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 181
} 
#line 183
static __inline int4 make_int4(int x, int y, int z, int w) 
#line 184
{ 
#line 185
int4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 186
} 
#line 188
static __inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w) 
#line 189
{ 
#line 190
uint4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 191
} 
#line 193
static __inline long1 make_long1(long x) 
#line 194
{ 
#line 195
long1 t; (t.x) = x; return t; 
#line 196
} 
#line 198
static __inline ulong1 make_ulong1(unsigned long x) 
#line 199
{ 
#line 200
ulong1 t; (t.x) = x; return t; 
#line 201
} 
#line 203
static __inline long2 make_long2(long x, long y) 
#line 204
{ 
#line 205
long2 t; (t.x) = x; (t.y) = y; return t; 
#line 206
} 
#line 208
static __inline ulong2 make_ulong2(unsigned long x, unsigned long y) 
#line 209
{ 
#line 210
ulong2 t; (t.x) = x; (t.y) = y; return t; 
#line 211
} 
#line 213
static __inline long3 make_long3(long x, long y, long z) 
#line 214
{ 
#line 215
long3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 216
} 
#line 218
static __inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z) 
#line 219
{ 
#line 220
ulong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 221
} 
#line 223
static __inline long4 make_long4(long x, long y, long z, long w) 
#line 224
{ 
#line 225
long4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 226
} 
#line 228
static __inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w) 
#line 229
{ 
#line 230
ulong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 231
} 
#line 233
static __inline float1 make_float1(float x) 
#line 234
{ 
#line 235
float1 t; (t.x) = x; return t; 
#line 236
} 
#line 238
static __inline float2 make_float2(float x, float y) 
#line 239
{ 
#line 240
float2 t; (t.x) = x; (t.y) = y; return t; 
#line 241
} 
#line 243
static __inline float3 make_float3(float x, float y, float z) 
#line 244
{ 
#line 245
float3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 246
} 
#line 248
static __inline float4 make_float4(float x, float y, float z, float w) 
#line 249
{ 
#line 250
float4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 251
} 
#line 253
static __inline longlong1 make_longlong1(__int64 x) 
#line 254
{ 
#line 255
longlong1 t; (t.x) = x; return t; 
#line 256
} 
#line 258
static __inline ulonglong1 make_ulonglong1(unsigned __int64 x) 
#line 259
{ 
#line 260
ulonglong1 t; (t.x) = x; return t; 
#line 261
} 
#line 263
static __inline longlong2 make_longlong2(__int64 x, __int64 y) 
#line 264
{ 
#line 265
longlong2 t; (t.x) = x; (t.y) = y; return t; 
#line 266
} 
#line 268
static __inline ulonglong2 make_ulonglong2(unsigned __int64 x, unsigned __int64 y) 
#line 269
{ 
#line 270
ulonglong2 t; (t.x) = x; (t.y) = y; return t; 
#line 271
} 
#line 273
static __inline longlong3 make_longlong3(__int64 x, __int64 y, __int64 z) 
#line 274
{ 
#line 275
longlong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 276
} 
#line 278
static __inline ulonglong3 make_ulonglong3(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z) 
#line 279
{ 
#line 280
ulonglong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 281
} 
#line 283
static __inline longlong4 make_longlong4(__int64 x, __int64 y, __int64 z, __int64 w) 
#line 284
{ 
#line 285
longlong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 286
} 
#line 288
static __inline ulonglong4 make_ulonglong4(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z, unsigned __int64 w) 
#line 289
{ 
#line 290
ulonglong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 291
} 
#line 293
static __inline double1 make_double1(double x) 
#line 294
{ 
#line 295
double1 t; (t.x) = x; return t; 
#line 296
} 
#line 298
static __inline double2 make_double2(double x, double y) 
#line 299
{ 
#line 300
double2 t; (t.x) = x; (t.y) = y; return t; 
#line 301
} 
#line 303
static __inline double3 make_double3(double x, double y, double z) 
#line 304
{ 
#line 305
double3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 306
} 
#line 308
static __inline double4 make_double4(double x, double y, double z, double w) 
#line 309
{ 
#line 310
double4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 311
} 
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\errno.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 18
__pragma( pack ( push, 8 )) extern "C" {
#line 23
int *__cdecl _errno(); 
#line 26
errno_t __cdecl _set_errno(int _Value); 
#line 27
errno_t __cdecl _get_errno(int * _Value); 
#line 29
unsigned long *__cdecl __doserrno(); 
#line 32
errno_t __cdecl _set_doserrno(unsigned long _Value); 
#line 33
errno_t __cdecl _get_doserrno(unsigned long * _Value); 
#line 134 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\errno.h"
}__pragma( pack ( pop )) 
#line 136
#pragma warning(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_string.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 17
__pragma( pack ( push, 8 )) extern "C" {
#line 21
[[nodiscard]] const void *__cdecl 
#line 22
memchr(const void * _Buf, int _Val, size_t _MaxCount); 
#line 28
[[nodiscard]] int __cdecl 
#line 29
memcmp(const void * _Buf1, const void * _Buf2, size_t _Size); 
#line 43 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_string.h"
void *__cdecl memcpy(void * _Dst, const void * _Src, size_t _Size); 
#line 50
void *__cdecl memmove(void * _Dst, const void * _Src, size_t _Size); 
#line 63 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_string.h"
void *__cdecl memset(void * _Dst, int _Val, size_t _Size); 
#line 69
[[nodiscard]] const char *__cdecl 
#line 70
strchr(const char * _Str, int _Val); 
#line 75
[[nodiscard]] const char *__cdecl 
#line 76
strrchr(const char * _Str, int _Ch); 
#line 81
[[nodiscard]] const char *__cdecl 
#line 82
strstr(const char * _Str, const char * _SubStr); 
#line 87
[[nodiscard]] const __wchar_t *__cdecl 
#line 89
wcschr(const __wchar_t * _Str, __wchar_t _Ch); 
#line 94
[[nodiscard]] const __wchar_t *__cdecl 
#line 95
wcsrchr(const __wchar_t * _Str, __wchar_t _Ch); 
#line 100
[[nodiscard]] const __wchar_t *__cdecl 
#line 102
wcsstr(const __wchar_t * _Str, const __wchar_t * _SubStr); 
#line 109
}__pragma( pack ( pop )) 
#line 113 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_string.h"
#pragma warning(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_memcpy_s.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 18
__pragma( pack ( push, 8 )) extern "C" {
#line 39 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_memcpy_s.h"
static __inline errno_t __cdecl memcpy_s(void *const 
#line 40
_Destination, const rsize_t 
#line 41
_DestinationSize, const void *const 
#line 42
_Source, const rsize_t 
#line 43
_SourceSize) 
#line 45
{ 
#line 46
if (_SourceSize == (0)) 
#line 47
{ 
#line 48
return 0; 
#line 49
}  
#line 51
{ int _Expr_val = !(!(_Destination != (0))); if (!_Expr_val) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; }  } ; 
#line 52
if ((_Source == (0)) || (_DestinationSize < _SourceSize)) 
#line 53
{ 
#line 54
memset(_Destination, 0, _DestinationSize); 
#line 56
{ int _Expr_val = !(!(_Source != (0))); if (!_Expr_val) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; }  } ; 
#line 57
{ int _Expr_val = !(!(_DestinationSize >= _SourceSize)); if (!_Expr_val) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; }  } ; 
#line 60
return 22; 
#line 61
}  
#line 62
memcpy(_Destination, _Source, _SourceSize); 
#line 63
return 0; 
#line 64
} 
#line 67
static __inline errno_t __cdecl memmove_s(void *const 
#line 68
_Destination, const rsize_t 
#line 69
_DestinationSize, const void *const 
#line 70
_Source, const rsize_t 
#line 71
_SourceSize) 
#line 73
{ 
#line 74
if (_SourceSize == (0)) 
#line 75
{ 
#line 76
return 0; 
#line 77
}  
#line 79
{ int _Expr_val = !(!(_Destination != (0))); if (!_Expr_val) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; }  } ; 
#line 80
{ int _Expr_val = !(!(_Source != (0))); if (!_Expr_val) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; }  } ; 
#line 81
{ int _Expr_val = !(!(_DestinationSize >= _SourceSize)); if (!_Expr_val) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; }  } ; 
#line 83
memmove(_Destination, _Source, _SourceSize); 
#line 84
return 0; 
#line 85
} 
#line 93 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_memcpy_s.h"
}
#line 92
#pragma warning(pop)
__pragma( pack ( pop )) 
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_memory.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 23
__pragma( pack ( push, 8 )) extern "C" {
#line 28
int __cdecl _memicmp(const void * _Buf1, const void * _Buf2, size_t _Size); 
#line 35
int __cdecl _memicmp_l(const void * _Buf1, const void * _Buf2, size_t _Size, _locale_t _Locale); 
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_memory.h"
void *__cdecl memccpy(void * _Dst, const void * _Src, int _Val, size_t _Size); 
#line 91
int __cdecl memicmp(const void * _Buf1, const void * _Buf2, size_t _Size); 
#line 104 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_memory.h"
extern "C++" inline void *__cdecl memchr(void *
#line 105
_Pv, int 
#line 106
_C, size_t 
#line 107
_N) 
#line 109
{ 
#line 110
const void *const _Pvc = _Pv; 
#line 111
return const_cast< void *>(memchr(_Pvc, _C, _N)); 
#line 112
} 
#line 118 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_memory.h"
}__pragma( pack ( pop )) 
#line 122 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_memory.h"
#pragma warning(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 20
__pragma( pack ( push, 8 )) extern "C" {
#line 32
errno_t __cdecl wcscat_s(__wchar_t * _Destination, rsize_t _SizeInWords, const __wchar_t * _Source); 
#line 39
errno_t __cdecl wcscpy_s(__wchar_t * _Destination, rsize_t _SizeInWords, const __wchar_t * _Source); 
#line 46
errno_t __cdecl wcsncat_s(__wchar_t * _Destination, rsize_t _SizeInWords, const __wchar_t * _Source, rsize_t _MaxCount); 
#line 54
errno_t __cdecl wcsncpy_s(__wchar_t * _Destination, rsize_t _SizeInWords, const __wchar_t * _Source, rsize_t _MaxCount); 
#line 62
__wchar_t *__cdecl wcstok_s(__wchar_t * _String, const __wchar_t * _Delimiter, __wchar_t ** _Context); 
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
__declspec(allocator) __wchar_t *__cdecl _wcsdup(const __wchar_t * _String); 
#line 93 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcscat_s ( wchar_t ( & _Destination ) [ _Size ], wchar_t const * _Source ) throw ( ) { return wcscat_s ( _Destination, _Size, _Source ); }}
#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl wcscat(__wchar_t * _Destination, const __wchar_t * _Source); 
#line 108 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
int __cdecl wcscmp(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 113
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcscpy_s ( wchar_t ( & _Destination ) [ _Size ], wchar_t const * _Source ) throw ( ) { return wcscpy_s ( _Destination, _Size, _Source ); }}
#line 119 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl wcscpy(__wchar_t * _Destination, const __wchar_t * _Source); 
#line 126 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
size_t __cdecl wcscspn(const __wchar_t * _String, const __wchar_t * _Control); 
#line 132
size_t __cdecl wcslen(const __wchar_t * _String); 
#line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
size_t __cdecl wcsnlen(const __wchar_t * _Source, size_t _MaxCount); 
#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
static __inline size_t __cdecl wcsnlen_s(const __wchar_t *
#line 162
_Source, size_t 
#line 163
_MaxCount) 
#line 165
{ 
#line 166
return (_Source == (0)) ? 0 : wcsnlen(_Source, _MaxCount); 
#line 167
} 
#line 171 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcsncat_s ( wchar_t ( & _Destination ) [ _Size ], wchar_t const * _Source, size_t _Count ) throw ( ) { return wcsncat_s ( _Destination, _Size, _Source, _Count ); }}
#line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl wcsncat(__wchar_t * _Destination, const __wchar_t * _Source, size_t _Count); 
#line 187 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
int __cdecl wcsncmp(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount); 
#line 193
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcsncpy_s ( wchar_t ( & _Destination ) [ _Size ], wchar_t const * _Source, size_t _Count ) throw ( ) { return wcsncpy_s ( _Destination, _Size, _Source, _Count ); }}
#line 200 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl wcsncpy(__wchar_t * _Destination, const __wchar_t * _Source, size_t _Count); 
#line 209 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
const __wchar_t *__cdecl wcspbrk(const __wchar_t * _String, const __wchar_t * _Control); 
#line 215
size_t __cdecl wcsspn(const __wchar_t * _String, const __wchar_t * _Control); 
#line 221
__wchar_t *__cdecl wcstok(__wchar_t * _String, const __wchar_t * _Delimiter, __wchar_t ** _Context); 
#line 239 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
static __inline __wchar_t *__cdecl _wcstok(__wchar_t *const 
#line 240
_String, const __wchar_t *const 
#line 241
_Delimiter) 
#line 243
{ 
#line 244
return wcstok(_String, _Delimiter, 0); 
#line 245
} 
#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
extern "C++" 
#line 252
__declspec(deprecated("wcstok has been changed to conform with the ISO C standard, adding an extra context parameter. To use the legacy Microsoft wcsto" "k, define _CRT_NON_CONFORMING_WCSTOK.")) inline __wchar_t *__cdecl 
#line 253
wcstok(__wchar_t *
#line 254
_String, const __wchar_t *
#line 255
_Delimiter) throw() 
#line 257
{ 
#line 258
return wcstok(_String, _Delimiter, 0); 
#line 259
} 
#line 268 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl _wcserror(int _ErrorNumber); 
#line 273
errno_t __cdecl _wcserror_s(__wchar_t * _Buffer, size_t _SizeInWords, int _ErrorNumber); 
#line 279
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcserror_s ( wchar_t ( & _Buffer ) [ _Size ], int _Error ) throw ( ) { return _wcserror_s ( _Buffer, _Size, _Error ); }}
#line 288 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl __wcserror(const __wchar_t * _String); 
#line 292
errno_t __cdecl __wcserror_s(__wchar_t * _Buffer, size_t _SizeInWords, const __wchar_t * _ErrorMessage); 
#line 298
extern "C++" {template < size_t _Size > inline errno_t __cdecl __wcserror_s ( wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _ErrorMessage ) throw ( ) { return __wcserror_s ( _Buffer, _Size, _ErrorMessage ); }}
#line 304 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
int __cdecl _wcsicmp(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 309
int __cdecl _wcsicmp_l(const __wchar_t * _String1, const __wchar_t * _String2, _locale_t _Locale); 
#line 315
int __cdecl _wcsnicmp(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount); 
#line 321
int __cdecl _wcsnicmp_l(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 328
errno_t __cdecl _wcsnset_s(__wchar_t * _Destination, size_t _SizeInWords, __wchar_t _Value, size_t _MaxCount); 
#line 335
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcsnset_s ( wchar_t ( & _Destination ) [ _Size ], wchar_t _Value, size_t _MaxCount ) throw ( ) { return _wcsnset_s ( _Destination, _Size, _Value, _MaxCount ); }}
#line 342 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl _wcsnset(__wchar_t * _String, __wchar_t _Value, size_t _MaxCount); 
#line 350 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl _wcsrev(__wchar_t * _String); 
#line 354
errno_t __cdecl _wcsset_s(__wchar_t * _Destination, size_t _SizeInWords, __wchar_t _Value); 
#line 360
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcsset_s ( wchar_t ( & _String ) [ _Size ], wchar_t _Value ) throw ( ) { return _wcsset_s ( _String, _Size, _Value ); }}
#line 366 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl _wcsset(__wchar_t * _String, __wchar_t _Value); 
#line 373 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
errno_t __cdecl _wcslwr_s(__wchar_t * _String, size_t _SizeInWords); 
#line 378
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcslwr_s ( wchar_t ( & _String ) [ _Size ] ) throw ( ) { return _wcslwr_s ( _String, _Size ); }}
#line 383 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl _wcslwr(__wchar_t * _String); 
#line 389 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
errno_t __cdecl _wcslwr_s_l(__wchar_t * _String, size_t _SizeInWords, _locale_t _Locale); 
#line 395
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcslwr_s_l ( wchar_t ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _wcslwr_s_l ( _String, _Size, _Locale ); }}
#line 401 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl _wcslwr_l(__wchar_t * _String, _locale_t _Locale); 
#line 409 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
errno_t __cdecl _wcsupr_s(__wchar_t * _String, size_t _Size); 
#line 414
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcsupr_s ( wchar_t ( & _String ) [ _Size ] ) throw ( ) { return _wcsupr_s ( _String, _Size ); }}
#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl _wcsupr(__wchar_t * _String); 
#line 425 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
errno_t __cdecl _wcsupr_s_l(__wchar_t * _String, size_t _Size, _locale_t _Locale); 
#line 431
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcsupr_s_l ( wchar_t ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _wcsupr_s_l ( _String, _Size, _Locale ); }}
#line 437 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl _wcsupr_l(__wchar_t * _String, _locale_t _Locale); 
#line 446 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
size_t __cdecl wcsxfrm(__wchar_t * _Destination, const __wchar_t * _Source, size_t _MaxCount); 
#line 454
size_t __cdecl _wcsxfrm_l(__wchar_t * _Destination, const __wchar_t * _Source, size_t _MaxCount, _locale_t _Locale); 
#line 462
int __cdecl wcscoll(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 468
int __cdecl _wcscoll_l(const __wchar_t * _String1, const __wchar_t * _String2, _locale_t _Locale); 
#line 475
int __cdecl _wcsicoll(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 481
int __cdecl _wcsicoll_l(const __wchar_t * _String1, const __wchar_t * _String2, _locale_t _Locale); 
#line 488
int __cdecl _wcsncoll(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount); 
#line 495
int __cdecl _wcsncoll_l(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 503
int __cdecl _wcsnicoll(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount); 
#line 510
int __cdecl _wcsnicoll_l(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 525
extern "C++" {
#line 529
inline __wchar_t *__cdecl wcschr(__wchar_t *_String, __wchar_t _C) 
#line 530
{ 
#line 531
return const_cast< __wchar_t *>(wcschr(static_cast< const __wchar_t *>(_String), _C)); 
#line 532
} 
#line 535
inline __wchar_t *__cdecl wcspbrk(__wchar_t *_String, const __wchar_t *_Control) 
#line 536
{ 
#line 537
return const_cast< __wchar_t *>(wcspbrk(static_cast< const __wchar_t *>(_String), _Control)); 
#line 538
} 
#line 541
inline __wchar_t *__cdecl wcsrchr(__wchar_t *_String, __wchar_t _C) 
#line 542
{ 
#line 543
return const_cast< __wchar_t *>(wcsrchr(static_cast< const __wchar_t *>(_String), _C)); 
#line 544
} 
#line 548
inline __wchar_t *__cdecl wcsstr(__wchar_t *_String, const __wchar_t *_SubStr) 
#line 549
{ 
#line 550
return const_cast< __wchar_t *>(wcsstr(static_cast< const __wchar_t *>(_String), _SubStr)); 
#line 551
} 
#line 553
}
#line 570 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl wcsdup(const __wchar_t * _String); 
#line 582 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
int __cdecl wcsicmp(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 588
int __cdecl wcsnicmp(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount); 
#line 596
__wchar_t *__cdecl wcsnset(__wchar_t * _String, __wchar_t _Value, size_t _MaxCount); 
#line 604
__wchar_t *__cdecl wcsrev(__wchar_t * _String); 
#line 610
__wchar_t *__cdecl wcsset(__wchar_t * _String, __wchar_t _Value); 
#line 617
__wchar_t *__cdecl wcslwr(__wchar_t * _String); 
#line 623
__wchar_t *__cdecl wcsupr(__wchar_t * _String); 
#line 628
int __cdecl wcsicoll(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 637 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
}__pragma( pack ( pop )) 
#line 641 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
#pragma warning(pop)
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 23
__pragma( pack ( push, 8 )) extern "C" {
#line 32
errno_t __cdecl strcpy_s(char * _Destination, rsize_t _SizeInBytes, const char * _Source); 
#line 39
errno_t __cdecl strcat_s(char * _Destination, rsize_t _SizeInBytes, const char * _Source); 
#line 46
errno_t __cdecl strerror_s(char * _Buffer, size_t _SizeInBytes, int _ErrorNumber); 
#line 52
errno_t __cdecl strncat_s(char * _Destination, rsize_t _SizeInBytes, const char * _Source, rsize_t _MaxCount); 
#line 60
errno_t __cdecl strncpy_s(char * _Destination, rsize_t _SizeInBytes, const char * _Source, rsize_t _MaxCount); 
#line 68
char *__cdecl strtok_s(char * _String, const char * _Delimiter, char ** _Context); 
#line 76 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
void *__cdecl _memccpy(void * _Dst, const void * _Src, int _Val, size_t _MaxCount); 
#line 83
extern "C++" {template < size_t _Size > inline errno_t __cdecl strcat_s ( char ( & _Destination ) [ _Size ], char const * _Source ) throw ( ) { return strcat_s ( _Destination, _Size, _Source ); }}
#line 91 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
char *__cdecl strcat(char * _Destination, const char * _Source); 
#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
int __cdecl strcmp(const char * _Str1, const char * _Str2); 
#line 106
int __cdecl _strcmpi(const char * _String1, const char * _String2); 
#line 112
int __cdecl strcoll(const char * _String1, const char * _String2); 
#line 118
int __cdecl _strcoll_l(const char * _String1, const char * _String2, _locale_t _Locale); 
#line 124
extern "C++" {template < size_t _Size > inline errno_t __cdecl strcpy_s ( char ( & _Destination ) [ _Size ], char const * _Source ) throw ( ) { return strcpy_s ( _Destination, _Size, _Source ); }}
#line 130 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
char *__cdecl strcpy(char * _Destination, const char * _Source); 
#line 137 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
size_t __cdecl strcspn(const char * _Str, const char * _Control); 
#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
__declspec(allocator) char *__cdecl _strdup(const char * _Source); 
#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
char *__cdecl _strerror(const char * _ErrorMessage); 
#line 164
errno_t __cdecl _strerror_s(char * _Buffer, size_t _SizeInBytes, const char * _ErrorMessage); 
#line 170
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strerror_s ( char ( & _Buffer ) [ _Size ], char const * _ErrorMessage ) throw ( ) { return _strerror_s ( _Buffer, _Size, _ErrorMessage ); }}
#line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
char *__cdecl strerror(int _ErrorMessage); 
#line 182
extern "C++" {template < size_t _Size > inline errno_t __cdecl strerror_s ( char ( & _Buffer ) [ _Size ], int _ErrorMessage ) throw ( ) { return strerror_s ( _Buffer, _Size, _ErrorMessage ); }}
#line 189 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
int __cdecl _stricmp(const char * _String1, const char * _String2); 
#line 195
int __cdecl _stricoll(const char * _String1, const char * _String2); 
#line 201
int __cdecl _stricoll_l(const char * _String1, const char * _String2, _locale_t _Locale); 
#line 208
int __cdecl _stricmp_l(const char * _String1, const char * _String2, _locale_t _Locale); 
#line 215
size_t __cdecl strlen(const char * _Str); 
#line 220
errno_t __cdecl _strlwr_s(char * _String, size_t _Size); 
#line 225
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strlwr_s ( char ( & _String ) [ _Size ] ) throw ( ) { return _strlwr_s ( _String, _Size ); }}
#line 230 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
char *__cdecl _strlwr(char * _String); 
#line 236 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
errno_t __cdecl _strlwr_s_l(char * _String, size_t _Size, _locale_t _Locale); 
#line 242
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strlwr_s_l ( char ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _strlwr_s_l ( _String, _Size, _Locale ); }}
#line 248 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
char *__cdecl _strlwr_l(char * _String, _locale_t _Locale); 
#line 255 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
extern "C++" {template < size_t _Size > inline errno_t __cdecl strncat_s ( char ( & _Destination ) [ _Size ], char const * _Source, size_t _Count ) throw ( ) { return strncat_s ( _Destination, _Size, _Source, _Count ); }}
#line 262 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
char *__cdecl strncat(char * _Destination, const char * _Source, size_t _Count); 
#line 271 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
int __cdecl strncmp(const char * _Str1, const char * _Str2, size_t _MaxCount); 
#line 278
int __cdecl _strnicmp(const char * _String1, const char * _String2, size_t _MaxCount); 
#line 285
int __cdecl _strnicmp_l(const char * _String1, const char * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 293
int __cdecl _strnicoll(const char * _String1, const char * _String2, size_t _MaxCount); 
#line 300
int __cdecl _strnicoll_l(const char * _String1, const char * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 308
int __cdecl _strncoll(const char * _String1, const char * _String2, size_t _MaxCount); 
#line 315
int __cdecl _strncoll_l(const char * _String1, const char * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 322
size_t __cdecl __strncnt(const char * _String, size_t _Count); 
#line 327
extern "C++" {template < size_t _Size > inline errno_t __cdecl strncpy_s ( char ( & _Destination ) [ _Size ], char const * _Source, size_t _Count ) throw ( ) { return strncpy_s ( _Destination, _Size, _Source, _Count ); }}
#line 334 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
char *__cdecl strncpy(char * _Destination, const char * _Source, size_t _Count); 
#line 351 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
size_t __cdecl strnlen(const char * _String, size_t _MaxCount); 
#line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
static __inline size_t __cdecl strnlen_s(const char *
#line 368
_String, size_t 
#line 369
_MaxCount) 
#line 371
{ 
#line 372
return (_String == (0)) ? 0 : strnlen(_String, _MaxCount); 
#line 373
} 
#line 378 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
errno_t __cdecl _strnset_s(char * _String, size_t _SizeInBytes, int _Value, size_t _MaxCount); 
#line 385
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strnset_s ( char ( & _Destination ) [ _Size ], int _Value, size_t _Count ) throw ( ) { return _strnset_s ( _Destination, _Size, _Value, _Count ); }}
#line 392 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
char *__cdecl _strnset(char * _Destination, int _Value, size_t _Count); 
#line 401 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
const char *__cdecl strpbrk(const char * _Str, const char * _Control); 
#line 406
char *__cdecl _strrev(char * _Str); 
#line 411
errno_t __cdecl _strset_s(char * _Destination, size_t _DestinationSize, int _Value); 
#line 417
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strset_s ( char ( & _Destination ) [ _Size ], int _Value ) throw ( ) { return _strset_s ( _Destination, _Size, _Value ); }}
#line 423 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
char *__cdecl _strset(char * _Destination, int _Value); 
#line 430 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
size_t __cdecl strspn(const char * _Str, const char * _Control); 
#line 436
char *__cdecl strtok(char * _String, const char * _Delimiter); 
#line 442
errno_t __cdecl _strupr_s(char * _String, size_t _Size); 
#line 447
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strupr_s ( char ( & _String ) [ _Size ] ) throw ( ) { return _strupr_s ( _String, _Size ); }}
#line 452 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
char *__cdecl _strupr(char * _String); 
#line 458 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
errno_t __cdecl _strupr_s_l(char * _String, size_t _Size, _locale_t _Locale); 
#line 464
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strupr_s_l ( char ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _strupr_s_l ( _String, _Size, _Locale ); }}
#line 470 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
char *__cdecl _strupr_l(char * _String, _locale_t _Locale); 
#line 479 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
size_t __cdecl strxfrm(char * _Destination, const char * _Source, size_t _MaxCount); 
#line 487
size_t __cdecl _strxfrm_l(char * _Destination, const char * _Source, size_t _MaxCount, _locale_t _Locale); 
#line 497
extern "C++" {
#line 500
inline char *__cdecl strchr(char *const _String, const int _Ch) 
#line 501
{ 
#line 502
return const_cast< char *>(strchr(static_cast< const char *>(_String), _Ch)); 
#line 503
} 
#line 506
inline char *__cdecl strpbrk(char *const _String, const char *const _Control) 
#line 507
{ 
#line 508
return const_cast< char *>(strpbrk(static_cast< const char *>(_String), _Control)); 
#line 509
} 
#line 512
inline char *__cdecl strrchr(char *const _String, const int _Ch) 
#line 513
{ 
#line 514
return const_cast< char *>(strrchr(static_cast< const char *>(_String), _Ch)); 
#line 515
} 
#line 518
inline char *__cdecl strstr(char *const _String, const char *const _SubString) 
#line 519
{ 
#line 520
return const_cast< char *>(strstr(static_cast< const char *>(_String), _SubString)); 
#line 521
} 
#line 522
}
#line 532 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
char *__cdecl strdup(const char * _String); 
#line 539
int __cdecl strcmpi(const char * _String1, const char * _String2); 
#line 545
int __cdecl stricmp(const char * _String1, const char * _String2); 
#line 551
char *__cdecl strlwr(char * _String); 
#line 556
int __cdecl strnicmp(const char * _String1, const char * _String2, size_t _MaxCount); 
#line 563
char *__cdecl strnset(char * _String, int _Value, size_t _MaxCount); 
#line 570
char *__cdecl strrev(char * _String); 
#line 575
char *__cdecl strset(char * _String, int _Value); 
#line 580
char *__cdecl strupr(char * _String); 
#line 588 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\string.h"
}__pragma( pack ( pop )) 
#line 590
#pragma warning(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wtime.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 17
__pragma( pack ( push, 8 )) extern "C" {
#line 26
struct tm { 
#line 28
int tm_sec; 
#line 29
int tm_min; 
#line 30
int tm_hour; 
#line 31
int tm_mday; 
#line 32
int tm_mon; 
#line 33
int tm_year; 
#line 34
int tm_wday; 
#line 35
int tm_yday; 
#line 36
int tm_isdst; 
#line 37
}; 
#line 48
__wchar_t *__cdecl _wasctime(const tm * _Tm); 
#line 54
errno_t __cdecl _wasctime_s(__wchar_t * _Buffer, size_t _SizeInWords, const tm * _Tm); 
#line 60
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wasctime_s ( wchar_t ( & _Buffer ) [ _Size ], struct tm const * _Time ) throw ( ) { return _wasctime_s ( _Buffer, _Size, _Time ); }}
#line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wtime.h"
size_t __cdecl wcsftime(__wchar_t * _Buffer, size_t _SizeInWords, const __wchar_t * _Format, const tm * _Tm); 
#line 78
size_t __cdecl _wcsftime_l(__wchar_t * _Buffer, size_t _SizeInWords, const __wchar_t * _Format, const tm * _Tm, _locale_t _Locale); 
#line 88
__wchar_t *__cdecl _wctime32(const __time32_t * _Time); 
#line 93
errno_t __cdecl _wctime32_s(__wchar_t * _Buffer, size_t _SizeInWords, const __time32_t * _Time); 
#line 99
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wctime32_s ( wchar_t ( & _Buffer ) [ _Size ], __time32_t const * _Time ) throw ( ) { return _wctime32_s ( _Buffer, _Size, _Time ); }}
#line 108 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wtime.h"
__wchar_t *__cdecl _wctime64(const __time64_t * _Time); 
#line 113
errno_t __cdecl _wctime64_s(__wchar_t * _Buffer, size_t _SizeInWords, const __time64_t * _Time); 
#line 118
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wctime64_s ( wchar_t ( & _Buffer ) [ _Size ], __time64_t const * _Time ) throw ( ) { return _wctime64_s ( _Buffer, _Size, _Time ); }}
#line 125 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wtime.h"
errno_t __cdecl _wstrdate_s(__wchar_t * _Buffer, size_t _SizeInWords); 
#line 130
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wstrdate_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wstrdate_s ( _Buffer, _Size ); }}
#line 135 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wtime.h"
__wchar_t *__cdecl _wstrdate(__wchar_t * _Buffer); 
#line 141 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wtime.h"
errno_t __cdecl _wstrtime_s(__wchar_t * _Buffer, size_t _SizeInWords); 
#line 146
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wstrtime_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wstrtime_s ( _Buffer, _Size ); }}
#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wtime.h"
__wchar_t *__cdecl _wstrtime(__wchar_t * _Buffer); 
#line 186 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wtime.h"
static __inline __wchar_t *__cdecl _wctime(const time_t *const 
#line 187
_Time) 
#line 188
{ 
#line 189
return _wctime64(_Time); 
#line 190
} 
#line 193
static __inline errno_t __cdecl _wctime_s(__wchar_t *const 
#line 194
_Buffer, const size_t 
#line 195
_SizeInWords, const time_t *const 
#line 196
_Time) 
#line 198
{ 
#line 199
return _wctime64_s(_Buffer, _SizeInWords, _Time); 
#line 200
} 
#line 205 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wtime.h"
}__pragma( pack ( pop )) 
#line 207
#pragma warning(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\time.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 19
__pragma( pack ( push, 8 )) extern "C" {
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\time.h"
typedef long clock_t; 
#line 32
struct _timespec32 { 
#line 34
__time32_t tv_sec; 
#line 35
long tv_nsec; 
#line 36
}; 
#line 38
struct _timespec64 { 
#line 40
__time64_t tv_sec; 
#line 41
long tv_nsec; 
#line 42
}; 
#line 45
struct timespec { 
#line 47
time_t tv_sec; 
#line 48
long tv_nsec; 
#line 49
}; 
#line 68 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\time.h"
int *__cdecl __daylight(); 
#line 74
long *__cdecl __dstbias(); 
#line 80
long *__cdecl __timezone(); 
#line 86
char **__cdecl __tzname(); 
#line 91
errno_t __cdecl _get_daylight(int * _Daylight); 
#line 96
errno_t __cdecl _get_dstbias(long * _DaylightSavingsBias); 
#line 101
errno_t __cdecl _get_timezone(long * _TimeZone); 
#line 106
errno_t __cdecl _get_tzname(size_t * _ReturnValue, char * _Buffer, size_t _SizeInBytes, int _Index); 
#line 123
char *__cdecl asctime(const tm * _Tm); 
#line 130
errno_t __cdecl asctime_s(char * _Buffer, size_t _SizeInBytes, const tm * _Tm); 
#line 137 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\time.h"
extern "C++" {template < size_t _Size > inline errno_t __cdecl asctime_s ( char ( & _Buffer ) [ _Size ], struct tm const * _Time ) throw ( ) { return asctime_s ( _Buffer, _Size, _Time ); }}
#line 144 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\time.h"
clock_t __cdecl clock(); 
#line 149
char *__cdecl _ctime32(const __time32_t * _Time); 
#line 154
errno_t __cdecl _ctime32_s(char * _Buffer, size_t _SizeInBytes, const __time32_t * _Time); 
#line 160
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ctime32_s ( char ( & _Buffer ) [ _Size ], __time32_t const * _Time ) throw ( ) { return _ctime32_s ( _Buffer, _Size, _Time ); }}
#line 169 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\time.h"
char *__cdecl _ctime64(const __time64_t * _Time); 
#line 174
errno_t __cdecl _ctime64_s(char * _Buffer, size_t _SizeInBytes, const __time64_t * _Time); 
#line 180
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ctime64_s ( char ( & _Buffer ) [ _Size ], __time64_t const * _Time ) throw ( ) { return _ctime64_s ( _Buffer, _Size, _Time ); }}
#line 187 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\time.h"
double __cdecl _difftime32(__time32_t _Time1, __time32_t _Time2); 
#line 193
double __cdecl _difftime64(__time64_t _Time1, __time64_t _Time2); 
#line 200
tm *__cdecl _gmtime32(const __time32_t * _Time); 
#line 205
errno_t __cdecl _gmtime32_s(tm * _Tm, const __time32_t * _Time); 
#line 212
tm *__cdecl _gmtime64(const __time64_t * _Time); 
#line 217
errno_t __cdecl _gmtime64_s(tm * _Tm, const __time64_t * _Time); 
#line 224
tm *__cdecl _localtime32(const __time32_t * _Time); 
#line 229
errno_t __cdecl _localtime32_s(tm * _Tm, const __time32_t * _Time); 
#line 236
tm *__cdecl _localtime64(const __time64_t * _Time); 
#line 241
errno_t __cdecl _localtime64_s(tm * _Tm, const __time64_t * _Time); 
#line 247
__time32_t __cdecl _mkgmtime32(tm * _Tm); 
#line 252
__time64_t __cdecl _mkgmtime64(tm * _Tm); 
#line 257
__time32_t __cdecl _mktime32(tm * _Tm); 
#line 262
__time64_t __cdecl _mktime64(tm * _Tm); 
#line 268
size_t __cdecl strftime(char * _Buffer, size_t _SizeInBytes, const char * _Format, const tm * _Tm); 
#line 277
size_t __cdecl _strftime_l(char * _Buffer, size_t _MaxSize, const char * _Format, const tm * _Tm, _locale_t _Locale); 
#line 286
errno_t __cdecl _strdate_s(char * _Buffer, size_t _SizeInBytes); 
#line 291
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strdate_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return _strdate_s ( _Buffer, _Size ); }}
#line 296 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\time.h"
char *__cdecl _strdate(char * _Buffer); 
#line 302 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\time.h"
errno_t __cdecl _strtime_s(char * _Buffer, size_t _SizeInBytes); 
#line 307
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strtime_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return _strtime_s ( _Buffer, _Size ); }}
#line 312 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\time.h"
char *__cdecl _strtime(char * _Buffer); 
#line 317 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\time.h"
__time32_t __cdecl _time32(__time32_t * _Time); 
#line 321
__time64_t __cdecl _time64(__time64_t * _Time); 
#line 327
int __cdecl _timespec32_get(_timespec32 * _Ts, int _Base); 
#line 334
int __cdecl _timespec64_get(_timespec64 * _Ts, int _Base); 
#line 348
void __cdecl _tzset(); 
#line 351
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using GetLocalTime in" "stead. See online help for details.")) unsigned __cdecl 
#line 352
_getsystime(tm * _Tm); 
#line 356
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetLocalTime in" "stead. See online help for details.")) unsigned __cdecl 
#line 357
_setsystime(tm * _Tm, unsigned _Milliseconds); 
#line 501 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\time.h"
static __inline char *__cdecl ctime(const time_t *const 
#line 502
_Time) 
#line 504
{ 
#line 505
return _ctime64(_Time); 
#line 506
} 
#line 509
static __inline double __cdecl difftime(const time_t 
#line 510
_Time1, const time_t 
#line 511
_Time2) 
#line 513
{ 
#line 514
return _difftime64(_Time1, _Time2); 
#line 515
} 
#line 518
static __inline tm *__cdecl gmtime(const time_t *const 
#line 519
_Time) 
#line 520
{ 
#line 521
return _gmtime64(_Time); 
#line 522
} 
#line 525
static __inline tm *__cdecl localtime(const time_t *const 
#line 526
_Time) 
#line 528
{ 
#line 529
return _localtime64(_Time); 
#line 530
} 
#line 533
static __inline time_t __cdecl _mkgmtime(tm *const 
#line 534
_Tm) 
#line 536
{ 
#line 537
return _mkgmtime64(_Tm); 
#line 538
} 
#line 541
static __inline time_t __cdecl mktime(tm *const 
#line 542
_Tm) 
#line 544
{ 
#line 545
return _mktime64(_Tm); 
#line 546
} 
#line 548
static __inline time_t __cdecl time(time_t *const 
#line 549
_Time) 
#line 551
{ 
#line 552
return _time64(_Time); 
#line 553
} 
#line 556
static __inline int __cdecl timespec_get(timespec *const 
#line 557
_Ts, const int 
#line 558
_Base) 
#line 560
{ 
#line 561
return _timespec64_get((_timespec64 *)_Ts, _Base); 
#line 562
} 
#line 566
static __inline errno_t __cdecl ctime_s(char *const 
#line 567
_Buffer, const size_t 
#line 568
_SizeInBytes, const time_t *const 
#line 569
_Time) 
#line 571
{ 
#line 572
return _ctime64_s(_Buffer, _SizeInBytes, _Time); 
#line 573
} 
#line 603 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\time.h"
static __inline errno_t __cdecl gmtime_s(tm *const 
#line 604
_Tm, const time_t *const 
#line 605
_Time) 
#line 607
{ 
#line 608
return _gmtime64_s(_Tm, _Time); 
#line 609
} 
#line 612
static __inline errno_t __cdecl localtime_s(tm *const 
#line 613
_Tm, const time_t *const 
#line 614
_Time) 
#line 616
{ 
#line 617
return _localtime64_s(_Tm, _Time); 
#line 618
} 
#line 638 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\time.h"
void __cdecl tzset(); 
#line 645 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\time.h"
}__pragma( pack ( pop )) 
#line 647
#pragma warning(pop)
#line 88 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt/common_functions.h"
extern "C" {
#line 91 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt/common_functions.h"
extern clock_t __cdecl clock(); 
#line 96 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt/common_functions.h"
extern void *__cdecl memset(void *, int, size_t); 
#line 97
extern void *__cdecl memcpy(void *, const void *, size_t); 
#line 99
}
#line 126 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern "C" {
#line 233 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern int __cdecl abs(int a); 
#line 244
extern long __cdecl labs(long a); 
#line 255
extern __int64 llabs(__int64 a); 
#line 283 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl fabs(double x); 
#line 306 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern __inline float fabsf(float x); 
#line 317 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern inline int min(const int a, const int b); 
#line 324
extern inline unsigned umin(const unsigned a, const unsigned b); 
#line 331
extern inline __int64 llmin(const __int64 a, const __int64 b); 
#line 338
extern inline unsigned __int64 ullmin(const unsigned __int64 a, const unsigned __int64 b); 
#line 361 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl fminf(float x, float y); 
#line 381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl fmin(double x, double y); 
#line 392 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern inline int max(const int a, const int b); 
#line 400
extern inline unsigned umax(const unsigned a, const unsigned b); 
#line 407
extern inline __int64 llmax(const __int64 a, const __int64 b); 
#line 414
extern inline unsigned __int64 ullmax(const unsigned __int64 a, const unsigned __int64 b); 
#line 437 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl fmaxf(float x, float y); 
#line 457 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl fmax(double, double); 
#line 477 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl sin(double x); 
#line 495
extern double __cdecl cos(double x); 
#line 511 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern void sincos(double x, double * sptr, double * cptr); 
#line 524
extern void sincosf(float x, float * sptr, float * cptr); 
#line 547 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl tan(double x); 
#line 571
extern double __cdecl sqrt(double x); 
#line 597 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double rsqrt(double x); 
#line 621
extern float rsqrtf(float x); 
#line 650 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl log2(double x); 
#line 679 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl exp2(double x); 
#line 708 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl exp2f(float x); 
#line 737 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double exp10(double x); 
#line 764
extern float exp10f(float x); 
#line 800 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl expm1(double x); 
#line 833 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl expm1f(float x); 
#line 860 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl log2f(float x); 
#line 883 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl log10(double x); 
#line 909
extern double __cdecl log(double x); 
#line 938 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl log1p(double x); 
#line 968 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl log1pf(float x); 
#line 992 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl floor(double x); 
#line 1021
extern double __cdecl exp(double x); 
#line 1040
extern double __cdecl cosh(double x); 
#line 1060
extern double __cdecl sinh(double x); 
#line 1080
extern double __cdecl tanh(double x); 
#line 1106 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl acosh(double x); 
#line 1133 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl acoshf(float x); 
#line 1157 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl asinh(double x); 
#line 1181 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl asinhf(float x); 
#line 1206 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl atanh(double x); 
#line 1231 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl atanhf(float x); 
#line 1247 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl ldexp(double x, int exp); 
#line 1262
extern __inline float ldexpf(float x, int exp); 
#line 1285 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl logb(double x); 
#line 1309 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl logbf(float x); 
#line 1333 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern int __cdecl ilogb(double x); 
#line 1357 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern int __cdecl ilogbf(float x); 
#line 1385 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl scalbn(double x, int n); 
#line 1413 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl scalbnf(float x, int n); 
#line 1441 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl scalbln(double x, long n); 
#line 1469 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl scalblnf(float x, long n); 
#line 1499 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl frexp(double x, int * nptr); 
#line 1528
extern __inline float frexpf(float x, int * nptr); 
#line 1553 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl round(double x); 
#line 1579 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl roundf(float x); 
#line 1597 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern long __cdecl lround(double x); 
#line 1615 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern long __cdecl lroundf(float x); 
#line 1633 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern __int64 __cdecl llround(double x); 
#line 1651 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern __int64 __cdecl llroundf(float x); 
#line 1721 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl rintf(float x); 
#line 1738 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern long __cdecl lrint(double x); 
#line 1755 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern long __cdecl lrintf(float x); 
#line 1772 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern __int64 __cdecl llrint(double x); 
#line 1789 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern __int64 __cdecl llrintf(float x); 
#line 1813 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl nearbyint(double x); 
#line 1837 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl nearbyintf(float x); 
#line 1859 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl ceil(double x); 
#line 1884 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl trunc(double x); 
#line 1910 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl truncf(float x); 
#line 1932 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl fdim(double x, double y); 
#line 1953 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl fdimf(float x, float y); 
#line 2034 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl atan2(double y, double x); 
#line 2060
extern double __cdecl atan(double x); 
#line 2077
extern double __cdecl acos(double x); 
#line 2099
extern double __cdecl asin(double x); 
#line 2127 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl hypot(double x, double y); 
#line 2185 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
static __inline float __cdecl hypotf(float x, float y); 
#line 2461 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl cbrt(double x); 
#line 2488 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl cbrtf(float x); 
#line 2512 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double rcbrt(double x); 
#line 2533
extern float rcbrtf(float x); 
#line 2556
extern double sinpi(double x); 
#line 2579
extern float sinpif(float x); 
#line 2601
extern double cospi(double x); 
#line 2623
extern float cospif(float x); 
#line 2636
extern void sincospi(double x, double * sptr, double * cptr); 
#line 2649
extern void sincospif(float x, float * sptr, float * cptr); 
#line 2735 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl pow(double x, double y); 
#line 2759
extern double __cdecl modf(double x, double * iptr); 
#line 2786
extern double __cdecl fmod(double x, double y); 
#line 2818 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl remainder(double x, double y); 
#line 2851 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl remainderf(float x, float y); 
#line 2889 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl remquo(double x, double y, int * quo); 
#line 2927 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl remquof(float x, float y, int * quo); 
#line 2946 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl j0(double x); 
#line 2968 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float j0f(float x); 
#line 2995 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl j1(double x); 
#line 3022 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float j1f(float x); 
#line 3045 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl jn(int n, double x); 
#line 3068 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float jnf(int n, float x); 
#line 3095 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl y0(double x); 
#line 3122 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float y0f(float x); 
#line 3149 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl y1(double x); 
#line 3176 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float y1f(float x); 
#line 3204 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl yn(int n, double x); 
#line 3232 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float ynf(int n, float x); 
#line 3330 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl erf(double x); 
#line 3355 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl erff(float x); 
#line 3383 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double erfinv(double x); 
#line 3406
extern float erfinvf(float x); 
#line 3432 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl erfc(double x); 
#line 3455 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl erfcf(float x); 
#line 3487 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl lgamma(double x); 
#line 3513 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double erfcinv(double x); 
#line 3534
extern float erfcinvf(float x); 
#line 3556
extern double normcdfinv(double x); 
#line 3578
extern float normcdfinvf(float x); 
#line 3597
extern double normcdf(double x); 
#line 3616
extern float normcdff(float x); 
#line 3636
extern double erfcx(double x); 
#line 3656
extern float erfcxf(float x); 
#line 3691 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl lgammaf(float x); 
#line 3720 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl tgamma(double x); 
#line 3749 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl tgammaf(float x); 
#line 3763 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl copysign(double x, double y); 
#line 3777 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl copysignf(float x, float y); 
#line 3796 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl nextafter(double x, double y); 
#line 3815 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl nextafterf(float x, float y); 
#line 3831 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl nan(const char * tagp); 
#line 3847 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl nanf(const char * tagp); 
#line 3852 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern int __isinff(float); 
#line 3853
extern int __isnanf(float); 
#line 3863 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern int __finite(double); 
#line 3864
extern int __finitef(float); 
#line 3865
extern int __signbit(double); 
#line 3866
extern int __isnan(double); 
#line 3867
extern int __isinf(double); 
#line 3870 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern int __signbitf(float); 
#line 3923 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern double __cdecl fma(double x, double y, double z); 
#line 3973 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl fmaf(float x, float y, float z); 
#line 3982 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern int __signbitl(long double); 
#line 3988 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern int __finitel(long double); 
#line 3989
extern int __isinfl(long double); 
#line 3990
extern int __isnanl(long double); 
#line 3994 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern float __cdecl acosf(float); 
#line 3995
extern float __cdecl asinf(float); 
#line 3996
extern float __cdecl atanf(float); 
#line 3997
extern float __cdecl atan2f(float, float); 
#line 3998
extern float __cdecl cosf(float); 
#line 3999
extern float __cdecl sinf(float); 
#line 4000
extern float __cdecl tanf(float); 
#line 4001
extern float __cdecl coshf(float); 
#line 4002
extern float __cdecl sinhf(float); 
#line 4003
extern float __cdecl tanhf(float); 
#line 4004
extern float __cdecl expf(float); 
#line 4005
extern float __cdecl logf(float); 
#line 4006
extern float __cdecl log10f(float); 
#line 4007
extern float __cdecl modff(float, float *); 
#line 4008
extern float __cdecl powf(float, float); 
#line 4009
extern float __cdecl sqrtf(float); 
#line 4010
extern float __cdecl ceilf(float); 
#line 4011
extern float __cdecl floorf(float); 
#line 4012
extern float __cdecl fmodf(float, float); 
#line 4574 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
}
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_math.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 18
__pragma( pack ( push, 8 )) extern "C" {
#line 23
struct _exception { 
#line 25
int type; 
#line 26
char *name; 
#line 27
double arg1; 
#line 28
double arg2; 
#line 29
double retval; 
#line 30
}; 
#line 37
struct _complex { 
#line 39
double x, y; 
#line 40
}; 
#line 59 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_math.h"
typedef float float_t; 
#line 60
typedef double double_t; 
#line 78 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_math.h"
extern const double _HUGE; 
#line 189 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_math.h"
void __cdecl _fperrraise(int _Except); 
#line 191
short __cdecl _dclass(double _X); 
#line 192
short __cdecl _ldclass(long double _X); 
#line 193
short __cdecl _fdclass(float _X); 
#line 195
int __cdecl _dsign(double _X); 
#line 196
int __cdecl _ldsign(long double _X); 
#line 197
int __cdecl _fdsign(float _X); 
#line 199
int __cdecl _dpcomp(double _X, double _Y); 
#line 200
int __cdecl _ldpcomp(long double _X, long double _Y); 
#line 201
int __cdecl _fdpcomp(float _X, float _Y); 
#line 203
short __cdecl _dtest(double * _Px); 
#line 204
short __cdecl _ldtest(long double * _Px); 
#line 205
short __cdecl _fdtest(float * _Px); 
#line 207
short __cdecl _d_int(double * _Px, short _Xexp); 
#line 208
short __cdecl _ld_int(long double * _Px, short _Xexp); 
#line 209
short __cdecl _fd_int(float * _Px, short _Xexp); 
#line 211
short __cdecl _dscale(double * _Px, long _Lexp); 
#line 212
short __cdecl _ldscale(long double * _Px, long _Lexp); 
#line 213
short __cdecl _fdscale(float * _Px, long _Lexp); 
#line 215
short __cdecl _dunscale(short * _Pex, double * _Px); 
#line 216
short __cdecl _ldunscale(short * _Pex, long double * _Px); 
#line 217
short __cdecl _fdunscale(short * _Pex, float * _Px); 
#line 219
short __cdecl _dexp(double * _Px, double _Y, long _Eoff); 
#line 220
short __cdecl _ldexp(long double * _Px, long double _Y, long _Eoff); 
#line 221
short __cdecl _fdexp(float * _Px, float _Y, long _Eoff); 
#line 223
short __cdecl _dnorm(unsigned short * _Ps); 
#line 224
short __cdecl _fdnorm(unsigned short * _Ps); 
#line 226
double __cdecl _dpoly(double _X, const double * _Tab, int _N); 
#line 227
long double __cdecl _ldpoly(long double _X, const long double * _Tab, int _N); 
#line 228
float __cdecl _fdpoly(float _X, const float * _Tab, int _N); 
#line 230
double __cdecl _dlog(double _X, int _Baseflag); 
#line 231
long double __cdecl _ldlog(long double _X, int _Baseflag); 
#line 232
float __cdecl _fdlog(float _X, int _Baseflag); 
#line 234
double __cdecl _dsin(double _X, unsigned _Qoff); 
#line 235
long double __cdecl _ldsin(long double _X, unsigned _Qoff); 
#line 236
float __cdecl _fdsin(float _X, unsigned _Qoff); 
#line 243
typedef 
#line 240
union { 
#line 241
unsigned short _Sh[4]; 
#line 242
double _Val; 
#line 243
} _double_val; 
#line 250
typedef 
#line 247
union { 
#line 248
unsigned short _Sh[2]; 
#line 249
float _Val; 
#line 250
} _float_val; 
#line 257
typedef 
#line 254
union { 
#line 255
unsigned short _Sh[4]; 
#line 256
long double _Val; 
#line 257
} _ldouble_val; 
#line 265
typedef 
#line 260
union { 
#line 261
unsigned short _Word[4]; 
#line 262
float _Float; 
#line 263
double _Double; 
#line 264
long double _Long_double; 
#line 265
} _float_const; 
#line 267
extern const _float_const _Denorm_C, _Inf_C, _Nan_C, _Snan_C, _Hugeval_C; 
#line 268
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C; 
#line 269
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C; 
#line 271
extern const _float_const _Eps_C, _Rteps_C; 
#line 272
extern const _float_const _FEps_C, _FRteps_C; 
#line 273
extern const _float_const _LEps_C, _LRteps_C; 
#line 275
extern const double _Zero_C, _Xbig_C; 
#line 276
extern const float _FZero_C, _FXbig_C; 
#line 277
extern const long double _LZero_C, _LXbig_C; 
#line 310
extern "C++" {
#line 312
inline int fpclassify(float _X) throw() 
#line 313
{ 
#line 317 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_math.h"
return _fdtest(&_X); 
#line 319 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_math.h"
} 
#line 321
inline int fpclassify(double _X) throw() 
#line 322
{ 
#line 326 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_math.h"
return _dtest(&_X); 
#line 328 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_math.h"
} 
#line 330
inline int fpclassify(long double _X) throw() 
#line 331
{ 
#line 335 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_math.h"
return _ldtest(&_X); 
#line 337 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_math.h"
} 
#line 339
inline bool signbit(float _X) throw() 
#line 340
{ 
#line 341
return _fdsign(_X) != 0; 
#line 342
} 
#line 344
inline bool signbit(double _X) throw() 
#line 345
{ 
#line 346
return _dsign(_X) != 0; 
#line 347
} 
#line 349
inline bool signbit(long double _X) throw() 
#line 350
{ 
#line 351
return _ldsign(_X) != 0; 
#line 352
} 
#line 354
inline int _fpcomp(float _X, float _Y) throw() 
#line 355
{ 
#line 356
return _fdpcomp(_X, _Y); 
#line 357
} 
#line 359
inline int _fpcomp(double _X, double _Y) throw() 
#line 360
{ 
#line 361
return _dpcomp(_X, _Y); 
#line 362
} 
#line 364
inline int _fpcomp(long double _X, long double _Y) throw() 
#line 365
{ 
#line 366
return _ldpcomp(_X, _Y); 
#line 367
} 
#line 369
template< class _Trc, class _Tre> struct _Combined_type { 
#line 371
typedef float _Type; 
#line 372
}; 
#line 374
template<> struct _Combined_type< float, double>  { 
#line 376
typedef double _Type; 
#line 377
}; 
#line 379
template<> struct _Combined_type< float, long double>  { 
#line 381
typedef long double _Type; 
#line 382
}; 
#line 384
template< class _Ty, class _T2> struct _Real_widened { 
#line 386
typedef long double _Type; 
#line 387
}; 
#line 389
template<> struct _Real_widened< float, float>  { 
#line 391
typedef float _Type; 
#line 392
}; 
#line 394
template<> struct _Real_widened< float, double>  { 
#line 396
typedef double _Type; 
#line 397
}; 
#line 399
template<> struct _Real_widened< double, float>  { 
#line 401
typedef double _Type; 
#line 402
}; 
#line 404
template<> struct _Real_widened< double, double>  { 
#line 406
typedef double _Type; 
#line 407
}; 
#line 409
template< class _Ty> struct _Real_type { 
#line 411
typedef double _Type; 
#line 412
}; 
#line 414
template<> struct _Real_type< float>  { 
#line 416
typedef float _Type; 
#line 417
}; 
#line 419
template<> struct _Real_type< long double>  { 
#line 421
typedef long double _Type; 
#line 422
}; 
#line 424
template < class _T1, class _T2 >
      inline int _fpcomp ( _T1 _X, _T2 _Y ) throw ( )
    {
        typedef typename _Combined_type < float,
            typename _Real_widened <
            typename _Real_type < _T1 > :: _Type,
            typename _Real_type < _T2 > :: _Type > :: _Type > :: _Type _Tw;
        return _fpcomp ( ( _Tw ) _X, ( _Tw ) _Y );
    }
#line 434
template < class _Ty >
      inline bool isfinite ( _Ty _X ) throw ( )
    {
        return fpclassify ( _X ) <= 0;
    }
#line 440
template < class _Ty >
      inline bool isinf ( _Ty _X ) throw ( )
    {
        return fpclassify ( _X ) == 1;
    }
#line 446
template < class _Ty >
      inline bool isnan ( _Ty _X ) throw ( )
    {
        return fpclassify ( _X ) == 2;
    }
#line 452
template < class _Ty >
      inline bool isnormal ( _Ty _X ) throw ( )
    {
        return fpclassify ( _X ) == ( - 1 );
    }
#line 458
template < class _Ty1, class _Ty2 >
      inline bool isgreater ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return ( _fpcomp ( _X, _Y ) & 4 ) != 0;
    }
#line 464
template < class _Ty1, class _Ty2 >
      inline bool isgreaterequal ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return ( _fpcomp ( _X, _Y ) & ( 2 | 4 ) ) != 0;
    }
#line 470
template < class _Ty1, class _Ty2 >
      inline bool isless ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return ( _fpcomp ( _X, _Y ) & 1 ) != 0;
    }
#line 476
template < class _Ty1, class _Ty2 >
      inline bool islessequal ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return ( _fpcomp ( _X, _Y ) & ( 1 | 2 ) ) != 0;
    }
#line 482
template < class _Ty1, class _Ty2 >
      inline bool islessgreater ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return ( _fpcomp ( _X, _Y ) & ( 1 | 4 ) ) != 0;
    }
#line 488
template < class _Ty1, class _Ty2 >
      inline bool isunordered ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return _fpcomp ( _X, _Y ) == 0;
    }
#line 493
}
#line 500 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_math.h"
int __cdecl abs(int _X); 
#line 501
long __cdecl labs(long _X); 
#line 502
__int64 __cdecl llabs(__int64 _X); 
#line 504
double __cdecl acos(double _X); 
#line 505
double __cdecl asin(double _X); 
#line 506
double __cdecl atan(double _X); 
#line 507
double __cdecl atan2(double _Y, double _X); 
#line 509
double __cdecl cos(double _X); 
#line 510
double __cdecl cosh(double _X); 
#line 511
double __cdecl exp(double _X); 
#line 512
double __cdecl fabs(double _X); 
#line 513
double __cdecl fmod(double _X, double _Y); 
#line 514
double __cdecl log(double _X); 
#line 515
double __cdecl log10(double _X); 
#line 516
double __cdecl pow(double _X, double _Y); 
#line 517
double __cdecl sin(double _X); 
#line 518
double __cdecl sinh(double _X); 
#line 519
double __cdecl sqrt(double _X); 
#line 520
double __cdecl tan(double _X); 
#line 521
double __cdecl tanh(double _X); 
#line 523
double __cdecl acosh(double _X); 
#line 524
double __cdecl asinh(double _X); 
#line 525
double __cdecl atanh(double _X); 
#line 526
double __cdecl atof(const char * _String); 
#line 527
double __cdecl _atof_l(const char * _String, _locale_t _Locale); 
#line 528
double __cdecl _cabs(_complex _Complex_value); 
#line 529
double __cdecl cbrt(double _X); 
#line 530
double __cdecl ceil(double _X); 
#line 531
double __cdecl _chgsign(double _X); 
#line 532
double __cdecl copysign(double _Number, double _Sign); 
#line 533
double __cdecl _copysign(double _Number, double _Sign); 
#line 534
double __cdecl erf(double _X); 
#line 535
double __cdecl erfc(double _X); 
#line 536
double __cdecl exp2(double _X); 
#line 537
double __cdecl expm1(double _X); 
#line 538
double __cdecl fdim(double _X, double _Y); 
#line 539
double __cdecl floor(double _X); 
#line 540
double __cdecl fma(double _X, double _Y, double _Z); 
#line 541
double __cdecl fmax(double _X, double _Y); 
#line 542
double __cdecl fmin(double _X, double _Y); 
#line 543
double __cdecl frexp(double _X, int * _Y); 
#line 544
double __cdecl hypot(double _X, double _Y); 
#line 545
double __cdecl _hypot(double _X, double _Y); 
#line 546
int __cdecl ilogb(double _X); 
#line 547
double __cdecl ldexp(double _X, int _Y); 
#line 548
double __cdecl lgamma(double _X); 
#line 549
__int64 __cdecl llrint(double _X); 
#line 550
__int64 __cdecl llround(double _X); 
#line 551
double __cdecl log1p(double _X); 
#line 552
double __cdecl log2(double _X); 
#line 553
double __cdecl logb(double _X); 
#line 554
long __cdecl lrint(double _X); 
#line 555
long __cdecl lround(double _X); 
#line 557
int __cdecl _matherr(_exception * _Except); 
#line 559
double __cdecl modf(double _X, double * _Y); 
#line 560
double __cdecl nan(const char * _X); 
#line 561
double __cdecl nearbyint(double _X); 
#line 562
double __cdecl nextafter(double _X, double _Y); 
#line 563
double __cdecl nexttoward(double _X, long double _Y); 
#line 564
double __cdecl remainder(double _X, double _Y); 
#line 565
double __cdecl remquo(double _X, double _Y, int * _Z); 
#line 566
double __cdecl rint(double _X); 
#line 567
double __cdecl round(double _X); 
#line 568
double __cdecl scalbln(double _X, long _Y); 
#line 569
double __cdecl scalbn(double _X, int _Y); 
#line 570
double __cdecl tgamma(double _X); 
#line 571
double __cdecl trunc(double _X); 
#line 572
double __cdecl _j0(double _X); 
#line 573
double __cdecl _j1(double _X); 
#line 574
double __cdecl _jn(int _X, double _Y); 
#line 575
double __cdecl _y0(double _X); 
#line 576
double __cdecl _y1(double _X); 
#line 577
double __cdecl _yn(int _X, double _Y); 
#line 579
float __cdecl acoshf(float _X); 
#line 580
float __cdecl asinhf(float _X); 
#line 581
float __cdecl atanhf(float _X); 
#line 582
float __cdecl cbrtf(float _X); 
#line 583
float __cdecl _chgsignf(float _X); 
#line 584
float __cdecl copysignf(float _Number, float _Sign); 
#line 585
float __cdecl _copysignf(float _Number, float _Sign); 
#line 586
float __cdecl erff(float _X); 
#line 587
float __cdecl erfcf(float _X); 
#line 588
float __cdecl expm1f(float _X); 
#line 589
float __cdecl exp2f(float _X); 
#line 590
float __cdecl fdimf(float _X, float _Y); 
#line 591
float __cdecl fmaf(float _X, float _Y, float _Z); 
#line 592
float __cdecl fmaxf(float _X, float _Y); 
#line 593
float __cdecl fminf(float _X, float _Y); 
#line 594
float __cdecl _hypotf(float _X, float _Y); 
#line 595
int __cdecl ilogbf(float _X); 
#line 596
float __cdecl lgammaf(float _X); 
#line 597
__int64 __cdecl llrintf(float _X); 
#line 598
__int64 __cdecl llroundf(float _X); 
#line 599
float __cdecl log1pf(float _X); 
#line 600
float __cdecl log2f(float _X); 
#line 601
float __cdecl logbf(float _X); 
#line 602
long __cdecl lrintf(float _X); 
#line 603
long __cdecl lroundf(float _X); 
#line 604
float __cdecl nanf(const char * _X); 
#line 605
float __cdecl nearbyintf(float _X); 
#line 606
float __cdecl nextafterf(float _X, float _Y); 
#line 607
float __cdecl nexttowardf(float _X, long double _Y); 
#line 608
float __cdecl remainderf(float _X, float _Y); 
#line 609
float __cdecl remquof(float _X, float _Y, int * _Z); 
#line 610
float __cdecl rintf(float _X); 
#line 611
float __cdecl roundf(float _X); 
#line 612
float __cdecl scalblnf(float _X, long _Y); 
#line 613
float __cdecl scalbnf(float _X, int _Y); 
#line 614
float __cdecl tgammaf(float _X); 
#line 615
float __cdecl truncf(float _X); 
#line 625 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_math.h"
float __cdecl _logbf(float _X); 
#line 626
float __cdecl _nextafterf(float _X, float _Y); 
#line 627
int __cdecl _finitef(float _X); 
#line 628
int __cdecl _isnanf(float _X); 
#line 629
int __cdecl _fpclassf(float _X); 
#line 631
int __cdecl _set_FMA3_enable(int _Flag); 
#line 632
int __cdecl _get_FMA3_enable(); 
#line 645 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_math.h"
float __cdecl acosf(float _X); 
#line 646
float __cdecl asinf(float _X); 
#line 647
float __cdecl atan2f(float _Y, float _X); 
#line 648
float __cdecl atanf(float _X); 
#line 649
float __cdecl ceilf(float _X); 
#line 650
float __cdecl cosf(float _X); 
#line 651
float __cdecl coshf(float _X); 
#line 652
float __cdecl expf(float _X); 
#line 709 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_math.h"
__inline float __cdecl fabsf(float _X) 
#line 710
{ 
#line 711
return (float)fabs(_X); 
#line 712
} 
#line 718 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_math.h"
float __cdecl floorf(float _X); 
#line 719
float __cdecl fmodf(float _X, float _Y); 
#line 735 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_math.h"
__inline float __cdecl frexpf(float _X, int *_Y) 
#line 736
{ 
#line 737
return (float)frexp(_X, _Y); 
#line 738
} 
#line 740
__inline float __cdecl hypotf(float _X, float _Y) 
#line 741
{ 
#line 742
return _hypotf(_X, _Y); 
#line 743
} 
#line 745
__inline float __cdecl ldexpf(float _X, int _Y) 
#line 746
{ 
#line 747
return (float)ldexp(_X, _Y); 
#line 748
} 
#line 752
float __cdecl log10f(float _X); 
#line 753
float __cdecl logf(float _X); 
#line 754
float __cdecl modff(float _X, float * _Y); 
#line 755
float __cdecl powf(float _X, float _Y); 
#line 756
float __cdecl sinf(float _X); 
#line 757
float __cdecl sinhf(float _X); 
#line 758
float __cdecl sqrtf(float _X); 
#line 759
float __cdecl tanf(float _X); 
#line 760
float __cdecl tanhf(float _X); 
#line 814 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_math.h"
long double __cdecl acoshl(long double _X); 
#line 816
__inline long double __cdecl acosl(long double _X) 
#line 817
{ 
#line 818
return acos((double)_X); 
#line 819
} 
#line 821
long double __cdecl asinhl(long double _X); 
#line 823
__inline long double __cdecl asinl(long double _X) 
#line 824
{ 
#line 825
return asin((double)_X); 
#line 826
} 
#line 828
__inline long double __cdecl atan2l(long double _Y, long double _X) 
#line 829
{ 
#line 830
return atan2((double)_Y, (double)_X); 
#line 831
} 
#line 833
long double __cdecl atanhl(long double _X); 
#line 835
__inline long double __cdecl atanl(long double _X) 
#line 836
{ 
#line 837
return atan((double)_X); 
#line 838
} 
#line 840
long double __cdecl cbrtl(long double _X); 
#line 842
__inline long double __cdecl ceill(long double _X) 
#line 843
{ 
#line 844
return ceil((double)_X); 
#line 845
} 
#line 847
__inline long double __cdecl _chgsignl(long double _X) 
#line 848
{ 
#line 849
return _chgsign((double)_X); 
#line 850
} 
#line 852
long double __cdecl copysignl(long double _Number, long double _Sign); 
#line 854
__inline long double __cdecl _copysignl(long double _Number, long double _Sign) 
#line 855
{ 
#line 856
return _copysign((double)_Number, (double)_Sign); 
#line 857
} 
#line 859
__inline long double __cdecl coshl(long double _X) 
#line 860
{ 
#line 861
return cosh((double)_X); 
#line 862
} 
#line 864
__inline long double __cdecl cosl(long double _X) 
#line 865
{ 
#line 866
return cos((double)_X); 
#line 867
} 
#line 869
long double __cdecl erfl(long double _X); 
#line 870
long double __cdecl erfcl(long double _X); 
#line 872
__inline long double __cdecl expl(long double _X) 
#line 873
{ 
#line 874
return exp((double)_X); 
#line 875
} 
#line 877
long double __cdecl exp2l(long double _X); 
#line 878
long double __cdecl expm1l(long double _X); 
#line 880
__inline long double __cdecl fabsl(long double _X) 
#line 881
{ 
#line 882
return fabs((double)_X); 
#line 883
} 
#line 885
long double __cdecl fdiml(long double _X, long double _Y); 
#line 887
__inline long double __cdecl floorl(long double _X) 
#line 888
{ 
#line 889
return floor((double)_X); 
#line 890
} 
#line 892
long double __cdecl fmal(long double _X, long double _Y, long double _Z); 
#line 893
long double __cdecl fmaxl(long double _X, long double _Y); 
#line 894
long double __cdecl fminl(long double _X, long double _Y); 
#line 896
__inline long double __cdecl fmodl(long double _X, long double _Y) 
#line 897
{ 
#line 898
return fmod((double)_X, (double)_Y); 
#line 899
} 
#line 901
__inline long double __cdecl frexpl(long double _X, int *_Y) 
#line 902
{ 
#line 903
return frexp((double)_X, _Y); 
#line 904
} 
#line 906
int __cdecl ilogbl(long double _X); 
#line 908
__inline long double __cdecl _hypotl(long double _X, long double _Y) 
#line 909
{ 
#line 910
return _hypot((double)_X, (double)_Y); 
#line 911
} 
#line 913
__inline long double __cdecl hypotl(long double _X, long double _Y) 
#line 914
{ 
#line 915
return _hypot((double)_X, (double)_Y); 
#line 916
} 
#line 918
__inline long double __cdecl ldexpl(long double _X, int _Y) 
#line 919
{ 
#line 920
return ldexp((double)_X, _Y); 
#line 921
} 
#line 923
long double __cdecl lgammal(long double _X); 
#line 924
__int64 __cdecl llrintl(long double _X); 
#line 925
__int64 __cdecl llroundl(long double _X); 
#line 927
__inline long double __cdecl logl(long double _X) 
#line 928
{ 
#line 929
return log((double)_X); 
#line 930
} 
#line 932
__inline long double __cdecl log10l(long double _X) 
#line 933
{ 
#line 934
return log10((double)_X); 
#line 935
} 
#line 937
long double __cdecl log1pl(long double _X); 
#line 938
long double __cdecl log2l(long double _X); 
#line 939
long double __cdecl logbl(long double _X); 
#line 940
long __cdecl lrintl(long double _X); 
#line 941
long __cdecl lroundl(long double _X); 
#line 943
__inline long double __cdecl modfl(long double _X, long double *_Y) 
#line 944
{ 
#line 945
double _F, _I; 
#line 946
_F = modf((double)_X, &_I); 
#line 947
(*_Y) = _I; 
#line 948
return _F; 
#line 949
} 
#line 951
long double __cdecl nanl(const char * _X); 
#line 952
long double __cdecl nearbyintl(long double _X); 
#line 953
long double __cdecl nextafterl(long double _X, long double _Y); 
#line 954
long double __cdecl nexttowardl(long double _X, long double _Y); 
#line 956
__inline long double __cdecl powl(long double _X, long double _Y) 
#line 957
{ 
#line 958
return pow((double)_X, (double)_Y); 
#line 959
} 
#line 961
long double __cdecl remainderl(long double _X, long double _Y); 
#line 962
long double __cdecl remquol(long double _X, long double _Y, int * _Z); 
#line 963
long double __cdecl rintl(long double _X); 
#line 964
long double __cdecl roundl(long double _X); 
#line 965
long double __cdecl scalblnl(long double _X, long _Y); 
#line 966
long double __cdecl scalbnl(long double _X, int _Y); 
#line 968
__inline long double __cdecl sinhl(long double _X) 
#line 969
{ 
#line 970
return sinh((double)_X); 
#line 971
} 
#line 973
__inline long double __cdecl sinl(long double _X) 
#line 974
{ 
#line 975
return sin((double)_X); 
#line 976
} 
#line 978
__inline long double __cdecl sqrtl(long double _X) 
#line 979
{ 
#line 980
return sqrt((double)_X); 
#line 981
} 
#line 983
__inline long double __cdecl tanhl(long double _X) 
#line 984
{ 
#line 985
return tanh((double)_X); 
#line 986
} 
#line 988
__inline long double __cdecl tanl(long double _X) 
#line 989
{ 
#line 990
return tan((double)_X); 
#line 991
} 
#line 993
long double __cdecl tgammal(long double _X); 
#line 994
long double __cdecl truncl(long double _X); 
#line 1015 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_math.h"
extern double HUGE; 
#line 1020 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_math.h"
double __cdecl j0(double _X); 
#line 1021
double __cdecl j1(double _X); 
#line 1022
double __cdecl jn(int _X, double _Y); 
#line 1023
double __cdecl y0(double _X); 
#line 1024
double __cdecl y1(double _X); 
#line 1025
double __cdecl yn(int _X, double _Y); 
#line 1030 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_math.h"
}__pragma( pack ( pop )) 
#line 1032
#pragma warning(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_new.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#pragma warning(disable: 4985)
#line 17
extern "C++" {
#line 19
#pragma pack ( push, 8 )
#line 33
namespace std { 
#line 35
struct nothrow_t { 
#line 36
explicit nothrow_t() = default;
#line 37
}; 
#line 39
extern const nothrow_t nothrow; 
#line 40
}
#line 43 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_new.h"
[[nodiscard]] __declspec(allocator) void *__cdecl 
#line 44
operator new(size_t _Size); 
#line 48
[[nodiscard]] __declspec(allocator) void *__cdecl 
#line 49
operator new(size_t _Size, const std::nothrow_t &) noexcept; 
#line 54
[[nodiscard]] __declspec(allocator) void *__cdecl 
#line 55
operator new[](size_t _Size); 
#line 59
[[nodiscard]] __declspec(allocator) void *__cdecl 
#line 60
operator new[](size_t _Size, const std::nothrow_t &) noexcept; 
#line 65
void __cdecl operator delete(void * _Block) noexcept; 
#line 69
void __cdecl operator delete(void * _Block, const std::nothrow_t &) noexcept; 
#line 74
void __cdecl operator delete[](void * _Block) noexcept; 
#line 78
void __cdecl operator delete[](void * _Block, const std::nothrow_t &) noexcept; 
#line 83
void __cdecl operator delete(void * _Block, size_t _Size) noexcept; 
#line 88
void __cdecl operator delete[](void * _Block, size_t _Size) noexcept; 
#line 156
#pragma warning(push)
#pragma warning(disable: 4577)
#pragma warning(disable: 4514)
#line 161
[[nodiscard]] [[msvc::constexpr]] inline void *__cdecl 
#line 162
operator new(size_t _Size, void *
#line 163
_Where) noexcept 
#line 164
{ 
#line 165
(void)_Size; 
#line 166
return _Where; 
#line 167
} 
#line 169
inline void __cdecl operator delete(void *, void *) noexcept 
#line 170
{ 
#line 172
} 
#line 177 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_new.h"
[[nodiscard]] inline void *__cdecl 
#line 178
operator new[](size_t _Size, void *
#line 179
_Where) noexcept 
#line 180
{ 
#line 181
(void)_Size; 
#line 182
return _Where; 
#line 183
} 
#line 185
inline void __cdecl operator delete[](void *, void *) noexcept 
#line 186
{ 
#line 187
} 
#line 195 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_new.h"
}
#line 189
#pragma warning(pop)
#line 193
#pragma pack ( pop )
#line 198 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_new.h"
#pragma warning(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_new_debug.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 16
extern "C++" {
#line 18
#pragma pack ( push, 8 )
#line 25
[[nodiscard]] 
#line 26
__declspec(allocator) void *__cdecl operator new(size_t _Size, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 33
[[nodiscard]] 
#line 34
__declspec(allocator) void *__cdecl operator new[](size_t _Size, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 41
void __cdecl operator delete(void * _Block, int _BlockUse, const char * _FileName, int _LineNumber) noexcept; 
#line 48
void __cdecl operator delete[](void * _Block, int _BlockUse, const char * _FileName, int _LineNumber) noexcept; 
#line 61 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_new_debug.h"
}
#line 59
#pragma pack ( pop )
#line 64 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_new_debug.h"
#pragma warning(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\crtdbg.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 19
__pragma( pack ( push, 8 )) extern "C" {
#line 23
typedef void *_HFILE; 
#line 49
typedef int (__cdecl *_CRT_REPORT_HOOK)(int, char *, int *); 
#line 50
typedef int (__cdecl *_CRT_REPORT_HOOKW)(int, __wchar_t *, int *); 
#line 56
typedef int (__cdecl *_CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int); 
#line 112
typedef void (__cdecl *_CRT_DUMP_CLIENT)(void *, size_t); 
#line 118
struct _CrtMemBlockHeader; 
#line 127
typedef 
#line 120
struct _CrtMemState { 
#line 122
_CrtMemBlockHeader *pBlockHeader; 
#line 123
size_t lCounts[5]; 
#line 124
size_t lSizes[5]; 
#line 125
size_t lHighWaterCount; 
#line 126
size_t lTotalCount; 
#line 127
} _CrtMemState; 
#line 813 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\crtdbg.h"
}__pragma( pack ( pop )) 
#line 815
#pragma warning(pop)
#line 23 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 141 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
#pragma detect_mismatch("_MSC_VER", "1900")
#line 145 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "0")
#line 150 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
#pragma detect_mismatch("RuntimeLibrary", "MT_StaticRelease")
#line 46 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\use_ansi.h"
#pragma comment(lib, "libcpmt")
#line 361 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
namespace std { 
#line 362
enum _Uninitialized { 
#line 363
_Noinit
#line 364
}; 
#line 366
class _Lockit { 
#line 381
public: __thiscall _Lockit() noexcept; 
#line 382
explicit __thiscall _Lockit(int) noexcept; 
#line 383
__thiscall ~_Lockit() noexcept; 
#line 386 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
static void __cdecl _Lockit_ctor(int) noexcept; 
#line 387
static void __cdecl _Lockit_dtor(int) noexcept; 
#line 390
private: static void __cdecl _Lockit_ctor(_Lockit *) noexcept; 
#line 391
static void __cdecl _Lockit_ctor(_Lockit *, int) noexcept; 
#line 392
static void __cdecl _Lockit_dtor(_Lockit *) noexcept; 
#line 395
public: _Lockit(const _Lockit &) = delete;
#line 396
_Lockit &operator=(const _Lockit &) = delete;
#line 399
private: int _Locktype; 
#line 400
}; 
#line 502 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
}
#line 506
#pragma warning(pop)
#pragma pack ( pop )
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstdlib"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 23
[[nodiscard]] inline double abs(double _Xx) noexcept { 
#line 24
return ::fabs(_Xx); 
#line 25
} 
#line 27
[[nodiscard]] inline float abs(float _Xx) noexcept { 
#line 28
return ::fabsf(_Xx); 
#line 29
} 
#line 31
[[nodiscard]] inline long double abs(long double _Xx) noexcept { 
#line 32
return ::fabsl(_Xx); 
#line 33
} 
#line 36
namespace std { 
#line 37
using ::size_t;
#line 38
using ::div_t;
#line 39
using ::ldiv_t;
#line 40
using ::abort;
#line 41
using ::abs;
#line 42
using ::atexit;
#line 43
using ::atof;
#line 44
using ::atoi;
#line 45
using ::atol;
#line 46
using ::bsearch;
#line 47
using ::calloc;
#line 48
using ::div;
#line 49
using ::exit;
#line 50
using ::free;
#line 51
using ::labs;
#line 52
using ::ldiv;
#line 53
using ::malloc;
#line 54
using ::mblen;
#line 55
using ::mbstowcs;
#line 56
using ::mbtowc;
#line 57
using ::qsort;
#line 58
using ::rand;
#line 59
using ::realloc;
#line 60
using ::srand;
#line 61
using ::strtod;
#line 62
using ::strtol;
#line 63
using ::strtoul;
#line 64
using ::wcstombs;
#line 65
using ::wctomb;
#line 67
using ::lldiv_t;
#line 69
using ::getenv;
#line 70
using ::system;
#line 72
using ::atoll;
#line 73
using ::llabs;
#line 74
using ::lldiv;
#line 75
using ::strtof;
#line 76
using ::strtold;
#line 77
using ::strtoll;
#line 78
using ::strtoull;
#line 80
using ::_Exit;
#line 81
using ::at_quick_exit;
#line 82
using ::quick_exit;
#line 83
}
#line 87
#pragma warning(pop)
#pragma pack ( pop )
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xtr1common"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 24
namespace std { 
#line 25
template < class _Ty, _Ty _Val >
struct integral_constant {
    static constexpr _Ty value = _Val;

    using value_type = _Ty;
    using type = integral_constant;

    constexpr operator value_type ( ) const noexcept {
        return value;
    }

    [ [ nodiscard ] ] constexpr value_type operator ( ) ( ) const noexcept {
        return value;
    }
};
#line 41
template< bool _Val> using bool_constant = integral_constant< bool, _Val> ; 
#line 44
using true_type = bool_constant< true> ; 
#line 45
using false_type = bool_constant< false> ; 
#line 47
template< bool _Test, class _Ty = void> 
#line 48
struct enable_if { }; 
#line 50
template< class _Ty> 
#line 51
struct enable_if< true, _Ty>  { 
#line 52
using type = _Ty; 
#line 53
}; 
#line 55
template< bool _Test, class _Ty = void> using enable_if_t = typename enable_if< _Test, _Ty> ::type; 
#line 58
template< bool _Test, class _Ty1, class _Ty2> 
#line 59
struct conditional { 
#line 60
using type = _Ty1; 
#line 61
}; 
#line 63
template< class _Ty1, class _Ty2> 
#line 64
struct conditional< false, _Ty1, _Ty2>  { 
#line 65
using type = _Ty2; 
#line 66
}; 
#line 68
template< bool _Test, class _Ty1, class _Ty2> using conditional_t = typename conditional< _Test, _Ty1, _Ty2> ::type; 
#line 78
template< class , class > constexpr bool 
#line 79
is_same_v = false; 
#line 80
template< class _Ty> constexpr bool 
#line 81
is_same_v< _Ty, _Ty>  = true; 
#line 83
template< class _Ty1, class _Ty2> 
#line 84
struct is_same : public bool_constant< is_same_v< _Ty1, _Ty2> >  { }; 
#line 87 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xtr1common"
template< class _Ty> 
#line 88
struct remove_const { 
#line 89
using type = _Ty; 
#line 90
}; 
#line 92
template< class _Ty> 
#line 93
struct remove_const< const _Ty>  { 
#line 94
using type = _Ty; 
#line 95
}; 
#line 97
template< class _Ty> using remove_const_t = typename remove_const< _Ty> ::type; 
#line 100
template< class _Ty> 
#line 101
struct remove_volatile { 
#line 102
using type = _Ty; 
#line 103
}; 
#line 105
template< class _Ty> 
#line 106
struct remove_volatile< volatile _Ty>  { 
#line 107
using type = _Ty; 
#line 108
}; 
#line 110
template< class _Ty> using remove_volatile_t = typename remove_volatile< _Ty> ::type; 
#line 113
template< class _Ty> 
#line 114
struct remove_cv { 
#line 115
using type = _Ty; 
#line 117
template< template< class >  class _Fn> using _Apply = _Fn< _Ty> ; 
#line 119
}; 
#line 121
template< class _Ty> 
#line 122
struct remove_cv< const _Ty>  { 
#line 123
using type = _Ty; 
#line 125
template< template< class >  class _Fn> using _Apply = const _Fn< _Ty> ; 
#line 127
}; 
#line 129
template< class _Ty> 
#line 130
struct remove_cv< volatile _Ty>  { 
#line 131
using type = _Ty; 
#line 133
template< template< class >  class _Fn> using _Apply = volatile _Fn< _Ty> ; 
#line 135
}; 
#line 137
template< class _Ty> 
#line 138
struct remove_cv< const volatile _Ty>  { 
#line 139
using type = _Ty; 
#line 141
template< template< class >  class _Fn> using _Apply = const volatile _Fn< _Ty> ; 
#line 143
}; 
#line 145
template< class _Ty> using remove_cv_t = typename remove_cv< _Ty> ::type; 
#line 148
template< bool _First_value, class _First, class ..._Rest> 
#line 149
struct _Disjunction { 
#line 150
using type = _First; 
#line 151
}; 
#line 153
template< class _False, class _Next, class ..._Rest> 
#line 154
struct _Disjunction< false, _False, _Next, _Rest...>  { 
#line 155
using type = typename std::_Disjunction< static_cast< bool>(_Next::value), _Next, _Rest...> ::type; 
#line 156
}; 
#line 158
template< class ..._Traits> 
#line 159
struct disjunction : public false_type { }; 
#line 161
template< class _First, class ..._Rest> 
#line 162
struct disjunction< _First, _Rest...>  : public _Disjunction< static_cast< bool>(_First::value), _First, _Rest...> ::type { 
#line 164
}; 
#line 166
template< class ..._Traits> constexpr bool 
#line 167
disjunction_v = (disjunction< _Traits...> ::value); 
#line 169
template< class _Ty, class ..._Types> constexpr bool 
#line 170
_Is_any_of_v = disjunction_v< is_same< _Ty, _Types> ...> ; 
#line 177 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xtr1common"
[[nodiscard]] constexpr bool _Is_constant_evaluated() noexcept { 
#line 178
return __builtin_is_constant_evaluated(); 
#line 179
} 
#line 187 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xtr1common"
template< class _Ty> constexpr bool 
#line 188
is_integral_v = _Is_any_of_v< remove_cv_t< _Ty> , bool, char, signed char, unsigned char, __wchar_t, char16_t, char32_t, short, unsigned short, int, unsigned, long, unsigned long, __int64, unsigned __int64> ; 
#line 194
template< class _Ty> 
#line 195
struct is_integral : public bool_constant< is_integral_v< _Ty> >  { }; 
#line 197
template< class _Ty> constexpr bool 
#line 198
is_floating_point_v = _Is_any_of_v< remove_cv_t< _Ty> , float, double, long double> ; 
#line 200
template< class _Ty> 
#line 201
struct is_floating_point : public bool_constant< is_floating_point_v< _Ty> >  { }; 
#line 203
template< class _Ty> constexpr bool 
#line 204
is_arithmetic_v = is_integral_v< _Ty>  || is_floating_point_v< _Ty> ; 
#line 207
template< class _Ty> 
#line 208
struct is_arithmetic : public bool_constant< is_arithmetic_v< _Ty> >  { }; 
#line 210
template< class _Ty> 
#line 211
struct remove_reference { 
#line 212
using type = _Ty; 
#line 213
using _Const_thru_ref_type = const _Ty; 
#line 214
}; 
#line 216
template< class _Ty> 
#line 217
struct remove_reference< _Ty &>  { 
#line 218
using type = _Ty; 
#line 219
using _Const_thru_ref_type = const _Ty &; 
#line 220
}; 
#line 222
template< class _Ty> 
#line 223
struct remove_reference< _Ty &&>  { 
#line 224
using type = _Ty; 
#line 225
using _Const_thru_ref_type = const _Ty &&; 
#line 226
}; 
#line 228
template< class _Ty> using remove_reference_t = typename remove_reference< _Ty> ::type; 
#line 231
template< class _Ty> using _Const_thru_ref = typename remove_reference< _Ty> ::_Const_thru_ref_type; 
#line 234
template< class _Ty> using _Remove_cvref_t
#line 235
 [[msvc::known_semantics]] = remove_cv_t< remove_reference_t< _Ty> > ; 
#line 247 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xtr1common"
}
#line 255
#pragma warning(pop)
#pragma pack ( pop )
#line 28 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 36
[[nodiscard]] inline float acos(float _Xx) noexcept { 
#line 37
return ::acosf(_Xx); 
#line 38
} 
#line 40
[[nodiscard]] inline float acosh(float _Xx) noexcept { 
#line 41
return ::acoshf(_Xx); 
#line 42
} 
#line 44
[[nodiscard]] inline float asin(float _Xx) noexcept { 
#line 45
return ::asinf(_Xx); 
#line 46
} 
#line 48
[[nodiscard]] inline float asinh(float _Xx) noexcept { 
#line 49
return ::asinhf(_Xx); 
#line 50
} 
#line 52
[[nodiscard]] inline float atan(float _Xx) noexcept { 
#line 53
return ::atanf(_Xx); 
#line 54
} 
#line 56
[[nodiscard]] inline float atanh(float _Xx) noexcept { 
#line 57
return ::atanhf(_Xx); 
#line 58
} 
#line 60
[[nodiscard]] inline float atan2(float _Yx, float _Xx) noexcept { 
#line 61
return ::atan2f(_Yx, _Xx); 
#line 62
} 
#line 64
[[nodiscard]] inline float cbrt(float _Xx) noexcept { 
#line 65
return ::cbrtf(_Xx); 
#line 66
} 
#line 68
[[nodiscard]] inline float ceil(float _Xx) noexcept { 
#line 74 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
return ::ceilf(_Xx); 
#line 76 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
} 
#line 78
[[nodiscard]] inline float copysign(float _Number, float _Sign) noexcept { 
#line 84 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
return ::copysignf(_Number, _Sign); 
#line 86 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
} 
#line 88
[[nodiscard]] inline float cos(float _Xx) noexcept { 
#line 89
return ::cosf(_Xx); 
#line 90
} 
#line 92
[[nodiscard]] inline float cosh(float _Xx) noexcept { 
#line 93
return ::coshf(_Xx); 
#line 94
} 
#line 96
[[nodiscard]] inline float erf(float _Xx) noexcept { 
#line 97
return ::erff(_Xx); 
#line 98
} 
#line 100
[[nodiscard]] inline float erfc(float _Xx) noexcept { 
#line 101
return ::erfcf(_Xx); 
#line 102
} 
#line 104
[[nodiscard]] inline float exp(float _Xx) noexcept { 
#line 105
return ::expf(_Xx); 
#line 106
} 
#line 108
[[nodiscard]] inline float exp2(float _Xx) noexcept { 
#line 109
return ::exp2f(_Xx); 
#line 110
} 
#line 112
[[nodiscard]] inline float expm1(float _Xx) noexcept { 
#line 113
return ::expm1f(_Xx); 
#line 114
} 
#line 116
[[nodiscard]] inline float fabs(float _Xx) noexcept { 
#line 117
return ::fabsf(_Xx); 
#line 118
} 
#line 120
[[nodiscard]] inline float fdim(float _Xx, float _Yx) noexcept { 
#line 121
return ::fdimf(_Xx, _Yx); 
#line 122
} 
#line 124
[[nodiscard]] inline float floor(float _Xx) noexcept { 
#line 130 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
return ::floorf(_Xx); 
#line 132 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
} 
#line 134
[[nodiscard]] inline float fma(float _Xx, float _Yx, float _Zx) noexcept { 
#line 135
return ::fmaf(_Xx, _Yx, _Zx); 
#line 136
} 
#line 138
[[nodiscard]] inline float fmax(float _Xx, float _Yx) noexcept { 
#line 139
return ::fmaxf(_Xx, _Yx); 
#line 140
} 
#line 142
[[nodiscard]] inline float fmin(float _Xx, float _Yx) noexcept { 
#line 143
return ::fminf(_Xx, _Yx); 
#line 144
} 
#line 146
[[nodiscard]] inline float fmod(float _Xx, float _Yx) noexcept { 
#line 147
return ::fmodf(_Xx, _Yx); 
#line 148
} 
#line 150
inline float frexp(float _Xx, int *_Yx) noexcept { 
#line 151
return ::frexpf(_Xx, _Yx); 
#line 152
} 
#line 154
[[nodiscard]] inline float hypot(float _Xx, float _Yx) noexcept { 
#line 155
return ::hypotf(_Xx, _Yx); 
#line 156
} 
#line 158
[[nodiscard]] inline int ilogb(float _Xx) noexcept { 
#line 159
return ::ilogbf(_Xx); 
#line 160
} 
#line 162
[[nodiscard]] inline float ldexp(float _Xx, int _Yx) noexcept { 
#line 163
return ::ldexpf(_Xx, _Yx); 
#line 164
} 
#line 166
[[nodiscard]] inline float lgamma(float _Xx) noexcept { 
#line 167
return ::lgammaf(_Xx); 
#line 168
} 
#line 170
[[nodiscard]] inline __int64 llrint(float _Xx) noexcept { 
#line 171
return ::llrintf(_Xx); 
#line 172
} 
#line 174
[[nodiscard]] inline __int64 llround(float _Xx) noexcept { 
#line 175
return ::llroundf(_Xx); 
#line 176
} 
#line 178
[[nodiscard]] inline float log(float _Xx) noexcept { 
#line 179
return ::logf(_Xx); 
#line 180
} 
#line 182
[[nodiscard]] inline float log10(float _Xx) noexcept { 
#line 183
return ::log10f(_Xx); 
#line 184
} 
#line 186
[[nodiscard]] inline float log1p(float _Xx) noexcept { 
#line 187
return ::log1pf(_Xx); 
#line 188
} 
#line 190
[[nodiscard]] inline float log2(float _Xx) noexcept { 
#line 191
return ::log2f(_Xx); 
#line 192
} 
#line 194
[[nodiscard]] inline float logb(float _Xx) noexcept { 
#line 195
return ::logbf(_Xx); 
#line 196
} 
#line 198
[[nodiscard]] inline long lrint(float _Xx) noexcept { 
#line 199
return ::lrintf(_Xx); 
#line 200
} 
#line 202
[[nodiscard]] inline long lround(float _Xx) noexcept { 
#line 203
return ::lroundf(_Xx); 
#line 204
} 
#line 206
inline float modf(float _Xx, float *_Yx) noexcept { 
#line 207
return ::modff(_Xx, _Yx); 
#line 208
} 
#line 210
[[nodiscard]] inline float nearbyint(float _Xx) noexcept { 
#line 211
return ::nearbyintf(_Xx); 
#line 212
} 
#line 214
[[nodiscard]] inline float nextafter(float _Xx, float _Yx) noexcept { 
#line 215
return ::nextafterf(_Xx, _Yx); 
#line 216
} 
#line 218
[[nodiscard]] inline float nexttoward(float _Xx, long double _Yx) noexcept { 
#line 219
return ::nexttowardf(_Xx, _Yx); 
#line 220
} 
#line 222
[[nodiscard]] inline float pow(float _Xx, float _Yx) noexcept { 
#line 223
return ::powf(_Xx, _Yx); 
#line 224
} 
#line 226
[[nodiscard]] inline float remainder(float _Xx, float _Yx) noexcept { 
#line 227
return ::remainderf(_Xx, _Yx); 
#line 228
} 
#line 230
inline float remquo(float _Xx, float _Yx, int *_Zx) noexcept { 
#line 231
return ::remquof(_Xx, _Yx, _Zx); 
#line 232
} 
#line 234
[[nodiscard]] inline float rint(float _Xx) noexcept { 
#line 235
return ::rintf(_Xx); 
#line 236
} 
#line 238
[[nodiscard]] inline float round(float _Xx) noexcept { 
#line 244 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
return ::roundf(_Xx); 
#line 246 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
} 
#line 248
[[nodiscard]] inline float scalbln(float _Xx, long _Yx) noexcept { 
#line 249
return ::scalblnf(_Xx, _Yx); 
#line 250
} 
#line 252
[[nodiscard]] inline float scalbn(float _Xx, int _Yx) noexcept { 
#line 253
return ::scalbnf(_Xx, _Yx); 
#line 254
} 
#line 256
[[nodiscard]] inline float sin(float _Xx) noexcept { 
#line 257
return ::sinf(_Xx); 
#line 258
} 
#line 260
[[nodiscard]] inline float sinh(float _Xx) noexcept { 
#line 261
return ::sinhf(_Xx); 
#line 262
} 
#line 264
[[nodiscard]] inline float sqrt(float _Xx) noexcept { 
#line 265
return ::sqrtf(_Xx); 
#line 266
} 
#line 268
[[nodiscard]] inline float tan(float _Xx) noexcept { 
#line 269
return ::tanf(_Xx); 
#line 270
} 
#line 272
[[nodiscard]] inline float tanh(float _Xx) noexcept { 
#line 273
return ::tanhf(_Xx); 
#line 274
} 
#line 276
[[nodiscard]] inline float tgamma(float _Xx) noexcept { 
#line 277
return ::tgammaf(_Xx); 
#line 278
} 
#line 280
[[nodiscard]] inline float trunc(float _Xx) noexcept { 
#line 286 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
return ::truncf(_Xx); 
#line 288 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
} 
#line 290
[[nodiscard]] inline long double acos(long double _Xx) noexcept { 
#line 291
return ::acosl(_Xx); 
#line 292
} 
#line 294
[[nodiscard]] inline long double acosh(long double _Xx) noexcept { 
#line 295
return ::acoshl(_Xx); 
#line 296
} 
#line 298
[[nodiscard]] inline long double asin(long double _Xx) noexcept { 
#line 299
return ::asinl(_Xx); 
#line 300
} 
#line 302
[[nodiscard]] inline long double asinh(long double _Xx) noexcept { 
#line 303
return ::asinhl(_Xx); 
#line 304
} 
#line 306
[[nodiscard]] inline long double atan(long double _Xx) noexcept { 
#line 307
return ::atanl(_Xx); 
#line 308
} 
#line 310
[[nodiscard]] inline long double atanh(long double _Xx) noexcept { 
#line 311
return ::atanhl(_Xx); 
#line 312
} 
#line 314
[[nodiscard]] inline long double atan2(long double _Yx, long double _Xx) noexcept 
#line 315
{ 
#line 316
return ::atan2l(_Yx, _Xx); 
#line 317
} 
#line 319
[[nodiscard]] inline long double cbrt(long double _Xx) noexcept { 
#line 320
return ::cbrtl(_Xx); 
#line 321
} 
#line 323
[[nodiscard]] inline long double ceil(long double _Xx) noexcept { 
#line 329 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
return ::ceill(_Xx); 
#line 331 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
} 
#line 333
[[nodiscard]] inline long double copysign(long double _Number, long double _Sign) noexcept 
#line 334
{ 
#line 340 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
return ::copysignl(_Number, _Sign); 
#line 342 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
} 
#line 344
[[nodiscard]] inline long double cos(long double _Xx) noexcept { 
#line 345
return ::cosl(_Xx); 
#line 346
} 
#line 348
[[nodiscard]] inline long double cosh(long double _Xx) noexcept { 
#line 349
return ::coshl(_Xx); 
#line 350
} 
#line 352
[[nodiscard]] inline long double erf(long double _Xx) noexcept { 
#line 353
return ::erfl(_Xx); 
#line 354
} 
#line 356
[[nodiscard]] inline long double erfc(long double _Xx) noexcept { 
#line 357
return ::erfcl(_Xx); 
#line 358
} 
#line 360
[[nodiscard]] inline long double exp(long double _Xx) noexcept { 
#line 361
return ::expl(_Xx); 
#line 362
} 
#line 364
[[nodiscard]] inline long double exp2(long double _Xx) noexcept { 
#line 365
return ::exp2l(_Xx); 
#line 366
} 
#line 368
[[nodiscard]] inline long double expm1(long double _Xx) noexcept { 
#line 369
return ::expm1l(_Xx); 
#line 370
} 
#line 372
[[nodiscard]] inline long double fabs(long double _Xx) noexcept { 
#line 373
return ::fabsl(_Xx); 
#line 374
} 
#line 376
[[nodiscard]] inline long double fdim(long double _Xx, long double _Yx) noexcept 
#line 377
{ 
#line 378
return ::fdiml(_Xx, _Yx); 
#line 379
} 
#line 381
[[nodiscard]] inline long double floor(long double _Xx) noexcept { 
#line 387 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
return ::floorl(_Xx); 
#line 389 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
} 
#line 391
[[nodiscard]] inline long double fma(long double 
#line 392
_Xx, long double _Yx, long double _Zx) noexcept { 
#line 393
return ::fmal(_Xx, _Yx, _Zx); 
#line 394
} 
#line 396
[[nodiscard]] inline long double fmax(long double _Xx, long double _Yx) noexcept 
#line 397
{ 
#line 398
return ::fmaxl(_Xx, _Yx); 
#line 399
} 
#line 401
[[nodiscard]] inline long double fmin(long double _Xx, long double _Yx) noexcept 
#line 402
{ 
#line 403
return ::fminl(_Xx, _Yx); 
#line 404
} 
#line 406
[[nodiscard]] inline long double fmod(long double _Xx, long double _Yx) noexcept 
#line 407
{ 
#line 408
return ::fmodl(_Xx, _Yx); 
#line 409
} 
#line 411
inline long double frexp(long double _Xx, int *_Yx) noexcept { 
#line 412
return ::frexpl(_Xx, _Yx); 
#line 413
} 
#line 415
[[nodiscard]] inline long double hypot(long double _Xx, long double _Yx) noexcept 
#line 416
{ 
#line 417
return ::hypotl(_Xx, _Yx); 
#line 418
} 
#line 420
[[nodiscard]] inline int ilogb(long double _Xx) noexcept { 
#line 421
return ::ilogbl(_Xx); 
#line 422
} 
#line 424
[[nodiscard]] inline long double ldexp(long double _Xx, int _Yx) noexcept { 
#line 425
return ::ldexpl(_Xx, _Yx); 
#line 426
} 
#line 428
[[nodiscard]] inline long double lgamma(long double _Xx) noexcept { 
#line 429
return ::lgammal(_Xx); 
#line 430
} 
#line 432
[[nodiscard]] inline __int64 llrint(long double _Xx) noexcept { 
#line 433
return ::llrintl(_Xx); 
#line 434
} 
#line 436
[[nodiscard]] inline __int64 llround(long double _Xx) noexcept { 
#line 437
return ::llroundl(_Xx); 
#line 438
} 
#line 440
[[nodiscard]] inline long double log(long double _Xx) noexcept { 
#line 441
return ::logl(_Xx); 
#line 442
} 
#line 444
[[nodiscard]] inline long double log10(long double _Xx) noexcept { 
#line 445
return ::log10l(_Xx); 
#line 446
} 
#line 448
[[nodiscard]] inline long double log1p(long double _Xx) noexcept { 
#line 449
return ::log1pl(_Xx); 
#line 450
} 
#line 452
[[nodiscard]] inline long double log2(long double _Xx) noexcept { 
#line 453
return ::log2l(_Xx); 
#line 454
} 
#line 456
[[nodiscard]] inline long double logb(long double _Xx) noexcept { 
#line 457
return ::logbl(_Xx); 
#line 458
} 
#line 460
[[nodiscard]] inline long lrint(long double _Xx) noexcept { 
#line 461
return ::lrintl(_Xx); 
#line 462
} 
#line 464
[[nodiscard]] inline long lround(long double _Xx) noexcept { 
#line 465
return ::lroundl(_Xx); 
#line 466
} 
#line 468
inline long double modf(long double _Xx, long double *_Yx) noexcept { 
#line 469
return ::modfl(_Xx, _Yx); 
#line 470
} 
#line 472
[[nodiscard]] inline long double nearbyint(long double _Xx) noexcept { 
#line 473
return ::nearbyintl(_Xx); 
#line 474
} 
#line 476
[[nodiscard]] inline long double nextafter(long double _Xx, long double _Yx) noexcept 
#line 477
{ 
#line 478
return ::nextafterl(_Xx, _Yx); 
#line 479
} 
#line 481
[[nodiscard]] inline long double nexttoward(long double _Xx, long double _Yx) noexcept 
#line 482
{ 
#line 483
return ::nexttowardl(_Xx, _Yx); 
#line 484
} 
#line 486
[[nodiscard]] inline long double pow(long double _Xx, long double _Yx) noexcept 
#line 487
{ 
#line 488
return ::powl(_Xx, _Yx); 
#line 489
} 
#line 491
[[nodiscard]] inline long double remainder(long double _Xx, long double _Yx) noexcept 
#line 492
{ 
#line 493
return ::remainderl(_Xx, _Yx); 
#line 494
} 
#line 496
inline long double remquo(long double _Xx, long double _Yx, int *_Zx) noexcept { 
#line 497
return ::remquol(_Xx, _Yx, _Zx); 
#line 498
} 
#line 500
[[nodiscard]] inline long double rint(long double _Xx) noexcept { 
#line 501
return ::rintl(_Xx); 
#line 502
} 
#line 504
[[nodiscard]] inline long double round(long double _Xx) noexcept { 
#line 510 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
return ::roundl(_Xx); 
#line 512 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
} 
#line 514
[[nodiscard]] inline long double scalbln(long double _Xx, long _Yx) noexcept { 
#line 515
return ::scalblnl(_Xx, _Yx); 
#line 516
} 
#line 518
[[nodiscard]] inline long double scalbn(long double _Xx, int _Yx) noexcept { 
#line 519
return ::scalbnl(_Xx, _Yx); 
#line 520
} 
#line 522
[[nodiscard]] inline long double sin(long double _Xx) noexcept { 
#line 523
return ::sinl(_Xx); 
#line 524
} 
#line 526
[[nodiscard]] inline long double sinh(long double _Xx) noexcept { 
#line 527
return ::sinhl(_Xx); 
#line 528
} 
#line 530
[[nodiscard]] inline long double sqrt(long double _Xx) noexcept { 
#line 531
return ::sqrtl(_Xx); 
#line 532
} 
#line 534
[[nodiscard]] inline long double tan(long double _Xx) noexcept { 
#line 535
return ::tanl(_Xx); 
#line 536
} 
#line 538
[[nodiscard]] inline long double tanh(long double _Xx) noexcept { 
#line 539
return ::tanhl(_Xx); 
#line 540
} 
#line 542
[[nodiscard]] inline long double tgamma(long double _Xx) noexcept { 
#line 543
return ::tgammal(_Xx); 
#line 544
} 
#line 546
[[nodiscard]] inline long double trunc(long double _Xx) noexcept { 
#line 552 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
return ::truncl(_Xx); 
#line 554 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
} 
#line 557
namespace std { 
#line 558
template< class _Ty1, class _Ty2> using _Common_float_type_t = conditional_t< is_same_v< _Ty1, long double>  || is_same_v< _Ty2, long double> , long double, conditional_t< is_same_v< _Ty1, float>  && is_same_v< _Ty2, float> , float, double> > ; 
#line 562
}
#line 565
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 >
double frexp ( _Ty _Value, int * const _Exp ) noexcept {
    return :: frexp ( static_cast < double > ( _Value ), _Exp );
}
#line 570
template < class _Ty1, class _Ty2, class _Ty3,
    :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 > && :: std :: is_arithmetic_v < _Ty3 >, int > = 0 >
[ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, :: std :: _Common_float_type_t < _Ty2, _Ty3 > > fma (
    _Ty1 _Left, _Ty2 _Middle, _Ty3 _Right ) noexcept {
    using _Common = :: std :: _Common_float_type_t < _Ty1, :: std :: _Common_float_type_t < _Ty2, _Ty3 >>;
    if constexpr ( :: std :: is_same_v < _Common, float > ) {
        return :: fmaf ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Middle ), static_cast < _Common > ( _Right ) );
    } else if constexpr ( :: std :: is_same_v < _Common, double > ) {
        return :: fma ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Middle ), static_cast < _Common > ( _Right ) );
    } else {
        return :: fmal ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Middle ), static_cast < _Common > ( _Right ) );
    }
}
#line 584
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 >
:: std :: _Common_float_type_t < _Ty1, _Ty2 > remquo ( _Ty1 _Left, _Ty2 _Right, int * _Pquo ) noexcept {
    using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >;
    if constexpr ( :: std :: is_same_v < _Common, float > ) {
        return :: remquof ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ), _Pquo );
    } else if constexpr ( :: std :: is_same_v < _Common, double > ) {
        return :: remquo ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ), _Pquo );
    } else {
        return :: remquol ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ), _Pquo );
    }
}
#line 707
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 >
[ [ nodiscard ] ] inline int fpclassify ( const _Ty _Ix ) noexcept {
    return _Ix == 0 ? 0 : ( - 1 );
}
#line 713
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 >
[ [ nodiscard ] ] inline bool signbit ( const _Ty _Ix ) noexcept {
    if constexpr ( static_cast < _Ty > ( - 1 ) < _Ty { } ) {
        return _Ix < 0;
    } else {
        return false;
    }
}
#line 728
[[nodiscard]] inline bool isnormal(const signed char _Ix) noexcept { return _Ix != 0; } 
#line 729
[[nodiscard]] inline bool isnormal(const unsigned char _Ix) noexcept { return _Ix != 0; } 
#line 730
[[nodiscard]] inline bool isnormal(const short _Ix) noexcept { return _Ix != 0; } 
#line 731
[[nodiscard]] inline bool isnormal(const unsigned short _Ix) noexcept { return _Ix != 0; } 
#line 732
[[nodiscard]] inline bool isnormal(const int _Ix) noexcept { return _Ix != 0; } 
#line 733
[[nodiscard]] inline bool isnormal(const unsigned _Ix) noexcept { return _Ix != (0); } 
#line 734
[[nodiscard]] inline bool isnormal(const long _Ix) noexcept { return _Ix != (0); } 
#line 735
[[nodiscard]] inline bool isnormal(const unsigned long _Ix) noexcept { return _Ix != (0); } 
#line 736
[[nodiscard]] inline bool isnormal(const __int64 _Ix) noexcept { return _Ix != (0); } 
#line 737
[[nodiscard]] inline bool isnormal(const unsigned __int64 _Ix) noexcept { return _Ix != (0); } 
#line 738
[[nodiscard]] inline bool isnormal(const bool _Ix) noexcept { return _Ix != 0; } 
#line 739
[[nodiscard]] inline bool isnormal(const char _Ix) noexcept { return _Ix != 0; } 
#line 743
[[nodiscard]] inline bool isnormal(const char16_t _Ix) noexcept { return _Ix != 0; } 
#line 744
[[nodiscard]] inline bool isnormal(const char32_t _Ix) noexcept { return _Ix != (0); } 
#line 746
[[nodiscard]] inline bool isnormal(const __wchar_t _Ix) noexcept { return _Ix != 0; } 
#line 833 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double acos ( _Ty _Left ) noexcept { return :: acos ( static_cast < double > ( _Left ) ); }
#line 834
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double asin ( _Ty _Left ) noexcept { return :: asin ( static_cast < double > ( _Left ) ); }
#line 835
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double atan ( _Ty _Left ) noexcept { return :: atan ( static_cast < double > ( _Left ) ); }
#line 836
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 > [ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, _Ty2 > atan2 ( _Ty1 _Left, _Ty2 _Right ) noexcept { return :: atan2 ( static_cast < double > ( _Left ), static_cast < double > ( _Right ) ); }
#line 837
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double cos ( _Ty _Left ) noexcept { return :: cos ( static_cast < double > ( _Left ) ); }
#line 838
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double sin ( _Ty _Left ) noexcept { return :: sin ( static_cast < double > ( _Left ) ); }
#line 839
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double tan ( _Ty _Left ) noexcept { return :: tan ( static_cast < double > ( _Left ) ); }
#line 840
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double acosh ( _Ty _Left ) noexcept { return :: acosh ( static_cast < double > ( _Left ) ); }
#line 841
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double asinh ( _Ty _Left ) noexcept { return :: asinh ( static_cast < double > ( _Left ) ); }
#line 842
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double atanh ( _Ty _Left ) noexcept { return :: atanh ( static_cast < double > ( _Left ) ); }
#line 843
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double cosh ( _Ty _Left ) noexcept { return :: cosh ( static_cast < double > ( _Left ) ); }
#line 844
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double sinh ( _Ty _Left ) noexcept { return :: sinh ( static_cast < double > ( _Left ) ); }
#line 845
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double tanh ( _Ty _Left ) noexcept { return :: tanh ( static_cast < double > ( _Left ) ); }
#line 846
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double exp ( _Ty _Left ) noexcept { return :: exp ( static_cast < double > ( _Left ) ); }
#line 847
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double exp2 ( _Ty _Left ) noexcept { return :: exp2 ( static_cast < double > ( _Left ) ); }
#line 848
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double expm1 ( _Ty _Left ) noexcept { return :: expm1 ( static_cast < double > ( _Left ) ); }
#line 850
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] int ilogb ( _Ty _Left ) noexcept { return :: ilogb ( static_cast < double > ( _Left ) ); }
#line 851
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double ldexp ( _Ty _Left, int _Arg2 ) noexcept { return :: ldexp ( static_cast < double > ( _Left ), _Arg2 ); }
#line 852
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double log ( _Ty _Left ) noexcept { return :: log ( static_cast < double > ( _Left ) ); }
#line 853
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double log10 ( _Ty _Left ) noexcept { return :: log10 ( static_cast < double > ( _Left ) ); }
#line 854
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double log1p ( _Ty _Left ) noexcept { return :: log1p ( static_cast < double > ( _Left ) ); }
#line 855
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double log2 ( _Ty _Left ) noexcept { return :: log2 ( static_cast < double > ( _Left ) ); }
#line 856
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double logb ( _Ty _Left ) noexcept { return :: logb ( static_cast < double > ( _Left ) ); }
#line 858
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double scalbn ( _Ty _Left, int _Arg2 ) noexcept { return :: scalbn ( static_cast < double > ( _Left ), _Arg2 ); }
#line 859
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double scalbln ( _Ty _Left, long _Arg2 ) noexcept { return :: scalbln ( static_cast < double > ( _Left ), _Arg2 ); }
#line 860
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double cbrt ( _Ty _Left ) noexcept { return :: cbrt ( static_cast < double > ( _Left ) ); }
#line 862
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double fabs ( _Ty _Left ) noexcept { return :: fabs ( static_cast < double > ( _Left ) ); }
#line 863
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 > [ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, _Ty2 > hypot ( _Ty1 _Left, _Ty2 _Right ) noexcept { return :: hypot ( static_cast < double > ( _Left ), static_cast < double > ( _Right ) ); }
#line 865
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 > [ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, _Ty2 > pow ( _Ty1 _Left, _Ty2 _Right ) noexcept { return :: pow ( static_cast < double > ( _Left ), static_cast < double > ( _Right ) ); }
#line 866
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double sqrt ( _Ty _Left ) noexcept { return :: sqrt ( static_cast < double > ( _Left ) ); }
#line 867
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double erf ( _Ty _Left ) noexcept { return :: erf ( static_cast < double > ( _Left ) ); }
#line 868
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double erfc ( _Ty _Left ) noexcept { return :: erfc ( static_cast < double > ( _Left ) ); }
#line 869
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double lgamma ( _Ty _Left ) noexcept { return :: lgamma ( static_cast < double > ( _Left ) ); }
#line 870
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double tgamma ( _Ty _Left ) noexcept { return :: tgamma ( static_cast < double > ( _Left ) ); }
#line 871
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double ceil ( _Ty _Left ) noexcept { return :: ceil ( static_cast < double > ( _Left ) ); }
#line 872
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double floor ( _Ty _Left ) noexcept { return :: floor ( static_cast < double > ( _Left ) ); }
#line 873
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double nearbyint ( _Ty _Left ) noexcept { return :: nearbyint ( static_cast < double > ( _Left ) ); }
#line 874
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double rint ( _Ty _Left ) noexcept { return :: rint ( static_cast < double > ( _Left ) ); }
#line 875
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] long lrint ( _Ty _Left ) noexcept { return :: lrint ( static_cast < double > ( _Left ) ); }
#line 876
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] long long llrint ( _Ty _Left ) noexcept { return :: llrint ( static_cast < double > ( _Left ) ); }
#line 877
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double round ( _Ty _Left ) noexcept { return :: round ( static_cast < double > ( _Left ) ); }
#line 878
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] long lround ( _Ty _Left ) noexcept { return :: lround ( static_cast < double > ( _Left ) ); }
#line 879
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] long long llround ( _Ty _Left ) noexcept { return :: llround ( static_cast < double > ( _Left ) ); }
#line 880
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double trunc ( _Ty _Left ) noexcept { return :: trunc ( static_cast < double > ( _Left ) ); }
#line 881
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 > [ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, _Ty2 > fmod ( _Ty1 _Left, _Ty2 _Right ) noexcept { return :: fmod ( static_cast < double > ( _Left ), static_cast < double > ( _Right ) ); }
#line 882
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 > [ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, _Ty2 > remainder ( _Ty1 _Left, _Ty2 _Right ) noexcept { return :: remainder ( static_cast < double > ( _Left ), static_cast < double > ( _Right ) ); }
#line 884
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 > [ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, _Ty2 > copysign ( _Ty1 _Left, _Ty2 _Right ) noexcept { return :: copysign ( static_cast < double > ( _Left ), static_cast < double > ( _Right ) ); }
#line 886
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 > [ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, _Ty2 > nextafter ( _Ty1 _Left, _Ty2 _Right ) noexcept { return :: nextafter ( static_cast < double > ( _Left ), static_cast < double > ( _Right ) ); }
#line 887
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double nexttoward ( _Ty _Left, long double _Arg2 ) noexcept { return :: nexttoward ( static_cast < double > ( _Left ), _Arg2 ); }
#line 888
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 > [ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, _Ty2 > fdim ( _Ty1 _Left, _Ty2 _Right ) noexcept { return :: fdim ( static_cast < double > ( _Left ), static_cast < double > ( _Right ) ); }
#line 889
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 > [ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, _Ty2 > fmax ( _Ty1 _Left, _Ty2 _Right ) noexcept { return :: fmax ( static_cast < double > ( _Left ), static_cast < double > ( _Right ) ); }
#line 890
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 > [ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, _Ty2 > fmin ( _Ty1 _Left, _Ty2 _Right ) noexcept { return :: fmin ( static_cast < double > ( _Left ), static_cast < double > ( _Right ) ); }
#line 894
[[nodiscard]] inline bool isfinite(signed char) noexcept { return true; } [[nodiscard]] inline bool isfinite(unsigned char) noexcept { return true; } [[nodiscard]] inline bool isfinite(short) noexcept { return true; } [[nodiscard]] inline bool isfinite(unsigned short) noexcept { return true; } [[nodiscard]] inline bool isfinite(int) noexcept { return true; } [[nodiscard]] inline bool isfinite(unsigned) noexcept { return true; } [[nodiscard]] inline bool isfinite(long) noexcept { return true; } [[nodiscard]] inline bool isfinite(unsigned long) noexcept { return true; } [[nodiscard]] inline bool isfinite(__int64) noexcept { return true; } [[nodiscard]] inline bool isfinite(unsigned __int64) noexcept { return true; } [[nodiscard]] inline bool isfinite(bool) noexcept { return true; } [[nodiscard]] inline bool isfinite(char) noexcept { return true; } [[nodiscard]] inline bool isfinite(char16_t) noexcept { return true; } [[nodiscard]] inline bool isfinite(char32_t) noexcept { return true; } [[nodiscard]] inline bool isfinite(__wchar_t) noexcept { return true; } 
#line 895
[[nodiscard]] inline bool isinf(signed char) noexcept { return false; } [[nodiscard]] inline bool isinf(unsigned char) noexcept { return false; } [[nodiscard]] inline bool isinf(short) noexcept { return false; } [[nodiscard]] inline bool isinf(unsigned short) noexcept { return false; } [[nodiscard]] inline bool isinf(int) noexcept { return false; } [[nodiscard]] inline bool isinf(unsigned) noexcept { return false; } [[nodiscard]] inline bool isinf(long) noexcept { return false; } [[nodiscard]] inline bool isinf(unsigned long) noexcept { return false; } [[nodiscard]] inline bool isinf(__int64) noexcept { return false; } [[nodiscard]] inline bool isinf(unsigned __int64) noexcept { return false; } [[nodiscard]] inline bool isinf(bool) noexcept { return false; } [[nodiscard]] inline bool isinf(char) noexcept { return false; } [[nodiscard]] inline bool isinf(char16_t) noexcept { return false; } [[nodiscard]] inline bool isinf(char32_t) noexcept { return false; } [[nodiscard]] inline bool isinf(__wchar_t) noexcept { return false; } 
#line 896
[[nodiscard]] inline bool isnan(signed char) noexcept { return false; } [[nodiscard]] inline bool isnan(unsigned char) noexcept { return false; } [[nodiscard]] inline bool isnan(short) noexcept { return false; } [[nodiscard]] inline bool isnan(unsigned short) noexcept { return false; } [[nodiscard]] inline bool isnan(int) noexcept { return false; } [[nodiscard]] inline bool isnan(unsigned) noexcept { return false; } [[nodiscard]] inline bool isnan(long) noexcept { return false; } [[nodiscard]] inline bool isnan(unsigned long) noexcept { return false; } [[nodiscard]] inline bool isnan(__int64) noexcept { return false; } [[nodiscard]] inline bool isnan(unsigned __int64) noexcept { return false; } [[nodiscard]] inline bool isnan(bool) noexcept { return false; } [[nodiscard]] inline bool isnan(char) noexcept { return false; } [[nodiscard]] inline bool isnan(char16_t) noexcept { return false; } [[nodiscard]] inline bool isnan(char32_t) noexcept { return false; } [[nodiscard]] inline bool isnan(__wchar_t) noexcept { return false; } 
#line 915
namespace std { 
#line 916
using ::abs;
#line 917
using ::acos;
#line 918
using ::asin;
#line 919
using ::atan;
#line 920
using ::atan2;
#line 921
using ::ceil;
#line 922
using ::cos;
#line 923
using ::cosh;
#line 924
using ::exp;
#line 925
using ::fabs;
#line 926
using ::floor;
#line 927
using ::fmod;
#line 928
using ::frexp;
#line 929
using ::ldexp;
#line 930
using ::log;
#line 931
using ::log10;
#line 932
using ::modf;
#line 933
using ::pow;
#line 934
using ::sin;
#line 935
using ::sinh;
#line 936
using ::sqrt;
#line 937
using ::tan;
#line 938
using ::tanh;
#line 940
using ::acosf;
#line 941
using ::asinf;
#line 942
using ::atanf;
#line 943
using ::atan2f;
#line 944
using ::ceilf;
#line 945
using ::cosf;
#line 946
using ::coshf;
#line 947
using ::expf;
#line 948
using ::fabsf;
#line 949
using ::floorf;
#line 950
using ::fmodf;
#line 951
using ::frexpf;
#line 952
using ::ldexpf;
#line 953
using ::logf;
#line 954
using ::log10f;
#line 955
using ::modff;
#line 956
using ::powf;
#line 957
using ::sinf;
#line 958
using ::sinhf;
#line 959
using ::sqrtf;
#line 960
using ::tanf;
#line 961
using ::tanhf;
#line 963
using ::acosl;
#line 964
using ::asinl;
#line 965
using ::atanl;
#line 966
using ::atan2l;
#line 967
using ::ceill;
#line 968
using ::cosl;
#line 969
using ::coshl;
#line 970
using ::expl;
#line 971
using ::fabsl;
#line 972
using ::floorl;
#line 973
using ::fmodl;
#line 974
using ::frexpl;
#line 975
using ::ldexpl;
#line 976
using ::logl;
#line 977
using ::log10l;
#line 978
using ::modfl;
#line 979
using ::powl;
#line 980
using ::sinl;
#line 981
using ::sinhl;
#line 982
using ::sqrtl;
#line 983
using ::tanl;
#line 984
using ::tanhl;
#line 986
using ::float_t;
#line 987
using ::double_t;
#line 989
using ::acosh;
#line 990
using ::asinh;
#line 991
using ::atanh;
#line 992
using ::cbrt;
#line 993
using ::erf;
#line 994
using ::erfc;
#line 995
using ::expm1;
#line 996
using ::exp2;
#line 998
inline namespace _Binary_hypot { 
#line 999
using ::hypot;
#line 1000
}
#line 1002
using ::ilogb;
#line 1003
using ::lgamma;
#line 1004
using ::log1p;
#line 1005
using ::log2;
#line 1006
using ::logb;
#line 1007
using ::llrint;
#line 1008
using ::lrint;
#line 1009
using ::nearbyint;
#line 1010
using ::rint;
#line 1011
using ::llround;
#line 1012
using ::lround;
#line 1013
using ::fdim;
#line 1014
using ::fma;
#line 1015
using ::fmax;
#line 1016
using ::fmin;
#line 1017
using ::round;
#line 1018
using ::trunc;
#line 1019
using ::remainder;
#line 1020
using ::remquo;
#line 1021
using ::copysign;
#line 1022
using ::nan;
#line 1023
using ::nextafter;
#line 1024
using ::scalbn;
#line 1025
using ::scalbln;
#line 1026
using ::nexttoward;
#line 1027
using ::tgamma;
#line 1029
using ::acoshf;
#line 1030
using ::asinhf;
#line 1031
using ::atanhf;
#line 1032
using ::cbrtf;
#line 1033
using ::erff;
#line 1034
using ::erfcf;
#line 1035
using ::expm1f;
#line 1036
using ::exp2f;
#line 1037
using ::hypotf;
#line 1038
using ::ilogbf;
#line 1039
using ::lgammaf;
#line 1040
using ::log1pf;
#line 1041
using ::log2f;
#line 1042
using ::logbf;
#line 1043
using ::llrintf;
#line 1044
using ::lrintf;
#line 1045
using ::nearbyintf;
#line 1046
using ::rintf;
#line 1047
using ::llroundf;
#line 1048
using ::lroundf;
#line 1049
using ::fdimf;
#line 1050
using ::fmaf;
#line 1051
using ::fmaxf;
#line 1052
using ::fminf;
#line 1053
using ::roundf;
#line 1054
using ::truncf;
#line 1055
using ::remainderf;
#line 1056
using ::remquof;
#line 1057
using ::copysignf;
#line 1058
using ::nanf;
#line 1059
using ::nextafterf;
#line 1060
using ::scalbnf;
#line 1061
using ::scalblnf;
#line 1062
using ::nexttowardf;
#line 1063
using ::tgammaf;
#line 1065
using ::acoshl;
#line 1066
using ::asinhl;
#line 1067
using ::atanhl;
#line 1068
using ::cbrtl;
#line 1069
using ::erfl;
#line 1070
using ::erfcl;
#line 1071
using ::expm1l;
#line 1072
using ::exp2l;
#line 1073
using ::hypotl;
#line 1074
using ::ilogbl;
#line 1075
using ::lgammal;
#line 1076
using ::log1pl;
#line 1077
using ::log2l;
#line 1078
using ::logbl;
#line 1079
using ::llrintl;
#line 1080
using ::lrintl;
#line 1081
using ::nearbyintl;
#line 1082
using ::rintl;
#line 1083
using ::llroundl;
#line 1084
using ::lroundl;
#line 1085
using ::fdiml;
#line 1086
using ::fmal;
#line 1087
using ::fmaxl;
#line 1088
using ::fminl;
#line 1089
using ::roundl;
#line 1090
using ::truncl;
#line 1091
using ::remainderl;
#line 1092
using ::remquol;
#line 1093
using ::copysignl;
#line 1094
using ::nanl;
#line 1095
using ::nextafterl;
#line 1096
using ::scalbnl;
#line 1097
using ::scalblnl;
#line 1098
using ::nexttowardl;
#line 1099
using ::tgammal;
#line 1101
using ::fpclassify;
#line 1102
using ::signbit;
#line 1103
using ::isfinite;
#line 1104
using ::isinf;
#line 1105
using ::isnan;
#line 1106
using ::isnormal;
#line 1107
using ::isgreater;
#line 1108
using ::isgreaterequal;
#line 1109
using ::isless;
#line 1110
using ::islessequal;
#line 1111
using ::islessgreater;
#line 1112
using ::isunordered;
#line 1113
}
#line 1696 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
#pragma warning(pop)
#pragma pack ( pop )
#line 4866 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern "C" double __cdecl _hypot(double x, double y); 
#line 4867
extern "C" float __cdecl _hypotf(float x, float y); 
#line 4877 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern inline bool signbit(long double) throw(); 
#line 4878
extern "C" int _ldsign(long double); 
#line 4921 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern inline bool signbit(double) throw(); 
#line 4922
extern "C" int _dsign(double); 
#line 4966 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern inline bool signbit(float) throw(); 
#line 4967
extern "C" int _fdsign(float); 
#line 4975 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
static __inline bool isinf(long double a); 
#line 5010 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
static __inline bool isinf(double a); 
#line 5048 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
static __inline bool isinf(float a); 
#line 5055 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
static __inline bool isnan(long double a); 
#line 5088 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
static __inline bool isnan(double a); 
#line 5124 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
static __inline bool isnan(float a); 
#line 5131 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
static __inline bool isfinite(long double a); 
#line 5168 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
static __inline bool isfinite(double a); 
#line 5204 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
static __inline bool isfinite(float a); 
#line 5222 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
template< class T> extern T _Pow_int(T, int) throw(); 
#line 5223
extern inline __int64 abs(__int64) throw(); 
#line 5314 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern inline long __cdecl abs(long) throw(); 
#line 5318 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern inline float __cdecl abs(float) throw(); 
#line 5319
extern inline double __cdecl abs(double) throw(); 
#line 5320
extern inline float __cdecl fabs(float) throw(); 
#line 5321
extern inline float __cdecl ceil(float) throw(); 
#line 5322
extern inline float __cdecl floor(float) throw(); 
#line 5323
extern inline float __cdecl sqrt(float) throw(); 
#line 5324
extern inline float __cdecl pow(float, float) throw(); 
#line 5363 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
template< class _Ty1, class _Ty2, std::enable_if_t< std::is_arithmetic_v< _Ty1>  && std::is_arithmetic_v< _Ty2> , int>  > [[nodiscard]] std::_Common_float_type_t< _Ty1, _Ty2>  __cdecl pow(_Ty1 _Left, _Ty2 _Right) noexcept; 
#line 5370 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern inline float __cdecl log(float) throw(); 
#line 5371
extern inline float __cdecl log10(float) throw(); 
#line 5372
extern inline float __cdecl fmod(float, float) throw(); 
#line 5373
extern inline float __cdecl modf(float, float *) throw(); 
#line 5374
extern inline float __cdecl exp(float) throw(); 
#line 5375
extern inline float __cdecl frexp(float, int *) throw(); 
#line 5376
extern inline float __cdecl ldexp(float, int) throw(); 
#line 5377
extern inline float __cdecl asin(float) throw(); 
#line 5378
extern inline float __cdecl sin(float) throw(); 
#line 5379
extern inline float __cdecl sinh(float) throw(); 
#line 5380
extern inline float __cdecl acos(float) throw(); 
#line 5381
extern inline float __cdecl cos(float) throw(); 
#line 5382
extern inline float __cdecl cosh(float) throw(); 
#line 5383
extern inline float __cdecl atan(float) throw(); 
#line 5384
extern inline float __cdecl atan2(float, float) throw(); 
#line 5385
extern inline float __cdecl tan(float) throw(); 
#line 5386
extern inline float __cdecl tanh(float) throw(); 
#line 5609 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
extern inline float __cdecl logb(float) throw(); 
#line 5610
extern inline int __cdecl ilogb(float) throw(); 
#line 5611
extern float __cdecl scalbn(float, float) throw(); 
#line 5612
extern inline float __cdecl scalbln(float, long) throw(); 
#line 5613
extern inline float __cdecl exp2(float) throw(); 
#line 5614
extern inline float __cdecl expm1(float) throw(); 
#line 5615
extern inline float __cdecl log2(float) throw(); 
#line 5616
extern inline float __cdecl log1p(float) throw(); 
#line 5617
extern inline float __cdecl acosh(float) throw(); 
#line 5618
extern inline float __cdecl asinh(float) throw(); 
#line 5619
extern inline float __cdecl atanh(float) throw(); 
#line 5620
extern inline float __cdecl hypot(float, float) throw(); 
#line 5621
extern inline float __cdecl cbrt(float) throw(); 
#line 5622
extern inline float __cdecl erf(float) throw(); 
#line 5623
extern inline float __cdecl erfc(float) throw(); 
#line 5624
extern inline float __cdecl lgamma(float) throw(); 
#line 5625
extern inline float __cdecl tgamma(float) throw(); 
#line 5626
extern inline float __cdecl copysign(float, float) throw(); 
#line 5627
extern inline float __cdecl nextafter(float, float) throw(); 
#line 5628
extern inline float __cdecl remainder(float, float) throw(); 
#line 5629
extern inline float __cdecl remquo(float, float, int *) throw(); 
#line 5630
extern inline float __cdecl round(float) throw(); 
#line 5631
extern inline long __cdecl lround(float) throw(); 
#line 5632
extern inline __int64 __cdecl llround(float) throw(); 
#line 5633
extern inline float __cdecl trunc(float) throw(); 
#line 5634
extern inline float __cdecl rint(float) throw(); 
#line 5635
extern inline long __cdecl lrint(float) throw(); 
#line 5636
extern inline __int64 __cdecl llrint(float) throw(); 
#line 5637
extern inline float __cdecl nearbyint(float) throw(); 
#line 5638
extern inline float __cdecl fdim(float, float) throw(); 
#line 5639
extern inline float __cdecl fma(float, float, float) throw(); 
#line 5640
extern inline float __cdecl fmax(float, float) throw(); 
#line 5641
extern inline float __cdecl fmin(float, float) throw(); 
#line 5644 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
static inline float exp10(const float a); 
#line 5646
static inline float rsqrt(const float a); 
#line 5648
static inline float rcbrt(const float a); 
#line 5650
static inline float sinpi(const float a); 
#line 5652
static inline float cospi(const float a); 
#line 5654
static inline void sincospi(const float a, float *const sptr, float *const cptr); 
#line 5656
static inline void sincos(const float a, float *const sptr, float *const cptr); 
#line 5658
static inline float j0(const float a); 
#line 5660
static inline float j1(const float a); 
#line 5662
static inline float jn(const int n, const float a); 
#line 5664
static inline float y0(const float a); 
#line 5666
static inline float y1(const float a); 
#line 5668
static inline float yn(const int n, const float a); 
#line 5670
static inline float cyl_bessel_i0(const float a); 
#line 5672
static inline float cyl_bessel_i1(const float a); 
#line 5674
static inline float erfinv(const float a); 
#line 5676
static inline float erfcinv(const float a); 
#line 5678
static inline float normcdfinv(const float a); 
#line 5680
static inline float normcdf(const float a); 
#line 5682
static inline float erfcx(const float a); 
#line 5684
static inline double copysign(const double a, const float b); 
#line 5686
static inline double copysign(const float a, const double b); 
#line 5694
static inline unsigned min(const unsigned a, const unsigned b); 
#line 5702
static inline unsigned min(const int a, const unsigned b); 
#line 5710
static inline unsigned min(const unsigned a, const int b); 
#line 5718
static inline long min(const long a, const long b); 
#line 5726
static inline unsigned long min(const unsigned long a, const unsigned long b); 
#line 5734
static inline unsigned long min(const long a, const unsigned long b); 
#line 5742
static inline unsigned long min(const unsigned long a, const long b); 
#line 5750
static inline __int64 min(const __int64 a, const __int64 b); 
#line 5758
static inline unsigned __int64 min(const unsigned __int64 a, const unsigned __int64 b); 
#line 5766
static inline unsigned __int64 min(const __int64 a, const unsigned __int64 b); 
#line 5774
static inline unsigned __int64 min(const unsigned __int64 a, const __int64 b); 
#line 5785
static inline float min(const float a, const float b); 
#line 5796
static inline double min(const double a, const double b); 
#line 5806
static inline double min(const float a, const double b); 
#line 5816
static inline double min(const double a, const float b); 
#line 5824
static inline unsigned max(const unsigned a, const unsigned b); 
#line 5832
static inline unsigned max(const int a, const unsigned b); 
#line 5840
static inline unsigned max(const unsigned a, const int b); 
#line 5848
static inline long max(const long a, const long b); 
#line 5856
static inline unsigned long max(const unsigned long a, const unsigned long b); 
#line 5864
static inline unsigned long max(const long a, const unsigned long b); 
#line 5872
static inline unsigned long max(const unsigned long a, const long b); 
#line 5880
static inline __int64 max(const __int64 a, const __int64 b); 
#line 5888
static inline unsigned __int64 max(const unsigned __int64 a, const unsigned __int64 b); 
#line 5896
static inline unsigned __int64 max(const __int64 a, const unsigned __int64 b); 
#line 5904
static inline unsigned __int64 max(const unsigned __int64 a, const __int64 b); 
#line 5915
static inline float max(const float a, const float b); 
#line 5926
static inline double max(const double a, const double b); 
#line 5936
static inline double max(const float a, const double b); 
#line 5946
static inline double max(const double a, const float b); 
#line 5958
extern "C" {
#line 5959
inline void *__nv_aligned_device_malloc(size_t size, size_t align) {int volatile ___ = 1;(void)size;(void)align;::exit(___);}
#if 0
#line 5960
{ 
#line 5961
void *__nv_aligned_device_malloc_impl(size_t, size_t); 
#line 5962
return __nv_aligned_device_malloc_impl(size, align); 
#line 5963
} 
#endif
#line 5964 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.h"
}
#line 433 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
static __inline bool isinf(const long double a) 
#line 434
{ 
#line 438 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
return isinf< long double> (a); 
#line 440 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
} 
#line 449 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
static __inline bool isinf(const double a) 
#line 450
{ 
#line 454 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
return isinf< double> (a); 
#line 456 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
} 
#line 465 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
static __inline bool isinf(const float a) 
#line 466
{ 
#line 470 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
return isinf< float> (a); 
#line 472 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
} 
#line 481 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
static __inline bool isnan(const long double a) 
#line 482
{ 
#line 486 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
return isnan< long double> (a); 
#line 488 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
} 
#line 497 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
static __inline bool isnan(const double a) 
#line 498
{ 
#line 502 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
return isnan< double> (a); 
#line 504 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
} 
#line 513 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
static __inline bool isnan(const float a) 
#line 514
{ 
#line 518 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
return isnan< float> (a); 
#line 520 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
} 
#line 529 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
static __inline bool isfinite(const long double a) 
#line 530
{ 
#line 534 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
return isfinite< long double> (a); 
#line 536 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
} 
#line 545 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
static __inline bool isfinite(const double a) 
#line 546
{ 
#line 550 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
return isfinite< double> (a); 
#line 552 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
} 
#line 561 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
static __inline bool isfinite(const float a) 
#line 562
{ 
#line 566 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
return isfinite< float> (a); 
#line 568 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
} 
#line 758 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
static inline float exp10(const float a) 
#line 759
{ 
#line 760
return exp10f(a); 
#line 761
} 
#line 763
static inline float rsqrt(const float a) 
#line 764
{ 
#line 765
return rsqrtf(a); 
#line 766
} 
#line 768
static inline float rcbrt(const float a) 
#line 769
{ 
#line 770
return rcbrtf(a); 
#line 771
} 
#line 773
static inline float sinpi(const float a) 
#line 774
{ 
#line 775
return sinpif(a); 
#line 776
} 
#line 778
static inline float cospi(const float a) 
#line 779
{ 
#line 780
return cospif(a); 
#line 781
} 
#line 783
static inline void sincospi(const float a, float *const sptr, float *const cptr) 
#line 784
{ 
#line 785
sincospif(a, sptr, cptr); 
#line 786
} 
#line 788
static inline void sincos(const float a, float *const sptr, float *const cptr) 
#line 789
{ 
#line 790
sincosf(a, sptr, cptr); 
#line 791
} 
#line 793
static inline float j0(const float a) 
#line 794
{ 
#line 795
return j0f(a); 
#line 796
} 
#line 798
static inline float j1(const float a) 
#line 799
{ 
#line 800
return j1f(a); 
#line 801
} 
#line 803
static inline float jn(const int n, const float a) 
#line 804
{ 
#line 805
return jnf(n, a); 
#line 806
} 
#line 808
static inline float y0(const float a) 
#line 809
{ 
#line 810
return y0f(a); 
#line 811
} 
#line 813
static inline float y1(const float a) 
#line 814
{ 
#line 815
return y1f(a); 
#line 816
} 
#line 818
static inline float yn(const int n, const float a) 
#line 819
{ 
#line 820
return ynf(n, a); 
#line 821
} 
#line 823
static inline float cyl_bessel_i0(const float a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 824
{ 
#line 825
return cyl_bessel_i0f(a); 
#line 826
} 
#endif
#line 828 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
static inline float cyl_bessel_i1(const float a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 829
{ 
#line 830
return cyl_bessel_i1f(a); 
#line 831
} 
#endif
#line 833 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
static inline float erfinv(const float a) 
#line 834
{ 
#line 835
return erfinvf(a); 
#line 836
} 
#line 838
static inline float erfcinv(const float a) 
#line 839
{ 
#line 840
return erfcinvf(a); 
#line 841
} 
#line 843
static inline float normcdfinv(const float a) 
#line 844
{ 
#line 845
return normcdfinvf(a); 
#line 846
} 
#line 848
static inline float normcdf(const float a) 
#line 849
{ 
#line 850
return normcdff(a); 
#line 851
} 
#line 853
static inline float erfcx(const float a) 
#line 854
{ 
#line 855
return erfcxf(a); 
#line 856
} 
#line 858
static inline double copysign(const double a, const float b) 
#line 859
{ 
#line 860
return copysign(a, static_cast< double>(b)); 
#line 861
} 
#line 863
static inline double copysign(const float a, const double b) 
#line 864
{ 
#line 865
return copysign(static_cast< double>(a), b); 
#line 866
} 
#line 868
static inline unsigned min(const unsigned a, const unsigned b) 
#line 869
{ 
#line 870
return umin(a, b); 
#line 871
} 
#line 873
static inline unsigned min(const int a, const unsigned b) 
#line 874
{ 
#line 875
return umin(static_cast< unsigned>(a), b); 
#line 876
} 
#line 878
static inline unsigned min(const unsigned a, const int b) 
#line 879
{ 
#line 880
return umin(a, static_cast< unsigned>(b)); 
#line 881
} 
#line 883
static inline long min(const long a, const long b) 
#line 884
{ 
#line 885
long retval; 
#line 888
#pragma warning (push)
#pragma warning (disable: 4127)
#line 892 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
if (sizeof(long) == sizeof(int)) { 
#line 894
#pragma warning (pop)
#line 896 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
retval = (static_cast< long>(min(static_cast< int>(a), static_cast< int>(b)))); 
#line 897
} else { 
#line 898
retval = (static_cast< long>(llmin(static_cast< __int64>(a), static_cast< __int64>(b)))); 
#line 899
}  
#line 900
return retval; 
#line 901
} 
#line 903
static inline unsigned long min(const unsigned long a, const unsigned long b) 
#line 904
{ 
#line 905
unsigned long retval; 
#line 907
#pragma warning (push)
#pragma warning (disable: 4127)
#line 910 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 912
#pragma warning (pop)
#line 914 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
retval = (static_cast< unsigned long>(umin(static_cast< unsigned>(a), static_cast< unsigned>(b)))); 
#line 915
} else { 
#line 916
retval = (static_cast< unsigned long>(ullmin(static_cast< unsigned __int64>(a), static_cast< unsigned __int64>(b)))); 
#line 917
}  
#line 918
return retval; 
#line 919
} 
#line 921
static inline unsigned long min(const long a, const unsigned long b) 
#line 922
{ 
#line 923
unsigned long retval; 
#line 925
#pragma warning (push)
#pragma warning (disable: 4127)
#line 928 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 930
#pragma warning (pop)
#line 932 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
retval = (static_cast< unsigned long>(umin(static_cast< unsigned>(a), static_cast< unsigned>(b)))); 
#line 933
} else { 
#line 934
retval = (static_cast< unsigned long>(ullmin(static_cast< unsigned __int64>(a), static_cast< unsigned __int64>(b)))); 
#line 935
}  
#line 936
return retval; 
#line 937
} 
#line 939
static inline unsigned long min(const unsigned long a, const long b) 
#line 940
{ 
#line 941
unsigned long retval; 
#line 943
#pragma warning (push)
#pragma warning (disable: 4127)
#line 946 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 948
#pragma warning (pop)
#line 950 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
retval = (static_cast< unsigned long>(umin(static_cast< unsigned>(a), static_cast< unsigned>(b)))); 
#line 951
} else { 
#line 952
retval = (static_cast< unsigned long>(ullmin(static_cast< unsigned __int64>(a), static_cast< unsigned __int64>(b)))); 
#line 953
}  
#line 954
return retval; 
#line 955
} 
#line 957
static inline __int64 min(const __int64 a, const __int64 b) 
#line 958
{ 
#line 959
return llmin(a, b); 
#line 960
} 
#line 962
static inline unsigned __int64 min(const unsigned __int64 a, const unsigned __int64 b) 
#line 963
{ 
#line 964
return ullmin(a, b); 
#line 965
} 
#line 967
static inline unsigned __int64 min(const __int64 a, const unsigned __int64 b) 
#line 968
{ 
#line 969
return ullmin(static_cast< unsigned __int64>(a), b); 
#line 970
} 
#line 972
static inline unsigned __int64 min(const unsigned __int64 a, const __int64 b) 
#line 973
{ 
#line 974
return ullmin(a, static_cast< unsigned __int64>(b)); 
#line 975
} 
#line 977
static inline float min(const float a, const float b) 
#line 978
{ 
#line 979
return fminf(a, b); 
#line 980
} 
#line 982
static inline double min(const double a, const double b) 
#line 983
{ 
#line 984
return fmin(a, b); 
#line 985
} 
#line 987
static inline double min(const float a, const double b) 
#line 988
{ 
#line 989
return fmin(static_cast< double>(a), b); 
#line 990
} 
#line 992
static inline double min(const double a, const float b) 
#line 993
{ 
#line 994
return fmin(a, static_cast< double>(b)); 
#line 995
} 
#line 997
static inline unsigned max(const unsigned a, const unsigned b) 
#line 998
{ 
#line 999
return umax(a, b); 
#line 1000
} 
#line 1002
static inline unsigned max(const int a, const unsigned b) 
#line 1003
{ 
#line 1004
return umax(static_cast< unsigned>(a), b); 
#line 1005
} 
#line 1007
static inline unsigned max(const unsigned a, const int b) 
#line 1008
{ 
#line 1009
return umax(a, static_cast< unsigned>(b)); 
#line 1010
} 
#line 1012
static inline long max(const long a, const long b) 
#line 1013
{ 
#line 1014
long retval; 
#line 1017
#pragma warning (push)
#pragma warning (disable: 4127)
#line 1020 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
if (sizeof(long) == sizeof(int)) { 
#line 1022
#pragma warning (pop)
#line 1024 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
retval = (static_cast< long>(max(static_cast< int>(a), static_cast< int>(b)))); 
#line 1025
} else { 
#line 1026
retval = (static_cast< long>(llmax(static_cast< __int64>(a), static_cast< __int64>(b)))); 
#line 1027
}  
#line 1028
return retval; 
#line 1029
} 
#line 1031
static inline unsigned long max(const unsigned long a, const unsigned long b) 
#line 1032
{ 
#line 1033
unsigned long retval; 
#line 1035
#pragma warning (push)
#pragma warning (disable: 4127)
#line 1038 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 1040
#pragma warning (pop)
#line 1042 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
retval = (static_cast< unsigned long>(umax(static_cast< unsigned>(a), static_cast< unsigned>(b)))); 
#line 1043
} else { 
#line 1044
retval = (static_cast< unsigned long>(ullmax(static_cast< unsigned __int64>(a), static_cast< unsigned __int64>(b)))); 
#line 1045
}  
#line 1046
return retval; 
#line 1047
} 
#line 1049
static inline unsigned long max(const long a, const unsigned long b) 
#line 1050
{ 
#line 1051
unsigned long retval; 
#line 1053
#pragma warning (push)
#pragma warning (disable: 4127)
#line 1056 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 1058
#pragma warning (pop)
#line 1060 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
retval = (static_cast< unsigned long>(umax(static_cast< unsigned>(a), static_cast< unsigned>(b)))); 
#line 1061
} else { 
#line 1062
retval = (static_cast< unsigned long>(ullmax(static_cast< unsigned __int64>(a), static_cast< unsigned __int64>(b)))); 
#line 1063
}  
#line 1064
return retval; 
#line 1065
} 
#line 1067
static inline unsigned long max(const unsigned long a, const long b) 
#line 1068
{ 
#line 1069
unsigned long retval; 
#line 1071
#pragma warning (push)
#pragma warning (disable: 4127)
#line 1074 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 1076
#pragma warning (pop)
#line 1078 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
retval = (static_cast< unsigned long>(umax(static_cast< unsigned>(a), static_cast< unsigned>(b)))); 
#line 1079
} else { 
#line 1080
retval = (static_cast< unsigned long>(ullmax(static_cast< unsigned __int64>(a), static_cast< unsigned __int64>(b)))); 
#line 1081
}  
#line 1082
return retval; 
#line 1083
} 
#line 1085
static inline __int64 max(const __int64 a, const __int64 b) 
#line 1086
{ 
#line 1087
return llmax(a, b); 
#line 1088
} 
#line 1090
static inline unsigned __int64 max(const unsigned __int64 a, const unsigned __int64 b) 
#line 1091
{ 
#line 1092
return ullmax(a, b); 
#line 1093
} 
#line 1095
static inline unsigned __int64 max(const __int64 a, const unsigned __int64 b) 
#line 1096
{ 
#line 1097
return ullmax(static_cast< unsigned __int64>(a), b); 
#line 1098
} 
#line 1100
static inline unsigned __int64 max(const unsigned __int64 a, const __int64 b) 
#line 1101
{ 
#line 1102
return ullmax(a, static_cast< unsigned __int64>(b)); 
#line 1103
} 
#line 1105
static inline float max(const float a, const float b) 
#line 1106
{ 
#line 1107
return fmaxf(a, b); 
#line 1108
} 
#line 1110
static inline double max(const double a, const double b) 
#line 1111
{ 
#line 1112
return fmax(a, b); 
#line 1113
} 
#line 1115
static inline double max(const float a, const double b) 
#line 1116
{ 
#line 1117
return fmax(static_cast< double>(a), b); 
#line 1118
} 
#line 1120
static inline double max(const double a, const float b) 
#line 1121
{ 
#line 1122
return fmax(a, static_cast< double>(b)); 
#line 1123
} 
#line 1129
#pragma warning (push)
#pragma warning (disable : 4211)
#line 1135 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\math_functions.hpp"
static inline int min(const int a, const int b) 
#line 1136
{ 
#line 1137
return (a < b) ? a : b; 
#line 1138
} 
#line 1140
static inline unsigned umin(const unsigned a, const unsigned b) 
#line 1141
{ 
#line 1142
return (a < b) ? a : b; 
#line 1143
} 
#line 1145
static inline __int64 llmin(const __int64 a, const __int64 b) 
#line 1146
{ 
#line 1147
return (a < b) ? a : b; 
#line 1148
} 
#line 1150
static inline unsigned __int64 ullmin(const unsigned __int64 a, const unsigned __int64 
#line 1151
b) 
#line 1152
{ 
#line 1153
return (a < b) ? a : b; 
#line 1154
} 
#line 1156
static inline int max(const int a, const int b) 
#line 1157
{ 
#line 1158
return (a > b) ? a : b; 
#line 1159
} 
#line 1161
static inline unsigned umax(const unsigned a, const unsigned b) 
#line 1162
{ 
#line 1163
return (a > b) ? a : b; 
#line 1164
} 
#line 1166
static inline __int64 llmax(const __int64 a, const __int64 b) 
#line 1167
{ 
#line 1168
return (a > b) ? a : b; 
#line 1169
} 
#line 1171
static inline unsigned __int64 ullmax(const unsigned __int64 a, const unsigned __int64 
#line 1172
b) 
#line 1173
{ 
#line 1174
return (a > b) ? a : b; 
#line 1175
} 
#line 1178
#pragma warning (pop)
#line 95 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt/device_functions.h"
extern "C" {
#line 2497 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt/device_functions.h"
static __inline int __vimax_s32_relu(const int a, const int b); 
#line 2509
static __inline unsigned __vimax_s16x2_relu(const unsigned a, const unsigned b); 
#line 2518
static __inline int __vimin_s32_relu(const int a, const int b); 
#line 2530
static __inline unsigned __vimin_s16x2_relu(const unsigned a, const unsigned b); 
#line 2539
static __inline int __vimax3_s32(const int a, const int b, const int c); 
#line 2551
static __inline unsigned __vimax3_s16x2(const unsigned a, const unsigned b, const unsigned c); 
#line 2560
static __inline unsigned __vimax3_u32(const unsigned a, const unsigned b, const unsigned c); 
#line 2572
static __inline unsigned __vimax3_u16x2(const unsigned a, const unsigned b, const unsigned c); 
#line 2581
static __inline int __vimin3_s32(const int a, const int b, const int c); 
#line 2593
static __inline unsigned __vimin3_s16x2(const unsigned a, const unsigned b, const unsigned c); 
#line 2602
static __inline unsigned __vimin3_u32(const unsigned a, const unsigned b, const unsigned c); 
#line 2614
static __inline unsigned __vimin3_u16x2(const unsigned a, const unsigned b, const unsigned c); 
#line 2623
static __inline int __vimax3_s32_relu(const int a, const int b, const int c); 
#line 2635
static __inline unsigned __vimax3_s16x2_relu(const unsigned a, const unsigned b, const unsigned c); 
#line 2644
static __inline int __vimin3_s32_relu(const int a, const int b, const int c); 
#line 2656
static __inline unsigned __vimin3_s16x2_relu(const unsigned a, const unsigned b, const unsigned c); 
#line 2665
static __inline int __viaddmax_s32(const int a, const int b, const int c); 
#line 2677
static __inline unsigned __viaddmax_s16x2(const unsigned a, const unsigned b, const unsigned c); 
#line 2686
static __inline unsigned __viaddmax_u32(const unsigned a, const unsigned b, const unsigned c); 
#line 2698
static __inline unsigned __viaddmax_u16x2(const unsigned a, const unsigned b, const unsigned c); 
#line 2707
static __inline int __viaddmin_s32(const int a, const int b, const int c); 
#line 2719
static __inline unsigned __viaddmin_s16x2(const unsigned a, const unsigned b, const unsigned c); 
#line 2728
static __inline unsigned __viaddmin_u32(const unsigned a, const unsigned b, const unsigned c); 
#line 2740
static __inline unsigned __viaddmin_u16x2(const unsigned a, const unsigned b, const unsigned c); 
#line 2750
static __inline int __viaddmax_s32_relu(const int a, const int b, const int c); 
#line 2762
static __inline unsigned __viaddmax_s16x2_relu(const unsigned a, const unsigned b, const unsigned c); 
#line 2772
static __inline int __viaddmin_s32_relu(const int a, const int b, const int c); 
#line 2784
static __inline unsigned __viaddmin_s16x2_relu(const unsigned a, const unsigned b, const unsigned c); 
#line 2793
static __inline int __vibmax_s32(const int a, const int b, bool *const pred); 
#line 2802
static __inline unsigned __vibmax_u32(const unsigned a, const unsigned b, bool *const pred); 
#line 2811
static __inline int __vibmin_s32(const int a, const int b, bool *const pred); 
#line 2820
static __inline unsigned __vibmin_u32(const unsigned a, const unsigned b, bool *const pred); 
#line 2834
static __inline unsigned __vibmax_s16x2(const unsigned a, const unsigned b, bool *const pred_hi, bool *const pred_lo); 
#line 2848
static __inline unsigned __vibmax_u16x2(const unsigned a, const unsigned b, bool *const pred_hi, bool *const pred_lo); 
#line 2862
static __inline unsigned __vibmin_s16x2(const unsigned a, const unsigned b, bool *const pred_hi, bool *const pred_lo); 
#line 2876
static __inline unsigned __vibmin_u16x2(const unsigned a, const unsigned b, bool *const pred_hi, bool *const pred_lo); 
#line 2883
}
#line 116 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
static short __internal_cast_u2s(unsigned short x) 
#line 117
{ 
#line 118
short res; 
#line 120
(void)memcpy(&res, &x, sizeof x); 
#line 124 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
return res; 
#line 125
} 
#line 127
static __inline int __vimax_s32_relu(const int a, const int b) { 
#line 134
int ans = max(a, b); 
#line 136
return (ans > 0) ? ans : 0; 
#line 138 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 140
static __inline unsigned __vimax_s16x2_relu(const unsigned a, const unsigned b) { 
#line 141
unsigned res; 
#line 149 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
unsigned short aU_lo = (unsigned short)(a & 65535U); 
#line 150
unsigned short aU_hi = (unsigned short)(a >> 16); 
#line 152
unsigned short bU_lo = (unsigned short)(b & 65535U); 
#line 153
unsigned short bU_hi = (unsigned short)(b >> 16); 
#line 156
short aS_lo = __internal_cast_u2s(aU_lo); 
#line 157
short aS_hi = __internal_cast_u2s(aU_hi); 
#line 159
short bS_lo = __internal_cast_u2s(bU_lo); 
#line 160
short bS_hi = __internal_cast_u2s(bU_hi); 
#line 163
int ansI_lo = max(aS_lo, bS_lo); 
#line 164
int ansI_hi = max(aS_hi, bS_hi); 
#line 167
if (ansI_lo < 0) { ansI_lo = 0; }  
#line 168
if (ansI_hi < 0) { ansI_hi = 0; }  
#line 171
unsigned ansU_lo = (unsigned)ansI_lo; 
#line 172
unsigned ansU_hi = (unsigned)ansI_hi; 
#line 175
res = (ansU_lo | (ansU_hi << 16)); 
#line 178 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
return res; 
#line 179
} 
#line 181
static __inline int __vimin_s32_relu(const int a, const int b) { 
#line 188
int ans = min(a, b); 
#line 190
return (ans > 0) ? ans : 0; 
#line 192 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 194
static __inline unsigned __vimin_s16x2_relu(const unsigned a, const unsigned b) { 
#line 195
unsigned res; 
#line 203 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
unsigned short aU_lo = (unsigned short)(a & 65535U); 
#line 204
unsigned short aU_hi = (unsigned short)(a >> 16); 
#line 206
unsigned short bU_lo = (unsigned short)(b & 65535U); 
#line 207
unsigned short bU_hi = (unsigned short)(b >> 16); 
#line 210
short aS_lo = __internal_cast_u2s(aU_lo); 
#line 211
short aS_hi = __internal_cast_u2s(aU_hi); 
#line 213
short bS_lo = __internal_cast_u2s(bU_lo); 
#line 214
short bS_hi = __internal_cast_u2s(bU_hi); 
#line 217
int ansI_lo = min(aS_lo, bS_lo); 
#line 218
int ansI_hi = min(aS_hi, bS_hi); 
#line 221
if (ansI_lo < 0) { ansI_lo = 0; }  
#line 222
if (ansI_hi < 0) { ansI_hi = 0; }  
#line 225
unsigned ansU_lo = (unsigned)ansI_lo; 
#line 226
unsigned ansU_hi = (unsigned)ansI_hi; 
#line 229
res = (ansU_lo | (ansU_hi << 16)); 
#line 232 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
return res; 
#line 233
} 
#line 235
static __inline int __vimax3_s32(const int a, const int b, const int c) { 
#line 245
return max(max(a, b), c); 
#line 247 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 249
static __inline unsigned __vimax3_s16x2(const unsigned a, const unsigned b, const unsigned c) { 
#line 250
unsigned res; 
#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
unsigned short aU_lo = (unsigned short)(a & 65535U); 
#line 263
unsigned short aU_hi = (unsigned short)(a >> 16); 
#line 265
unsigned short bU_lo = (unsigned short)(b & 65535U); 
#line 266
unsigned short bU_hi = (unsigned short)(b >> 16); 
#line 268
unsigned short cU_lo = (unsigned short)(c & 65535U); 
#line 269
unsigned short cU_hi = (unsigned short)(c >> 16); 
#line 272
short aS_lo = __internal_cast_u2s(aU_lo); 
#line 273
short aS_hi = __internal_cast_u2s(aU_hi); 
#line 275
short bS_lo = __internal_cast_u2s(bU_lo); 
#line 276
short bS_hi = __internal_cast_u2s(bU_hi); 
#line 278
short cS_lo = __internal_cast_u2s(cU_lo); 
#line 279
short cS_hi = __internal_cast_u2s(cU_hi); 
#line 282
unsigned ansU_lo = (unsigned)max(max(aS_lo, bS_lo), cS_lo); 
#line 283
unsigned ansU_hi = (unsigned)max(max(aS_hi, bS_hi), cS_hi); 
#line 286
res = ((ansU_lo & 65535U) | (ansU_hi << 16)); 
#line 288 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
return res; 
#line 289
} 
#line 291
static __inline unsigned __vimax3_u32(const unsigned a, const unsigned b, const unsigned c) { 
#line 301
return max(max(a, b), c); 
#line 303 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 305
static __inline unsigned __vimax3_u16x2(const unsigned a, const unsigned b, const unsigned c) { 
#line 306
unsigned res; 
#line 317 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
unsigned short aU_lo = (unsigned short)(a & 65535U); 
#line 318
unsigned short aU_hi = (unsigned short)(a >> 16); 
#line 320
unsigned short bU_lo = (unsigned short)(b & 65535U); 
#line 321
unsigned short bU_hi = (unsigned short)(b >> 16); 
#line 323
unsigned short cU_lo = (unsigned short)(c & 65535U); 
#line 324
unsigned short cU_hi = (unsigned short)(c >> 16); 
#line 327
unsigned short ansU_lo = (unsigned short)max(max(aU_lo, bU_lo), cU_lo); 
#line 328
unsigned short ansU_hi = (unsigned short)max(max(aU_hi, bU_hi), cU_hi); 
#line 331
res = (((unsigned)ansU_lo) | (((unsigned)ansU_hi) << 16)); 
#line 334 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
return res; 
#line 335
} 
#line 337
static __inline int __vimin3_s32(const int a, const int b, const int c) { 
#line 347
return min(min(a, b), c); 
#line 349 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 351
static __inline unsigned __vimin3_s16x2(const unsigned a, const unsigned b, const unsigned c) { 
#line 352
unsigned res; 
#line 363 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
unsigned short aU_lo = (unsigned short)(a & 65535U); 
#line 364
unsigned short aU_hi = (unsigned short)(a >> 16); 
#line 366
unsigned short bU_lo = (unsigned short)(b & 65535U); 
#line 367
unsigned short bU_hi = (unsigned short)(b >> 16); 
#line 369
unsigned short cU_lo = (unsigned short)(c & 65535U); 
#line 370
unsigned short cU_hi = (unsigned short)(c >> 16); 
#line 373
short aS_lo = __internal_cast_u2s(aU_lo); 
#line 374
short aS_hi = __internal_cast_u2s(aU_hi); 
#line 376
short bS_lo = __internal_cast_u2s(bU_lo); 
#line 377
short bS_hi = __internal_cast_u2s(bU_hi); 
#line 379
short cS_lo = __internal_cast_u2s(cU_lo); 
#line 380
short cS_hi = __internal_cast_u2s(cU_hi); 
#line 383
unsigned ansU_lo = (unsigned)min(min(aS_lo, bS_lo), cS_lo); 
#line 384
unsigned ansU_hi = (unsigned)min(min(aS_hi, bS_hi), cS_hi); 
#line 387
res = ((ansU_lo & 65535U) | (ansU_hi << 16)); 
#line 390 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
return res; 
#line 391
} 
#line 393
static __inline unsigned __vimin3_u32(const unsigned a, const unsigned b, const unsigned c) { 
#line 403
return min(min(a, b), c); 
#line 405 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 407
static __inline unsigned __vimin3_u16x2(const unsigned a, const unsigned b, const unsigned c) { 
#line 408
unsigned res; 
#line 419 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
unsigned short aU_lo = (unsigned short)(a & 65535U); 
#line 420
unsigned short aU_hi = (unsigned short)(a >> 16); 
#line 422
unsigned short bU_lo = (unsigned short)(b & 65535U); 
#line 423
unsigned short bU_hi = (unsigned short)(b >> 16); 
#line 425
unsigned short cU_lo = (unsigned short)(c & 65535U); 
#line 426
unsigned short cU_hi = (unsigned short)(c >> 16); 
#line 429
unsigned short ansU_lo = (unsigned short)min(min(aU_lo, bU_lo), cU_lo); 
#line 430
unsigned short ansU_hi = (unsigned short)min(min(aU_hi, bU_hi), cU_hi); 
#line 433
res = (((unsigned)ansU_lo) | (((unsigned)ansU_hi) << 16)); 
#line 436 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
return res; 
#line 437
} 
#line 439
static __inline int __vimax3_s32_relu(const int a, const int b, const int c) { 
#line 449
int ans = max(max(a, b), c); 
#line 451
return (ans > 0) ? ans : 0; 
#line 453 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 455
static __inline unsigned __vimax3_s16x2_relu(const unsigned a, const unsigned b, const unsigned c) { 
#line 456
unsigned res; 
#line 467 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
unsigned short aU_lo = (unsigned short)(a & 65535U); 
#line 468
unsigned short aU_hi = (unsigned short)(a >> 16); 
#line 470
unsigned short bU_lo = (unsigned short)(b & 65535U); 
#line 471
unsigned short bU_hi = (unsigned short)(b >> 16); 
#line 473
unsigned short cU_lo = (unsigned short)(c & 65535U); 
#line 474
unsigned short cU_hi = (unsigned short)(c >> 16); 
#line 477
short aS_lo = __internal_cast_u2s(aU_lo); 
#line 478
short aS_hi = __internal_cast_u2s(aU_hi); 
#line 480
short bS_lo = __internal_cast_u2s(bU_lo); 
#line 481
short bS_hi = __internal_cast_u2s(bU_hi); 
#line 483
short cS_lo = __internal_cast_u2s(cU_lo); 
#line 484
short cS_hi = __internal_cast_u2s(cU_hi); 
#line 487
unsigned ansU_lo = (unsigned)max(0, max(max(aS_lo, bS_lo), cS_lo)); 
#line 488
unsigned ansU_hi = (unsigned)max(0, max(max(aS_hi, bS_hi), cS_hi)); 
#line 491
res = (ansU_lo | (ansU_hi << 16)); 
#line 494 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
return res; 
#line 495
} 
#line 497
static __inline int __vimin3_s32_relu(const int a, const int b, const int c) { 
#line 507
int ans = min(min(a, b), c); 
#line 509
return (ans > 0) ? ans : 0; 
#line 511 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 513
static __inline unsigned __vimin3_s16x2_relu(const unsigned a, const unsigned b, const unsigned c) { 
#line 514
unsigned res; 
#line 525 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
unsigned short aU_lo = (unsigned short)(a & 65535U); 
#line 526
unsigned short aU_hi = (unsigned short)(a >> 16); 
#line 528
unsigned short bU_lo = (unsigned short)(b & 65535U); 
#line 529
unsigned short bU_hi = (unsigned short)(b >> 16); 
#line 531
unsigned short cU_lo = (unsigned short)(c & 65535U); 
#line 532
unsigned short cU_hi = (unsigned short)(c >> 16); 
#line 535
short aS_lo = __internal_cast_u2s(aU_lo); 
#line 536
short aS_hi = __internal_cast_u2s(aU_hi); 
#line 538
short bS_lo = __internal_cast_u2s(bU_lo); 
#line 539
short bS_hi = __internal_cast_u2s(bU_hi); 
#line 541
short cS_lo = __internal_cast_u2s(cU_lo); 
#line 542
short cS_hi = __internal_cast_u2s(cU_hi); 
#line 545
unsigned ansU_lo = (unsigned)max(0, min(min(aS_lo, bS_lo), cS_lo)); 
#line 546
unsigned ansU_hi = (unsigned)max(0, min(min(aS_hi, bS_hi), cS_hi)); 
#line 549
res = (ansU_lo | (ansU_hi << 16)); 
#line 553 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
return res; 
#line 554
} 
#line 556
static __inline int __viaddmax_s32(const int a, const int b, const int c) { 
#line 566
return max(a + b, c); 
#line 568 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 570
static __inline unsigned __viaddmax_s16x2(const unsigned a, const unsigned b, const unsigned c) { 
#line 571
unsigned res; 
#line 582 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
unsigned short aU_lo = (unsigned short)(a & 65535U); 
#line 583
unsigned short aU_hi = (unsigned short)(a >> 16); 
#line 585
unsigned short bU_lo = (unsigned short)(b & 65535U); 
#line 586
unsigned short bU_hi = (unsigned short)(b >> 16); 
#line 588
unsigned short cU_lo = (unsigned short)(c & 65535U); 
#line 589
unsigned short cU_hi = (unsigned short)(c >> 16); 
#line 591
aU_lo += bU_lo; 
#line 592
aU_hi += bU_hi; 
#line 595
short sS_lo = __internal_cast_u2s(aU_lo); 
#line 596
short sS_hi = __internal_cast_u2s(aU_hi); 
#line 598
short cS_lo = __internal_cast_u2s(cU_lo); 
#line 599
short cS_hi = __internal_cast_u2s(cU_hi); 
#line 602
unsigned ansU_lo = (unsigned)max(sS_lo, cS_lo); 
#line 603
unsigned ansU_hi = (unsigned)max(sS_hi, cS_hi); 
#line 606
res = ((ansU_lo & 65535U) | (ansU_hi << 16)); 
#line 609 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
return res; 
#line 610
} 
#line 612
static __inline unsigned __viaddmax_u32(const unsigned a, const unsigned b, const unsigned c) { 
#line 622
return max(a + b, c); 
#line 624 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 626
static __inline unsigned __viaddmax_u16x2(const unsigned a, const unsigned b, const unsigned c) { 
#line 627
unsigned res; 
#line 638 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
unsigned short aU_lo = (unsigned short)(a & 65535U); 
#line 639
unsigned short aU_hi = (unsigned short)(a >> 16); 
#line 641
unsigned short bU_lo = (unsigned short)(b & 65535U); 
#line 642
unsigned short bU_hi = (unsigned short)(b >> 16); 
#line 644
unsigned short cU_lo = (unsigned short)(c & 65535U); 
#line 645
unsigned short cU_hi = (unsigned short)(c >> 16); 
#line 648
unsigned short ansU_lo = (unsigned short)max((unsigned short)(aU_lo + bU_lo), cU_lo); 
#line 649
unsigned short ansU_hi = (unsigned short)max((unsigned short)(aU_hi + bU_hi), cU_hi); 
#line 652
res = (((unsigned)ansU_lo) | (((unsigned)ansU_hi) << 16)); 
#line 655 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
return res; 
#line 656
} 
#line 658
static __inline int __viaddmin_s32(const int a, const int b, const int c) { 
#line 668
return min(a + b, c); 
#line 670 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 672
static __inline unsigned __viaddmin_s16x2(const unsigned a, const unsigned b, const unsigned c) { 
#line 673
unsigned res; 
#line 684 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
unsigned short aU_lo = (unsigned short)(a & 65535U); 
#line 685
unsigned short aU_hi = (unsigned short)(a >> 16); 
#line 687
unsigned short bU_lo = (unsigned short)(b & 65535U); 
#line 688
unsigned short bU_hi = (unsigned short)(b >> 16); 
#line 690
unsigned short cU_lo = (unsigned short)(c & 65535U); 
#line 691
unsigned short cU_hi = (unsigned short)(c >> 16); 
#line 693
aU_lo += bU_lo; 
#line 694
aU_hi += bU_hi; 
#line 697
short sS_lo = __internal_cast_u2s(aU_lo); 
#line 698
short sS_hi = __internal_cast_u2s(aU_hi); 
#line 700
short cS_lo = __internal_cast_u2s(cU_lo); 
#line 701
short cS_hi = __internal_cast_u2s(cU_hi); 
#line 704
unsigned ansU_lo = (unsigned)min(sS_lo, cS_lo); 
#line 705
unsigned ansU_hi = (unsigned)min(sS_hi, cS_hi); 
#line 708
res = ((ansU_lo & 65535U) | (ansU_hi << 16)); 
#line 711 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
return res; 
#line 712
} 
#line 714
static __inline unsigned __viaddmin_u32(const unsigned a, const unsigned b, const unsigned c) { 
#line 724
return min(a + b, c); 
#line 726 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 728
static __inline unsigned __viaddmin_u16x2(const unsigned a, const unsigned b, const unsigned c) { 
#line 729
unsigned res; 
#line 740 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
unsigned short aU_lo = (unsigned short)(a & 65535U); 
#line 741
unsigned short aU_hi = (unsigned short)(a >> 16); 
#line 743
unsigned short bU_lo = (unsigned short)(b & 65535U); 
#line 744
unsigned short bU_hi = (unsigned short)(b >> 16); 
#line 746
unsigned short cU_lo = (unsigned short)(c & 65535U); 
#line 747
unsigned short cU_hi = (unsigned short)(c >> 16); 
#line 750
unsigned short ansU_lo = (unsigned short)min((unsigned short)(aU_lo + bU_lo), cU_lo); 
#line 751
unsigned short ansU_hi = (unsigned short)min((unsigned short)(aU_hi + bU_hi), cU_hi); 
#line 754
res = (((unsigned)ansU_lo) | (((unsigned)ansU_hi) << 16)); 
#line 757 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
return res; 
#line 758
} 
#line 760
static __inline int __viaddmax_s32_relu(const int a, const int b, const int c) { 
#line 770
int ans = max(a + b, c); 
#line 772
return (ans > 0) ? ans : 0; 
#line 774 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 776
static __inline unsigned __viaddmax_s16x2_relu(const unsigned a, const unsigned b, const unsigned c) { 
#line 777
unsigned res; 
#line 788 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
unsigned short aU_lo = (unsigned short)(a & 65535U); 
#line 789
unsigned short aU_hi = (unsigned short)(a >> 16); 
#line 791
unsigned short bU_lo = (unsigned short)(b & 65535U); 
#line 792
unsigned short bU_hi = (unsigned short)(b >> 16); 
#line 794
unsigned short cU_lo = (unsigned short)(c & 65535U); 
#line 795
unsigned short cU_hi = (unsigned short)(c >> 16); 
#line 797
aU_lo += bU_lo; 
#line 798
aU_hi += bU_hi; 
#line 801
short sS_lo = __internal_cast_u2s(aU_lo); 
#line 802
short sS_hi = __internal_cast_u2s(aU_hi); 
#line 804
short cS_lo = __internal_cast_u2s(cU_lo); 
#line 805
short cS_hi = __internal_cast_u2s(cU_hi); 
#line 808
unsigned ansU_lo = (unsigned)max(0, max(sS_lo, cS_lo)); 
#line 809
unsigned ansU_hi = (unsigned)max(0, max(sS_hi, cS_hi)); 
#line 812
res = (ansU_lo | (ansU_hi << 16)); 
#line 815 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
return res; 
#line 816
} 
#line 818
static __inline int __viaddmin_s32_relu(const int a, const int b, const int c) { 
#line 828
int ans = min(a + b, c); 
#line 830
return (ans > 0) ? ans : 0; 
#line 832 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 834
static __inline unsigned __viaddmin_s16x2_relu(const unsigned a, const unsigned b, const unsigned c) { 
#line 835
unsigned res; 
#line 846 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
unsigned short aU_lo = (unsigned short)(a & 65535U); 
#line 847
unsigned short aU_hi = (unsigned short)(a >> 16); 
#line 849
unsigned short bU_lo = (unsigned short)(b & 65535U); 
#line 850
unsigned short bU_hi = (unsigned short)(b >> 16); 
#line 852
unsigned short cU_lo = (unsigned short)(c & 65535U); 
#line 853
unsigned short cU_hi = (unsigned short)(c >> 16); 
#line 855
aU_lo += bU_lo; 
#line 856
aU_hi += bU_hi; 
#line 859
short sS_lo = __internal_cast_u2s(aU_lo); 
#line 860
short sS_hi = __internal_cast_u2s(aU_hi); 
#line 862
short cS_lo = __internal_cast_u2s(cU_lo); 
#line 863
short cS_hi = __internal_cast_u2s(cU_hi); 
#line 866
unsigned ansU_lo = (unsigned)max(0, min(sS_lo, cS_lo)); 
#line 867
unsigned ansU_hi = (unsigned)max(0, min(sS_hi, cS_hi)); 
#line 870
res = (ansU_lo | (ansU_hi << 16)); 
#line 873 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
return res; 
#line 874
} 
#line 878
static __inline int __vibmax_s32(const int a, const int b, bool *const pred) { 
#line 892
int ans = max(a, b); 
#line 894
(*pred) = (a >= b); 
#line 895
return ans; 
#line 897 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 899
static __inline unsigned __vibmax_u32(const unsigned a, const unsigned b, bool *const pred) { 
#line 913
unsigned ans = max(a, b); 
#line 915
(*pred) = (a >= b); 
#line 916
return ans; 
#line 918 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 921
static __inline int __vibmin_s32(const int a, const int b, bool *const pred) { 
#line 935
int ans = min(a, b); 
#line 937
(*pred) = (a <= b); 
#line 938
return ans; 
#line 940 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 943
static __inline unsigned __vibmin_u32(const unsigned a, const unsigned b, bool *const pred) { 
#line 957
unsigned ans = min(a, b); 
#line 959
(*pred) = (a <= b); 
#line 960
return ans; 
#line 962 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 964
static __inline unsigned __vibmax_s16x2(const unsigned a, const unsigned b, bool *const pred_hi, bool *const pred_lo) { 
#line 986
unsigned short aU_lo = (unsigned short)(a & 65535U); 
#line 987
unsigned short aU_hi = (unsigned short)(a >> 16); 
#line 989
unsigned short bU_lo = (unsigned short)(b & 65535U); 
#line 990
unsigned short bU_hi = (unsigned short)(b >> 16); 
#line 993
short aS_lo = __internal_cast_u2s(aU_lo); 
#line 994
short aS_hi = __internal_cast_u2s(aU_hi); 
#line 996
short bS_lo = __internal_cast_u2s(bU_lo); 
#line 997
short bS_hi = __internal_cast_u2s(bU_hi); 
#line 1000
unsigned ansU_lo = (unsigned)max(aS_lo, bS_lo); 
#line 1001
unsigned ansU_hi = (unsigned)max(aS_hi, bS_hi); 
#line 1003
(*pred_hi) = (aS_hi >= bS_hi); 
#line 1004
(*pred_lo) = (aS_lo >= bS_lo); 
#line 1007
unsigned ans = (ansU_lo & 65535U) | (ansU_hi << 16); 
#line 1009
return ans; 
#line 1011 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 1013
static __inline unsigned __vibmax_u16x2(const unsigned a, const unsigned b, bool *const pred_hi, bool *const pred_lo) { 
#line 1035
unsigned short aU_lo = (unsigned short)(a & 65535U); 
#line 1036
unsigned short aU_hi = (unsigned short)(a >> 16); 
#line 1038
unsigned short bU_lo = (unsigned short)(b & 65535U); 
#line 1039
unsigned short bU_hi = (unsigned short)(b >> 16); 
#line 1042
unsigned short ansU_lo = (unsigned short)max(aU_lo, bU_lo); 
#line 1043
unsigned short ansU_hi = (unsigned short)max(aU_hi, bU_hi); 
#line 1045
(*pred_hi) = (aU_hi >= bU_hi); 
#line 1046
(*pred_lo) = (aU_lo >= bU_lo); 
#line 1049
unsigned ans = ((unsigned)ansU_lo) | (((unsigned)ansU_hi) << 16); 
#line 1051
return ans; 
#line 1053 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 1055
static __inline unsigned __vibmin_s16x2(const unsigned a, const unsigned b, bool *const pred_hi, bool *const pred_lo) { 
#line 1077
unsigned short aU_lo = (unsigned short)(a & 65535U); 
#line 1078
unsigned short aU_hi = (unsigned short)(a >> 16); 
#line 1080
unsigned short bU_lo = (unsigned short)(b & 65535U); 
#line 1081
unsigned short bU_hi = (unsigned short)(b >> 16); 
#line 1084
short aS_lo = __internal_cast_u2s(aU_lo); 
#line 1085
short aS_hi = __internal_cast_u2s(aU_hi); 
#line 1087
short bS_lo = __internal_cast_u2s(bU_lo); 
#line 1088
short bS_hi = __internal_cast_u2s(bU_hi); 
#line 1091
unsigned ansU_lo = (unsigned)min(aS_lo, bS_lo); 
#line 1092
unsigned ansU_hi = (unsigned)min(aS_hi, bS_hi); 
#line 1094
(*pred_hi) = (aS_hi <= bS_hi); 
#line 1095
(*pred_lo) = (aS_lo <= bS_lo); 
#line 1098
unsigned ans = (ansU_lo & 65535U) | (ansU_hi << 16); 
#line 1100
return ans; 
#line 1102 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 1104
static __inline unsigned __vibmin_u16x2(const unsigned a, const unsigned b, bool *const pred_hi, bool *const pred_lo) { 
#line 1126
unsigned short aU_lo = (unsigned short)(a & 65535U); 
#line 1127
unsigned short aU_hi = (unsigned short)(a >> 16); 
#line 1129
unsigned short bU_lo = (unsigned short)(b & 65535U); 
#line 1130
unsigned short bU_hi = (unsigned short)(b >> 16); 
#line 1133
unsigned short ansU_lo = (unsigned short)min(aU_lo, bU_lo); 
#line 1134
unsigned short ansU_hi = (unsigned short)min(aU_hi, bU_hi); 
#line 1136
(*pred_hi) = (aU_hi <= bU_hi); 
#line 1137
(*pred_lo) = (aU_lo <= bU_lo); 
#line 1140
unsigned ans = ((unsigned)ansU_lo) | (((unsigned)ansU_hi) << 16); 
#line 1142
return ans; 
#line 1144 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_functions.hpp"
} 
#line 89 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline int atomicAdd(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 89
{ } 
#endif
#line 91 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline unsigned atomicAdd(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 91
{ } 
#endif
#line 93 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline int atomicSub(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 93
{ } 
#endif
#line 95 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline unsigned atomicSub(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 95
{ } 
#endif
#line 97 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline int atomicExch(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 97
{ } 
#endif
#line 99 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline unsigned atomicExch(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 99
{ } 
#endif
#line 101 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline float atomicExch(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 101
{ } 
#endif
#line 103 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline int atomicMin(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 103
{ } 
#endif
#line 105 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline unsigned atomicMin(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 105
{ } 
#endif
#line 107 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline int atomicMax(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 107
{ } 
#endif
#line 109 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline unsigned atomicMax(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 109
{ } 
#endif
#line 111 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline unsigned atomicInc(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 111
{ } 
#endif
#line 113 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline unsigned atomicDec(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 113
{ } 
#endif
#line 115 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline int atomicAnd(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 115
{ } 
#endif
#line 117 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline unsigned atomicAnd(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 117
{ } 
#endif
#line 119 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline int atomicOr(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 119
{ } 
#endif
#line 121 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline unsigned atomicOr(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 121
{ } 
#endif
#line 123 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline int atomicXor(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 123
{ } 
#endif
#line 125 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline unsigned atomicXor(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 125
{ } 
#endif
#line 127 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline int atomicCAS(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 127
{ } 
#endif
#line 129 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline unsigned atomicCAS(unsigned *address, unsigned compare, unsigned val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 129
{ } 
#endif
#line 156 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
extern "C" {
#line 160
}
#line 169
static __inline unsigned __int64 atomicAdd(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 169
{ } 
#endif
#line 171 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline unsigned __int64 atomicExch(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 171
{ } 
#endif
#line 173 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
static __inline unsigned __int64 atomicCAS(unsigned __int64 *address, unsigned __int64 compare, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 173
{ } 
#endif
#line 175 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
__declspec(deprecated("__any() is deprecated in favor of __any_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppr" "ess this warning).")) static __inline bool any(bool cond) {int volatile ___ = 1;(void)cond;::exit(___);}
#if 0
#line 175
{ } 
#endif
#line 177 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_atomic_functions.h"
__declspec(deprecated("__all() is deprecated in favor of __all_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppr" "ess this warning).")) static __inline bool all(bool cond) {int volatile ___ = 1;(void)cond;::exit(___);}
#if 0
#line 177
{ } 
#endif
#line 90 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_double_functions.h"
extern "C" {
#line 1142
}
#line 1150
static __inline double fma(double a, double b, double c, cudaRoundMode mode); 
#line 1154
static __inline double dmul(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
#line 1156
static __inline double dadd(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
#line 1158
static __inline double dsub(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
#line 1160
static __inline int double2int(double a, cudaRoundMode mode = cudaRoundZero); 
#line 1162
static __inline unsigned double2uint(double a, cudaRoundMode mode = cudaRoundZero); 
#line 1164
static __inline __int64 double2ll(double a, cudaRoundMode mode = cudaRoundZero); 
#line 1166
static __inline unsigned __int64 double2ull(double a, cudaRoundMode mode = cudaRoundZero); 
#line 1168
static __inline double ll2double(__int64 a, cudaRoundMode mode = cudaRoundNearest); 
#line 1170
static __inline double ull2double(unsigned __int64 a, cudaRoundMode mode = cudaRoundNearest); 
#line 1172
static __inline double int2double(int a, cudaRoundMode mode = cudaRoundNearest); 
#line 1174
static __inline double uint2double(unsigned a, cudaRoundMode mode = cudaRoundNearest); 
#line 1176
static __inline double float2double(float a, cudaRoundMode mode = cudaRoundNearest); 
#line 93 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_double_functions.hpp"
static __inline double fma(double a, double b, double c, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)b;(void)c;(void)mode;::exit(___);}
#if 0
#line 94
{ 
#line 95
return (mode == (cudaRoundZero)) ? __fma_rz(a, b, c) : ((mode == (cudaRoundPosInf)) ? __fma_ru(a, b, c) : ((mode == (cudaRoundMinInf)) ? __fma_rd(a, b, c) : __fma_rn(a, b, c))); 
#line 99
} 
#endif
#line 101 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_double_functions.hpp"
static __inline double dmul(double a, double b, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)b;(void)mode;::exit(___);}
#if 0
#line 102
{ 
#line 103
return (mode == (cudaRoundZero)) ? __dmul_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dmul_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dmul_rd(a, b) : __dmul_rn(a, b))); 
#line 107
} 
#endif
#line 109 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_double_functions.hpp"
static __inline double dadd(double a, double b, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)b;(void)mode;::exit(___);}
#if 0
#line 110
{ 
#line 111
return (mode == (cudaRoundZero)) ? __dadd_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dadd_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dadd_rd(a, b) : __dadd_rn(a, b))); 
#line 115
} 
#endif
#line 117 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_double_functions.hpp"
static __inline double dsub(double a, double b, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)b;(void)mode;::exit(___);}
#if 0
#line 118
{ 
#line 119
return (mode == (cudaRoundZero)) ? __dsub_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dsub_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dsub_rd(a, b) : __dsub_rn(a, b))); 
#line 123
} 
#endif
#line 125 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_double_functions.hpp"
static __inline int double2int(double a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 126
{ 
#line 127
return (mode == (cudaRoundNearest)) ? __double2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2int_rd(a) : __double2int_rz(a))); 
#line 131
} 
#endif
#line 133 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_double_functions.hpp"
static __inline unsigned double2uint(double a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 134
{ 
#line 135
return (mode == (cudaRoundNearest)) ? __double2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2uint_rd(a) : __double2uint_rz(a))); 
#line 139
} 
#endif
#line 141 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_double_functions.hpp"
static __inline __int64 double2ll(double a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 142
{ 
#line 143
return (mode == (cudaRoundNearest)) ? __double2ll_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ll_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ll_rd(a) : __double2ll_rz(a))); 
#line 147
} 
#endif
#line 149 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_double_functions.hpp"
static __inline unsigned __int64 double2ull(double a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 150
{ 
#line 151
return (mode == (cudaRoundNearest)) ? __double2ull_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ull_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ull_rd(a) : __double2ull_rz(a))); 
#line 155
} 
#endif
#line 157 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_double_functions.hpp"
static __inline double ll2double(__int64 a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 158
{ 
#line 159
return (mode == (cudaRoundZero)) ? __ll2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ll2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ll2double_rd(a) : __ll2double_rn(a))); 
#line 163
} 
#endif
#line 165 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_double_functions.hpp"
static __inline double ull2double(unsigned __int64 a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 166
{ 
#line 167
return (mode == (cudaRoundZero)) ? __ull2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ull2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ull2double_rd(a) : __ull2double_rn(a))); 
#line 171
} 
#endif
#line 173 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_double_functions.hpp"
static __inline double int2double(int a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 174
{ 
#line 175
return (double)a; 
#line 176
} 
#endif
#line 178 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_double_functions.hpp"
static __inline double uint2double(unsigned a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 179
{ 
#line 180
return (double)a; 
#line 181
} 
#endif
#line 183 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\device_double_functions.hpp"
static __inline double float2double(float a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 184
{ 
#line 185
return (double)a; 
#line 186
} 
#endif
#line 88 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_atomic_functions.h"
static __inline float atomicAdd(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 88
{ } 
#endif
#line 89 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicMin(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 89
{ } 
#endif
#line 91 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicMax(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 91
{ } 
#endif
#line 93 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicAnd(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 93
{ } 
#endif
#line 95 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicOr(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 95
{ } 
#endif
#line 97 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicXor(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 97
{ } 
#endif
#line 99 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicMin(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 99
{ } 
#endif
#line 101 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicMax(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 101
{ } 
#endif
#line 103 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicAnd(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 103
{ } 
#endif
#line 105 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicOr(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 105
{ } 
#endif
#line 107 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicXor(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 107
{ } 
#endif
#line 93 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline double atomicAdd(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 93
{ } 
#endif
#line 96 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline int atomicAdd_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 96
{ } 
#endif
#line 99 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline int atomicAdd_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 99
{ } 
#endif
#line 102 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicAdd_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 102
{ } 
#endif
#line 105 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicAdd_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 105
{ } 
#endif
#line 108 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicAdd_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 108
{ } 
#endif
#line 111 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicAdd_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 111
{ } 
#endif
#line 114 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline float atomicAdd_block(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 114
{ } 
#endif
#line 117 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline float atomicAdd_system(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 117
{ } 
#endif
#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline double atomicAdd_block(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 120
{ } 
#endif
#line 123 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline double atomicAdd_system(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 123
{ } 
#endif
#line 126 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline int atomicSub_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 126
{ } 
#endif
#line 129 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline int atomicSub_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 129
{ } 
#endif
#line 132 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicSub_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 132
{ } 
#endif
#line 135 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicSub_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 135
{ } 
#endif
#line 138 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline int atomicExch_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 138
{ } 
#endif
#line 141 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline int atomicExch_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 141
{ } 
#endif
#line 144 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicExch_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 144
{ } 
#endif
#line 147 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicExch_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 147
{ } 
#endif
#line 150 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicExch_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 150
{ } 
#endif
#line 153 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicExch_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 153
{ } 
#endif
#line 156 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline float atomicExch_block(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 156
{ } 
#endif
#line 159 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline float atomicExch_system(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 159
{ } 
#endif
#line 162 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline int atomicMin_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 162
{ } 
#endif
#line 165 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline int atomicMin_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 165
{ } 
#endif
#line 168 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicMin_block(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 168
{ } 
#endif
#line 171 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicMin_system(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 171
{ } 
#endif
#line 174 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicMin_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 174
{ } 
#endif
#line 177 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicMin_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 177
{ } 
#endif
#line 180 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicMin_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 180
{ } 
#endif
#line 183 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicMin_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 183
{ } 
#endif
#line 186 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline int atomicMax_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 186
{ } 
#endif
#line 189 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline int atomicMax_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 189
{ } 
#endif
#line 192 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicMax_block(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 192
{ } 
#endif
#line 195 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicMax_system(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 195
{ } 
#endif
#line 198 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicMax_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 198
{ } 
#endif
#line 201 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicMax_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 201
{ } 
#endif
#line 204 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicMax_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 204
{ } 
#endif
#line 207 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicMax_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 207
{ } 
#endif
#line 210 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicInc_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 210
{ } 
#endif
#line 213 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicInc_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 213
{ } 
#endif
#line 216 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicDec_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 216
{ } 
#endif
#line 219 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicDec_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 219
{ } 
#endif
#line 222 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline int atomicCAS_block(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 222
{ } 
#endif
#line 225 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline int atomicCAS_system(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 225
{ } 
#endif
#line 228 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicCAS_block(unsigned *address, unsigned compare, unsigned 
#line 229
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 229
{ } 
#endif
#line 232 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicCAS_system(unsigned *address, unsigned compare, unsigned 
#line 233
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 233
{ } 
#endif
#line 236 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicCAS_block(unsigned __int64 *address, unsigned __int64 
#line 237
compare, unsigned __int64 
#line 238
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 238
{ } 
#endif
#line 241 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicCAS_system(unsigned __int64 *address, unsigned __int64 
#line 242
compare, unsigned __int64 
#line 243
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 243
{ } 
#endif
#line 246 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline int atomicAnd_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 246
{ } 
#endif
#line 249 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline int atomicAnd_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 249
{ } 
#endif
#line 252 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicAnd_block(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 252
{ } 
#endif
#line 255 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicAnd_system(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 255
{ } 
#endif
#line 258 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicAnd_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 258
{ } 
#endif
#line 261 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicAnd_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 261
{ } 
#endif
#line 264 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicAnd_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 264
{ } 
#endif
#line 267 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicAnd_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 267
{ } 
#endif
#line 270 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline int atomicOr_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 270
{ } 
#endif
#line 273 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline int atomicOr_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 273
{ } 
#endif
#line 276 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicOr_block(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 276
{ } 
#endif
#line 279 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicOr_system(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 279
{ } 
#endif
#line 282 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicOr_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 282
{ } 
#endif
#line 285 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicOr_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 285
{ } 
#endif
#line 288 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicOr_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 288
{ } 
#endif
#line 291 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicOr_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 291
{ } 
#endif
#line 294 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline int atomicXor_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 294
{ } 
#endif
#line 297 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline int atomicXor_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 297
{ } 
#endif
#line 300 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicXor_block(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 300
{ } 
#endif
#line 303 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicXor_system(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 303
{ } 
#endif
#line 306 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicXor_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 306
{ } 
#endif
#line 309 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicXor_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 309
{ } 
#endif
#line 312 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicXor_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 312
{ } 
#endif
#line 315 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicXor_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 315
{ } 
#endif
#line 97 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
extern "C" {
#line 1038
}
#line 1045
__declspec(deprecated("__ballot() is deprecated in favor of __ballot_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to" " suppress this warning).")) static __inline unsigned ballot(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
#line 1045
{ } 
#endif
#line 1047 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
static __inline int syncthreads_count(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
#line 1047
{ } 
#endif
#line 1049 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
static __inline bool syncthreads_and(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
#line 1049
{ } 
#endif
#line 1051 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
static __inline bool syncthreads_or(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
#line 1051
{ } 
#endif
#line 1056 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
static __inline unsigned __isGlobal(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1056
{ } 
#endif
#line 1057 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
static __inline unsigned __isShared(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1057
{ } 
#endif
#line 1058 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
static __inline unsigned __isConstant(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1058
{ } 
#endif
#line 1059 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
static __inline unsigned __isLocal(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1059
{ } 
#endif
#line 1061 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
static __inline unsigned __isGridConstant(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1061
{ } 
#endif
#line 1063 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
static __inline size_t __cvta_generic_to_global(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1063
{ } 
#endif
#line 1064 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
static __inline size_t __cvta_generic_to_shared(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1064
{ } 
#endif
#line 1065 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
static __inline size_t __cvta_generic_to_constant(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1065
{ } 
#endif
#line 1066 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
static __inline size_t __cvta_generic_to_local(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1066
{ } 
#endif
#line 1068 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
static __inline size_t __cvta_generic_to_grid_constant(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1068
{ } 
#endif
#line 1071 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
static __inline void *__cvta_global_to_generic(size_t rawbits) {int volatile ___ = 1;(void)rawbits;::exit(___);}
#if 0
#line 1071
{ } 
#endif
#line 1072 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
static __inline void *__cvta_shared_to_generic(size_t rawbits) {int volatile ___ = 1;(void)rawbits;::exit(___);}
#if 0
#line 1072
{ } 
#endif
#line 1073 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
static __inline void *__cvta_constant_to_generic(size_t rawbits) {int volatile ___ = 1;(void)rawbits;::exit(___);}
#if 0
#line 1073
{ } 
#endif
#line 1074 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
static __inline void *__cvta_local_to_generic(size_t rawbits) {int volatile ___ = 1;(void)rawbits;::exit(___);}
#if 0
#line 1074
{ } 
#endif
#line 1076 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
static __inline void *__cvta_grid_constant_to_generic(size_t rawbits) {int volatile ___ = 1;(void)rawbits;::exit(___);}
#if 0
#line 1076
{ } 
#endif
#line 1090 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
static __inline unsigned short __nv_bswap16(unsigned short x) { 
#line 1094 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
return _byteswap_ushort(x); 
#line 1098 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
} 
#line 1109
static __inline unsigned __nv_bswap32(unsigned x) { 
#line 1113 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
unsigned long ret = _byteswap_ulong(static_cast< unsigned long>(x)); 
#line 1114
return static_cast< unsigned>(ret); 
#line 1118 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
} 
#line 1129
static __inline unsigned __int64 __nv_bswap64(unsigned __int64 x) { 
#line 1133 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
unsigned __int64 ret = _byteswap_uint64(x); 
#line 1134
return ret; 
#line 1138 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_20_intrinsics.h"
} 
#line 123 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline unsigned __fns(unsigned mask, unsigned base, int offset) {int volatile ___ = 1;(void)mask;(void)base;(void)offset;::exit(___);}
#if 0
#line 123
{ } 
#endif
#line 124 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline void __barrier_sync(unsigned id) {int volatile ___ = 1;(void)id;::exit(___);}
#if 0
#line 124
{ } 
#endif
#line 125 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline void __barrier_sync_count(unsigned id, unsigned cnt) {int volatile ___ = 1;(void)id;(void)cnt;::exit(___);}
#if 0
#line 125
{ } 
#endif
#line 126 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline void __syncwarp(unsigned mask = 4294967295U) {int volatile ___ = 1;(void)mask;::exit(___);}
#if 0
#line 126
{ } 
#endif
#line 127 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline int __all_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
#line 127
{ } 
#endif
#line 128 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline int __any_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
#line 128
{ } 
#endif
#line 129 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline int __uni_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
#line 129
{ } 
#endif
#line 130 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline unsigned __ballot_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
#line 130
{ } 
#endif
#line 131 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline unsigned __activemask() {int volatile ___ = 1;::exit(___);}
#if 0
#line 131
{ } 
#endif
#line 140 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline int __shfl(int var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 140
{ } 
#endif
#line 141 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline unsigned __shfl(unsigned var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 141
{ } 
#endif
#line 142 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline int __shfl_up(int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 142
{ } 
#endif
#line 143 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline unsigned __shfl_up(unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 143
{ } 
#endif
#line 144 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline int __shfl_down(int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 144
{ } 
#endif
#line 145 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline unsigned __shfl_down(unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 145
{ } 
#endif
#line 146 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline int __shfl_xor(int var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 146
{ } 
#endif
#line 147 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline unsigned __shfl_xor(unsigned var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 147
{ } 
#endif
#line 148 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline float __shfl(float var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 148
{ } 
#endif
#line 149 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline float __shfl_up(float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 149
{ } 
#endif
#line 150 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline float __shfl_down(float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 150
{ } 
#endif
#line 151 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline float __shfl_xor(float var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 151
{ } 
#endif
#line 154 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline int __shfl_sync(unsigned mask, int var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 154
{ } 
#endif
#line 155 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline unsigned __shfl_sync(unsigned mask, unsigned var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 155
{ } 
#endif
#line 156 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline int __shfl_up_sync(unsigned mask, int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 156
{ } 
#endif
#line 157 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline unsigned __shfl_up_sync(unsigned mask, unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 157
{ } 
#endif
#line 158 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline int __shfl_down_sync(unsigned mask, int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 158
{ } 
#endif
#line 159 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline unsigned __shfl_down_sync(unsigned mask, unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 159
{ } 
#endif
#line 160 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline int __shfl_xor_sync(unsigned mask, int var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 160
{ } 
#endif
#line 161 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline unsigned __shfl_xor_sync(unsigned mask, unsigned var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 161
{ } 
#endif
#line 162 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline float __shfl_sync(unsigned mask, float var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 162
{ } 
#endif
#line 163 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline float __shfl_up_sync(unsigned mask, float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 163
{ } 
#endif
#line 164 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline float __shfl_down_sync(unsigned mask, float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 164
{ } 
#endif
#line 165 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline float __shfl_xor_sync(unsigned mask, float var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 165
{ } 
#endif
#line 169 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline unsigned __int64 __shfl(unsigned __int64 var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 169
{ } 
#endif
#line 170 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline __int64 __shfl(__int64 var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 170
{ } 
#endif
#line 171 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline __int64 __shfl_up(__int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 171
{ } 
#endif
#line 172 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline unsigned __int64 __shfl_up(unsigned __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 172
{ } 
#endif
#line 173 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline __int64 __shfl_down(__int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 173
{ } 
#endif
#line 174 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline unsigned __int64 __shfl_down(unsigned __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 174
{ } 
#endif
#line 175 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline __int64 __shfl_xor(__int64 var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 175
{ } 
#endif
#line 176 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline unsigned __int64 __shfl_xor(unsigned __int64 var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 176
{ } 
#endif
#line 177 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline double __shfl(double var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 177
{ } 
#endif
#line 178 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline double __shfl_up(double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 178
{ } 
#endif
#line 179 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline double __shfl_down(double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 179
{ } 
#endif
#line 180 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline double __shfl_xor(double var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 180
{ } 
#endif
#line 183 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline __int64 __shfl_sync(unsigned mask, __int64 var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 183
{ } 
#endif
#line 184 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline unsigned __int64 __shfl_sync(unsigned mask, unsigned __int64 var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 184
{ } 
#endif
#line 185 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline __int64 __shfl_up_sync(unsigned mask, __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 185
{ } 
#endif
#line 186 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline unsigned __int64 __shfl_up_sync(unsigned mask, unsigned __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 186
{ } 
#endif
#line 187 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline __int64 __shfl_down_sync(unsigned mask, __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 187
{ } 
#endif
#line 188 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline unsigned __int64 __shfl_down_sync(unsigned mask, unsigned __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 188
{ } 
#endif
#line 189 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline __int64 __shfl_xor_sync(unsigned mask, __int64 var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 189
{ } 
#endif
#line 190 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline unsigned __int64 __shfl_xor_sync(unsigned mask, unsigned __int64 var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 190
{ } 
#endif
#line 191 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline double __shfl_sync(unsigned mask, double var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 191
{ } 
#endif
#line 192 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline double __shfl_up_sync(unsigned mask, double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 192
{ } 
#endif
#line 193 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline double __shfl_down_sync(unsigned mask, double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 193
{ } 
#endif
#line 194 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline double __shfl_xor_sync(unsigned mask, double var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 194
{ } 
#endif
#line 198 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline long __shfl(long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 198
{ } 
#endif
#line 199 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline unsigned long __shfl(unsigned long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 199
{ } 
#endif
#line 200 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline long __shfl_up(long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 200
{ } 
#endif
#line 201 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline unsigned long __shfl_up(unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 201
{ } 
#endif
#line 202 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline long __shfl_down(long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 202
{ } 
#endif
#line 203 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline unsigned long __shfl_down(unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 203
{ } 
#endif
#line 204 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline long __shfl_xor(long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 204
{ } 
#endif
#line 205 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline unsigned long __shfl_xor(unsigned long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 205
{ } 
#endif
#line 208 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline long __shfl_sync(unsigned mask, long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 208
{ } 
#endif
#line 209 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline unsigned long __shfl_sync(unsigned mask, unsigned long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 209
{ } 
#endif
#line 210 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline long __shfl_up_sync(unsigned mask, long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 210
{ } 
#endif
#line 211 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline unsigned long __shfl_up_sync(unsigned mask, unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 211
{ } 
#endif
#line 212 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline long __shfl_down_sync(unsigned mask, long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 212
{ } 
#endif
#line 213 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline unsigned long __shfl_down_sync(unsigned mask, unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 213
{ } 
#endif
#line 214 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline long __shfl_xor_sync(unsigned mask, long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 214
{ } 
#endif
#line 215 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_30_intrinsics.h"
static __inline unsigned long __shfl_xor_sync(unsigned mask, unsigned long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 215
{ } 
#endif
#line 91 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline long __ldg(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 91
{ } 
#endif
#line 92 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned long __ldg(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 92
{ } 
#endif
#line 94 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline char __ldg(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 94
{ } 
#endif
#line 95 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline signed char __ldg(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 95
{ } 
#endif
#line 96 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline short __ldg(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 96
{ } 
#endif
#line 97 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline int __ldg(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 97
{ } 
#endif
#line 98 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldg(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 98
{ } 
#endif
#line 99 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline char2 __ldg(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 99
{ } 
#endif
#line 100 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline char4 __ldg(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 100
{ } 
#endif
#line 101 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline short2 __ldg(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 101
{ } 
#endif
#line 102 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline short4 __ldg(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 102
{ } 
#endif
#line 103 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline int2 __ldg(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 103
{ } 
#endif
#line 104 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline int4 __ldg(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 104
{ } 
#endif
#line 105 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldg(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 105
{ } 
#endif
#line 107 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldg(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 107
{ } 
#endif
#line 108 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldg(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 108
{ } 
#endif
#line 109 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldg(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 109
{ } 
#endif
#line 110 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldg(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 110
{ } 
#endif
#line 111 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldg(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 111
{ } 
#endif
#line 112 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldg(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 112
{ } 
#endif
#line 113 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldg(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 113
{ } 
#endif
#line 114 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldg(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 114
{ } 
#endif
#line 115 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldg(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 115
{ } 
#endif
#line 116 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldg(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 116
{ } 
#endif
#line 117 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldg(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 117
{ } 
#endif
#line 119 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline float __ldg(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 119
{ } 
#endif
#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline double __ldg(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 120
{ } 
#endif
#line 121 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline float2 __ldg(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 121
{ } 
#endif
#line 122 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline float4 __ldg(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 122
{ } 
#endif
#line 123 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline double2 __ldg(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 123
{ } 
#endif
#line 128 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline long __ldcg(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 128
{ } 
#endif
#line 129 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned long __ldcg(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 129
{ } 
#endif
#line 131 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline char __ldcg(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 131
{ } 
#endif
#line 132 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline signed char __ldcg(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 132
{ } 
#endif
#line 133 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline short __ldcg(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 133
{ } 
#endif
#line 134 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline int __ldcg(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 134
{ } 
#endif
#line 135 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldcg(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 135
{ } 
#endif
#line 136 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline char2 __ldcg(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 136
{ } 
#endif
#line 137 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline char4 __ldcg(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 137
{ } 
#endif
#line 138 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline short2 __ldcg(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 138
{ } 
#endif
#line 139 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline short4 __ldcg(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 139
{ } 
#endif
#line 140 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline int2 __ldcg(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 140
{ } 
#endif
#line 141 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline int4 __ldcg(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 141
{ } 
#endif
#line 142 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldcg(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 142
{ } 
#endif
#line 144 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldcg(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 144
{ } 
#endif
#line 145 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldcg(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 145
{ } 
#endif
#line 146 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldcg(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 146
{ } 
#endif
#line 147 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldcg(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 147
{ } 
#endif
#line 148 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldcg(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 148
{ } 
#endif
#line 149 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldcg(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 149
{ } 
#endif
#line 150 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldcg(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 150
{ } 
#endif
#line 151 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldcg(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 151
{ } 
#endif
#line 152 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldcg(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 152
{ } 
#endif
#line 153 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldcg(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 153
{ } 
#endif
#line 154 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldcg(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 154
{ } 
#endif
#line 156 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline float __ldcg(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 156
{ } 
#endif
#line 157 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline double __ldcg(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 157
{ } 
#endif
#line 158 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline float2 __ldcg(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 158
{ } 
#endif
#line 159 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline float4 __ldcg(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 159
{ } 
#endif
#line 160 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline double2 __ldcg(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 160
{ } 
#endif
#line 164 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline long __ldca(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 164
{ } 
#endif
#line 165 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned long __ldca(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 165
{ } 
#endif
#line 167 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline char __ldca(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 167
{ } 
#endif
#line 168 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline signed char __ldca(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 168
{ } 
#endif
#line 169 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline short __ldca(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 169
{ } 
#endif
#line 170 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline int __ldca(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 170
{ } 
#endif
#line 171 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldca(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 171
{ } 
#endif
#line 172 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline char2 __ldca(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 172
{ } 
#endif
#line 173 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline char4 __ldca(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 173
{ } 
#endif
#line 174 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline short2 __ldca(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 174
{ } 
#endif
#line 175 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline short4 __ldca(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 175
{ } 
#endif
#line 176 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline int2 __ldca(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 176
{ } 
#endif
#line 177 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline int4 __ldca(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 177
{ } 
#endif
#line 178 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldca(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 178
{ } 
#endif
#line 180 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldca(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 180
{ } 
#endif
#line 181 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldca(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 181
{ } 
#endif
#line 182 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldca(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 182
{ } 
#endif
#line 183 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldca(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 183
{ } 
#endif
#line 184 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldca(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 184
{ } 
#endif
#line 185 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldca(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 185
{ } 
#endif
#line 186 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldca(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 186
{ } 
#endif
#line 187 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldca(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 187
{ } 
#endif
#line 188 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldca(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 188
{ } 
#endif
#line 189 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldca(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 189
{ } 
#endif
#line 190 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldca(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 190
{ } 
#endif
#line 192 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline float __ldca(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 192
{ } 
#endif
#line 193 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline double __ldca(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 193
{ } 
#endif
#line 194 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline float2 __ldca(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 194
{ } 
#endif
#line 195 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline float4 __ldca(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 195
{ } 
#endif
#line 196 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline double2 __ldca(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 196
{ } 
#endif
#line 200 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline long __ldcs(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 200
{ } 
#endif
#line 201 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned long __ldcs(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 201
{ } 
#endif
#line 203 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline char __ldcs(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 203
{ } 
#endif
#line 204 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline signed char __ldcs(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 204
{ } 
#endif
#line 205 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline short __ldcs(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 205
{ } 
#endif
#line 206 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline int __ldcs(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 206
{ } 
#endif
#line 207 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldcs(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 207
{ } 
#endif
#line 208 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline char2 __ldcs(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 208
{ } 
#endif
#line 209 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline char4 __ldcs(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 209
{ } 
#endif
#line 210 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline short2 __ldcs(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 210
{ } 
#endif
#line 211 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline short4 __ldcs(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 211
{ } 
#endif
#line 212 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline int2 __ldcs(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 212
{ } 
#endif
#line 213 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline int4 __ldcs(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 213
{ } 
#endif
#line 214 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldcs(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 214
{ } 
#endif
#line 216 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldcs(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 216
{ } 
#endif
#line 217 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldcs(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 217
{ } 
#endif
#line 218 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldcs(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 218
{ } 
#endif
#line 219 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldcs(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 219
{ } 
#endif
#line 220 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldcs(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 220
{ } 
#endif
#line 221 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldcs(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 221
{ } 
#endif
#line 222 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldcs(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 222
{ } 
#endif
#line 223 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldcs(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 223
{ } 
#endif
#line 224 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldcs(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 224
{ } 
#endif
#line 225 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldcs(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 225
{ } 
#endif
#line 226 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldcs(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 226
{ } 
#endif
#line 228 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline float __ldcs(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 228
{ } 
#endif
#line 229 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline double __ldcs(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 229
{ } 
#endif
#line 230 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline float2 __ldcs(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 230
{ } 
#endif
#line 231 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline float4 __ldcs(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 231
{ } 
#endif
#line 232 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline double2 __ldcs(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 232
{ } 
#endif
#line 236 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline long __ldlu(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 236
{ } 
#endif
#line 237 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned long __ldlu(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 237
{ } 
#endif
#line 239 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline char __ldlu(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 239
{ } 
#endif
#line 240 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline signed char __ldlu(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 240
{ } 
#endif
#line 241 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline short __ldlu(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 241
{ } 
#endif
#line 242 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline int __ldlu(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 242
{ } 
#endif
#line 243 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldlu(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 243
{ } 
#endif
#line 244 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline char2 __ldlu(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 244
{ } 
#endif
#line 245 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline char4 __ldlu(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 245
{ } 
#endif
#line 246 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline short2 __ldlu(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 246
{ } 
#endif
#line 247 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline short4 __ldlu(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 247
{ } 
#endif
#line 248 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline int2 __ldlu(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 248
{ } 
#endif
#line 249 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline int4 __ldlu(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 249
{ } 
#endif
#line 250 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldlu(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 250
{ } 
#endif
#line 252 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldlu(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 252
{ } 
#endif
#line 253 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldlu(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 253
{ } 
#endif
#line 254 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldlu(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 254
{ } 
#endif
#line 255 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldlu(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 255
{ } 
#endif
#line 256 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldlu(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 256
{ } 
#endif
#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldlu(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 257
{ } 
#endif
#line 258 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldlu(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 258
{ } 
#endif
#line 259 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldlu(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 259
{ } 
#endif
#line 260 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldlu(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 260
{ } 
#endif
#line 261 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldlu(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 261
{ } 
#endif
#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldlu(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 262
{ } 
#endif
#line 264 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline float __ldlu(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 264
{ } 
#endif
#line 265 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline double __ldlu(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 265
{ } 
#endif
#line 266 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline float2 __ldlu(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 266
{ } 
#endif
#line 267 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline float4 __ldlu(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 267
{ } 
#endif
#line 268 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline double2 __ldlu(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 268
{ } 
#endif
#line 272 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline long __ldcv(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 272
{ } 
#endif
#line 273 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned long __ldcv(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 273
{ } 
#endif
#line 275 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline char __ldcv(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 275
{ } 
#endif
#line 276 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline signed char __ldcv(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 276
{ } 
#endif
#line 277 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline short __ldcv(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 277
{ } 
#endif
#line 278 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline int __ldcv(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 278
{ } 
#endif
#line 279 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldcv(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 279
{ } 
#endif
#line 280 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline char2 __ldcv(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 280
{ } 
#endif
#line 281 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline char4 __ldcv(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 281
{ } 
#endif
#line 282 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline short2 __ldcv(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 282
{ } 
#endif
#line 283 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline short4 __ldcv(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 283
{ } 
#endif
#line 284 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline int2 __ldcv(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 284
{ } 
#endif
#line 285 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline int4 __ldcv(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 285
{ } 
#endif
#line 286 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldcv(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 286
{ } 
#endif
#line 288 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldcv(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 288
{ } 
#endif
#line 289 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldcv(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 289
{ } 
#endif
#line 290 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldcv(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 290
{ } 
#endif
#line 291 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldcv(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 291
{ } 
#endif
#line 292 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldcv(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 292
{ } 
#endif
#line 293 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldcv(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 293
{ } 
#endif
#line 294 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldcv(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 294
{ } 
#endif
#line 295 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldcv(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 295
{ } 
#endif
#line 296 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldcv(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 296
{ } 
#endif
#line 297 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldcv(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 297
{ } 
#endif
#line 298 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldcv(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 298
{ } 
#endif
#line 300 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline float __ldcv(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 300
{ } 
#endif
#line 301 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline double __ldcv(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 301
{ } 
#endif
#line 302 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline float2 __ldcv(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 302
{ } 
#endif
#line 303 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline float4 __ldcv(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 303
{ } 
#endif
#line 304 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline double2 __ldcv(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 304
{ } 
#endif
#line 308 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(long *ptr, long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 308
{ } 
#endif
#line 309 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(unsigned long *ptr, unsigned long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 309
{ } 
#endif
#line 311 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(char *ptr, char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 311
{ } 
#endif
#line 312 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(signed char *ptr, signed char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 312
{ } 
#endif
#line 313 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(short *ptr, short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 313
{ } 
#endif
#line 314 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(int *ptr, int value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 314
{ } 
#endif
#line 315 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(__int64 *ptr, __int64 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 315
{ } 
#endif
#line 316 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(char2 *ptr, char2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 316
{ } 
#endif
#line 317 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(char4 *ptr, char4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 317
{ } 
#endif
#line 318 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(short2 *ptr, short2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 318
{ } 
#endif
#line 319 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(short4 *ptr, short4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 319
{ } 
#endif
#line 320 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(int2 *ptr, int2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 320
{ } 
#endif
#line 321 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(int4 *ptr, int4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 321
{ } 
#endif
#line 322 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(longlong2 *ptr, longlong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 322
{ } 
#endif
#line 324 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(unsigned char *ptr, unsigned char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 324
{ } 
#endif
#line 325 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(unsigned short *ptr, unsigned short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 325
{ } 
#endif
#line 326 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(unsigned *ptr, unsigned value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 326
{ } 
#endif
#line 327 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(unsigned __int64 *ptr, unsigned __int64 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 327
{ } 
#endif
#line 328 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(uchar2 *ptr, uchar2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 328
{ } 
#endif
#line 329 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(uchar4 *ptr, uchar4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 329
{ } 
#endif
#line 330 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(ushort2 *ptr, ushort2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 330
{ } 
#endif
#line 331 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(ushort4 *ptr, ushort4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 331
{ } 
#endif
#line 332 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(uint2 *ptr, uint2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 332
{ } 
#endif
#line 333 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(uint4 *ptr, uint4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 333
{ } 
#endif
#line 334 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(ulonglong2 *ptr, ulonglong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 334
{ } 
#endif
#line 336 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(float *ptr, float value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 336
{ } 
#endif
#line 337 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(double *ptr, double value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 337
{ } 
#endif
#line 338 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(float2 *ptr, float2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 338
{ } 
#endif
#line 339 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(float4 *ptr, float4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 339
{ } 
#endif
#line 340 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwb(double2 *ptr, double2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 340
{ } 
#endif
#line 344 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(long *ptr, long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 344
{ } 
#endif
#line 345 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(unsigned long *ptr, unsigned long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 345
{ } 
#endif
#line 347 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(char *ptr, char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 347
{ } 
#endif
#line 348 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(signed char *ptr, signed char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 348
{ } 
#endif
#line 349 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(short *ptr, short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 349
{ } 
#endif
#line 350 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(int *ptr, int value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 350
{ } 
#endif
#line 351 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(__int64 *ptr, __int64 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 351
{ } 
#endif
#line 352 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(char2 *ptr, char2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 352
{ } 
#endif
#line 353 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(char4 *ptr, char4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 353
{ } 
#endif
#line 354 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(short2 *ptr, short2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 354
{ } 
#endif
#line 355 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(short4 *ptr, short4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 355
{ } 
#endif
#line 356 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(int2 *ptr, int2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 356
{ } 
#endif
#line 357 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(int4 *ptr, int4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 357
{ } 
#endif
#line 358 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(longlong2 *ptr, longlong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 358
{ } 
#endif
#line 360 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(unsigned char *ptr, unsigned char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 360
{ } 
#endif
#line 361 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(unsigned short *ptr, unsigned short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 361
{ } 
#endif
#line 362 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(unsigned *ptr, unsigned value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 362
{ } 
#endif
#line 363 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(unsigned __int64 *ptr, unsigned __int64 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 363
{ } 
#endif
#line 364 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(uchar2 *ptr, uchar2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 364
{ } 
#endif
#line 365 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(uchar4 *ptr, uchar4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 365
{ } 
#endif
#line 366 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(ushort2 *ptr, ushort2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 366
{ } 
#endif
#line 367 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(ushort4 *ptr, ushort4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 367
{ } 
#endif
#line 368 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(uint2 *ptr, uint2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 368
{ } 
#endif
#line 369 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(uint4 *ptr, uint4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 369
{ } 
#endif
#line 370 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(ulonglong2 *ptr, ulonglong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 370
{ } 
#endif
#line 372 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(float *ptr, float value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 372
{ } 
#endif
#line 373 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(double *ptr, double value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 373
{ } 
#endif
#line 374 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(float2 *ptr, float2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 374
{ } 
#endif
#line 375 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(float4 *ptr, float4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 375
{ } 
#endif
#line 376 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcg(double2 *ptr, double2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 376
{ } 
#endif
#line 380 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(long *ptr, long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 380
{ } 
#endif
#line 381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(unsigned long *ptr, unsigned long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 381
{ } 
#endif
#line 383 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(char *ptr, char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 383
{ } 
#endif
#line 384 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(signed char *ptr, signed char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 384
{ } 
#endif
#line 385 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(short *ptr, short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 385
{ } 
#endif
#line 386 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(int *ptr, int value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 386
{ } 
#endif
#line 387 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(__int64 *ptr, __int64 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 387
{ } 
#endif
#line 388 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(char2 *ptr, char2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 388
{ } 
#endif
#line 389 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(char4 *ptr, char4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 389
{ } 
#endif
#line 390 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(short2 *ptr, short2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 390
{ } 
#endif
#line 391 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(short4 *ptr, short4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 391
{ } 
#endif
#line 392 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(int2 *ptr, int2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 392
{ } 
#endif
#line 393 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(int4 *ptr, int4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 393
{ } 
#endif
#line 394 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(longlong2 *ptr, longlong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 394
{ } 
#endif
#line 396 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(unsigned char *ptr, unsigned char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 396
{ } 
#endif
#line 397 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(unsigned short *ptr, unsigned short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 397
{ } 
#endif
#line 398 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(unsigned *ptr, unsigned value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 398
{ } 
#endif
#line 399 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(unsigned __int64 *ptr, unsigned __int64 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 399
{ } 
#endif
#line 400 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(uchar2 *ptr, uchar2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 400
{ } 
#endif
#line 401 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(uchar4 *ptr, uchar4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 401
{ } 
#endif
#line 402 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(ushort2 *ptr, ushort2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 402
{ } 
#endif
#line 403 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(ushort4 *ptr, ushort4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 403
{ } 
#endif
#line 404 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(uint2 *ptr, uint2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 404
{ } 
#endif
#line 405 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(uint4 *ptr, uint4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 405
{ } 
#endif
#line 406 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(ulonglong2 *ptr, ulonglong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 406
{ } 
#endif
#line 408 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(float *ptr, float value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 408
{ } 
#endif
#line 409 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(double *ptr, double value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 409
{ } 
#endif
#line 410 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(float2 *ptr, float2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 410
{ } 
#endif
#line 411 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(float4 *ptr, float4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 411
{ } 
#endif
#line 412 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stcs(double2 *ptr, double2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 412
{ } 
#endif
#line 416 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(long *ptr, long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 416
{ } 
#endif
#line 417 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(unsigned long *ptr, unsigned long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 417
{ } 
#endif
#line 419 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(char *ptr, char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 419
{ } 
#endif
#line 420 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(signed char *ptr, signed char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 420
{ } 
#endif
#line 421 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(short *ptr, short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 421
{ } 
#endif
#line 422 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(int *ptr, int value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 422
{ } 
#endif
#line 423 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(__int64 *ptr, __int64 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 423
{ } 
#endif
#line 424 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(char2 *ptr, char2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 424
{ } 
#endif
#line 425 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(char4 *ptr, char4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 425
{ } 
#endif
#line 426 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(short2 *ptr, short2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 426
{ } 
#endif
#line 427 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(short4 *ptr, short4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 427
{ } 
#endif
#line 428 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(int2 *ptr, int2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 428
{ } 
#endif
#line 429 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(int4 *ptr, int4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 429
{ } 
#endif
#line 430 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(longlong2 *ptr, longlong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 430
{ } 
#endif
#line 432 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(unsigned char *ptr, unsigned char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 432
{ } 
#endif
#line 433 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(unsigned short *ptr, unsigned short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 433
{ } 
#endif
#line 434 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(unsigned *ptr, unsigned value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 434
{ } 
#endif
#line 435 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(unsigned __int64 *ptr, unsigned __int64 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 435
{ } 
#endif
#line 436 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(uchar2 *ptr, uchar2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 436
{ } 
#endif
#line 437 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(uchar4 *ptr, uchar4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 437
{ } 
#endif
#line 438 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(ushort2 *ptr, ushort2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 438
{ } 
#endif
#line 439 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(ushort4 *ptr, ushort4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 439
{ } 
#endif
#line 440 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(uint2 *ptr, uint2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 440
{ } 
#endif
#line 441 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(uint4 *ptr, uint4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 441
{ } 
#endif
#line 442 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(ulonglong2 *ptr, ulonglong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 442
{ } 
#endif
#line 444 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(float *ptr, float value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 444
{ } 
#endif
#line 445 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(double *ptr, double value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 445
{ } 
#endif
#line 446 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(float2 *ptr, float2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 446
{ } 
#endif
#line 447 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(float4 *ptr, float4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 447
{ } 
#endif
#line 448 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline void __stwt(double2 *ptr, double2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 448
{ } 
#endif
#line 465 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned __funnelshift_l(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
#line 465
{ } 
#endif
#line 477 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned __funnelshift_lc(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
#line 477
{ } 
#endif
#line 490 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned __funnelshift_r(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
#line 490
{ } 
#endif
#line 502 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_32_intrinsics.h"
static __inline unsigned __funnelshift_rc(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
#line 502
{ } 
#endif
#line 102 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_61_intrinsics.h"
static __inline int __dp2a_lo(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 102
{ } 
#endif
#line 113 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp2a_lo(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 113
{ } 
#endif
#line 125 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_61_intrinsics.h"
static __inline int __dp2a_lo(short2 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 125
{ } 
#endif
#line 136 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp2a_lo(ushort2 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 136
{ } 
#endif
#line 148 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_61_intrinsics.h"
static __inline int __dp2a_hi(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 148
{ } 
#endif
#line 159 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp2a_hi(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 159
{ } 
#endif
#line 171 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_61_intrinsics.h"
static __inline int __dp2a_hi(short2 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 171
{ } 
#endif
#line 182 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp2a_hi(ushort2 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 182
{ } 
#endif
#line 197 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_61_intrinsics.h"
static __inline int __dp4a(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 197
{ } 
#endif
#line 206 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp4a(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 206
{ } 
#endif
#line 216 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_61_intrinsics.h"
static __inline int __dp4a(char4 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 216
{ } 
#endif
#line 225 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp4a(uchar4 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 225
{ } 
#endif
#line 98 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 98
{ } 
#endif
#line 99 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, int value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 99
{ } 
#endif
#line 100 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, unsigned long value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 100
{ } 
#endif
#line 101 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, long value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 101
{ } 
#endif
#line 102 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, unsigned __int64 value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 102
{ } 
#endif
#line 103 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, __int64 value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 103
{ } 
#endif
#line 104 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, float value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 104
{ } 
#endif
#line 105 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, double value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 105
{ } 
#endif
#line 107 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, unsigned value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 107
{ } 
#endif
#line 108 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, int value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 108
{ } 
#endif
#line 109 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, unsigned long value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 109
{ } 
#endif
#line 110 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, long value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 110
{ } 
#endif
#line 111 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, unsigned __int64 value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 111
{ } 
#endif
#line 112 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, __int64 value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 112
{ } 
#endif
#line 113 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, float value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 113
{ } 
#endif
#line 114 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, double value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 114
{ } 
#endif
#line 116 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_70_rt.h"
static __inline void __nanosleep(unsigned ns) {int volatile ___ = 1;(void)ns;::exit(___);}
#if 0
#line 116
{ } 
#endif
#line 118 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_70_rt.h"
static __inline unsigned short atomicCAS(unsigned short *address, unsigned short compare, unsigned short val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 118
{ } 
#endif
#line 97 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_80_rt.h"
static __inline unsigned __reduce_add_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 97
{ } 
#endif
#line 98 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_80_rt.h"
static __inline unsigned __reduce_min_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 98
{ } 
#endif
#line 99 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_80_rt.h"
static __inline unsigned __reduce_max_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 99
{ } 
#endif
#line 101 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_80_rt.h"
static __inline int __reduce_add_sync(unsigned mask, int value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 101
{ } 
#endif
#line 102 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_80_rt.h"
static __inline int __reduce_min_sync(unsigned mask, int value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 102
{ } 
#endif
#line 103 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_80_rt.h"
static __inline int __reduce_max_sync(unsigned mask, int value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 103
{ } 
#endif
#line 105 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_80_rt.h"
static __inline unsigned __reduce_and_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 105
{ } 
#endif
#line 106 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_80_rt.h"
static __inline unsigned __reduce_or_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 106
{ } 
#endif
#line 107 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_80_rt.h"
static __inline unsigned __reduce_xor_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 107
{ } 
#endif
#line 112 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_80_rt.h"
extern "C" {
#line 113
inline void *__nv_associate_access_property(const void *ptr, unsigned __int64 
#line 114
property) {int volatile ___ = 1;(void)ptr;(void)property;::exit(___);}
#if 0
#line 114
{ 
#line 115
extern void *__nv_associate_access_property_impl(const void *, unsigned __int64); 
#line 117
return __nv_associate_access_property_impl(ptr, property); 
#line 118
} 
#endif
#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_80_rt.h"
inline void __nv_memcpy_async_shared_global_4(void *dst, const void *
#line 121
src, unsigned 
#line 122
src_size) {int volatile ___ = 1;(void)dst;(void)src;(void)src_size;::exit(___);}
#if 0
#line 122
{ 
#line 123
extern void __nv_memcpy_async_shared_global_4_impl(void *, const void *, unsigned); 
#line 126
__nv_memcpy_async_shared_global_4_impl(dst, src, src_size); 
#line 127
} 
#endif
#line 129 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_80_rt.h"
inline void __nv_memcpy_async_shared_global_8(void *dst, const void *
#line 130
src, unsigned 
#line 131
src_size) {int volatile ___ = 1;(void)dst;(void)src;(void)src_size;::exit(___);}
#if 0
#line 131
{ 
#line 132
extern void __nv_memcpy_async_shared_global_8_impl(void *, const void *, unsigned); 
#line 135
__nv_memcpy_async_shared_global_8_impl(dst, src, src_size); 
#line 136
} 
#endif
#line 138 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_80_rt.h"
inline void __nv_memcpy_async_shared_global_16(void *dst, const void *
#line 139
src, unsigned 
#line 140
src_size) {int volatile ___ = 1;(void)dst;(void)src;(void)src_size;::exit(___);}
#if 0
#line 140
{ 
#line 141
extern void __nv_memcpy_async_shared_global_16_impl(void *, const void *, unsigned); 
#line 144
__nv_memcpy_async_shared_global_16_impl(dst, src, src_size); 
#line 145
} 
#endif
#line 147 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_80_rt.h"
}
#line 92 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline unsigned __isCtaShared(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 92
{ } 
#endif
#line 93 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline unsigned __isClusterShared(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 93
{ } 
#endif
#line 94 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline void *__cluster_map_shared_rank(const void *ptr, unsigned target_block_rank) {int volatile ___ = 1;(void)ptr;(void)target_block_rank;::exit(___);}
#if 0
#line 94
{ } 
#endif
#line 95 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline unsigned __cluster_query_shared_rank(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 95
{ } 
#endif
#line 96 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline uint2 __cluster_map_shared_multicast(const void *ptr, unsigned cluster_cta_mask) {int volatile ___ = 1;(void)ptr;(void)cluster_cta_mask;::exit(___);}
#if 0
#line 96
{ } 
#endif
#line 97 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline unsigned __clusterDimIsSpecified() {int volatile ___ = 1;::exit(___);}
#if 0
#line 97
{ } 
#endif
#line 98 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline dim3 __clusterDim() {int volatile ___ = 1;::exit(___);}
#if 0
#line 98
{ } 
#endif
#line 99 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline dim3 __clusterRelativeBlockIdx() {int volatile ___ = 1;::exit(___);}
#if 0
#line 99
{ } 
#endif
#line 100 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline dim3 __clusterGridDimInClusters() {int volatile ___ = 1;::exit(___);}
#if 0
#line 100
{ } 
#endif
#line 101 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline dim3 __clusterIdx() {int volatile ___ = 1;::exit(___);}
#if 0
#line 101
{ } 
#endif
#line 102 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline unsigned __clusterRelativeBlockRank() {int volatile ___ = 1;::exit(___);}
#if 0
#line 102
{ } 
#endif
#line 103 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline unsigned __clusterSizeInBlocks() {int volatile ___ = 1;::exit(___);}
#if 0
#line 103
{ } 
#endif
#line 104 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline void __cluster_barrier_arrive() {int volatile ___ = 1;::exit(___);}
#if 0
#line 104
{ } 
#endif
#line 105 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline void __cluster_barrier_arrive_relaxed() {int volatile ___ = 1;::exit(___);}
#if 0
#line 105
{ } 
#endif
#line 106 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline void __cluster_barrier_wait() {int volatile ___ = 1;::exit(___);}
#if 0
#line 106
{ } 
#endif
#line 107 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline void __threadfence_cluster() {int volatile ___ = 1;::exit(___);}
#if 0
#line 107
{ } 
#endif
#line 109 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline float2 atomicAdd(float2 *__address, float2 val) {int volatile ___ = 1;(void)__address;(void)val;::exit(___);}
#if 0
#line 109
{ } 
#endif
#line 110 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline float2 atomicAdd_block(float2 *__address, float2 val) {int volatile ___ = 1;(void)__address;(void)val;::exit(___);}
#if 0
#line 110
{ } 
#endif
#line 111 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline float2 atomicAdd_system(float2 *__address, float2 val) {int volatile ___ = 1;(void)__address;(void)val;::exit(___);}
#if 0
#line 111
{ } 
#endif
#line 112 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline float4 atomicAdd(float4 *__address, float4 val) {int volatile ___ = 1;(void)__address;(void)val;::exit(___);}
#if 0
#line 112
{ } 
#endif
#line 113 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline float4 atomicAdd_block(float4 *__address, float4 val) {int volatile ___ = 1;(void)__address;(void)val;::exit(___);}
#if 0
#line 113
{ } 
#endif
#line 114 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static __inline float4 atomicAdd_system(float4 *__address, float4 val) {int volatile ___ = 1;(void)__address;(void)val;::exit(___);}
#if 0
#line 114
{ } 
#endif
#line 125 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
extern "C" {
#line 132
}
#line 139
template< bool __b, class _T> 
#line 140
struct __nv_atomic_enable_if { }; 
#line 142
template< class _T> 
#line 143
struct __nv_atomic_enable_if< true, _T>  { typedef _T __type; }; 
#line 153 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
template< class _T> 
#line 154
struct __nv_atomic_triv_cp_helper { 
#line 164 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
static const bool __val = __is_trivially_copyable(_T); 
#line 166 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
}; 
#line 201 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
template< class _T> static __inline typename __nv_atomic_enable_if< ((sizeof(_T) == (16)) && (__alignof(_T) >= (16))) && __nv_atomic_triv_cp_helper< _T> ::__val, _T> ::__type 
#line 203
atomicCAS(_T *__address, _T __compare, _T __val) {int volatile ___ = 1;(void)__address;(void)__compare;(void)__val;::exit(___);}
#if 0
#line 203
{ 
#line 204
union _U { _T __ret; __inline _U() {int *volatile ___ = 0;::free(___);}
#if 0
#line 204
{ } 
#endif
#line 204 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
}; _U __u; 
#line 205
__u128AtomicCAS((void *)__address, (void *)(&(const_cast< char &>(reinterpret_cast< const volatile char &>(__compare)))), (void *)(&(const_cast< char &>(reinterpret_cast< const volatile char &>(__val)))), (void *)(&(const_cast< char &>(reinterpret_cast< const volatile char &>(__u.__ret))))); 
#line 209
return __u.__ret; 
#line 210
} 
#endif
#line 212 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
template< class _T> static __inline typename __nv_atomic_enable_if< ((sizeof(_T) == (16)) && (__alignof(_T) >= (16))) && __nv_atomic_triv_cp_helper< _T> ::__val, _T> ::__type 
#line 214
atomicCAS_block(_T *__address, _T __compare, _T __val) {int volatile ___ = 1;(void)__address;(void)__compare;(void)__val;::exit(___);}
#if 0
#line 214
{ 
#line 215
union _U { _T __ret; __inline _U() {int *volatile ___ = 0;::free(___);}
#if 0
#line 215
{ } 
#endif
#line 215 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
}; _U __u; 
#line 216
__u128AtomicCAS_block((void *)__address, (void *)(&(const_cast< char &>(reinterpret_cast< const volatile char &>(__compare)))), (void *)(&(const_cast< char &>(reinterpret_cast< const volatile char &>(__val)))), (void *)(&(const_cast< char &>(reinterpret_cast< const volatile char &>(__u.__ret))))); 
#line 220
return __u.__ret; 
#line 221
} 
#endif
#line 223 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
template< class _T> static __inline typename __nv_atomic_enable_if< ((sizeof(_T) == (16)) && (__alignof(_T) >= (16))) && __nv_atomic_triv_cp_helper< _T> ::__val, _T> ::__type 
#line 225
atomicCAS_system(_T *__address, _T __compare, _T __val) {int volatile ___ = 1;(void)__address;(void)__compare;(void)__val;::exit(___);}
#if 0
#line 225
{ 
#line 226
union _U { _T __ret; __inline _U() {int *volatile ___ = 0;::free(___);}
#if 0
#line 226
{ } 
#endif
#line 226 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
}; _U __u; 
#line 227
__u128AtomicCAS_system((void *)__address, (void *)(&(const_cast< char &>(reinterpret_cast< const volatile char &>(__compare)))), (void *)(&(const_cast< char &>(reinterpret_cast< const volatile char &>(__val)))), (void *)(&(const_cast< char &>(reinterpret_cast< const volatile char &>(__u.__ret))))); 
#line 231
return __u.__ret; 
#line 232
} 
#endif
#line 234 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
template< class _T> static __inline typename __nv_atomic_enable_if< ((sizeof(_T) == (16)) && (__alignof(_T) >= (16))) && __nv_atomic_triv_cp_helper< _T> ::__val, _T> ::__type 
#line 236
atomicExch(_T *__address, _T __val) {int volatile ___ = 1;(void)__address;(void)__val;::exit(___);}
#if 0
#line 236
{ 
#line 237
union _U { _T __ret; __inline _U() {int *volatile ___ = 0;::free(___);}
#if 0
#line 237
{ } 
#endif
#line 237 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
}; _U __u; 
#line 238
__u128AtomicExch((void *)__address, (void *)(&(const_cast< char &>(reinterpret_cast< const volatile char &>(__val)))), (void *)(&(const_cast< char &>(reinterpret_cast< const volatile char &>(__u.__ret))))); 
#line 241
return __u.__ret; 
#line 242
} 
#endif
#line 244 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
template< class _T> static __inline typename __nv_atomic_enable_if< ((sizeof(_T) == (16)) && (__alignof(_T) >= (16))) && __nv_atomic_triv_cp_helper< _T> ::__val, _T> ::__type 
#line 246
atomicExch_block(_T *__address, _T __val) {int volatile ___ = 1;(void)__address;(void)__val;::exit(___);}
#if 0
#line 246
{ 
#line 247
union _U { _T __ret; __inline _U() {int *volatile ___ = 0;::free(___);}
#if 0
#line 247
{ } 
#endif
#line 247 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
}; _U __u; 
#line 248
__u128AtomicExch_block((void *)__address, (void *)(&(const_cast< char &>(reinterpret_cast< const volatile char &>(__val)))), (void *)(&(const_cast< char &>(reinterpret_cast< const volatile char &>(__u.__ret))))); 
#line 251
return __u.__ret; 
#line 252
} 
#endif
#line 254 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
template< class _T> static __inline typename __nv_atomic_enable_if< ((sizeof(_T) == (16)) && (__alignof(_T) >= (16))) && __nv_atomic_triv_cp_helper< _T> ::__val, _T> ::__type 
#line 256
atomicExch_system(_T *__address, _T __val) {int volatile ___ = 1;(void)__address;(void)__val;::exit(___);}
#if 0
#line 256
{ 
#line 257
union _U { _T __ret; __inline _U() {int *volatile ___ = 0;::free(___);}
#if 0
#line 257
{ } 
#endif
#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_90_rt.h"
}; _U __u; 
#line 258
__u128AtomicExch_system((void *)__address, (void *)(&(const_cast< char &>(reinterpret_cast< const volatile char &>(__val)))), (void *)(&(const_cast< char &>(reinterpret_cast< const volatile char &>(__u.__ret))))); 
#line 261
return __u.__ret; 
#line 262
} 
#endif
#line 100 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_100_rt.h"
static __inline float2 __ffma2_rn(float2 x, float2 y, float2 z) {int volatile ___ = 1;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 100
{ } 
#endif
#line 112 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_100_rt.h"
static __inline float2 __ffma2_rz(float2 x, float2 y, float2 z) {int volatile ___ = 1;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 112
{ } 
#endif
#line 124 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_100_rt.h"
static __inline float2 __ffma2_rd(float2 x, float2 y, float2 z) {int volatile ___ = 1;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 124
{ } 
#endif
#line 136 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_100_rt.h"
static __inline float2 __ffma2_ru(float2 x, float2 y, float2 z) {int volatile ___ = 1;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 136
{ } 
#endif
#line 149 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_100_rt.h"
static __inline float2 __fadd2_rn(float2 x, float2 y) {int volatile ___ = 1;(void)x;(void)y;::exit(___);}
#if 0
#line 149
{ } 
#endif
#line 161 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_100_rt.h"
static __inline float2 __fadd2_rz(float2 x, float2 y) {int volatile ___ = 1;(void)x;(void)y;::exit(___);}
#if 0
#line 161
{ } 
#endif
#line 173 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_100_rt.h"
static __inline float2 __fadd2_rd(float2 x, float2 y) {int volatile ___ = 1;(void)x;(void)y;::exit(___);}
#if 0
#line 173
{ } 
#endif
#line 185 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_100_rt.h"
static __inline float2 __fadd2_ru(float2 x, float2 y) {int volatile ___ = 1;(void)x;(void)y;::exit(___);}
#if 0
#line 185
{ } 
#endif
#line 198 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_100_rt.h"
static __inline float2 __fmul2_rn(float2 x, float2 y) {int volatile ___ = 1;(void)x;(void)y;::exit(___);}
#if 0
#line 198
{ } 
#endif
#line 210 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_100_rt.h"
static __inline float2 __fmul2_rz(float2 x, float2 y) {int volatile ___ = 1;(void)x;(void)y;::exit(___);}
#if 0
#line 210
{ } 
#endif
#line 222 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_100_rt.h"
static __inline float2 __fmul2_rd(float2 x, float2 y) {int volatile ___ = 1;(void)x;(void)y;::exit(___);}
#if 0
#line 222
{ } 
#endif
#line 234 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt\\sm_100_rt.h"
static __inline float2 __fmul2_ru(float2 x, float2 y) {int volatile ___ = 1;(void)x;(void)y;::exit(___);}
#if 0
#line 234
{ } 
#endif
#line 65 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> struct __nv_itex_trait { }; 
#line 66
template<> struct __nv_itex_trait< char>  { typedef void type; }; 
#line 67
template<> struct __nv_itex_trait< signed char>  { typedef void type; }; 
#line 68
template<> struct __nv_itex_trait< char1>  { typedef void type; }; 
#line 69
template<> struct __nv_itex_trait< char2>  { typedef void type; }; 
#line 70
template<> struct __nv_itex_trait< char4>  { typedef void type; }; 
#line 71
template<> struct __nv_itex_trait< unsigned char>  { typedef void type; }; 
#line 72
template<> struct __nv_itex_trait< uchar1>  { typedef void type; }; 
#line 73
template<> struct __nv_itex_trait< uchar2>  { typedef void type; }; 
#line 74
template<> struct __nv_itex_trait< uchar4>  { typedef void type; }; 
#line 75
template<> struct __nv_itex_trait< short>  { typedef void type; }; 
#line 76
template<> struct __nv_itex_trait< short1>  { typedef void type; }; 
#line 77
template<> struct __nv_itex_trait< short2>  { typedef void type; }; 
#line 78
template<> struct __nv_itex_trait< short4>  { typedef void type; }; 
#line 79
template<> struct __nv_itex_trait< unsigned short>  { typedef void type; }; 
#line 80
template<> struct __nv_itex_trait< ushort1>  { typedef void type; }; 
#line 81
template<> struct __nv_itex_trait< ushort2>  { typedef void type; }; 
#line 82
template<> struct __nv_itex_trait< ushort4>  { typedef void type; }; 
#line 83
template<> struct __nv_itex_trait< int>  { typedef void type; }; 
#line 84
template<> struct __nv_itex_trait< int1>  { typedef void type; }; 
#line 85
template<> struct __nv_itex_trait< int2>  { typedef void type; }; 
#line 86
template<> struct __nv_itex_trait< int4>  { typedef void type; }; 
#line 87
template<> struct __nv_itex_trait< unsigned>  { typedef void type; }; 
#line 88
template<> struct __nv_itex_trait< uint1>  { typedef void type; }; 
#line 89
template<> struct __nv_itex_trait< uint2>  { typedef void type; }; 
#line 90
template<> struct __nv_itex_trait< uint4>  { typedef void type; }; 
#line 92
template<> struct __nv_itex_trait< long>  { typedef void type; }; 
#line 93
template<> struct __nv_itex_trait< long1>  { typedef void type; }; 
#line 94
template<> struct __nv_itex_trait< long2>  { typedef void type; }; 
#line 95
template<> struct __nv_itex_trait< long4>  { typedef void type; }; 
#line 96
template<> struct __nv_itex_trait< unsigned long>  { typedef void type; }; 
#line 97
template<> struct __nv_itex_trait< ulong1>  { typedef void type; }; 
#line 98
template<> struct __nv_itex_trait< ulong2>  { typedef void type; }; 
#line 99
template<> struct __nv_itex_trait< ulong4>  { typedef void type; }; 
#line 101 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template<> struct __nv_itex_trait< float>  { typedef void type; }; 
#line 102
template<> struct __nv_itex_trait< float1>  { typedef void type; }; 
#line 103
template<> struct __nv_itex_trait< float2>  { typedef void type; }; 
#line 104
template<> struct __nv_itex_trait< float4>  { typedef void type; }; 
__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 108
template< class T> static typename __nv_itex_trait< T> ::type 
#line 109
tex1Dfetch(T *ptr, ::cudaTextureObject_t obj, int x) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;::exit(___);}
#if 0
#line 110
{ 
#line 111
__nv_tex_surf_handler("__itex1Dfetch", ptr, obj, x); 
#line 112
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 114 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 115
tex1Dfetch(::cudaTextureObject_t texObject, int x) {int volatile ___ = 1;(void)texObject;(void)x;::exit(___);}
#if 0
#line 116
{ 
#line 117
T ret; 
#line 118
tex1Dfetch(&ret, texObject, x); 
#line 119
return ret; 
#line 120
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 122 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 123
tex1D(T *ptr, ::cudaTextureObject_t obj, float x) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;::exit(___);}
#if 0
#line 124
{ 
#line 125
__nv_tex_surf_handler("__itex1D", ptr, obj, x); 
#line 126
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 129 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 130
tex1D(::cudaTextureObject_t texObject, float x) {int volatile ___ = 1;(void)texObject;(void)x;::exit(___);}
#if 0
#line 131
{ 
#line 132
T ret; 
#line 133
tex1D(&ret, texObject, x); 
#line 134
return ret; 
#line 135
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 138 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 139
tex2D(T *ptr, ::cudaTextureObject_t obj, float x, float y) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;::exit(___);}
#if 0
#line 140
{ 
#line 141
__nv_tex_surf_handler("__itex2D", ptr, obj, x, y); 
#line 142
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 144 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 145
tex2D(::cudaTextureObject_t texObject, float x, float y) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;::exit(___);}
#if 0
#line 146
{ 
#line 147
T ret; 
#line 148
tex2D(&ret, texObject, x, y); 
#line 149
return ret; 
#line 150
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 153 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 154
tex2D(T *ptr, ::cudaTextureObject_t obj, float x, float y, bool *
#line 155
isResident) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)isResident;::exit(___);}
#if 0
#line 156
{ 
#line 157
unsigned char res; 
#line 158
__nv_tex_surf_handler("__itex2D_sparse", ptr, obj, x, y, &res); 
#line 159
(*isResident) = (res != 0); 
#line 160
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 162 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 163
tex2D(::cudaTextureObject_t texObject, float x, float y, bool *isResident) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)isResident;::exit(___);}
#if 0
#line 164
{ 
#line 165
T ret; 
#line 166
tex2D(&ret, texObject, x, y, isResident); 
#line 167
return ret; 
#line 168
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 173 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 174
tex3D(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 175
{ 
#line 176
__nv_tex_surf_handler("__itex3D", ptr, obj, x, y, z); 
#line 177
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 179 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 180
tex3D(::cudaTextureObject_t texObject, float x, float y, float z) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 181
{ 
#line 182
T ret; 
#line 183
tex3D(&ret, texObject, x, y, z); 
#line 184
return ret; 
#line 185
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 188 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 189
tex3D(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, bool *
#line 190
isResident) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)isResident;::exit(___);}
#if 0
#line 191
{ 
#line 192
unsigned char res; 
#line 193
__nv_tex_surf_handler("__itex3D_sparse", ptr, obj, x, y, z, &res); 
#line 194
(*isResident) = (res != 0); 
#line 195
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 197 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 198
tex3D(::cudaTextureObject_t texObject, float x, float y, float z, bool *isResident) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)isResident;::exit(___);}
#if 0
#line 199
{ 
#line 200
T ret; 
#line 201
tex3D(&ret, texObject, x, y, z, isResident); 
#line 202
return ret; 
#line 203
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 207 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 208
tex1DLayered(T *ptr, ::cudaTextureObject_t obj, float x, int layer) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;::exit(___);}
#if 0
#line 209
{ 
#line 210
__nv_tex_surf_handler("__itex1DLayered", ptr, obj, x, layer); 
#line 211
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 213 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 214
tex1DLayered(::cudaTextureObject_t texObject, float x, int layer) {int volatile ___ = 1;(void)texObject;(void)x;(void)layer;::exit(___);}
#if 0
#line 215
{ 
#line 216
T ret; 
#line 217
tex1DLayered(&ret, texObject, x, layer); 
#line 218
return ret; 
#line 219
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 221 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 222
tex2DLayered(T *ptr, ::cudaTextureObject_t obj, float x, float y, int layer) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;::exit(___);}
#if 0
#line 223
{ 
#line 224
__nv_tex_surf_handler("__itex2DLayered", ptr, obj, x, y, layer); 
#line 225
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 227 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 228
tex2DLayered(::cudaTextureObject_t texObject, float x, float y, int layer) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;::exit(___);}
#if 0
#line 229
{ 
#line 230
T ret; 
#line 231
tex2DLayered(&ret, texObject, x, y, layer); 
#line 232
return ret; 
#line 233
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 236 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 237
tex2DLayered(T *ptr, ::cudaTextureObject_t obj, float x, float y, int layer, bool *isResident) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)isResident;::exit(___);}
#if 0
#line 238
{ 
#line 239
unsigned char res; 
#line 240
__nv_tex_surf_handler("__itex2DLayered_sparse", ptr, obj, x, y, layer, &res); 
#line 241
(*isResident) = (res != 0); 
#line 242
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 244 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 245
tex2DLayered(::cudaTextureObject_t texObject, float x, float y, int layer, bool *isResident) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)isResident;::exit(___);}
#if 0
#line 246
{ 
#line 247
T ret; 
#line 248
tex2DLayered(&ret, texObject, x, y, layer, isResident); 
#line 249
return ret; 
#line 250
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 254 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 255
texCubemap(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 256
{ 
#line 257
__nv_tex_surf_handler("__itexCubemap", ptr, obj, x, y, z); 
#line 258
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 261 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 262
texCubemap(::cudaTextureObject_t texObject, float x, float y, float z) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 263
{ 
#line 264
T ret; 
#line 265
texCubemap(&ret, texObject, x, y, z); 
#line 266
return ret; 
#line 267
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 270 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 271
texCubemapLayered(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, int layer) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)layer;::exit(___);}
#if 0
#line 272
{ 
#line 273
__nv_tex_surf_handler("__itexCubemapLayered", ptr, obj, x, y, z, layer); 
#line 274
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 276 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 277
texCubemapLayered(::cudaTextureObject_t texObject, float x, float y, float z, int layer) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;::exit(___);}
#if 0
#line 278
{ 
#line 279
T ret; 
#line 280
texCubemapLayered(&ret, texObject, x, y, z, layer); 
#line 281
return ret; 
#line 282
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 284 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 285
tex2Dgather(T *ptr, ::cudaTextureObject_t obj, float x, float y, int comp = 0) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)comp;::exit(___);}
#if 0
#line 286
{ 
#line 287
__nv_tex_surf_handler("__itex2Dgather", ptr, obj, x, y, comp); 
#line 288
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 290 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 291
tex2Dgather(::cudaTextureObject_t to, float x, float y, int comp = 0) {int volatile ___ = 1;(void)to;(void)x;(void)y;(void)comp;::exit(___);}
#if 0
#line 292
{ 
#line 293
T ret; 
#line 294
tex2Dgather(&ret, to, x, y, comp); 
#line 295
return ret; 
#line 296
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 299 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 300
tex2Dgather(T *ptr, ::cudaTextureObject_t obj, float x, float y, bool *isResident, int comp = 0) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)isResident;(void)comp;::exit(___);}
#if 0
#line 301
{ 
#line 302
unsigned char res; 
#line 303
__nv_tex_surf_handler("__itex2Dgather_sparse", ptr, obj, x, y, comp, &res); 
#line 304
(*isResident) = (res != 0); 
#line 305
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 307 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 308
tex2Dgather(::cudaTextureObject_t to, float x, float y, bool *isResident, int comp = 0) {int volatile ___ = 1;(void)to;(void)x;(void)y;(void)isResident;(void)comp;::exit(___);}
#if 0
#line 309
{ 
#line 310
T ret; 
#line 311
tex2Dgather(&ret, to, x, y, isResident, comp); 
#line 312
return ret; 
#line 313
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 317 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 318
tex1DLod(T *ptr, ::cudaTextureObject_t obj, float x, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)level;::exit(___);}
#if 0
#line 319
{ 
#line 320
__nv_tex_surf_handler("__itex1DLod", ptr, obj, x, level); 
#line 321
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 323 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 324
tex1DLod(::cudaTextureObject_t texObject, float x, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)level;::exit(___);}
#if 0
#line 325
{ 
#line 326
T ret; 
#line 327
tex1DLod(&ret, texObject, x, level); 
#line 328
return ret; 
#line 329
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 332 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 333
tex2DLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)level;::exit(___);}
#if 0
#line 334
{ 
#line 335
__nv_tex_surf_handler("__itex2DLod", ptr, obj, x, y, level); 
#line 336
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 338 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 339
tex2DLod(::cudaTextureObject_t texObject, float x, float y, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)level;::exit(___);}
#if 0
#line 340
{ 
#line 341
T ret; 
#line 342
tex2DLod(&ret, texObject, x, y, level); 
#line 343
return ret; 
#line 344
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 348 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 349
tex2DLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, float level, bool *isResident) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)level;(void)isResident;::exit(___);}
#if 0
#line 350
{ 
#line 351
unsigned char res; 
#line 352
__nv_tex_surf_handler("__itex2DLod_sparse", ptr, obj, x, y, level, &res); 
#line 353
(*isResident) = (res != 0); 
#line 354
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 356 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 357
tex2DLod(::cudaTextureObject_t texObject, float x, float y, float level, bool *isResident) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)level;(void)isResident;::exit(___);}
#if 0
#line 358
{ 
#line 359
T ret; 
#line 360
tex2DLod(&ret, texObject, x, y, level, isResident); 
#line 361
return ret; 
#line 362
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 367 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 368
tex3DLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)level;::exit(___);}
#if 0
#line 369
{ 
#line 370
__nv_tex_surf_handler("__itex3DLod", ptr, obj, x, y, z, level); 
#line 371
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 373 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 374
tex3DLod(::cudaTextureObject_t texObject, float x, float y, float z, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;::exit(___);}
#if 0
#line 375
{ 
#line 376
T ret; 
#line 377
tex3DLod(&ret, texObject, x, y, z, level); 
#line 378
return ret; 
#line 379
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 382 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 383
tex3DLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, float level, bool *isResident) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)level;(void)isResident;::exit(___);}
#if 0
#line 384
{ 
#line 385
unsigned char res; 
#line 386
__nv_tex_surf_handler("__itex3DLod_sparse", ptr, obj, x, y, z, level, &res); 
#line 387
(*isResident) = (res != 0); 
#line 388
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 390 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 391
tex3DLod(::cudaTextureObject_t texObject, float x, float y, float z, float level, bool *isResident) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;(void)isResident;::exit(___);}
#if 0
#line 392
{ 
#line 393
T ret; 
#line 394
tex3DLod(&ret, texObject, x, y, z, level, isResident); 
#line 395
return ret; 
#line 396
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 401 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 402
tex1DLayeredLod(T *ptr, ::cudaTextureObject_t obj, float x, int layer, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;(void)level;::exit(___);}
#if 0
#line 403
{ 
#line 404
__nv_tex_surf_handler("__itex1DLayeredLod", ptr, obj, x, layer, level); 
#line 405
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 407 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 408
tex1DLayeredLod(::cudaTextureObject_t texObject, float x, int layer, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)level;::exit(___);}
#if 0
#line 409
{ 
#line 410
T ret; 
#line 411
tex1DLayeredLod(&ret, texObject, x, layer, level); 
#line 412
return ret; 
#line 413
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 416 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 417
tex2DLayeredLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, int layer, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)level;::exit(___);}
#if 0
#line 418
{ 
#line 419
__nv_tex_surf_handler("__itex2DLayeredLod", ptr, obj, x, y, layer, level); 
#line 420
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 422 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 423
tex2DLayeredLod(::cudaTextureObject_t texObject, float x, float y, int layer, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)level;::exit(___);}
#if 0
#line 424
{ 
#line 425
T ret; 
#line 426
tex2DLayeredLod(&ret, texObject, x, y, layer, level); 
#line 427
return ret; 
#line 428
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 431 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 432
tex2DLayeredLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, int layer, float level, bool *isResident) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)level;(void)isResident;::exit(___);}
#if 0
#line 433
{ 
#line 434
unsigned char res; 
#line 435
__nv_tex_surf_handler("__itex2DLayeredLod_sparse", ptr, obj, x, y, layer, level, &res); 
#line 436
(*isResident) = (res != 0); 
#line 437
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 439 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 440
tex2DLayeredLod(::cudaTextureObject_t texObject, float x, float y, int layer, float level, bool *isResident) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)level;(void)isResident;::exit(___);}
#if 0
#line 441
{ 
#line 442
T ret; 
#line 443
tex2DLayeredLod(&ret, texObject, x, y, layer, level, isResident); 
#line 444
return ret; 
#line 445
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 448 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 449
texCubemapLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)level;::exit(___);}
#if 0
#line 450
{ 
#line 451
__nv_tex_surf_handler("__itexCubemapLod", ptr, obj, x, y, z, level); 
#line 452
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 454 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 455
texCubemapLod(::cudaTextureObject_t texObject, float x, float y, float z, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;::exit(___);}
#if 0
#line 456
{ 
#line 457
T ret; 
#line 458
texCubemapLod(&ret, texObject, x, y, z, level); 
#line 459
return ret; 
#line 460
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 463 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 464
texCubemapGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 465
{ 
#line 466
__nv_tex_surf_handler("__itexCubemapGrad_v2", ptr, obj, x, y, z, &dPdx, &dPdy); 
#line 467
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 469 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 470
texCubemapGrad(::cudaTextureObject_t texObject, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 471
{ 
#line 472
T ret; 
#line 473
texCubemapGrad(&ret, texObject, x, y, z, dPdx, dPdy); 
#line 474
return ret; 
#line 475
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 477 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 478
texCubemapLayeredLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, int layer, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)layer;(void)level;::exit(___);}
#if 0
#line 479
{ 
#line 480
__nv_tex_surf_handler("__itexCubemapLayeredLod", ptr, obj, x, y, z, layer, level); 
#line 481
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 483 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 484
texCubemapLayeredLod(::cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;::exit(___);}
#if 0
#line 485
{ 
#line 486
T ret; 
#line 487
texCubemapLayeredLod(&ret, texObject, x, y, z, layer, level); 
#line 488
return ret; 
#line 489
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 491 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 492
tex1DGrad(T *ptr, ::cudaTextureObject_t obj, float x, float dPdx, float dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 493
{ 
#line 494
__nv_tex_surf_handler("__itex1DGrad", ptr, obj, x, dPdx, dPdy); 
#line 495
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 497 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 498
tex1DGrad(::cudaTextureObject_t texObject, float x, float dPdx, float dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 499
{ 
#line 500
T ret; 
#line 501
tex1DGrad(&ret, texObject, x, dPdx, dPdy); 
#line 502
return ret; 
#line 503
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 506 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 507
tex2DGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, ::float2 dPdx, ::float2 dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 508
{ 
#line 509
__nv_tex_surf_handler("__itex2DGrad_v2", ptr, obj, x, y, &dPdx, &dPdy); 
#line 510
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 512 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 513
tex2DGrad(::cudaTextureObject_t texObject, float x, float y, ::float2 dPdx, ::float2 dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 514
{ 
#line 515
T ret; 
#line 516
tex2DGrad(&ret, texObject, x, y, dPdx, dPdy); 
#line 517
return ret; 
#line 518
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 521 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 522
tex2DGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, ::float2 dPdx, ::float2 dPdy, bool *isResident) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)dPdx;(void)dPdy;(void)isResident;::exit(___);}
#if 0
#line 523
{ 
#line 524
unsigned char res; 
#line 525
__nv_tex_surf_handler("__itex2DGrad_sparse", ptr, obj, x, y, &dPdx, &dPdy, &res); 
#line 526
(*isResident) = (res != 0); 
#line 527
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 529 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 530
tex2DGrad(::cudaTextureObject_t texObject, float x, float y, ::float2 dPdx, ::float2 dPdy, bool *isResident) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;(void)isResident;::exit(___);}
#if 0
#line 531
{ 
#line 532
T ret; 
#line 533
tex2DGrad(&ret, texObject, x, y, dPdx, dPdy, isResident); 
#line 534
return ret; 
#line 535
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 539 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 540
tex3DGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 541
{ 
#line 542
__nv_tex_surf_handler("__itex3DGrad_v2", ptr, obj, x, y, z, &dPdx, &dPdy); 
#line 543
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 545 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 546
tex3DGrad(::cudaTextureObject_t texObject, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 547
{ 
#line 548
T ret; 
#line 549
tex3DGrad(&ret, texObject, x, y, z, dPdx, dPdy); 
#line 550
return ret; 
#line 551
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 554 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 555
tex3DGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, ::float4 dPdx, ::float4 dPdy, bool *isResident) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;(void)isResident;::exit(___);}
#if 0
#line 556
{ 
#line 557
unsigned char res; 
#line 558
__nv_tex_surf_handler("__itex3DGrad_sparse", ptr, obj, x, y, z, &dPdx, &dPdy, &res); 
#line 559
(*isResident) = (res != 0); 
#line 560
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 562 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 563
tex3DGrad(::cudaTextureObject_t texObject, float x, float y, float z, ::float4 dPdx, ::float4 dPdy, bool *isResident) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;(void)isResident;::exit(___);}
#if 0
#line 564
{ 
#line 565
T ret; 
#line 566
tex3DGrad(&ret, texObject, x, y, z, dPdx, dPdy, isResident); 
#line 567
return ret; 
#line 568
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 573 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 574
tex1DLayeredGrad(T *ptr, ::cudaTextureObject_t obj, float x, int layer, float dPdx, float dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 575
{ 
#line 576
__nv_tex_surf_handler("__itex1DLayeredGrad", ptr, obj, x, layer, dPdx, dPdy); 
#line 577
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 579 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 580
tex1DLayeredGrad(::cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 581
{ 
#line 582
T ret; 
#line 583
tex1DLayeredGrad(&ret, texObject, x, layer, dPdx, dPdy); 
#line 584
return ret; 
#line 585
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 588 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 589
tex2DLayeredGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 590
{ 
#line 591
__nv_tex_surf_handler("__itex2DLayeredGrad_v2", ptr, obj, x, y, layer, &dPdx, &dPdy); 
#line 592
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 594 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 595
tex2DLayeredGrad(::cudaTextureObject_t texObject, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 596
{ 
#line 597
T ret; 
#line 598
tex2DLayeredGrad(&ret, texObject, x, y, layer, dPdx, dPdy); 
#line 599
return ret; 
#line 600
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 603 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 604
tex2DLayeredGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy, bool *isResident) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;(void)isResident;::exit(___);}
#if 0
#line 605
{ 
#line 606
unsigned char res; 
#line 607
__nv_tex_surf_handler("__itex2DLayeredGrad_sparse", ptr, obj, x, y, layer, &dPdx, &dPdy, &res); 
#line 608
(*isResident) = (res != 0); 
#line 609
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 611 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 612
tex2DLayeredGrad(::cudaTextureObject_t texObject, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy, bool *isResident) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;(void)isResident;::exit(___);}
#if 0
#line 613
{ 
#line 614
T ret; 
#line 615
tex2DLayeredGrad(&ret, texObject, x, y, layer, dPdx, dPdy, isResident); 
#line 616
return ret; 
#line 617
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 621 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 622
texCubemapLayeredGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, int layer, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 623
{ 
#line 624
__nv_tex_surf_handler("__itexCubemapLayeredGrad_v2", ptr, obj, x, y, z, layer, &dPdx, &dPdy); 
#line 625
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 627 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 628
texCubemapLayeredGrad(::cudaTextureObject_t texObject, float x, float y, float z, int layer, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 629
{ 
#line 630
T ret; 
#line 631
texCubemapLayeredGrad(&ret, texObject, x, y, z, layer, dPdx, dPdy); 
#line 632
return ret; 
#line 633
} 
#endif

__pragma(warning(pop))

#line 58 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> struct __nv_isurf_trait { }; 
#line 59
template<> struct __nv_isurf_trait< char>  { typedef void type; }; 
#line 60
template<> struct __nv_isurf_trait< signed char>  { typedef void type; }; 
#line 61
template<> struct __nv_isurf_trait< char1>  { typedef void type; }; 
#line 62
template<> struct __nv_isurf_trait< unsigned char>  { typedef void type; }; 
#line 63
template<> struct __nv_isurf_trait< uchar1>  { typedef void type; }; 
#line 64
template<> struct __nv_isurf_trait< short>  { typedef void type; }; 
#line 65
template<> struct __nv_isurf_trait< short1>  { typedef void type; }; 
#line 66
template<> struct __nv_isurf_trait< unsigned short>  { typedef void type; }; 
#line 67
template<> struct __nv_isurf_trait< ushort1>  { typedef void type; }; 
#line 68
template<> struct __nv_isurf_trait< int>  { typedef void type; }; 
#line 69
template<> struct __nv_isurf_trait< int1>  { typedef void type; }; 
#line 70
template<> struct __nv_isurf_trait< unsigned>  { typedef void type; }; 
#line 71
template<> struct __nv_isurf_trait< uint1>  { typedef void type; }; 
#line 72
template<> struct __nv_isurf_trait< __int64>  { typedef void type; }; 
#line 73
template<> struct __nv_isurf_trait< longlong1>  { typedef void type; }; 
#line 74
template<> struct __nv_isurf_trait< unsigned __int64>  { typedef void type; }; 
#line 75
template<> struct __nv_isurf_trait< ulonglong1>  { typedef void type; }; 
#line 76
template<> struct __nv_isurf_trait< float>  { typedef void type; }; 
#line 77
template<> struct __nv_isurf_trait< float1>  { typedef void type; }; 
#line 79
template<> struct __nv_isurf_trait< char2>  { typedef void type; }; 
#line 80
template<> struct __nv_isurf_trait< uchar2>  { typedef void type; }; 
#line 81
template<> struct __nv_isurf_trait< short2>  { typedef void type; }; 
#line 82
template<> struct __nv_isurf_trait< ushort2>  { typedef void type; }; 
#line 83
template<> struct __nv_isurf_trait< int2>  { typedef void type; }; 
#line 84
template<> struct __nv_isurf_trait< uint2>  { typedef void type; }; 
#line 85
template<> struct __nv_isurf_trait< longlong2>  { typedef void type; }; 
#line 86
template<> struct __nv_isurf_trait< ulonglong2>  { typedef void type; }; 
#line 87
template<> struct __nv_isurf_trait< float2>  { typedef void type; }; 
#line 89
template<> struct __nv_isurf_trait< char4>  { typedef void type; }; 
#line 90
template<> struct __nv_isurf_trait< uchar4>  { typedef void type; }; 
#line 91
template<> struct __nv_isurf_trait< short4>  { typedef void type; }; 
#line 92
template<> struct __nv_isurf_trait< ushort4>  { typedef void type; }; 
#line 93
template<> struct __nv_isurf_trait< int4>  { typedef void type; }; 
#line 94
template<> struct __nv_isurf_trait< uint4>  { typedef void type; }; 
#line 95
template<> struct __nv_isurf_trait< float4>  { typedef void type; }; 
__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 98
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 99
surf1Dread(T *ptr, ::cudaSurfaceObject_t obj, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)mode;::exit(___);}
#if 0
#line 100
{ 
#line 101
__nv_tex_surf_handler("__isurf1Dread", ptr, obj, x, mode); 
#line 102
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 104 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 105
surf1Dread(::cudaSurfaceObject_t surfObject, int x, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)boundaryMode;::exit(___);}
#if 0
#line 106
{ 
#line 107
T ret; 
#line 108
surf1Dread(&ret, surfObject, x, boundaryMode); 
#line 109
return ret; 
#line 110
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 112 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 113
surf2Dread(T *ptr, ::cudaSurfaceObject_t obj, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)mode;::exit(___);}
#if 0
#line 114
{ 
#line 115
__nv_tex_surf_handler("__isurf2Dread", ptr, obj, x, y, mode); 
#line 116
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 118 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 119
surf2Dread(::cudaSurfaceObject_t surfObject, int x, int y, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)boundaryMode;::exit(___);}
#if 0
#line 120
{ 
#line 121
T ret; 
#line 122
surf2Dread(&ret, surfObject, x, y, boundaryMode); 
#line 123
return ret; 
#line 124
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 127 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 128
surf3Dread(T *ptr, ::cudaSurfaceObject_t obj, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)mode;::exit(___);}
#if 0
#line 129
{ 
#line 130
__nv_tex_surf_handler("__isurf3Dread", ptr, obj, x, y, z, mode); 
#line 131
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 133 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 134
surf3Dread(::cudaSurfaceObject_t surfObject, int x, int y, int z, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;::exit(___);}
#if 0
#line 135
{ 
#line 136
T ret; 
#line 137
surf3Dread(&ret, surfObject, x, y, z, boundaryMode); 
#line 138
return ret; 
#line 139
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 141 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 142
surf1DLayeredread(T *ptr, ::cudaSurfaceObject_t obj, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;(void)mode;::exit(___);}
#if 0
#line 143
{ 
#line 144
__nv_tex_surf_handler("__isurf1DLayeredread", ptr, obj, x, layer, mode); 
#line 145
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 147 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 148
surf1DLayeredread(::cudaSurfaceObject_t surfObject, int x, int layer, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;::exit(___);}
#if 0
#line 149
{ 
#line 150
T ret; 
#line 151
surf1DLayeredread(&ret, surfObject, x, layer, boundaryMode); 
#line 152
return ret; 
#line 153
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 155 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 156
surf2DLayeredread(T *ptr, ::cudaSurfaceObject_t obj, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)mode;::exit(___);}
#if 0
#line 157
{ 
#line 158
__nv_tex_surf_handler("__isurf2DLayeredread", ptr, obj, x, y, layer, mode); 
#line 159
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 161 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 162
surf2DLayeredread(::cudaSurfaceObject_t surfObject, int x, int y, int layer, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;::exit(___);}
#if 0
#line 163
{ 
#line 164
T ret; 
#line 165
surf2DLayeredread(&ret, surfObject, x, y, layer, boundaryMode); 
#line 166
return ret; 
#line 167
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 169 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 170
surfCubemapread(T *ptr, ::cudaSurfaceObject_t obj, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)face;(void)mode;::exit(___);}
#if 0
#line 171
{ 
#line 172
__nv_tex_surf_handler("__isurfCubemapread", ptr, obj, x, y, face, mode); 
#line 173
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 175 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 176
surfCubemapread(::cudaSurfaceObject_t surfObject, int x, int y, int face, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;::exit(___);}
#if 0
#line 177
{ 
#line 178
T ret; 
#line 179
surfCubemapread(&ret, surfObject, x, y, face, boundaryMode); 
#line 180
return ret; 
#line 181
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 183 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 184
surfCubemapLayeredread(T *ptr, ::cudaSurfaceObject_t obj, int x, int y, int layerface, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layerface;(void)mode;::exit(___);}
#if 0
#line 185
{ 
#line 186
__nv_tex_surf_handler("__isurfCubemapLayeredread", ptr, obj, x, y, layerface, mode); 
#line 187
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 189 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 190
surfCubemapLayeredread(::cudaSurfaceObject_t surfObject, int x, int y, int layerface, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;::exit(___);}
#if 0
#line 191
{ 
#line 192
T ret; 
#line 193
surfCubemapLayeredread(&ret, surfObject, x, y, layerface, boundaryMode); 
#line 194
return ret; 
#line 195
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 197 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 198
surf1Dwrite(T val, ::cudaSurfaceObject_t obj, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)mode;::exit(___);}
#if 0
#line 199
{ 
#line 200
__nv_tex_surf_handler("__isurf1Dwrite_v2", &val, obj, x, mode); 
#line 201
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 203 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 204
surf2Dwrite(T val, ::cudaSurfaceObject_t obj, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)mode;::exit(___);}
#if 0
#line 205
{ 
#line 206
__nv_tex_surf_handler("__isurf2Dwrite_v2", &val, obj, x, y, mode); 
#line 207
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 209 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 210
surf3Dwrite(T val, ::cudaSurfaceObject_t obj, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)z;(void)mode;::exit(___);}
#if 0
#line 211
{ 
#line 212
__nv_tex_surf_handler("__isurf3Dwrite_v2", &val, obj, x, y, z, mode); 
#line 213
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 215 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 216
surf1DLayeredwrite(T val, ::cudaSurfaceObject_t obj, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)layer;(void)mode;::exit(___);}
#if 0
#line 217
{ 
#line 218
__nv_tex_surf_handler("__isurf1DLayeredwrite_v2", &val, obj, x, layer, mode); 
#line 219
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 221 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 222
surf2DLayeredwrite(T val, ::cudaSurfaceObject_t obj, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)layer;(void)mode;::exit(___);}
#if 0
#line 223
{ 
#line 224
__nv_tex_surf_handler("__isurf2DLayeredwrite_v2", &val, obj, x, y, layer, mode); 
#line 225
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 227 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 228
surfCubemapwrite(T val, ::cudaSurfaceObject_t obj, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)face;(void)mode;::exit(___);}
#if 0
#line 229
{ 
#line 230
__nv_tex_surf_handler("__isurfCubemapwrite_v2", &val, obj, x, y, face, mode); 
#line 231
} 
#endif

__pragma(warning(pop))

__pragma(warning(push))
__pragma(warning(disable : 4505)) /* "unreferenced local function has been removed" */

#line 233 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 234
surfCubemapLayeredwrite(T val, ::cudaSurfaceObject_t obj, int x, int y, int layerface, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)layerface;(void)mode;::exit(___);}
#if 0
#line 235
{ 
#line 236
__nv_tex_surf_handler("__isurfCubemapLayeredwrite_v2", &val, obj, x, y, layerface, mode); 
#line 237
} 
#endif

__pragma(warning(pop))

#line 2924 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt/device_functions.h"
extern "C" unsigned __stdcall __cudaPushCallConfiguration(dim3 gridDim, dim3 blockDim = 1, size_t sharedMem = 0, CUstream_st * stream = 0); 
#line 2969 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\crt/device_functions.h"
enum { 
#line 2970
__NV_ATOMIC_RELAXED, 
#line 2971
__NV_ATOMIC_CONSUME, 
#line 2972
__NV_ATOMIC_ACQUIRE, 
#line 2973
__NV_ATOMIC_RELEASE, 
#line 2974
__NV_ATOMIC_ACQ_REL, 
#line 2975
__NV_ATOMIC_SEQ_CST
#line 2976
}; 
#line 2978
enum { 
#line 2979
__NV_THREAD_SCOPE_THREAD, 
#line 2980
__NV_THREAD_SCOPE_BLOCK, 
#line 2981
__NV_THREAD_SCOPE_CLUSTER, 
#line 2982
__NV_THREAD_SCOPE_DEVICE, 
#line 2983
__NV_THREAD_SCOPE_SYSTEM
#line 2984
}; 
#line 68 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_launch_parameters.h"
extern "C" {
#line 71 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\include\\device_launch_parameters.h"
extern const uint3 __device_builtin_variable_threadIdx; 
#line 72
extern const uint3 __device_builtin_variable_blockIdx; 
#line 73
extern const dim3 __device_builtin_variable_blockDim; 
#line 74
extern const dim3 __device_builtin_variable_gridDim; 
#line 75
extern const int __device_builtin_variable_warpSize; 
#line 80
}
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstddef"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 27
namespace std { 
#line 28
using ::ptrdiff_t;
#line 30
using max_align_t = double; 
#line 31
using nullptr_t = decltype(nullptr); 
#line 99
}
#line 102
using std::max_align_t;
#line 111
#pragma warning(pop)
#pragma pack ( pop )
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\initializer_list"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 19
namespace std { 
#line 20
template < class _Elem >
class initializer_list {
public :
    using value_type = _Elem;
    using reference = const _Elem &;
    using const_reference = const _Elem &;
    using size_type = size_t;

    using iterator = const _Elem *;
    using const_iterator = const _Elem *;

    constexpr initializer_list ( ) noexcept : _First ( nullptr ), _Last ( nullptr ) { }

    constexpr initializer_list ( const _Elem * _First_arg, const _Elem * _Last_arg ) noexcept
        : _First ( _First_arg ), _Last ( _Last_arg ) { }

    [ [ nodiscard ] ] constexpr const _Elem * begin ( ) const noexcept {
        return _First;
    }

    [ [ nodiscard ] ] constexpr const _Elem * end ( ) const noexcept {
        return _Last;
    }

    [ [ nodiscard ] ] constexpr size_t size ( ) const noexcept {
        return static_cast < size_t > ( _Last - _First );
    }

private :
    const _Elem * _First;
    const _Elem * _Last;
};
#line 53
template < class _Elem >
[ [ nodiscard ] ] constexpr const _Elem * begin ( initializer_list < _Elem > _Ilist ) noexcept {
    return _Ilist . begin ( );
}
#line 58
template < class _Elem >
[ [ nodiscard ] ] constexpr const _Elem * end ( initializer_list < _Elem > _Ilist ) noexcept {
    return _Ilist . end ( );
}
#line 62
}
#line 65
#pragma warning(pop)
#pragma pack ( pop )
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\stdint.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 18
typedef signed char int8_t; 
#line 19
typedef short int16_t; 
#line 20
typedef int int32_t; 
#line 21
typedef __int64 int64_t; 
#line 22
typedef unsigned char uint8_t; 
#line 23
typedef unsigned short uint16_t; 
#line 24
typedef unsigned uint32_t; 
#line 25
typedef unsigned __int64 uint64_t; 
#line 27
typedef signed char int_least8_t; 
#line 28
typedef short int_least16_t; 
#line 29
typedef int int_least32_t; 
#line 30
typedef __int64 int_least64_t; 
#line 31
typedef unsigned char uint_least8_t; 
#line 32
typedef unsigned short uint_least16_t; 
#line 33
typedef unsigned uint_least32_t; 
#line 34
typedef unsigned __int64 uint_least64_t; 
#line 36
typedef signed char int_fast8_t; 
#line 37
typedef int int_fast16_t; 
#line 38
typedef int int_fast32_t; 
#line 39
typedef __int64 int_fast64_t; 
#line 40
typedef unsigned char uint_fast8_t; 
#line 41
typedef unsigned uint_fast16_t; 
#line 42
typedef unsigned uint_fast32_t; 
#line 43
typedef unsigned __int64 uint_fast64_t; 
#line 45
typedef __int64 intmax_t; 
#line 46
typedef unsigned __int64 uintmax_t; 
#line 136 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\stdint.h"
#pragma warning(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstdint"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 20
namespace std { 
#line 21
using ::int8_t;
#line 22
using ::int16_t;
#line 23
using ::int32_t;
#line 24
using ::int64_t;
#line 25
using ::uint8_t;
#line 26
using ::uint16_t;
#line 27
using ::uint32_t;
#line 28
using ::uint64_t;
#line 30
using ::int_least8_t;
#line 31
using ::int_least16_t;
#line 32
using ::int_least32_t;
#line 33
using ::int_least64_t;
#line 34
using ::uint_least8_t;
#line 35
using ::uint_least16_t;
#line 36
using ::uint_least32_t;
#line 37
using ::uint_least64_t;
#line 39
using ::int_fast8_t;
#line 40
using ::int_fast16_t;
#line 41
using ::int_fast32_t;
#line 42
using ::int_fast64_t;
#line 43
using ::uint_fast8_t;
#line 44
using ::uint_fast16_t;
#line 45
using ::uint_fast32_t;
#line 46
using ::uint_fast64_t;
#line 48
using ::intmax_t;
#line 49
using ::intptr_t;
#line 50
using ::uintmax_t;
#line 51
using ::uintptr_t;
#line 54
namespace [[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to suppress this warning.")]] tr1 { 
#line 55
using ::int8_t;
#line 56
using ::int16_t;
#line 57
using ::int32_t;
#line 58
using ::int64_t;
#line 59
using ::uint8_t;
#line 60
using ::uint16_t;
#line 61
using ::uint32_t;
#line 62
using ::uint64_t;
#line 64
using ::int_least8_t;
#line 65
using ::int_least16_t;
#line 66
using ::int_least32_t;
#line 67
using ::int_least64_t;
#line 68
using ::uint_least8_t;
#line 69
using ::uint_least16_t;
#line 70
using ::uint_least32_t;
#line 71
using ::uint_least64_t;
#line 73
using ::int_fast8_t;
#line 74
using ::int_fast16_t;
#line 75
using ::int_fast32_t;
#line 76
using ::int_fast64_t;
#line 77
using ::uint_fast8_t;
#line 78
using ::uint_fast16_t;
#line 79
using ::uint_fast32_t;
#line 80
using ::uint_fast64_t;
#line 82
using ::intmax_t;
#line 83
using ::intptr_t;
#line 84
using ::uintmax_t;
#line 85
using ::uintptr_t;
#line 86
}
#line 88 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstdint"
}
#line 92
#pragma warning(pop)
#pragma pack ( pop )
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstring"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 20
namespace std { 
#pragma warning(push)
#pragma warning(disable : 4995)
#line 25
using ::memchr;
#line 26
using ::memcmp;
#line 27
using ::memcpy;
#line 28
using ::memmove;
#line 29
using ::memset;
#line 30
using ::strcat;
#line 31
using ::strchr;
#line 32
using ::strcmp;
#line 33
using ::strcoll;
#line 34
using ::strcpy;
#line 35
using ::strcspn;
#line 36
using ::strerror;
#line 37
using ::strlen;
#line 38
using ::strncat;
#line 39
using ::strncmp;
#line 40
using ::strncpy;
#line 41
using ::strpbrk;
#line 42
using ::strrchr;
#line 43
using ::strspn;
#line 44
using ::strstr;
#line 45
using ::strtok;
#line 46
using ::strxfrm;
#line 48
#pragma warning(pop)
}
#line 53
#pragma warning(pop)
#pragma pack ( pop )
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 30
namespace std { 
#line 31
template< class > constexpr bool 
#line 32
_Always_false = false; 
#line 34
template< bool _First_value, class _First, class ..._Rest> 
#line 35
struct _Conjunction { 
#line 36
using type = _First; 
#line 37
}; 
#line 39
template< class _True, class _Next, class ..._Rest> 
#line 40
struct _Conjunction< true, _True, _Next, _Rest...>  { 
#line 41
using type = typename std::_Conjunction< static_cast< bool>(_Next::value), _Next, _Rest...> ::type; 
#line 42
}; 
#line 44
template< class ..._Traits> 
#line 45
struct conjunction : public true_type { }; 
#line 47
template< class _First, class ..._Rest> 
#line 48
struct conjunction< _First, _Rest...>  : public _Conjunction< static_cast< bool>(_First::value), _First, _Rest...> ::type { 
#line 50
}; 
#line 52
template< class ..._Traits> constexpr bool 
#line 53
conjunction_v = (conjunction< _Traits...> ::value); 
#line 55
template< class _Trait> 
#line 56
struct negation : public bool_constant< !(static_cast< bool>(_Trait::value))>  { }; 
#line 58
template< class _Trait> constexpr bool 
#line 59
negation_v = (negation< _Trait> ::value); 
#line 61
template< class _Ty> constexpr bool 
#line 62
is_void_v = is_same_v< remove_cv_t< _Ty> , void> ; 
#line 64
template< class _Ty> 
#line 65
struct is_void : public bool_constant< is_void_v< _Ty> >  { }; 
#line 67
template< class ..._Types> using void_t = void; 
#line 70
template< class _Ty> 
#line 71
struct _Identity { 
#line 72
using type = _Ty; 
#line 73
}; 
#line 74
template< class _Ty> using _Identity_t
#line 75
 [[msvc::known_semantics]] = typename _Identity< _Ty> ::type; 
#line 78
template< class _Ty> 
#line 79
struct add_const { 
#line 80
using type = const _Ty; 
#line 81
}; 
#line 83
template< class _Ty> using add_const_t = typename add_const< _Ty> ::type; 
#line 86
template< class _Ty> 
#line 87
struct add_volatile { 
#line 88
using type = volatile _Ty; 
#line 89
}; 
#line 91
template< class _Ty> using add_volatile_t = typename add_volatile< _Ty> ::type; 
#line 94
template< class _Ty> 
#line 95
struct add_cv { 
#line 96
using type = const volatile _Ty; 
#line 97
}; 
#line 99
template< class _Ty> using add_cv_t = typename add_cv< _Ty> ::type; 
#line 102
template< class _Ty, class  = void> 
#line 103
struct _Add_reference { 
#line 104
using _Lvalue = _Ty; 
#line 105
using _Rvalue = _Ty; 
#line 106
}; 
#line 108
template< class _Ty> 
#line 109
struct _Add_reference< _Ty, void_t< _Ty &> >  { 
#line 110
using _Lvalue = _Ty &; 
#line 111
using _Rvalue = _Ty &&; 
#line 112
}; 
#line 114
template< class _Ty> 
#line 115
struct add_lvalue_reference { 
#line 116
using type = typename _Add_reference< _Ty> ::_Lvalue; 
#line 117
}; 
#line 119
template< class _Ty> using add_lvalue_reference_t = typename _Add_reference< _Ty> ::_Lvalue; 
#line 122
template< class _Ty> 
#line 123
struct add_rvalue_reference { 
#line 124
using type = typename _Add_reference< _Ty> ::_Rvalue; 
#line 125
}; 
#line 127
template< class _Ty> using add_rvalue_reference_t = typename _Add_reference< _Ty> ::_Rvalue; 
#line 130
template < class _Ty >
add_rvalue_reference_t < _Ty > declval ( ) noexcept {
    static_assert ( false, "Calling declval is ill-formed, see N4950 [declval]/2." );
}
#line 135
template< class _Ty> 
#line 136
struct remove_extent { 
#line 137
using type = _Ty; 
#line 138
}; 
#line 140
template< class _Ty, size_t _Ix> 
#line 141
struct remove_extent< _Ty [_Ix]>  { 
#line 142
using type = _Ty; 
#line 143
}; 
#line 145
template< class _Ty> 
#line 146
struct remove_extent< _Ty []>  { 
#line 147
using type = _Ty; 
#line 148
}; 
#line 150
template< class _Ty> using remove_extent_t = typename remove_extent< _Ty> ::type; 
#line 153
template< class _Ty> 
#line 154
struct remove_all_extents { 
#line 155
using type = _Ty; 
#line 156
}; 
#line 158
template< class _Ty, size_t _Ix> 
#line 159
struct remove_all_extents< _Ty [_Ix]>  { 
#line 160
using type = typename std::remove_all_extents< _Ty> ::type; 
#line 161
}; 
#line 163
template< class _Ty> 
#line 164
struct remove_all_extents< _Ty []>  { 
#line 165
using type = typename std::remove_all_extents< _Ty> ::type; 
#line 166
}; 
#line 168
template< class _Ty> using remove_all_extents_t = typename remove_all_extents< _Ty> ::type; 
#line 171
template< class _Ty> 
#line 172
struct remove_pointer { 
#line 173
using type = _Ty; 
#line 174
}; 
#line 176
template< class _Ty> 
#line 177
struct remove_pointer< _Ty *>  { 
#line 178
using type = _Ty; 
#line 179
}; 
#line 181
template< class _Ty> 
#line 182
struct remove_pointer< _Ty *const>  { 
#line 183
using type = _Ty; 
#line 184
}; 
#line 186
template< class _Ty> 
#line 187
struct remove_pointer< _Ty *volatile>  { 
#line 188
using type = _Ty; 
#line 189
}; 
#line 191
template< class _Ty> 
#line 192
struct remove_pointer< _Ty *const volatile>  { 
#line 193
using type = _Ty; 
#line 194
}; 
#line 196
template< class _Ty> using remove_pointer_t = typename remove_pointer< _Ty> ::type; 
#line 199
template< class _Ty, class  = void> 
#line 200
struct _Add_pointer { 
#line 201
using type = _Ty; 
#line 202
}; 
#line 204
template< class _Ty> 
#line 205
struct _Add_pointer< _Ty, void_t< remove_reference_t< _Ty>  *> >  { 
#line 206
using type = remove_reference_t< _Ty>  *; 
#line 207
}; 
#line 209
template< class _Ty> 
#line 210
struct add_pointer { 
#line 211
using type = typename _Add_pointer< _Ty> ::type; 
#line 212
}; 
#line 214
template< class _Ty> using add_pointer_t = typename _Add_pointer< _Ty> ::type; 
#line 217
template< class > constexpr bool 
#line 218
is_array_v = false; 
#line 220
template< class _Ty, size_t _Nx> constexpr bool 
#line 221
is_array_v< _Ty [_Nx]>  = true; 
#line 223
template< class _Ty> constexpr bool 
#line 224
is_array_v< _Ty []>  = true; 
#line 226
template< class _Ty> 
#line 227
struct is_array : public bool_constant< is_array_v< _Ty> >  { }; 
#line 249 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class > constexpr bool 
#line 250
is_lvalue_reference_v = false; 
#line 252
template< class _Ty> constexpr bool 
#line 253
is_lvalue_reference_v< _Ty &>  = true; 
#line 255
template< class _Ty> 
#line 256
struct is_lvalue_reference : public bool_constant< is_lvalue_reference_v< _Ty> >  { }; 
#line 258
template< class > constexpr bool 
#line 259
is_rvalue_reference_v = false; 
#line 261
template< class _Ty> constexpr bool 
#line 262
is_rvalue_reference_v< _Ty &&>  = true; 
#line 264
template< class _Ty> 
#line 265
struct is_rvalue_reference : public bool_constant< is_rvalue_reference_v< _Ty> >  { }; 
#line 267
template< class > constexpr bool 
#line 268
is_reference_v = false; 
#line 270
template< class _Ty> constexpr bool 
#line 271
is_reference_v< _Ty &>  = true; 
#line 273
template< class _Ty> constexpr bool 
#line 274
is_reference_v< _Ty &&>  = true; 
#line 276
template< class _Ty> 
#line 277
struct is_reference : public bool_constant< is_reference_v< _Ty> >  { }; 
#line 279
template< class > constexpr bool 
#line 280
is_pointer_v = false; 
#line 282
template< class _Ty> constexpr bool 
#line 283
is_pointer_v< _Ty *>  = true; 
#line 285
template< class _Ty> constexpr bool 
#line 286
is_pointer_v< _Ty *const>  = true; 
#line 288
template< class _Ty> constexpr bool 
#line 289
is_pointer_v< _Ty *volatile>  = true; 
#line 291
template< class _Ty> constexpr bool 
#line 292
is_pointer_v< _Ty *const volatile>  = true; 
#line 294
template< class _Ty> 
#line 295
struct is_pointer : public bool_constant< is_pointer_v< _Ty> >  { }; 
#line 297
template< class _Ty> constexpr bool 
#line 298
is_null_pointer_v = is_same_v< remove_cv_t< _Ty> , std::nullptr_t> ; 
#line 301
template< class _Ty> 
#line 302
struct is_null_pointer : public bool_constant< is_null_pointer_v< _Ty> >  { }; 
#line 304
template< class _Ty> 
#line 305
struct is_union : public bool_constant< __is_union(_Ty)>  { }; 
#line 307
template< class _Ty> constexpr bool 
#line 308
is_union_v = __is_union(_Ty); 
#line 310
template< class _Ty> 
#line 311
struct is_class : public bool_constant< __is_class(_Ty)>  { }; 
#line 313
template< class _Ty> constexpr bool 
#line 314
is_class_v = __is_class(_Ty); 
#line 316
template< class _Ty> constexpr bool 
#line 317
is_fundamental_v = (is_arithmetic_v< _Ty>  || is_void_v< _Ty> ) || is_null_pointer_v< _Ty> ; 
#line 319
template< class _Ty> 
#line 320
struct is_fundamental : public bool_constant< is_fundamental_v< _Ty> >  { }; 
#line 322
template< class _From, class _To> 
#line 323
struct is_convertible : public bool_constant< __is_convertible_to(_From, _To)>  { 
#line 325
}; 
#line 327
template< class _From, class _To> constexpr bool 
#line 328
is_convertible_v = __is_convertible_to(_From, _To); 
#line 330
template< class _Ty> 
#line 331
struct is_enum : public bool_constant< __is_enum(_Ty)>  { }; 
#line 333
template< class _Ty> constexpr bool 
#line 334
is_enum_v = __is_enum(_Ty); 
#line 344 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class _Ty> 
#line 345
struct is_compound : public bool_constant< !is_fundamental_v< _Ty> >  { }; 
#line 347
template< class _Ty> constexpr bool 
#line 348
is_compound_v = (!is_fundamental_v< _Ty> ); 
#line 473 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class ..._Types> 
#line 474
struct _Arg_types { }; 
#line 476
template< class _Ty1> 
#line 477
struct _Arg_types< _Ty1>  { 
#line 478
using argument_type = _Ty1; 
#line 479
}; 
#line 481
template< class _Ty1, class _Ty2> 
#line 482
struct _Arg_types< _Ty1, _Ty2>  { 
#line 483
using first_argument_type = _Ty1; 
#line 484
using second_argument_type = _Ty2; 
#line 485
}; 
#line 487
template< class _Ty> 
#line 488
struct _Is_memfunptr { 
#line 489
using _Bool_type = false_type; 
#line 490
}; 
#line 502
template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...)>  : public _Arg_types< _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...)>  : public _Arg_types< _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const>  : public _Arg_types< const _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const>  : public _Arg_types< const _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) volatile>  : public _Arg_types< volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) volatile>  : public _Arg_types< volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const volatile>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const volatile>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) &>  : public _Arg_types< _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) &>  : public _Arg_types< _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const &>  : public _Arg_types< const _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const &>  : public _Arg_types< const _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) volatile &>  : public _Arg_types< volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) volatile &>  : public _Arg_types< volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const volatile &>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const volatile &>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) &&>  : public _Arg_types< _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) &&>  : public _Arg_types< _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const &&>  : public _Arg_types< const _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const &&>  : public _Arg_types< const _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) volatile &&>  : public _Arg_types< volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) volatile &&>  : public _Arg_types< volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const volatile &&>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const volatile &&>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; 
#line 515
template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...)>  { using _Bool_type = true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const>  { using _Bool_type = true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) volatile>  { using _Bool_type = true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const volatile>  { using _Bool_type = true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) &>  { using _Bool_type = true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const &>  { using _Bool_type = true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) volatile &>  { using _Bool_type = true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const volatile &>  { using _Bool_type = true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) &&>  { using _Bool_type = true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const &&>  { using _Bool_type = true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) volatile &&>  { using _Bool_type = true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const volatile &&>  { using _Bool_type = true_type; using result_type = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; 
#line 538 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class _Ty> constexpr bool 
#line 539
is_member_function_pointer_v = (_Is_memfunptr< remove_cv_t< _Ty> > ::_Bool_type::value); 
#line 542 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class _Ty> 
#line 543
struct is_member_function_pointer : public bool_constant< is_member_function_pointer_v< _Ty> >  { }; 
#line 545
template< class > constexpr bool 
#line 546
is_const_v = false; 
#line 548
template< class _Ty> constexpr bool 
#line 549
is_const_v< const _Ty>  = true; 
#line 551
template< class _Ty> 
#line 552
struct is_const : public bool_constant< is_const_v< _Ty> >  { }; 
#line 554
template< class > constexpr bool 
#line 555
is_volatile_v = false; 
#line 557
template< class _Ty> constexpr bool 
#line 558
is_volatile_v< volatile _Ty>  = true; 
#line 560
template< class _Ty> 
#line 561
struct is_volatile : public bool_constant< is_volatile_v< _Ty> >  { }; 
#line 563
template< class _Ty> constexpr bool 
#line 564
is_function_v = ((!is_const_v< const _Ty> ) && (!is_reference_v< _Ty> )); 
#line 567
template< class _Ty> 
#line 568
struct is_function : public bool_constant< is_function_v< _Ty> >  { }; 
#line 570
template< class _Ty> constexpr bool 
#line 571
is_object_v = is_const_v< const _Ty>  && (!is_void_v< _Ty> ); 
#line 574
template< class _Ty> 
#line 575
struct is_object : public bool_constant< is_object_v< _Ty> >  { }; 
#line 577
template< class > 
#line 578
struct _Is_member_object_pointer { 
#line 579
static constexpr bool value = false; 
#line 580
}; 
#line 582
template< class _Ty1, class _Ty2> 
#line 583
struct _Is_member_object_pointer< _Ty1 _Ty2::*>  { 
#line 584
static constexpr bool value = (!is_function_v< _Ty1> ); 
#line 585
using _Class_type = _Ty2; 
#line 586
}; 
#line 592
template< class _Ty> constexpr bool 
#line 593
is_member_object_pointer_v = (_Is_member_object_pointer< remove_cv_t< _Ty> > ::value); 
#line 596 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class _Ty> 
#line 597
struct is_member_object_pointer : public bool_constant< is_member_object_pointer_v< _Ty> >  { }; 
#line 603
template< class _Ty> constexpr bool 
#line 604
is_member_pointer_v = is_member_object_pointer_v< _Ty>  || is_member_function_pointer_v< _Ty> ; 
#line 607 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class _Ty> 
#line 608
struct is_member_pointer : public bool_constant< is_member_pointer_v< _Ty> >  { }; 
#line 610
template< class _Ty> constexpr bool 
#line 611
is_scalar_v = (((is_arithmetic_v< _Ty>  || is_enum_v< _Ty> ) || is_pointer_v< _Ty> ) || is_member_pointer_v< _Ty> ) || is_null_pointer_v< _Ty> ; 
#line 614
template< class _Ty> 
#line 615
struct is_scalar : public bool_constant< is_scalar_v< _Ty> >  { }; 
#line 617
template< class _Ty> 
#line 618
struct is_pod : public bool_constant< __is_pod(_Ty)>  { }; 
#line 620
template< class _Ty> constexpr bool 
#line 621
is_pod_v = __is_pod(_Ty); 
#line 623
template< class _Ty> 
#line 624
struct is_empty : public bool_constant< __is_empty(_Ty)>  { }; 
#line 626
template< class _Ty> constexpr bool 
#line 627
is_empty_v = __is_empty(_Ty); 
#line 629
template< class _Ty> 
#line 630
struct is_polymorphic : public bool_constant< __is_polymorphic(_Ty)>  { }; 
#line 632
template< class _Ty> constexpr bool 
#line 633
is_polymorphic_v = __is_polymorphic(_Ty); 
#line 635
template< class _Ty> 
#line 636
struct is_abstract : public bool_constant< __is_abstract(_Ty)>  { }; 
#line 638
template< class _Ty> constexpr bool 
#line 639
is_abstract_v = __is_abstract(_Ty); 
#line 641
template< class _Ty> 
#line 642
struct is_final : public bool_constant< __is_final(_Ty)>  { }; 
#line 644
template< class _Ty> constexpr bool 
#line 645
is_final_v = __is_final(_Ty); 
#line 647
template< class _Ty> 
#line 648
struct is_standard_layout : public bool_constant< __is_standard_layout(_Ty)>  { }; 
#line 650
template< class _Ty> constexpr bool 
#line 651
is_standard_layout_v = __is_standard_layout(_Ty); 
#line 654
template< class _Ty> 
#line 655
struct is_literal_type : public bool_constant< __is_literal_type(_Ty)>  { 
#line 657
}; 
#line 659
template< class _Ty> constexpr bool 
#line 660
is_literal_type_v = __is_literal_type(_Ty); 
#line 663 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class _Ty> 
#line 664
struct is_trivial : public bool_constant< __is_trivial(_Ty)>  { }; 
#line 666
template< class _Ty> constexpr bool 
#line 667
is_trivial_v = __is_trivial(_Ty); 
#line 669
template< class _Ty> 
#line 670
struct is_trivially_copyable : public bool_constant< __is_trivially_copyable(_Ty)>  { 
#line 672
}; 
#line 674
template< class _Ty> constexpr bool 
#line 675
is_trivially_copyable_v = __is_trivially_copyable(_Ty); 
#line 677
template< class _Ty> 
#line 678
struct has_virtual_destructor : public bool_constant< __has_virtual_destructor(_Ty)>  { 
#line 680
}; 
#line 682
template< class _Ty> constexpr bool 
#line 683
has_virtual_destructor_v = __has_virtual_destructor(_Ty); 
#line 712 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class _Ty, class ..._Args> 
#line 713
struct is_constructible : public bool_constant< __is_constructible(_Ty, _Args...)>  { 
#line 715
}; 
#line 717
template< class _Ty, class ..._Args> constexpr bool 
#line 718
is_constructible_v = __is_constructible(_Ty, _Args...); 
#line 720
template< class _Ty> 
#line 721
struct is_copy_constructible : public bool_constant< __is_constructible(_Ty, add_lvalue_reference_t< const _Ty> )>  { 
#line 723
}; 
#line 725
template< class _Ty> constexpr bool 
#line 726
is_copy_constructible_v = __is_constructible(_Ty, add_lvalue_reference_t< const _Ty> ); 
#line 728
template< class _Ty> 
#line 729
struct is_default_constructible : public bool_constant< __is_constructible(_Ty)>  { 
#line 731
}; 
#line 733
template< class _Ty> constexpr bool 
#line 734
is_default_constructible_v = __is_constructible(_Ty); 
#line 736
template< class _Ty, class  = void> 
#line 737
struct _Is_implicitly_default_constructible : public false_type { 
#line 739
}; 
#line 741
template< class _Ty> void _Implicitly_default_construct(const _Ty &); 
#line 744
template< class _Ty> 
#line 745
struct _Is_implicitly_default_constructible< _Ty, void_t< decltype(_Implicitly_default_construct< _Ty> ({}))> >  : public true_type { 
#line 746
}; 
#line 748
template< class _Ty> 
#line 749
struct is_move_constructible : public bool_constant< __is_constructible(_Ty, _Ty)>  { 
#line 751
}; 
#line 753
template< class _Ty> constexpr bool 
#line 754
is_move_constructible_v = __is_constructible(_Ty, _Ty); 
#line 756
template< class _To, class _From> 
#line 757
struct is_assignable : public bool_constant< __is_assignable(_To, _From)>  { }; 
#line 759
template< class _To, class _From> constexpr bool 
#line 760
is_assignable_v = __is_assignable(_To, _From); 
#line 766 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class _To, class _From> using _Is_assignable_no_precondition_check = is_assignable< _To, _From> ; 
#line 770 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class _Ty> 
#line 771
struct is_copy_assignable : public bool_constant< __is_assignable(add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< const _Ty> )>  { 
#line 774
}; 
#line 776
template< class _Ty> constexpr bool 
#line 777
is_copy_assignable_v = __is_assignable(add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< const _Ty> ); 
#line 789 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class _Ty> using _Is_copy_assignable_no_precondition_check = is_copy_assignable< _Ty> ; 
#line 792
template< class _Ty> constexpr bool 
#line 793
_Is_copy_assignable_unchecked_v = is_copy_assignable_v< _Ty> ; 
#line 796 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class _Ty> 
#line 797
struct is_move_assignable : public bool_constant< __is_assignable(add_lvalue_reference_t< _Ty> , _Ty)>  { 
#line 799
}; 
#line 801
template< class _Ty> constexpr bool 
#line 802
is_move_assignable_v = __is_assignable(add_lvalue_reference_t< _Ty> , _Ty); 
#line 813 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class _Ty> using _Is_move_assignable_no_precondition_check = is_move_assignable< _Ty> ; 
#line 816
template< class _Ty> constexpr bool 
#line 817
_Is_move_assignable_unchecked_v = is_move_assignable_v< _Ty> ; 
#line 820 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class _Ty> 
#line 821
struct is_destructible : public bool_constant< __is_destructible(_Ty)>  { 
#line 823
}; 
#line 825
template< class _Ty> constexpr bool 
#line 826
is_destructible_v = __is_destructible(_Ty); 
#line 828
template< class _Ty, class ..._Args> 
#line 829
struct is_trivially_constructible : public bool_constant< __is_trivially_constructible(_Ty, _Args...)>  { 
#line 831
}; 
#line 833
template< class _Ty, class ..._Args> constexpr bool 
#line 834
is_trivially_constructible_v = __is_trivially_constructible(_Ty, _Args...); 
#line 836
template< class _Ty> 
#line 837
struct is_trivially_copy_constructible : public bool_constant< __is_trivially_constructible(_Ty, add_lvalue_reference_t< const _Ty> )>  { 
#line 840
}; 
#line 842
template< class _Ty> constexpr bool 
#line 843
is_trivially_copy_constructible_v = __is_trivially_constructible(_Ty, add_lvalue_reference_t< const _Ty> ); 
#line 845
template< class _Ty> 
#line 846
struct is_trivially_default_constructible : public bool_constant< __is_trivially_constructible(_Ty)>  { 
#line 848
}; 
#line 850
template< class _Ty> constexpr bool 
#line 851
is_trivially_default_constructible_v = __is_trivially_constructible(_Ty); 
#line 853
template< class _Ty> 
#line 854
struct is_trivially_move_constructible : public bool_constant< __is_trivially_constructible(_Ty, _Ty)>  { 
#line 856
}; 
#line 858
template< class _Ty> constexpr bool 
#line 859
is_trivially_move_constructible_v = __is_trivially_constructible(_Ty, _Ty); 
#line 861
template< class _To, class _From> 
#line 862
struct is_trivially_assignable : public bool_constant< __is_trivially_assignable(_To, _From)>  { 
#line 864
}; 
#line 866
template< class _To, class _From> constexpr bool 
#line 867
is_trivially_assignable_v = __is_trivially_assignable(_To, _From); 
#line 869
template< class _Ty> 
#line 870
struct is_trivially_copy_assignable : public bool_constant< __is_trivially_assignable(add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< const _Ty> )>  { 
#line 873
}; 
#line 875
template< class _Ty> constexpr bool 
#line 876
is_trivially_copy_assignable_v = __is_trivially_assignable(add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< const _Ty> ); 
#line 879
template< class _Ty> 
#line 880
struct is_trivially_move_assignable : public bool_constant< __is_trivially_assignable(add_lvalue_reference_t< _Ty> , _Ty)>  { 
#line 882
}; 
#line 884
template< class _Ty> constexpr bool 
#line 885
is_trivially_move_assignable_v = __is_trivially_assignable(add_lvalue_reference_t< _Ty> , _Ty); 
#line 887
template< class _Ty> 
#line 888
struct is_trivially_destructible : public bool_constant< __is_trivially_destructible(_Ty)>  { 
#line 890
}; 
#line 892
template< class _Ty> constexpr bool 
#line 893
is_trivially_destructible_v = __is_trivially_destructible(_Ty); 
#line 895
template< class _Ty, class ..._Args> 
#line 896
struct is_nothrow_constructible : public bool_constant< __is_nothrow_constructible(_Ty, _Args...)>  { 
#line 898
}; 
#line 900
template< class _Ty, class ..._Args> constexpr bool 
#line 901
is_nothrow_constructible_v = __is_nothrow_constructible(_Ty, _Args...); 
#line 903
template< class _Ty> 
#line 904
struct is_nothrow_copy_constructible : public bool_constant< __is_nothrow_constructible(_Ty, add_lvalue_reference_t< const _Ty> )>  { 
#line 908
}; 
#line 910
template< class _Ty> constexpr bool 
#line 911
is_nothrow_copy_constructible_v = __is_nothrow_constructible(_Ty, add_lvalue_reference_t< const _Ty> ); 
#line 913
template< class _Ty> 
#line 914
struct is_nothrow_default_constructible : public bool_constant< __is_nothrow_constructible(_Ty)>  { 
#line 916
}; 
#line 918
template< class _Ty> constexpr bool 
#line 919
is_nothrow_default_constructible_v = __is_nothrow_constructible(_Ty); 
#line 921
template< class _Ty> 
#line 922
struct is_nothrow_move_constructible : public bool_constant< __is_nothrow_constructible(_Ty, _Ty)>  { 
#line 924
}; 
#line 926
template< class _Ty> constexpr bool 
#line 927
is_nothrow_move_constructible_v = __is_nothrow_constructible(_Ty, _Ty); 
#line 929
template< class _To, class _From> 
#line 930
struct is_nothrow_assignable : public bool_constant< __is_nothrow_assignable(_To, _From)>  { 
#line 932
}; 
#line 934
template< class _To, class _From> constexpr bool 
#line 935
is_nothrow_assignable_v = __is_nothrow_assignable(_To, _From); 
#line 937
template< class _Ty> 
#line 938
struct is_nothrow_copy_assignable : public bool_constant< __is_nothrow_assignable(add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< const _Ty> )>  { 
#line 941
}; 
#line 943
template< class _Ty> constexpr bool 
#line 944
is_nothrow_copy_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< const _Ty> ); 
#line 947
template< class _Ty> 
#line 948
struct is_nothrow_move_assignable : public bool_constant< __is_nothrow_assignable(add_lvalue_reference_t< _Ty> , _Ty)>  { 
#line 950
}; 
#line 952
template< class _Ty> constexpr bool 
#line 953
is_nothrow_move_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t< _Ty> , _Ty); 
#line 955
template< class _Ty> 
#line 956
struct is_nothrow_destructible : public bool_constant< __is_nothrow_destructible(_Ty)>  { 
#line 959
}; 
#line 961
template< class _Ty> constexpr bool 
#line 962
is_nothrow_destructible_v = __is_nothrow_destructible(_Ty); 
#line 964
template< class _Ty, bool  = is_integral_v< _Ty> > 
#line 965
struct _Sign_base { 
#line 966
using _Uty = remove_cv_t< _Ty> ; 
#line 968
static constexpr bool _Signed = ((static_cast< _Uty>(-1)) < (static_cast< _Uty>(0))); 
#line 969
static constexpr bool _Unsigned = (!_Signed); 
#line 970
}; 
#line 972
template< class _Ty> 
#line 973
struct _Sign_base< _Ty, false>  { 
#line 975
static constexpr bool _Signed = is_floating_point_v< _Ty> ; 
#line 976
static constexpr bool _Unsigned = false; 
#line 977
}; 
#line 979
template< class _Ty> 
#line 980
struct is_signed : public bool_constant< _Sign_base< _Ty> ::_Signed>  { }; 
#line 982
template< class _Ty> constexpr bool 
#line 983
is_signed_v = (_Sign_base< _Ty> ::_Signed); 
#line 985
template< class _Ty> 
#line 986
struct is_unsigned : public bool_constant< _Sign_base< _Ty> ::_Unsigned>  { }; 
#line 988
template< class _Ty> constexpr bool 
#line 989
is_unsigned_v = (_Sign_base< _Ty> ::_Unsigned); 
#line 991
template< class _Ty> constexpr bool 
#line 992
_Is_nonbool_integral = is_integral_v< _Ty>  && (!is_same_v< remove_cv_t< _Ty> , bool> ); 
#line 994
template< bool > 
#line 995
struct _Select { 
#line 996
template< class _Ty1, class > using _Apply = _Ty1; 
#line 998
}; 
#line 1001
template<> struct _Select< false>  { 
#line 1002
template< class , class _Ty2> using _Apply = _Ty2; 
#line 1004
}; 
#line 1006
template< size_t > struct _Make_signed2; 
#line 1010
template<> struct _Make_signed2< 1Ui64>  { 
#line 1011
template< class > using _Apply = signed char; 
#line 1013
}; 
#line 1016
template<> struct _Make_signed2< 2Ui64>  { 
#line 1017
template< class > using _Apply = short; 
#line 1019
}; 
#line 1022
template<> struct _Make_signed2< 4Ui64>  { 
#line 1023
template< class _Ty> using _Apply = typename _Select< is_same_v< _Ty, long>  || is_same_v< _Ty, unsigned long> > ::template _Apply< long, int> ; 
#line 1026
}; 
#line 1029
template<> struct _Make_signed2< 8Ui64>  { 
#line 1030
template< class > using _Apply = __int64; 
#line 1032
}; 
#line 1034
template< class _Ty> using _Make_signed1 = typename _Make_signed2< sizeof(_Ty)> ::template _Apply< _Ty> ; 
#line 1038
template< class _Ty> 
#line 1039
struct make_signed { 
#line 1040
static_assert((_Is_nonbool_integral< _Ty>  || is_enum_v< _Ty> ), "make_signed<T> requires that T shall be a (possibly cv-qualified) integral type or enumeration but not a bool type.");
#line 1044
using type = typename remove_cv< _Ty> ::template _Apply< _Make_signed1> ; 
#line 1045
}; 
#line 1047
template< class _Ty> using make_signed_t = typename make_signed< _Ty> ::type; 
#line 1050
template< size_t > struct _Make_unsigned2; 
#line 1054
template<> struct _Make_unsigned2< 1Ui64>  { 
#line 1055
template< class > using _Apply = unsigned char; 
#line 1057
}; 
#line 1060
template<> struct _Make_unsigned2< 2Ui64>  { 
#line 1061
template< class > using _Apply = unsigned short; 
#line 1063
}; 
#line 1066
template<> struct _Make_unsigned2< 4Ui64>  { 
#line 1067
template< class _Ty> using _Apply = typename _Select< is_same_v< _Ty, long>  || is_same_v< _Ty, unsigned long> > ::template _Apply< unsigned long, unsigned> ; 
#line 1071
}; 
#line 1074
template<> struct _Make_unsigned2< 8Ui64>  { 
#line 1075
template< class > using _Apply = unsigned __int64; 
#line 1077
}; 
#line 1079
template< class _Ty> using _Make_unsigned1 = typename _Make_unsigned2< sizeof(_Ty)> ::template _Apply< _Ty> ; 
#line 1083
template< class _Ty> 
#line 1084
struct make_unsigned { 
#line 1085
static_assert((_Is_nonbool_integral< _Ty>  || is_enum_v< _Ty> ), "make_unsigned<T> requires that T shall be a (possibly cv-qualified) integral type or enumeration but not a bool type.");
#line 1089
using type = typename remove_cv< _Ty> ::template _Apply< _Make_unsigned1> ; 
#line 1090
}; 
#line 1092
template< class _Ty> using make_unsigned_t = typename make_unsigned< _Ty> ::type; 
#line 1095
template < class _Rep >
constexpr make_unsigned_t < _Rep > _Unsigned_value ( _Rep _Val ) {
    return static_cast < make_unsigned_t < _Rep >> ( _Val );
}
#line 1100
template< class _Ty> 
#line 1101
struct alignment_of : public integral_constant< unsigned __int64, __alignof(_Ty)>  { }; 
#line 1103
template< class _Ty> constexpr size_t 
#line 1104
alignment_of_v = __alignof(_Ty); 
#line 1106
template< class _Ty, size_t _Len> 
#line 1107
union _Align_type { 
#line 1108
_Ty _Val; 
#line 1109
char _Pad[_Len]; 
#line 1110
}; 
#line 1112
template< size_t _Len, size_t _Align, class _Ty, bool _Ok> struct _Aligned; 
#line 1115
template< size_t _Len, size_t _Align, class _Ty> 
#line 1116
struct _Aligned< _Len, _Align, _Ty, true>  { 
#line 1117
using type = _Align_type< _Ty, _Len> ; 
#line 1118
}; 
#line 1120
template< size_t _Len, size_t _Align> 
#line 1121
struct _Aligned< _Len, _Align, double, false>  { 
#line 1128
static_assert((_Always_false< _Aligned> ), "You\'ve instantiated std::aligned_storage<Len, Align> with an extended alignment (in other words, Align > alignof(max_align_t))." " Before VS 2017 15.8, the member \"type\" would non-conformingly have an alignment of only alignof(max_align_t). VS 2017 15.8 wa" "s fixed to handle this correctly, but the fix inherently changes layout and breaks binary compatibility (*only* for uses of alig" "ned_storage with extended alignments). To suppress this error, please define either (1) _ENABLE_EXTENDED_ALIGNED_STORAGE to conf" "irm that you want a type with an extended alignment, or (2) _DISABLE_EXTENDED_ALIGNED_STORAGE to get the old non-conforming beha" "vior.");
#line 1138 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
using type = _Align_type< max_align_t, _Len> ; 
#line 1140 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
}; 
#line 1142
template< size_t _Len, size_t _Align> 
#line 1143
struct _Aligned< _Len, _Align, int, false>  { 
#line 1144
using _Next = double; 
#line 1145
static constexpr bool _Fits = (_Align <= __alignof(_Next)); 
#line 1146
using type = typename std::_Aligned< _Len, _Align, double, _Fits> ::type; 
#line 1147
}; 
#line 1149
template< size_t _Len, size_t _Align> 
#line 1150
struct _Aligned< _Len, _Align, short, false>  { 
#line 1151
using _Next = int; 
#line 1152
static constexpr bool _Fits = (_Align <= __alignof(_Next)); 
#line 1153
using type = typename std::_Aligned< _Len, _Align, int, _Fits> ::type; 
#line 1154
}; 
#line 1156
template< size_t _Len, size_t _Align> 
#line 1157
struct _Aligned< _Len, _Align, char, false>  { 
#line 1158
using _Next = short; 
#line 1159
static constexpr bool _Fits = (_Align <= __alignof(_Next)); 
#line 1160
using type = typename std::_Aligned< _Len, _Align, short, _Fits> ::type; 
#line 1161
}; 
#line 1164
template< size_t _Len, size_t _Align = 8Ui64> 
#line 1165
struct _Aligned_storage { 
#line 1166
using _Next = char; 
#line 1167
static constexpr bool _Fits = (_Align <= __alignof(_Next)); 
#line 1168
using type = typename _Aligned< _Len, _Align, char, _Fits> ::type; 
#line 1169
}; 
#line 1171
template< size_t _Len, size_t _Align = 8Ui64> using _Aligned_storage_t = typename _Aligned_storage< _Len, _Align> ::type; 
#line 1174
template< size_t _Len, size_t _Align = 8Ui64> 
#line 1175
struct aligned_storage { 
#line 1176
using type = _Aligned_storage_t< _Len, _Align> ; 
#line 1177
}; 
#line 1179
template< size_t _Len, size_t _Align = 8Ui64> using aligned_storage_t = _Aligned_storage_t< _Len, _Align> ; 
#line 1182
template< size_t ..._Vals> struct _Maximum; 
#line 1186
template<> struct _Maximum< >  : public integral_constant< unsigned __int64, 0Ui64>  { }; 
#line 1188
template< size_t _Val> 
#line 1189
struct _Maximum< _Val>  : public integral_constant< unsigned __int64, _Val>  { }; 
#line 1191
template< size_t _First, size_t _Second, size_t ..._Rest> 
#line 1192
struct _Maximum< _First, _Second, _Rest...>  : public std::_Maximum< (((_First) < _Second) ? _Second : _First), _Rest...> ::type { 
#line 1194
}; 
#line 1196
template< size_t _Len, class ..._Types> 
#line 1197
struct aligned_union { 
#line 1199
static constexpr size_t _Max_len = (_Maximum< _Len, sizeof(_Types)...> ::value); 
#line 1200
static constexpr size_t alignment_value = (_Maximum< __alignof(_Types)...> ::value); 
#line 1202
using type = _Aligned_storage_t< _Max_len, alignment_value> ; 
#line 1203
}; 
#line 1205
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 1206
template< size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union< _Len, _Types...> ::type; 
#line 1208
__pragma( warning(pop)) 
#line 1210
template< class _Ty, bool  = is_enum_v< _Ty> > 
#line 1211
struct _Underlying_type { 
#line 1212
using type = __underlying_type(_Ty); 
#line 1213
}; 
#line 1215
template< class _Ty> 
#line 1216
struct _Underlying_type< _Ty, false>  { }; 
#line 1218
template< class _Ty> 
#line 1219
struct underlying_type : public _Underlying_type< _Ty>  { }; 
#line 1221
template< class _Ty> using underlying_type_t = typename _Underlying_type< _Ty> ::type; 
#line 1224
template< class _Ty> constexpr size_t 
#line 1225
rank_v = (0); 
#line 1227
template< class _Ty, size_t _Nx> constexpr size_t 
#line 1228
rank_v< _Ty [_Nx]>  = rank_v< _Ty>  + 1; 
#line 1230
template< class _Ty> constexpr size_t 
#line 1231
rank_v< _Ty []>  = rank_v< _Ty>  + 1; 
#line 1233
template< class _Ty> 
#line 1234
struct rank : public integral_constant< unsigned __int64, rank_v< _Ty> >  { }; 
#line 1236
template< class _Ty, unsigned _Ix = 0U> constexpr size_t 
#line 1237
extent_v = (0); 
#line 1239
template< class _Ty, size_t _Nx> constexpr size_t 
#line 1240
extent_v< _Ty [_Nx], 0>  = _Nx; 
#line 1242
template< class _Ty, unsigned _Ix, size_t _Nx> constexpr size_t 
#line 1243
extent_v< _Ty [_Nx], _Ix>  = extent_v< _Ty, _Ix - (1)> ; 
#line 1245
template< class _Ty, unsigned _Ix> constexpr size_t 
#line 1246
extent_v< _Ty [], _Ix>  = extent_v< _Ty, _Ix - (1)> ; 
#line 1248
template< class _Ty, unsigned _Ix = 0U> 
#line 1249
struct extent : public integral_constant< unsigned __int64, extent_v< _Ty, _Ix> >  { }; 
#line 1251
template< class _Base, class _Derived> 
#line 1252
struct is_base_of : public bool_constant< __is_base_of(_Base, _Derived)>  { 
#line 1254
}; 
#line 1256
template< class _Base, class _Derived> constexpr bool 
#line 1257
is_base_of_v = __is_base_of(_Base, _Derived); 
#line 1259
template< class _Ty> 
#line 1260
struct decay { 
#line 1261
using _Ty1 = remove_reference_t< _Ty> ; 
#line 1262
using _Ty2 = typename _Select< is_function_v< _Ty1> > ::template _Apply< add_pointer< _Ty1> , remove_cv< _Ty1> > ; 
#line 1263
using type = typename _Select< is_array_v< _Ty1> > ::template _Apply< add_pointer< remove_extent_t< _Ty1> > , _Ty2> ::type; 
#line 1264
}; 
#line 1266
template< class _Ty> using decay_t = typename decay< _Ty> ::type; 
#line 1269
template< class _Ty1, class _Ty2> using _Conditional_type = decltype(false ? std::declval< _Ty1> () : std::declval< _Ty2> ()); 
#line 1287 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class _Ty1, class _Ty2, class  = void> 
#line 1288
struct _Decayed_cond_oper { }; 
#line 1291 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class _Ty1, class _Ty2> 
#line 1292
struct _Decayed_cond_oper< _Ty1, _Ty2, void_t< _Conditional_type< _Ty1, _Ty2> > >  { 
#line 1293
using type = decay_t< _Conditional_type< _Ty1, _Ty2> > ; 
#line 1294
}; 
#line 1296
template< class ..._Ty> struct common_type; 
#line 1299
template< class ..._Ty> using common_type_t = typename common_type< _Ty...> ::type; 
#line 1303
template<> struct common_type< >  { }; 
#line 1305
template< class _Ty1> 
#line 1306
struct common_type< _Ty1>  : public std::common_type< _Ty1, _Ty1>  { }; 
#line 1308
template< class _Ty1, class _Ty2, class _Decayed1 = decay_t< _Ty1> , class _Decayed2 = decay_t< _Ty2> > 
#line 1309
struct _Common_type2 : public common_type< _Decayed1, _Decayed2>  { }; 
#line 1311
template< class _Ty1, class _Ty2> 
#line 1312
struct _Common_type2< _Ty1, _Ty2, _Ty1, _Ty2>  : public _Decayed_cond_oper< _Ty1, _Ty2>  { }; 
#line 1314
template< class _Ty1, class _Ty2> 
#line 1315
struct common_type< _Ty1, _Ty2>  : public _Common_type2< _Ty1, _Ty2>  { }; 
#line 1317
template< class _Void, class _Ty1, class _Ty2, class ..._Rest> 
#line 1318
struct _Common_type3 { }; 
#line 1320
template< class _Ty1, class _Ty2, class ..._Rest> 
#line 1321
struct _Common_type3< void_t< common_type_t< _Ty1, _Ty2> > , _Ty1, _Ty2, _Rest...>  : public common_type< common_type_t< _Ty1, _Ty2> , _Rest...>  { 
#line 1322
}; 
#line 1324
template< class _Ty1, class _Ty2, class ..._Rest> 
#line 1325
struct common_type< _Ty1, _Ty2, _Rest...>  : public _Common_type3< void, _Ty1, _Ty2, _Rest...>  { }; 
#line 1327
template< class _Ty> _Ty _Returns_exactly() noexcept; 
#line 1492 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class _Type, template< class ...>  class _Template> constexpr bool 
#line 1493
_Is_specialization_v = false; 
#line 1494
template< template< class ...>  class _Template, class ..._Types> constexpr bool 
#line 1495
_Is_specialization_v< _Template< _Types...> , _Template>  = true; 
#line 1497
template< class _Type, template< class ...>  class _Template> 
#line 1498
struct _Is_specialization : public bool_constant< _Is_specialization_v< _Type, _Template> >  { }; 
#line 1500
template< class _Ty> 
#line 1501
[[nodiscard]] [[msvc::intrinsic]] constexpr _Ty &&forward(remove_reference_t< _Ty>  &_Arg) noexcept { 
#line 1502
return static_cast< _Ty &&>(_Arg); 
#line 1503
} 
#line 1505
template< class _Ty> 
#line 1506
[[nodiscard]] [[msvc::intrinsic]] constexpr _Ty &&forward(remove_reference_t< _Ty>  &&_Arg) noexcept { 
#line 1507
static_assert((!is_lvalue_reference_v< _Ty> ), "bad forward call");
#line 1508
return static_cast< _Ty &&>(_Arg); 
#line 1509
} 
#line 1511
template< class _Ty> 
#line 1512
[[nodiscard]] [[msvc::intrinsic]] constexpr remove_reference_t< _Ty>  &&move(_Ty &&_Arg) noexcept { 
#line 1513
return static_cast< remove_reference_t< _Ty>  &&>(_Arg); 
#line 1514
} 
#line 1516
template < class _Ty >
[ [ nodiscard ] ] [ [ msvc :: intrinsic ] ] constexpr
    conditional_t < ! is_nothrow_move_constructible_v < _Ty > && is_copy_constructible_v < _Ty >, const _Ty &, _Ty && >
    move_if_noexcept ( _Ty & _Arg ) noexcept {
    return :: std :: move ( _Arg );
}
#line 1523
template < class _Ty >
[ [ nodiscard ] ] constexpr _Ty * addressof ( _Ty & _Val ) noexcept {
    return __builtin_addressof ( _Val );
}
#line 1528
template < class _Ty >
const _Ty * addressof ( const _Ty && ) = delete;
#line 1531
#pragma warning(push)
#pragma warning(disable : 5215)
#pragma warning(disable : 5216)
#line 1540
template< class _Ty> 
#line 1541
[[nodiscard]] _Ty 
#line 1540
_Fake_copy_init(_Ty) noexcept; 
#line 1551
#pragma warning(pop)
#line 1553
template < class _Ty >
class reference_wrapper;
#line 1560
enum class _Invoker_strategy { 
#line 1561
_Functor, 
#line 1562
_Pmf_object, 
#line 1563
_Pmf_refwrap, 
#line 1564
_Pmf_pointer, 
#line 1565
_Pmd_object, 
#line 1566
_Pmd_refwrap, 
#line 1567
_Pmd_pointer
#line 1568
}; 
#line 1570
struct _Invoker_functor { 
#line 1571
static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Functor; 
#line 1573
template < class _Callable, class ... _Types >
    static constexpr auto _Call ( _Callable && _Obj, _Types && ... _Args )
        noexcept ( noexcept ( static_cast < _Callable && > ( _Obj ) ( static_cast < _Types && > ( _Args ) ... ) ) )
        -> decltype ( static_cast < _Callable && > ( _Obj ) ( static_cast < _Types && > ( _Args ) ... ) ) {
        return static_cast < _Callable && > ( _Obj ) ( static_cast < _Types && > ( _Args ) ... );
    }
#line 1579
}; 
#line 1581
struct _Invoker_pmf_object { 
#line 1582
static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_object; 
#line 1584
template < class _Decayed, class _Ty1, class ... _Types2 >
    static constexpr auto _Call ( _Decayed _Pmf, _Ty1 && _Arg1, _Types2 && ... _Args2 )
        noexcept ( noexcept ( ( static_cast < _Ty1 && > ( _Arg1 ) .* _Pmf ) ( static_cast < _Types2 && > ( _Args2 ) ... ) ) )
        -> decltype ( ( static_cast < _Ty1 && > ( _Arg1 ) .* _Pmf ) ( static_cast < _Types2 && > ( _Args2 ) ... ) ) {
        return ( static_cast < _Ty1 && > ( _Arg1 ) .* _Pmf ) ( static_cast < _Types2 && > ( _Args2 ) ... );
    }
#line 1590
}; 
#line 1592
struct _Invoker_pmf_refwrap { 
#line 1593
static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_refwrap; 
#line 1595
template < class _Decayed, class _Refwrap, class ... _Types2 >
    static constexpr auto _Call ( _Decayed _Pmf, _Refwrap _Rw, _Types2 && ... _Args2 )
        noexcept ( noexcept ( ( _Rw . get ( ) .* _Pmf ) ( static_cast < _Types2 && > ( _Args2 ) ... ) ) )
        -> decltype ( ( _Rw . get ( ) .* _Pmf ) ( static_cast < _Types2 && > ( _Args2 ) ... ) ) {
        return ( _Rw . get ( ) .* _Pmf ) ( static_cast < _Types2 && > ( _Args2 ) ... );
    }
#line 1601
}; 
#line 1603
struct _Invoker_pmf_pointer { 
#line 1604
static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_pointer; 
#line 1606
template < class _Decayed, class _Ty1, class ... _Types2 >
    static constexpr auto _Call ( _Decayed _Pmf, _Ty1 && _Arg1, _Types2 && ... _Args2 )
        noexcept ( noexcept ( ( ( * static_cast < _Ty1 && > ( _Arg1 ) ) .* _Pmf ) ( static_cast < _Types2 && > ( _Args2 ) ... ) ) )
        -> decltype ( ( ( * static_cast < _Ty1 && > ( _Arg1 ) ) .* _Pmf ) ( static_cast < _Types2 && > ( _Args2 ) ... ) ) {
        return ( ( * static_cast < _Ty1 && > ( _Arg1 ) ) .* _Pmf ) ( static_cast < _Types2 && > ( _Args2 ) ... );
    }
#line 1612
}; 
#line 1614
struct _Invoker_pmd_object { 
#line 1615
static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_object; 
#line 1617
template < class _Decayed, class _Ty1 >
    static constexpr auto _Call ( _Decayed _Pmd, _Ty1 && _Arg1 ) noexcept -> decltype ( static_cast < _Ty1 && > ( _Arg1 ) .* _Pmd ) {
        return static_cast < _Ty1 && > ( _Arg1 ) .* _Pmd;
    }
#line 1621
}; 
#line 1623
struct _Invoker_pmd_refwrap { 
#line 1624
static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_refwrap; 
#line 1626
template < class _Decayed, class _Refwrap >
    static constexpr auto _Call ( _Decayed _Pmd, _Refwrap _Rw ) noexcept -> decltype ( _Rw . get ( ) .* _Pmd ) {
        return _Rw . get ( ) .* _Pmd;
    }
#line 1630
}; 
#line 1632
struct _Invoker_pmd_pointer { 
#line 1633
static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_pointer; 
#line 1635
template < class _Decayed, class _Ty1 >
    static constexpr auto _Call ( _Decayed _Pmd, _Ty1 && _Arg1 ) noexcept ( noexcept ( ( * static_cast < _Ty1 && > ( _Arg1 ) ) .* _Pmd ) )
        -> decltype ( ( * static_cast < _Ty1 && > ( _Arg1 ) ) .* _Pmd ) {
        return ( * static_cast < _Ty1 && > ( _Arg1 ) ) .* _Pmd;
    }
#line 1640
}; 
#line 1642
template< class _Callable, class _Ty1, class _Removed_cvref = _Remove_cvref_t< _Callable> , bool 
#line 1643
_Is_pmf = is_member_function_pointer_v< _Removed_cvref> , bool 
#line 1644
_Is_pmd = is_member_object_pointer_v< _Removed_cvref> > struct _Invoker1; 
#line 1647
template< class _Callable, class _Ty1, class _Removed_cvref> 
#line 1648
struct _Invoker1< _Callable, _Ty1, _Removed_cvref, true, false>  : public conditional_t< is_same_v< typename _Is_memfunptr< _Removed_cvref> ::_Class_type, _Remove_cvref_t< _Ty1> >  || is_base_of_v< typename _Is_memfunptr< _Removed_cvref> ::_Class_type, _Remove_cvref_t< _Ty1> > , _Invoker_pmf_object, conditional_t< _Is_specialization_v< _Remove_cvref_t< _Ty1> , reference_wrapper> , _Invoker_pmf_refwrap, _Invoker_pmf_pointer> >  { 
#line 1653
}; 
#line 1655
template< class _Callable, class _Ty1, class _Removed_cvref> 
#line 1656
struct _Invoker1< _Callable, _Ty1, _Removed_cvref, false, true>  : public conditional_t< is_same_v< typename _Is_member_object_pointer< _Removed_cvref> ::_Class_type, _Remove_cvref_t< _Ty1> >  || is_base_of_v< typename _Is_member_object_pointer< _Removed_cvref> ::_Class_type, _Remove_cvref_t< _Ty1> > , _Invoker_pmd_object, conditional_t< _Is_specialization_v< _Remove_cvref_t< _Ty1> , reference_wrapper> , _Invoker_pmd_refwrap, _Invoker_pmd_pointer> >  { 
#line 1662
}; 
#line 1664
template< class _Callable, class _Ty1, class _Removed_cvref> 
#line 1665
struct _Invoker1< _Callable, _Ty1, _Removed_cvref, false, false>  : public _Invoker_functor { }; 
#line 1667
template < class _Callable >
constexpr auto invoke ( _Callable && _Obj ) noexcept ( noexcept ( static_cast < _Callable && > ( _Obj ) ( ) ) )
    -> decltype ( static_cast < _Callable && > ( _Obj ) ( ) ) {
    return static_cast < _Callable && > ( _Obj ) ( );
}
#line 1673
template < class _Callable, class _Ty1, class ... _Types2 >
constexpr auto invoke ( _Callable && _Obj, _Ty1 && _Arg1, _Types2 && ... _Args2 )
    noexcept ( noexcept ( _Invoker1 < _Callable, _Ty1 > :: _Call (
        static_cast < _Callable && > ( _Obj ), static_cast < _Ty1 && > ( _Arg1 ), static_cast < _Types2 && > ( _Args2 ) ... ) ) )
    -> decltype ( _Invoker1 < _Callable, _Ty1 > :: _Call (
        static_cast < _Callable && > ( _Obj ), static_cast < _Ty1 && > ( _Arg1 ), static_cast < _Types2 && > ( _Args2 ) ... ) ) {
    if constexpr ( _Invoker1 < _Callable, _Ty1 > :: _Strategy == _Invoker_strategy :: _Functor ) {
        return static_cast < _Callable && > ( _Obj ) ( static_cast < _Ty1 && > ( _Arg1 ), static_cast < _Types2 && > ( _Args2 ) ... );
    } else if constexpr ( _Invoker1 < _Callable, _Ty1 > :: _Strategy == _Invoker_strategy :: _Pmf_object ) {
        return ( static_cast < _Ty1 && > ( _Arg1 ) .* _Obj ) ( static_cast < _Types2 && > ( _Args2 ) ... );
    } else if constexpr ( _Invoker1 < _Callable, _Ty1 > :: _Strategy == _Invoker_strategy :: _Pmf_refwrap ) {
        return ( _Arg1 . get ( ) .* _Obj ) ( static_cast < _Types2 && > ( _Args2 ) ... );
    } else if constexpr ( _Invoker1 < _Callable, _Ty1 > :: _Strategy == _Invoker_strategy :: _Pmf_pointer ) {
        return ( ( * static_cast < _Ty1 && > ( _Arg1 ) ) .* _Obj ) ( static_cast < _Types2 && > ( _Args2 ) ... );
    } else if constexpr ( _Invoker1 < _Callable, _Ty1 > :: _Strategy == _Invoker_strategy :: _Pmd_object ) {
        return static_cast < _Ty1 && > ( _Arg1 ) .* _Obj;
    } else if constexpr ( _Invoker1 < _Callable, _Ty1 > :: _Strategy == _Invoker_strategy :: _Pmd_refwrap ) {



        auto & _Ref = _Arg1 . get ( );
        return _Ref .* _Obj;

    } else {
        ;
        return ( * static_cast < _Ty1 && > ( _Arg1 ) ) .* _Obj;
    }
}
#line 1702 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
#pragma warning(push)
#pragma warning(disable : 4242)
#pragma warning(disable : 4244)
#pragma warning(disable : 4365)
#line 1707
template< class _From, class _To, bool  = is_convertible_v< _From, _To> , bool  = is_void_v< _To> > constexpr bool 
#line 1708
_Is_nothrow_convertible_v = noexcept(std::_Fake_copy_init< _To> (std::declval< _From> ())); 
#line 1710
#pragma warning(pop)
#line 1712
template< class _From, class _To, bool _IsVoid> constexpr bool 
#line 1713
_Is_nothrow_convertible_v< _From, _To, false, _IsVoid>  = false; 
#line 1715
template< class _From, class _To> constexpr bool 
#line 1716
_Is_nothrow_convertible_v< _From, _To, true, true>  = true; 
#line 1718
template< class _From, class _To> 
#line 1719
struct _Is_nothrow_convertible : public bool_constant< _Is_nothrow_convertible_v< _From, _To, is_convertible_v< _From, _To> , is_void_v< _To> > >  { 
#line 1721
}; 
#line 1731 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class _From, class _To, class  = void> 
#line 1732
struct _Invoke_convertible : public false_type { }; 
#line 1734
template< class _From, class _To> 
#line 1735
struct _Invoke_convertible< _From, _To, void_t< decltype(std::_Fake_copy_init< _To> (std::_Returns_exactly< _From> ()))> >  : public true_type { 
#line 1736
}; 
#line 1738
template< class _From, class _To> 
#line 1739
struct _Invoke_nothrow_convertible : public bool_constant< noexcept(std::_Fake_copy_init< _To> (std::_Returns_exactly< _From> ()))>  { 
#line 1740
}; 
#line 1742
template< class _Result, bool _Nothrow> 
#line 1743
struct _Invoke_traits_common { 
#line 1744
using type = _Result; 
#line 1745
using _Is_invocable = true_type; 
#line 1746
using _Is_nothrow_invocable = bool_constant< _Nothrow> ; 
#line 1747
template< class _Rx> using _Is_invocable_r = bool_constant< disjunction_v< is_void< _Rx> , _Invoke_convertible< type, _Rx> > > ; 
#line 1749
template< class _Rx> using _Is_nothrow_invocable_r = bool_constant< conjunction_v< _Is_nothrow_invocable, disjunction< is_void< _Rx> , conjunction< _Invoke_convertible< type, _Rx> , _Invoke_nothrow_convertible< type, _Rx> > > > > ; 
#line 1753
}; 
#line 1755
template< class _Void, class _Callable> 
#line 1756
struct _Invoke_traits_zero { 
#line 1758
using _Is_invocable = false_type; 
#line 1759
using _Is_nothrow_invocable = false_type; 
#line 1760
template< class _Rx> using _Is_invocable_r = false_type; 
#line 1762
template< class _Rx> using _Is_nothrow_invocable_r = false_type; 
#line 1764
}; 
#line 1766
template< class _Callable> using _Decltype_invoke_zero = decltype(std::declval< _Callable> ()()); 
#line 1769
template< class _Callable> 
#line 1770
struct _Invoke_traits_zero< void_t< _Decltype_invoke_zero< _Callable> > , _Callable>  : public _Invoke_traits_common< _Decltype_invoke_zero< _Callable> , noexcept(std::declval< _Callable> ()())>  { 
#line 1771
}; 
#line 1773
template< class _Void, class ..._Types> 
#line 1774
struct _Invoke_traits_nonzero { 
#line 1776
using _Is_invocable = false_type; 
#line 1777
using _Is_nothrow_invocable = false_type; 
#line 1778
template< class _Rx> using _Is_invocable_r = false_type; 
#line 1780
template< class _Rx> using _Is_nothrow_invocable_r = false_type; 
#line 1782
}; 
#line 1784
template< class _Callable, class _Ty1, class ..._Types2> using _Decltype_invoke_nonzero = decltype(_Invoker1< _Callable, _Ty1> ::_Call(std::declval< _Callable> (), std::declval< _Ty1> (), std::declval< _Types2> ()...)); 
#line 1788
template< class _Callable, class _Ty1, class ..._Types2> 
#line 1789
struct _Invoke_traits_nonzero< void_t< _Decltype_invoke_nonzero< _Callable, _Ty1, _Types2...> > , _Callable, _Ty1, _Types2...>  : public _Invoke_traits_common< _Decltype_invoke_nonzero< _Callable, _Ty1, _Types2...> , noexcept(_Invoker1< _Callable, _Ty1> ::_Call(std::declval< _Callable> (), std::declval< _Ty1> (), std::declval< _Types2> ()...))>  { 
#line 1792
}; 
#line 1794
template< class _Callable, class ..._Args> using _Select_invoke_traits = conditional_t< sizeof...(_Args) == (0), _Invoke_traits_zero< void, _Callable> , _Invoke_traits_nonzero< void, _Callable, _Args...> > ; 
#line 1799
template< class _Fty> 
#line 1800
struct result_of { 
#line 1801
static_assert((_Always_false< _Fty> ), "result_of<CallableType> is invalid; use result_of<CallableType(zero or more argument types)> instead.");
#line 1803
}; 
#line 1811
template< class _Callable, class ..._Args> struct result_of< _Callable __cdecl (_Args ...)>  : public _Select_invoke_traits< _Callable, _Args...>  { }; template< class _Callable, class ..._Args> struct result_of< _Callable __vectorcall (_Args ...)>  : public _Select_invoke_traits< _Callable, _Args...>  { }; 
#line 1814
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 1815
template< class _Ty> using result_of_t = typename result_of< _Ty> ::type; 
#line 1817
__pragma( warning(pop)) 
#line 1820 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class _Callable, class ..._Args> using _Invoke_result_t = typename _Select_invoke_traits< _Callable, _Args...> ::type; 
#line 1823
template< class _Rx, class _Callable, class ..._Args> using _Is_invocable_r_ = typename conditional< sizeof...(_Args) == (0), _Invoke_traits_zero< void, _Callable> , _Invoke_traits_nonzero< void, _Callable, _Args...> > ::type::template _Is_invocable_r< _Rx> ; 
#line 1826
template< class _Rx, class _Callable, class ..._Args> 
#line 1827
struct _Is_invocable_r : public _Is_invocable_r_< _Rx, _Callable, _Args...>  { 
#line 1829
}; 
#line 1900 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class _Ty> 
#line 1901
struct _Function_args { }; 
#line 1909
template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...)>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...)>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) const>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) const>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) volatile>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) volatile>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) const volatile>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) const volatile>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) &>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) &>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) const &>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) const &>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) volatile &>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) volatile &>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) const volatile &>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) const volatile &>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) &&>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) &&>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) const &&>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) const &&>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) volatile &&>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) volatile &&>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) const volatile &&>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) const volatile &&>  : public _Arg_types< _Types...>  { using result_type = _Ret; }; 
#line 1918
template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...)>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) const>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) volatile>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) const volatile>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) &>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) const &>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) volatile &>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) const volatile &>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) &&>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) const &&>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) volatile &&>  { using result_type = _Ret; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) const volatile &&>  { using result_type = _Ret; }; 
#line 1921
template< class _Ty, class  = void> 
#line 1922
struct _Weak_result_type { }; 
#line 1924
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 1925
template< class _Ty> 
#line 1926
struct _Weak_result_type< _Ty, void_t< typename _Ty::result_type> >  { 
#line 1927
using result_type = typename _Ty::result_type; 
#line 1928
}; 
#line 1929
__pragma( warning(pop)) 
#line 1931
template< class _Ty, class  = void> 
#line 1932
struct _Weak_argument_type : public _Weak_result_type< _Ty>  { }; 
#line 1934
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 1935
template< class _Ty> 
#line 1936
struct _Weak_argument_type< _Ty, void_t< typename _Ty::argument_type> >  : public _Weak_result_type< _Ty>  { 
#line 1938
using argument_type = typename _Ty::argument_type; 
#line 1939
}; 
#line 1940
__pragma( warning(pop)) 
#line 1942
template< class _Ty, class  = void> 
#line 1943
struct _Weak_binary_args : public _Weak_argument_type< _Ty>  { }; 
#line 1945
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 1946
template< class _Ty> 
#line 1947
struct _Weak_binary_args< _Ty, void_t< typename _Ty::first_argument_type, typename _Ty::second_argument_type> >  : public _Weak_argument_type< _Ty>  { 
#line 1950
using first_argument_type = typename _Ty::first_argument_type; 
#line 1951
using second_argument_type = typename _Ty::second_argument_type; 
#line 1952
}; 
#line 1953
__pragma( warning(pop)) 
#line 1955
template< class _Ty> using _Weak_types = conditional_t< is_function_v< remove_pointer_t< _Ty> > , _Function_args< remove_pointer_t< _Ty> > , conditional_t< is_member_function_pointer_v< _Ty> , _Is_memfunptr< remove_cv_t< _Ty> > , _Weak_binary_args< _Ty> > > ; 
#line 1959
template< class _Ty> void _Refwrap_ctor_fun(_Identity_t< _Ty &> ) noexcept; 
#line 1961
template < class _Ty >
void _Refwrap_ctor_fun ( _Identity_t < _Ty && > ) = delete;
#line 1964
template< class _Ty, class _Uty, class  = void> 
#line 1965
struct _Refwrap_has_ctor_from : public false_type { }; 
#line 1967
template< class _Ty, class _Uty> 
#line 1968
struct _Refwrap_has_ctor_from< _Ty, _Uty, void_t< decltype(std::_Refwrap_ctor_fun< _Ty> (std::declval< _Uty> ()))> >  : public true_type { 
#line 1969
}; 
#line 1971
template < class _Ty >
class reference_wrapper

    : public _Weak_types < _Ty >

{
public :
    static_assert ( is_object_v < _Ty > || is_function_v < _Ty >,
        "reference_wrapper<T> requires T to be an object type or a function type." );

    using type = _Ty;

    template < class _Uty, enable_if_t < conjunction_v < negation < is_same < _Remove_cvref_t < _Uty >, reference_wrapper >>,
                                          _Refwrap_has_ctor_from < _Ty, _Uty >>,
                              int > = 0 >
    inline reference_wrapper ( _Uty && _Val ) noexcept (
        noexcept ( :: std :: _Refwrap_ctor_fun < _Ty > ( :: std :: declval < _Uty > ( ) ) ) ) {
        _Ty & _Ref = static_cast < _Uty && > ( _Val );
        _Ptr = :: std :: addressof ( _Ref );
    }

    inline operator _Ty & ( ) const noexcept {
        return * _Ptr;
    }

    [ [ nodiscard ] ] inline _Ty & get ( ) const noexcept {
        return * _Ptr;
    }

private :
    _Ty * _Ptr { };

public :
    template < class ... _Types >
    inline auto operator ( ) ( _Types && ... _Args ) const
        noexcept ( noexcept ( :: std :: invoke ( * _Ptr, static_cast < _Types && > ( _Args ) ... ) ) )
        -> decltype ( :: std :: invoke ( * _Ptr, static_cast < _Types && > ( _Args ) ... ) ) {
        return :: std :: invoke ( * _Ptr, static_cast < _Types && > ( _Args ) ... );
    }
};
#line 2017 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template < class _Ty >
[ [ nodiscard ] ] inline reference_wrapper < _Ty > ref ( _Ty & _Val ) noexcept {
    return reference_wrapper < _Ty > ( _Val );
}
#line 2022
template < class _Ty >
void ref ( const _Ty && ) = delete;
#line 2025
template < class _Ty >
[ [ nodiscard ] ] inline reference_wrapper < _Ty > ref ( reference_wrapper < _Ty > _Val ) noexcept {
    return _Val;
}
#line 2030
template < class _Ty >
[ [ nodiscard ] ] inline reference_wrapper < const _Ty > cref ( const _Ty & _Val ) noexcept {
    return reference_wrapper < const _Ty > ( _Val );
}
#line 2035
template < class _Ty >
void cref ( const _Ty && ) = delete;
#line 2038
template < class _Ty >
[ [ nodiscard ] ] inline reference_wrapper < const _Ty > cref ( reference_wrapper < _Ty > _Val ) noexcept {
    return _Val;
}
#line 2063 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class _Ty> struct _Is_swappable; 
#line 2066
template< class _Ty> struct _Is_nothrow_swappable; 
#line 2072 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template < class _Ty, int _Enabled = 0 >

inline void swap ( _Ty &, _Ty & ) noexcept ( is_nothrow_move_constructible_v < _Ty > && is_nothrow_move_assignable_v < _Ty > );
#line 2076 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template < class _Ty, size_t _Size, enable_if_t < _Is_swappable < _Ty > :: value, int > = 0 >
inline void swap ( _Ty ( & ) [ _Size ], _Ty ( & ) [ _Size ] ) noexcept ( _Is_nothrow_swappable < _Ty > :: value );
#line 2079
template< class _Ty1, class _Ty2, class  = void> 
#line 2080
struct _Swappable_with_helper : public false_type { }; 
#line 2082
template< class _Ty1, class _Ty2> 
#line 2083
struct _Swappable_with_helper< _Ty1, _Ty2, void_t< decltype(swap(std::declval< _Ty1> (), std::declval< _Ty2> ()))> >  : public true_type { 
#line 2084
}; 
#line 2086
template< class _Ty1, class _Ty2> 
#line 2087
struct _Is_swappable_with : public bool_constant< conjunction_v< _Swappable_with_helper< _Ty1, _Ty2> , _Swappable_with_helper< _Ty2, _Ty1> > >  { 
#line 2090
}; 
#line 2092
template< class _Ty> 
#line 2093
struct _Is_swappable : public _Is_swappable_with< add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< _Ty> > ::type { 
#line 2095
}; 
#line 2097
template< class _Ty1, class _Ty2> 
#line 2098
struct _Swap_cannot_throw : public bool_constant< noexcept(swap(std::declval< _Ty1> (), std::declval< _Ty2> ())) && noexcept(swap(std::declval< _Ty2> (), std::declval< _Ty1> ()))>  { 
#line 2102
}; 
#line 2104
template< class _Ty1, class _Ty2> 
#line 2105
struct _Is_nothrow_swappable_with : public bool_constant< conjunction_v< _Is_swappable_with< _Ty1, _Ty2> , _Swap_cannot_throw< _Ty1, _Ty2> > >  { 
#line 2109
}; 
#line 2111
template< class _Ty> 
#line 2112
struct _Is_nothrow_swappable : public _Is_nothrow_swappable_with< add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< _Ty> > ::type { 
#line 2115
}; 
#line 2152 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
namespace _Has_ADL_swap_detail { 
#line 2156 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
void swap(); 
#line 2159 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template< class , class  = void> 
#line 2160
struct _Has_ADL_swap : public false_type { }; 
#line 2161
template< class _Ty> 
#line 2162
struct _Has_ADL_swap< _Ty, void_t< decltype(swap(std::declval< _Ty &> (), std::declval< _Ty &> ()))> >  : public true_type { }; 
#line 2163
}
#line 2164
using _Has_ADL_swap_detail::_Has_ADL_swap;
#line 2166
template< class _Ty> constexpr bool 
#line 2167
_Is_trivially_swappable_v = conjunction_v< is_trivially_destructible< _Ty> , is_trivially_move_constructible< _Ty> , is_trivially_move_assignable< _Ty> , negation< _Has_ADL_swap_detail::_Has_ADL_swap< _Ty> > > ; 
#line 2175
template< class _Ty> 
#line 2176
struct _Is_trivially_swappable : public bool_constant< _Is_trivially_swappable_v< _Ty> >  { 
#line 2178
}; 
#line 2237 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template < class _Bitmask >
[ [ nodiscard ] ] constexpr bool _Bitmask_includes_any ( _Bitmask _Left, _Bitmask _Elements ) noexcept {
    return ( _Left & _Elements ) != _Bitmask { };
}
#line 2242
template < class _Bitmask >
[ [ nodiscard ] ] constexpr bool _Bitmask_includes_all ( _Bitmask _Left, _Bitmask _Elements ) noexcept {
    return ( _Left & _Elements ) == _Elements;
}
#line 2250
constexpr size_t _FNV_offset_basis = 14695981039346656037Ui64; 
#line 2251
constexpr size_t _FNV_prime = 1099511628211Ui64; 
#line 2257 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
[[nodiscard]] inline size_t _Fnv1a_append_bytes(size_t _Val, const unsigned char *const _First, const size_t 
#line 2258
_Count) noexcept { 
#line 2259
for (size_t _Idx = (0); _Idx < _Count; ++_Idx) { 
#line 2260
_Val ^= (static_cast< size_t>(_First[_Idx])); 
#line 2261
_Val *= _FNV_prime; 
#line 2262
}  
#line 2264
return _Val; 
#line 2265
} 
#line 2267
template < class _Ty >
[ [ nodiscard ] ] size_t _Fnv1a_append_range ( const size_t _Val, const _Ty * const _First,
    const _Ty * const _Last ) noexcept {
    static_assert ( is_trivially_copyable_v < _Ty >, "Only trivially copyable types can be directly hashed." );
    const auto _Firstb = reinterpret_cast < const unsigned char * > ( _First );
    const auto _Lastb = reinterpret_cast < const unsigned char * > ( _Last );
    return _Fnv1a_append_bytes ( _Val, _Firstb, static_cast < size_t > ( _Lastb - _Firstb ) );
}
#line 2276
template < class _Kty >
[ [ nodiscard ] ] size_t _Fnv1a_append_value (
    const size_t _Val, const _Kty & _Keyval ) noexcept {
    static_assert ( is_trivially_copyable_v < _Kty >, "Only trivially copyable types can be directly hashed." );
    return _Fnv1a_append_bytes ( _Val, & reinterpret_cast < const unsigned char & > ( _Keyval ), sizeof ( _Kty ) );
}
#line 2283
template < class _Kty >
[ [ nodiscard ] ] size_t _Hash_representation ( const _Kty & _Keyval ) noexcept {
    return _Fnv1a_append_value ( _FNV_offset_basis, _Keyval );
}
#line 2288
template < class _Kty >
[ [ nodiscard ] ] size_t _Hash_array_representation (
    const _Kty * const _First, const size_t _Count ) noexcept {
    static_assert ( is_trivially_copyable_v < _Kty >, "Only trivially copyable types can be directly hashed." );
    return _Fnv1a_append_bytes (
        _FNV_offset_basis, reinterpret_cast < const unsigned char * > ( _First ), _Count * sizeof ( _Kty ) );
}
#line 2296
template < class _Kty >
struct hash;
#line 2299
template < class _Kty, bool _Enabled >
struct _Conditionally_enabled_hash {
    using argument_type = _Kty;
    using result_type = size_t;

    [ [ nodiscard ] ] size_t operator ( ) ( const _Kty & _Keyval ) const
        noexcept ( noexcept ( hash < _Kty > :: _Do_hash ( _Keyval ) ) ) {
        return hash < _Kty > :: _Do_hash ( _Keyval );
    }
};
#line 2310
template< class _Kty> 
#line 2311
struct _Conditionally_enabled_hash< _Kty, false>  { 
#line 2312
_Conditionally_enabled_hash() = delete;
#line 2313
_Conditionally_enabled_hash(const _Conditionally_enabled_hash &) = delete;
#line 2314
_Conditionally_enabled_hash(_Conditionally_enabled_hash &&) = delete;
#line 2315
_Conditionally_enabled_hash &operator=(const _Conditionally_enabled_hash &) = delete;
#line 2316
_Conditionally_enabled_hash &operator=(_Conditionally_enabled_hash &&) = delete;
#line 2317
}; 
#line 2319
template < class _Kty >
struct hash : _Conditionally_enabled_hash < _Kty, ! is_const_v < _Kty > && ! is_volatile_v < _Kty >
                                                    && ( is_enum_v < _Kty > || is_integral_v < _Kty > || is_pointer_v < _Kty > ) > {

    static size_t _Do_hash ( const _Kty & _Keyval ) noexcept {
        return _Hash_representation ( _Keyval );
    }
};
#line 2329
#pragma pack(8)
template<> 
#line 2329
struct hash< float>  { 
#line 2330
using argument_type = float; 
#line 2331
using result_type = size_t; 
#line 2332
[[nodiscard]] size_t operator()(const float _Keyval) const noexcept { 
#line 2333
return _Hash_representation((_Keyval == (0.0F)) ? (0.0F) : _Keyval); 
#line 2334
} 
#line 2335
}; 
#pragma pack()
#line 2338
#pragma pack(8)
template<> 
#line 2338
struct hash< double>  { 
#line 2339
using argument_type = double; 
#line 2340
using result_type = size_t; 
#line 2341
[[nodiscard]] size_t operator()(const double _Keyval) const noexcept { 
#line 2342
return _Hash_representation((_Keyval == (0.0)) ? (0.0) : _Keyval); 
#line 2343
} 
#line 2344
}; 
#pragma pack()
#line 2347
#pragma pack(8)
template<> 
#line 2347
struct hash< long double>  { 
#line 2348
using argument_type = long double; 
#line 2349
using result_type = size_t; 
#line 2350
[[nodiscard]] size_t operator()(const long double _Keyval) const noexcept { 
#line 2351
return _Hash_representation((_Keyval == (0.0L)) ? (0.0L) : _Keyval); 
#line 2352
} 
#line 2353
}; 
#pragma pack()
#line 2356
#pragma pack(8)
template<> 
#line 2356
struct hash< std::nullptr_t>  { 
#line 2357
using argument_type = nullptr_t; 
#line 2358
using result_type = size_t; 
#line 2359
[[nodiscard]] size_t operator()(nullptr_t) const noexcept { 
#line 2360
void *_Null{((void *)0i64)}; 
#line 2361
return _Hash_representation(_Null); 
#line 2362
} 
#line 2363
}; 
#pragma pack()
template< class _Kty, class  = void> 
#pragma pack(8)
#line 2366
struct _Is_nothrow_hashable : public false_type { }; 
#pragma pack()
template< class _Kty> 
#pragma pack(8)
#line 2369
struct _Is_nothrow_hashable< _Kty, void_t< decltype(hash< _Kty> {}(std::declval< const _Kty &> ()))> >  : public bool_constant< noexcept(hash< _Kty> {}(std::declval< const _Kty &> ()))>  { 
#line 2370
}; 
#pragma pack()
template < class _Ty = void >
struct less {
    using first_argument_type = _Ty;
    using second_argument_type = _Ty;
    using result_type = bool;

    [ [ nodiscard ] ] constexpr bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
        noexcept ( noexcept ( :: std :: _Fake_copy_init < bool > ( _Left < _Right ) ) ) {
        return _Left < _Right;
    }
};
#line 2385
template<> struct less<>  { 
#line 2386
template < class _Ty1, class _Ty2 >
    [ [ nodiscard ] ] constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
        noexcept ( noexcept ( static_cast < _Ty1 && > ( _Left ) < static_cast < _Ty2 && > ( _Right ) ) )
        -> decltype ( static_cast < _Ty1 && > ( _Left ) < static_cast < _Ty2 && > ( _Right ) ) {
        return static_cast < _Ty1 && > ( _Left ) < static_cast < _Ty2 && > ( _Right );
    }
#line 2393
using is_transparent = int; 
#line 2394
}; 
#line 2398
template< class _FloatingType> struct _Floating_type_traits; 
#line 2402
template<> struct _Floating_type_traits< float>  { 
#line 2403
static constexpr int32_t _Mantissa_bits = 24; 
#line 2404
static constexpr int32_t _Exponent_bits = 8; 
#line 2405
static constexpr int32_t _Maximum_binary_exponent = 127; 
#line 2406
static constexpr int32_t _Minimum_binary_exponent = (-126); 
#line 2407
static constexpr int32_t _Exponent_bias = 127; 
#line 2408
static constexpr int32_t _Sign_shift = 31; 
#line 2409
static constexpr int32_t _Exponent_shift = 23; 
#line 2411
using _Uint_type = uint32_t; 
#line 2413
static constexpr uint32_t _Exponent_mask = 255U; 
#line 2414
static constexpr uint32_t _Normal_mantissa_mask = 16777215U; 
#line 2415
static constexpr uint32_t _Denormal_mantissa_mask = 8388607U; 
#line 2416
static constexpr uint32_t _Special_nan_mantissa_mask = 4194304U; 
#line 2417
static constexpr uint32_t _Shifted_sign_mask = 2147483648U; 
#line 2418
static constexpr uint32_t _Shifted_exponent_mask = 2139095040U; 
#line 2420
static constexpr float _Minimum_value = (1.175494351e-38F); 
#line 2421
static constexpr float _Maximum_value = (3.402823466e+38F); 
#line 2422
}; 
#line 2425
template<> struct _Floating_type_traits< double>  { 
#line 2426
static constexpr int32_t _Mantissa_bits = 53; 
#line 2427
static constexpr int32_t _Exponent_bits = 11; 
#line 2428
static constexpr int32_t _Maximum_binary_exponent = 1023; 
#line 2429
static constexpr int32_t _Minimum_binary_exponent = (-1022); 
#line 2430
static constexpr int32_t _Exponent_bias = 1023; 
#line 2431
static constexpr int32_t _Sign_shift = 63; 
#line 2432
static constexpr int32_t _Exponent_shift = 52; 
#line 2434
using _Uint_type = uint64_t; 
#line 2436
static constexpr uint64_t _Exponent_mask = (2047U); 
#line 2437
static constexpr uint64_t _Normal_mantissa_mask = 9007199254740991Ui64; 
#line 2438
static constexpr uint64_t _Denormal_mantissa_mask = 4503599627370495Ui64; 
#line 2439
static constexpr uint64_t _Special_nan_mantissa_mask = 2251799813685248Ui64; 
#line 2440
static constexpr uint64_t _Shifted_sign_mask = 9223372036854775808Ui64; 
#line 2441
static constexpr uint64_t _Shifted_exponent_mask = 9218868437227405312Ui64; 
#line 2443
static constexpr double _Minimum_value = (2.225073858507201383e-308); 
#line 2444
static constexpr double _Maximum_value = (1.797693134862315708e+308); 
#line 2445
}; 
#line 2448
template<> struct _Floating_type_traits< long double>  : public std::_Floating_type_traits< double>  { }; 
#line 2452
template < class _To, class _From,
    enable_if_t < conjunction_v < bool_constant < sizeof ( _To ) == sizeof ( _From ) >, is_trivially_copyable < _To >,
                    is_trivially_copyable < _From > >,
        int > = 0 >
[ [ nodiscard ] ] constexpr _To _Bit_cast ( const _From & _Val ) noexcept {
    return __builtin_bit_cast ( _To, _Val );
}
#line 2460
template < class _Ty, enable_if_t < is_floating_point_v < _Ty >, int > = 0 >
[ [ nodiscard ] ] constexpr auto _Float_abs_bits ( const _Ty & _Xx ) noexcept {
    using _Traits = _Floating_type_traits < _Ty >;
    using _Uint_type = typename _Traits :: _Uint_type;
    const auto _Bits = _Bit_cast < _Uint_type > ( _Xx );
    return _Bits & ~ _Traits :: _Shifted_sign_mask;
}
#line 2468
template < class _Ty, enable_if_t < is_floating_point_v < _Ty >, int > = 0 >
[ [ nodiscard ] ] constexpr _Ty _Float_abs ( const _Ty _Xx ) noexcept {
    return _Bit_cast < _Ty > ( _Float_abs_bits ( _Xx ) );
}
#line 2473
template < class _Ty, enable_if_t < is_floating_point_v < _Ty >, int > = 0 >
[ [ nodiscard ] ] constexpr bool _Is_nan ( const _Ty _Xx ) noexcept {
    using _Traits = _Floating_type_traits < _Ty >;
    return _Float_abs_bits ( _Xx ) > _Traits :: _Shifted_exponent_mask;
}
#line 2479
template < class _Ty, enable_if_t < is_floating_point_v < _Ty >, int > = 0 >
[ [ nodiscard ] ] constexpr bool _Is_finite ( const _Ty _Xx ) noexcept {
    using _Traits = _Floating_type_traits < _Ty >;
    return _Float_abs_bits ( _Xx ) < _Traits :: _Shifted_exponent_mask;
}
#line 2485
template< bool _IsConst, class _Ty> using _Maybe_const = conditional_t< _IsConst, const _Ty, _Ty> ; 
#line 2488
template < class _Ty, size_t _Size >
void _Swap_trivial_arrays ( _Ty ( & _Left ) [ _Size ], _Ty ( & _Right ) [ _Size ] ) noexcept {






    auto _Left_ptr = reinterpret_cast < unsigned char * > ( & _Left );
    auto _Right_ptr = reinterpret_cast < unsigned char * > ( & _Right );

    constexpr size_t _Part_size_bytes = 64;
    constexpr size_t _Size_bytes = _Size * sizeof ( _Ty );
    constexpr size_t _Size_tail = _Size_bytes % _Part_size_bytes;
    constexpr size_t _Size_parts = _Size_bytes - _Size_tail;

    if constexpr ( _Size_parts != 0 ) {
        const auto _Stop = _Left_ptr + _Size_parts;
        do {
            unsigned char _Buf [ _Part_size_bytes ];
            :: memcpy ( _Buf, _Left_ptr, _Part_size_bytes );
            :: memcpy ( _Left_ptr, _Right_ptr, _Part_size_bytes );
            :: memcpy ( _Right_ptr, _Buf, _Part_size_bytes );
            _Left_ptr += _Part_size_bytes;
            _Right_ptr += _Part_size_bytes;

        } while ( _Left_ptr != _Stop );
    }

    if constexpr ( _Size_tail != 0 ) {
        unsigned char _Buf [ _Size_tail ];
        :: memcpy ( _Buf, _Left_ptr, _Size_tail );
        :: memcpy ( _Left_ptr, _Right_ptr, _Size_tail );
        :: memcpy ( _Right_ptr, _Buf, _Size_tail );
    }
}
#line 2526
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 2527
namespace [[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to suppress this warning.")]] tr1 { 
#line 2528
using std::add_const;
#line 2529
using std::add_cv;
#line 2530
using std::add_pointer;
#line 2531
using std::add_volatile;
#line 2532
using std::aligned_storage;
#line 2533
using std::alignment_of;
#line 2534
using std::conditional;
#line 2535
using std::decay;
#line 2536
using std::enable_if;
#line 2537
using std::extent;
#line 2538
using std::false_type;
#line 2539
using std::has_virtual_destructor;
#line 2540
using std::integral_constant;
#line 2541
using std::is_abstract;
#line 2542
using std::is_arithmetic;
#line 2543
using std::is_array;
#line 2544
using std::is_base_of;
#line 2545
using std::is_class;
#line 2546
using std::is_compound;
#line 2547
using std::is_const;
#line 2548
using std::is_convertible;
#line 2549
using std::is_empty;
#line 2550
using std::is_enum;
#line 2551
using std::is_floating_point;
#line 2552
using std::is_function;
#line 2553
using std::is_fundamental;
#line 2554
using std::is_integral;
#line 2555
using std::is_member_function_pointer;
#line 2556
using std::is_member_object_pointer;
#line 2557
using std::is_member_pointer;
#line 2558
using std::is_object;
#line 2559
using std::is_pod;
#line 2560
using std::is_pointer;
#line 2561
using std::is_polymorphic;
#line 2562
using std::is_reference;
#line 2563
using std::is_same;
#line 2564
using std::is_scalar;
#line 2565
using std::is_signed;
#line 2566
using std::is_union;
#line 2567
using std::is_unsigned;
#line 2568
using std::is_void;
#line 2569
using std::is_volatile;
#line 2570
using std::make_signed;
#line 2571
using std::make_unsigned;
#line 2572
using std::rank;
#line 2573
using std::remove_all_extents;
#line 2574
using std::remove_const;
#line 2575
using std::remove_cv;
#line 2576
using std::remove_extent;
#line 2577
using std::remove_pointer;
#line 2578
using std::remove_reference;
#line 2579
using std::remove_volatile;
#line 2580
using std::true_type;
#line 2581
using std::cref;
#line 2582
using std::ref;
#line 2583
using std::reference_wrapper;
#line 2585
using std::result_of;
#line 2587 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
using std::hash;
#line 2588
}
#line 2589
__pragma( warning(pop)) 
#line 2592 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
}
#line 2601
#pragma warning(pop)
#pragma pack ( pop )
#line 22 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 39
namespace std { 
#line 40
template < class _Ty, _Ty ... _Vals >
struct integer_sequence {
    static_assert ( is_integral_v < _Ty >, "integer_sequence<T, I...> requires T to be an integral type." );

    using value_type = _Ty;

    [ [ nodiscard ] ] static constexpr size_t size ( ) noexcept {
        return sizeof ... ( _Vals );
    }
};
#line 51
template< class _Ty, _Ty _Size> using make_integer_sequence = __make_integer_seq< integer_sequence, _Ty, _Size> ; 
#line 54
template< size_t ..._Vals> using index_sequence = integer_sequence< unsigned __int64, _Vals...> ; 
#line 57
template< size_t _Size> using make_index_sequence = make_integer_sequence< unsigned __int64, _Size> ; 
#line 60
template< class ..._Types> using index_sequence_for = make_index_sequence< sizeof...(_Types)> ; 
#line 63
template < class _Ty, class _Pr >
[ [ nodiscard ] ] constexpr const _Ty & ( max ) ( const _Ty & _Left [ [ msvc :: lifetimebound ] ], const _Ty & _Right [ [ msvc :: lifetimebound ] ],
    _Pr _Pred ) noexcept ( noexcept ( _Pred ( _Left, _Right ) ) ) {

    return _Pred ( _Left, _Right ) ? _Right : _Left;
}
#line 70
#pragma warning(push)
#pragma warning(disable : 28285)
template < class _Ty >
[ [ nodiscard ] ] constexpr const _Ty &
    ( max ) ( const _Ty & _Left [ [ msvc :: lifetimebound ] ], const _Ty & _Right [ [ msvc :: lifetimebound ] ] )
        noexcept ( noexcept ( _Left < _Right ) ) {

    return _Left < _Right ? _Right : _Left;
}
#pragma warning(pop)
#line 81
template < class _Ty, class _Pr >
[ [ nodiscard ] ] constexpr _Ty ( max ) ( initializer_list < _Ty >, _Pr );
#line 84
template < class _Ty >
[ [ nodiscard ] ] constexpr _Ty ( max ) ( initializer_list < _Ty > );
#line 87
template < class _Ty, class _Pr >
[ [ nodiscard ] ] constexpr const _Ty & ( min ) ( const _Ty & _Left [ [ msvc :: lifetimebound ] ], const _Ty & _Right [ [ msvc :: lifetimebound ] ],
    _Pr _Pred ) noexcept ( noexcept ( _Pred ( _Right, _Left ) ) ) {

    return _Pred ( _Right, _Left ) ? _Right : _Left;
}
#line 94
#pragma warning(push)
#pragma warning(disable : 28285)
template < class _Ty >
[ [ nodiscard ] ] constexpr const _Ty &
    ( min ) ( const _Ty & _Left [ [ msvc :: lifetimebound ] ], const _Ty & _Right [ [ msvc :: lifetimebound ] ] )
        noexcept ( noexcept ( _Right < _Left ) ) {

    return _Right < _Left ? _Right : _Left;
}
#pragma warning(pop)
#line 105
template < class _Ty, class _Pr >
[ [ nodiscard ] ] constexpr _Ty ( min ) ( initializer_list < _Ty >, _Pr );
#line 108
template < class _Ty >
[ [ nodiscard ] ] constexpr _Ty ( min ) ( initializer_list < _Ty > );
#line 111
template < class _Ty, size_t _Size, enable_if_t < _Is_swappable < _Ty > :: value, int > >
inline void swap ( _Ty ( & _Left ) [ _Size ], _Ty ( & _Right ) [ _Size ] ) noexcept ( _Is_nothrow_swappable < _Ty > :: value ) {
    if ( & _Left == & _Right ) {
        return;
    }

    if constexpr ( _Is_trivially_swappable_v < _Ty > ) {
        if ( ! :: std :: _Is_constant_evaluated ( ) ) {
            :: std :: _Swap_trivial_arrays ( _Left, _Right );
            return;
        }
    }

    _Ty * _First1 = _Left;
    _Ty * _Last1 = _First1 + _Size;
    _Ty * _First2 = _Right;
    for (; _First1 != _Last1; ++ _First1, ++ _First2 ) {
        swap ( * _First1, * _First2 );
    }
}
#line 135 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"
template < class _Ty, int _Enabled >

inline void swap ( _Ty & _Left, _Ty & _Right )
    noexcept ( is_nothrow_move_constructible_v < _Ty > && is_nothrow_move_assignable_v < _Ty > ) {
    _Ty _Tmp = :: std :: move ( _Left );
    _Left = :: std :: move ( _Right );
    _Right = :: std :: move ( _Tmp );
}
#line 144 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"
#pragma pack(8)
#line 144
struct piecewise_construct_t { 
#line 145
explicit piecewise_construct_t() = default;
#line 146
}; 
#pragma pack()
constexpr piecewise_construct_t piecewise_construct{}; 
#line 150
#pragma pack(8)
#line 150
struct _Ignore { 
#line 151
template < class _Ty >
    constexpr const _Ignore & operator = ( const _Ty & ) const noexcept {

        return * this;
    }
#line 156
}; 
#pragma pack(8)
constexpr _Ignore ignore{}; 
#line 160
template< class ..._Types> class tuple; 
#line 163
template < class _Ty1, class _Ty2 >
struct pair;
#line 166
template< class _Ty, size_t _Size> class array; 
#line 169
template< class _Tuple> struct tuple_size; 
#line 172
template< class _Ty> constexpr size_t 
#line 173
tuple_size_v = (tuple_size< _Ty> ::value); 
#line 175
template< size_t _Index, class _Tuple> struct tuple_element; 
#line 178
template< size_t _Index, class _Tuple> using tuple_element_t = typename tuple_element< _Index, _Tuple> ::type; 
#line 181
template< size_t _Index, class ..._Types> 
#line 182
[[nodiscard]] constexpr auto &&
#line 181
_Tuple_get(tuple< _Types...>  && _Tuple) noexcept; 
#line 184
template< size_t _Index, class ..._Types> 
#line 185
[[nodiscard]] constexpr tuple_element_t< _Index, tuple< _Types...> >  &
#line 184
get(tuple< _Types...>  & _Tuple) noexcept; 
#line 187
template< size_t _Index, class ..._Types> 
#line 188
[[nodiscard]] constexpr const tuple_element_t< _Index, tuple< _Types...> >  &
#line 187
get(const tuple< _Types...>  & _Tuple) noexcept; 
#line 190
template< size_t _Index, class ..._Types> 
#line 191
[[nodiscard]] constexpr tuple_element_t< _Index, tuple< _Types...> >  &&
#line 190
get(tuple< _Types...>  && _Tuple) noexcept; 
#line 193
template< size_t _Index, class ..._Types> 
#line 194
[[nodiscard]] constexpr const tuple_element_t< _Index, tuple< _Types...> >  &&
#line 193
get(const tuple< _Types...>  && _Tuple) noexcept; 
#line 196
template< size_t _Idx, class _Ty, size_t _Size> 
#line 197
[[nodiscard]] constexpr _Ty &
#line 196
get(array< _Ty, _Size>  & _Arr) noexcept; 
#line 199
template< size_t _Idx, class _Ty, size_t _Size> 
#line 200
[[nodiscard]] constexpr const _Ty &
#line 199
get(const array< _Ty, _Size>  & _Arr) noexcept; 
#line 202
template< size_t _Idx, class _Ty, size_t _Size> 
#line 203
[[nodiscard]] constexpr _Ty &&
#line 202
get(array< _Ty, _Size>  && _Arr) noexcept; 
#line 205
template< size_t _Idx, class _Ty, size_t _Size> 
#line 206
[[nodiscard]] constexpr const _Ty &&
#line 205
get(const array< _Ty, _Size>  && _Arr) noexcept; 
#line 246 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"
template < class _Ty1, class _Ty2 >
struct pair {
    using first_type = _Ty1;
    using second_type = _Ty2;

    template < class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t < conjunction_v < is_default_constructible < _Uty1 >, is_default_constructible < _Uty2 >>, int > = 0 >
    constexpr explicit (
        ! conjunction_v < _Is_implicitly_default_constructible < _Uty1 >, _Is_implicitly_default_constructible < _Uty2 >> ) pair ( )
        noexcept ( is_nothrow_default_constructible_v < _Uty1 > && is_nothrow_default_constructible_v < _Uty2 > )
        : first ( ), second ( ) { }

    template < class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t < conjunction_v < is_copy_constructible < _Uty1 >, is_copy_constructible < _Uty2 >>, int > = 0 >
    constexpr explicit ( ! conjunction_v < is_convertible < const _Uty1 &, _Uty1 >, is_convertible < const _Uty2 &, _Uty2 >> )
        pair ( const _Ty1 & _Val1, const _Ty2 & _Val2 )
            noexcept ( is_nothrow_copy_constructible_v < _Uty1 > && is_nothrow_copy_constructible_v < _Uty2 > )
        : first ( _Val1 ), second ( _Val2 ) { }




    template < class _Other1, class _Other2,

        enable_if_t < conjunction_v < is_constructible < _Ty1, _Other1 >, is_constructible < _Ty2, _Other2 >>, int > = 0 >
    constexpr explicit ( ! conjunction_v < is_convertible < _Other1, _Ty1 >, is_convertible < _Other2, _Ty2 >> )
        pair ( _Other1 && _Val1, _Other2 && _Val2 ) noexcept (
            is_nothrow_constructible_v < _Ty1, _Other1 > && is_nothrow_constructible_v < _Ty2, _Other2 > )
        : first ( :: std :: forward < _Other1 > ( _Val1 ) ), second ( :: std :: forward < _Other2 > ( _Val2 ) ) {
    }

    pair ( const pair & ) = default;
    pair ( pair && ) = default;










    template < class _Other1, class _Other2,
        enable_if_t < conjunction_v < is_constructible < _Ty1, const _Other1 & >, is_constructible < _Ty2, const _Other2 & >>,
            int > = 0 >
    constexpr explicit ( ! conjunction_v < is_convertible < const _Other1 &, _Ty1 >, is_convertible < const _Other2 &, _Ty2 >> )
        pair ( const pair < _Other1, _Other2 > & _Right )
            noexcept ( is_nothrow_constructible_v < _Ty1, const _Other1 & >
                     && is_nothrow_constructible_v < _Ty2, const _Other2 & > )
        : first ( _Right . first ), second ( _Right . second ) { }

    template < class _Other1, class _Other2,
        enable_if_t < conjunction_v < is_constructible < _Ty1, _Other1 >, is_constructible < _Ty2, _Other2 >>, int > = 0 >
    constexpr explicit ( ! conjunction_v < is_convertible < _Other1, _Ty1 >, is_convertible < _Other2, _Ty2 >> )
        pair ( pair < _Other1, _Other2 > && _Right ) noexcept (
            is_nothrow_constructible_v < _Ty1, _Other1 > && is_nothrow_constructible_v < _Ty2, _Other2 > )
        : first ( :: std :: forward < _Other1 > ( _Right . first ) ), second ( :: std :: forward < _Other2 > ( _Right . second ) ) { }

























    template < class ... _Types1, class ... _Types2 >
    inline pair ( piecewise_construct_t, tuple < _Types1 ... > _Val1, tuple < _Types2 ... > _Val2 )
        : pair ( _Val1, _Val2, index_sequence_for < _Types1 ... > { }, index_sequence_for < _Types2 ... > { } ) { }

    pair & operator = ( const volatile pair & ) = delete;

    template < class _Myself = pair,
        enable_if_t < conjunction_v < _Is_copy_assignable_no_precondition_check < typename _Myself :: first_type >,
                        _Is_copy_assignable_no_precondition_check < typename _Myself :: second_type >>,
            int > = 0 >
    inline pair & operator = ( _Identity_t < const _Myself & > _Right )
        noexcept ( conjunction_v < is_nothrow_copy_assignable < _Ty1 >, is_nothrow_copy_assignable < _Ty2 >> ) {
        first = _Right . first;
        second = _Right . second;
        return * this;
    }














    template < class _Myself = pair,
        enable_if_t < conjunction_v < _Is_move_assignable_no_precondition_check < typename _Myself :: first_type >,
                        _Is_move_assignable_no_precondition_check < typename _Myself :: second_type >>,
            int > = 0 >
    inline pair & operator = ( _Identity_t < _Myself && > _Right )
        noexcept ( conjunction_v < is_nothrow_move_assignable < _Ty1 >, is_nothrow_move_assignable < _Ty2 >> ) {
        first = :: std :: forward < _Ty1 > ( _Right . first );
        second = :: std :: forward < _Ty2 > ( _Right . second );
        return * this;
    }














    template < class _Other1, class _Other2,
        enable_if_t < conjunction_v < negation < is_same < pair, pair < _Other1, _Other2 >> >, is_assignable < _Ty1 &, const _Other1 & >,
                        is_assignable < _Ty2 &, const _Other2 & >>,
            int > = 0 >
    inline pair & operator = ( const pair < _Other1, _Other2 > & _Right )
        noexcept ( is_nothrow_assignable_v < _Ty1 &, const _Other1 & >
                 && is_nothrow_assignable_v < _Ty2 &, const _Other2 & > ) {
        first = _Right . first;
        second = _Right . second;
        return * this;
    }














    template < class _Other1, class _Other2,
        enable_if_t < conjunction_v < negation < is_same < pair, pair < _Other1, _Other2 >> >, is_assignable < _Ty1 &, _Other1 >,
                        is_assignable < _Ty2 &, _Other2 >>,
            int > = 0 >
    inline pair & operator = ( pair < _Other1, _Other2 > && _Right ) noexcept (
        is_nothrow_assignable_v < _Ty1 &, _Other1 > && is_nothrow_assignable_v < _Ty2 &, _Other2 > ) {
        first = :: std :: forward < _Other1 > ( _Right . first );
        second = :: std :: forward < _Other2 > ( _Right . second );
        return * this;
    }





































    inline void swap ( pair & _Right )
        noexcept ( _Is_nothrow_swappable < _Ty1 > :: value && _Is_nothrow_swappable < _Ty2 > :: value ) {
        using :: std :: swap;
        swap ( first, _Right . first );
        swap ( second, _Right . second );
    }











    _Ty1 first;
    _Ty2 second;

private :
    template < class _Tuple1, class _Tuple2, size_t ... _Indices1, size_t ... _Indices2 >
    constexpr pair ( _Tuple1 & _Val1, _Tuple2 & _Val2, index_sequence < _Indices1 ... >, index_sequence < _Indices2 ... > )
        : first ( :: std :: _Tuple_get < _Indices1 > ( :: std :: move ( _Val1 ) ) ... ),
          second ( :: std :: _Tuple_get < _Indices2 > ( :: std :: move ( _Val2 ) ) ... ) { }
};
#line 487 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"
template < class _Ty1, class _Ty2,
    enable_if_t < _Is_swappable < _Ty1 > :: value && _Is_swappable < _Ty2 > :: value, int > = 0 >
inline void swap ( pair < _Ty1, _Ty2 > & _Left, pair < _Ty1, _Ty2 > & _Right ) noexcept ( noexcept ( _Left . swap ( _Right ) ) ) {
    _Left . swap ( _Right );
}
#line 502 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"
template < class _Ty1, class _Ty2, class _Uty1, class _Uty2 >
[ [ nodiscard ] ] constexpr bool operator == ( const pair < _Ty1, _Ty2 > & _Left, const pair < _Uty1, _Uty2 > & _Right ) {
    return _Left . first == _Right . first && _Left . second == _Right . second;
}
#line 518 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"
template < class _Ty1, class _Ty2, class _Uty1, class _Uty2 >
[ [ nodiscard ] ] constexpr bool operator != ( const pair < _Ty1, _Ty2 > & _Left, const pair < _Uty1, _Uty2 > & _Right ) {
    return ! ( _Left == _Right );
}
#line 523
template < class _Ty1, class _Ty2, class _Uty1, class _Uty2 >
[ [ nodiscard ] ] constexpr bool operator < ( const pair < _Ty1, _Ty2 > & _Left, const pair < _Uty1, _Uty2 > & _Right ) {
    return _Left . first < _Right . first || ( ! ( _Right . first < _Left . first ) && _Left . second < _Right . second );
}
#line 528
template < class _Ty1, class _Ty2, class _Uty1, class _Uty2 >
[ [ nodiscard ] ] constexpr bool operator > ( const pair < _Ty1, _Ty2 > & _Left, const pair < _Uty1, _Uty2 > & _Right ) {
    return _Right < _Left;
}
#line 533
template < class _Ty1, class _Ty2, class _Uty1, class _Uty2 >
[ [ nodiscard ] ] constexpr bool operator <= ( const pair < _Ty1, _Ty2 > & _Left, const pair < _Uty1, _Uty2 > & _Right ) {
    return ! ( _Right < _Left );
}
#line 538
template < class _Ty1, class _Ty2, class _Uty1, class _Uty2 >
[ [ nodiscard ] ] constexpr bool operator >= ( const pair < _Ty1, _Ty2 > & _Left, const pair < _Uty1, _Uty2 > & _Right ) {
    return ! ( _Left < _Right );
}
#line 561 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"
template< class _Ty> 
#line 562
struct _Unrefwrap_helper { 
#line 563
using type = _Ty; 
#line 564
}; 
#line 566
template< class _Ty> 
#line 567
struct _Unrefwrap_helper< reference_wrapper< _Ty> >  { 
#line 568
using type = _Ty &; 
#line 569
}; 
#line 572
template< class _Ty> using _Unrefwrap_t = typename _Unrefwrap_helper< decay_t< _Ty> > ::type; 
#line 575
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr pair < _Unrefwrap_t < _Ty1 >, _Unrefwrap_t < _Ty2 > > make_pair ( _Ty1 && _Val1, _Ty2 && _Val2 )
    noexcept ( is_nothrow_constructible_v < _Unrefwrap_t < _Ty1 >, _Ty1 >
             && is_nothrow_constructible_v < _Unrefwrap_t < _Ty2 >, _Ty2 > ) {

    using _Mypair = pair < _Unrefwrap_t < _Ty1 >, _Unrefwrap_t < _Ty2 >>;
    return _Mypair ( :: std :: forward < _Ty1 > ( _Val1 ), :: std :: forward < _Ty2 > ( _Val2 ) );
}
#line 584
namespace rel_ops { 
#line 585
template < class _Ty >
     [ [ nodiscard ] ] bool operator != ( const _Ty & _Left, const _Ty & _Right ) {
        return ! ( _Left == _Right );
    }
#line 590
template < class _Ty >
     [ [ nodiscard ] ] bool operator > ( const _Ty & _Left, const _Ty & _Right ) {
        return _Right < _Left;
    }
#line 595
template < class _Ty >
     [ [ nodiscard ] ] bool operator <= ( const _Ty & _Left, const _Ty & _Right ) {
        return ! ( _Right < _Left );
    }
#line 600
template < class _Ty >
     [ [ nodiscard ] ] bool operator >= ( const _Ty & _Left, const _Ty & _Right ) {
        return ! ( _Left < _Right );
    }
#line 604
}
#line 606
template< class _Tuple, class  = void> 
#line 607
struct _Tuple_size_sfinae { }; 
#line 609
template< class _Tuple> 
#line 610
struct _Tuple_size_sfinae< _Tuple, void_t< decltype(tuple_size< _Tuple> ::value)> >  : public integral_constant< unsigned __int64, tuple_size< _Tuple> ::value>  { 
#line 611
}; 
#line 613
template< class _Tuple> 
#line 614
struct tuple_size< const _Tuple>  : public _Tuple_size_sfinae< _Tuple>  { }; 
#line 616
template< class _Tuple> 
#line 617
struct tuple_size< volatile _Tuple>  : public _Tuple_size_sfinae< _Tuple>  { }; 
#line 619
template< class _Tuple> 
#line 620
struct tuple_size< const volatile _Tuple>  : public _Tuple_size_sfinae< _Tuple>  { }; 
#line 622
template< size_t _Index, class _Tuple> 
#line 623
struct [[msvc::known_semantics]] tuple_element< _Index, const _Tuple>  : public std::tuple_element< _Index, _Tuple>  { 
#line 624
using _Mybase = std::tuple_element< _Index, _Tuple> ; 
#line 625
using type = std::add_const_t< typename std::tuple_element< _Index, _Tuple> ::type> ; 
#line 626
}; 
#line 628
template< size_t _Index, class _Tuple> 
#line 629
struct [[msvc::known_semantics]] tuple_element< _Index, volatile _Tuple>  : public std::tuple_element< _Index, _Tuple>  { 
#line 631
using _Mybase = std::tuple_element< _Index, _Tuple> ; 
#line 632
using type = std::add_volatile_t< typename std::tuple_element< _Index, _Tuple> ::type> ; 
#line 633
}; 
#line 635
template< size_t _Index, class _Tuple> 
#line 636
struct [[msvc::known_semantics]] tuple_element< _Index, const volatile _Tuple>  : public std::tuple_element< _Index, _Tuple>  { 
#line 638
using _Mybase = std::tuple_element< _Index, _Tuple> ; 
#line 639
using type = std::add_cv_t< typename std::tuple_element< _Index, _Tuple> ::type> ; 
#line 640
}; 
#line 642
template< class _Ty, size_t _Size> 
#line 643
struct tuple_size< array< _Ty, _Size> >  : public integral_constant< unsigned __int64, _Size>  { }; 
#line 645
template< size_t _Idx, class _Ty, size_t _Size> 
#line 646
struct [[msvc::known_semantics]] tuple_element< _Idx, array< _Ty, _Size> >  { 
#line 647
static_assert((_Idx < _Size), "array index out of bounds");
#line 649
using type = _Ty; 
#line 650
}; 
#line 652
template< class ..._Types> 
#line 653
struct tuple_size< tuple< _Types...> >  : public integral_constant< unsigned __int64, sizeof...(_Types)>  { }; 
#line 655
template< size_t _Index> 
#line 656
struct [[msvc::known_semantics]] tuple_element< _Index, tuple< > >  { 
#line 657
static_assert((_Always_false< integral_constant< size_t, _Index> > ), "tuple index out of bounds");
#line 658
}; 
#line 660
template< class _This, class ..._Rest> 
#line 661
struct [[msvc::known_semantics]] tuple_element< 0, tuple< _This, _Rest...> >  { 
#line 662
using type = _This; 
#line 664
using _Ttype = tuple< _This, _Rest...> ; 
#line 665
}; 
#line 667
template< size_t _Index, class _This, class ..._Rest> 
#line 668
struct [[msvc::known_semantics]] tuple_element< _Index, tuple< _This, _Rest...> >  : public std::tuple_element< _Index - (1), tuple< _Rest...> >  { 
#line 669
}; 
#line 671
template< class _Ty1, class _Ty2> 
#line 672
struct tuple_size< pair< _Ty1, _Ty2> >  : public integral_constant< unsigned __int64, 2Ui64>  { }; 
#line 674
template< size_t _Idx, class _Ty1, class _Ty2> 
#line 675
struct [[msvc::known_semantics]] tuple_element< _Idx, pair< _Ty1, _Ty2> >  { 
#line 676
static_assert((_Idx < (2)), "pair index out of bounds");
#line 678
using type = conditional_t< _Idx == (0), _Ty1, _Ty2> ; 
#line 679
}; 
#line 681
template < size_t _Idx, class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr tuple_element_t < _Idx, pair < _Ty1, _Ty2 > > & get ( pair < _Ty1, _Ty2 > & _Pr ) noexcept {

    if constexpr ( _Idx == 0 ) {
        return _Pr . first;
    } else {
        return _Pr . second;
    }
}
#line 691
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr _Ty1 & get ( pair < _Ty1, _Ty2 > & _Pr ) noexcept {

    return _Pr . first;
}
#line 697
template < class _Ty2, class _Ty1 >
[ [ nodiscard ] ] constexpr _Ty2 & get ( pair < _Ty1, _Ty2 > & _Pr ) noexcept {

    return _Pr . second;
}
#line 703
template < size_t _Idx, class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr const tuple_element_t < _Idx, pair < _Ty1, _Ty2 > > & get ( const pair < _Ty1, _Ty2 > & _Pr ) noexcept {

    if constexpr ( _Idx == 0 ) {
        return _Pr . first;
    } else {
        return _Pr . second;
    }
}
#line 713
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr const _Ty1 & get ( const pair < _Ty1, _Ty2 > & _Pr ) noexcept {

    return _Pr . first;
}
#line 719
template < class _Ty2, class _Ty1 >
[ [ nodiscard ] ] constexpr const _Ty2 & get ( const pair < _Ty1, _Ty2 > & _Pr ) noexcept {

    return _Pr . second;
}
#line 725
template < size_t _Idx, class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr tuple_element_t < _Idx, pair < _Ty1, _Ty2 > > && get ( pair < _Ty1, _Ty2 > && _Pr ) noexcept {

    if constexpr ( _Idx == 0 ) {
        return :: std :: forward < _Ty1 > ( _Pr . first );
    } else {
        return :: std :: forward < _Ty2 > ( _Pr . second );
    }
}
#line 735
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr _Ty1 && get ( pair < _Ty1, _Ty2 > && _Pr ) noexcept {

    return :: std :: forward < _Ty1 > ( _Pr . first );
}
#line 741
template < class _Ty2, class _Ty1 >
[ [ nodiscard ] ] constexpr _Ty2 && get ( pair < _Ty1, _Ty2 > && _Pr ) noexcept {

    return :: std :: forward < _Ty2 > ( _Pr . second );
}
#line 747
template < size_t _Idx, class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr const tuple_element_t < _Idx, pair < _Ty1, _Ty2 > > && get ( const pair < _Ty1, _Ty2 > && _Pr ) noexcept {

    if constexpr ( _Idx == 0 ) {
        return :: std :: forward < const _Ty1 > ( _Pr . first );
    } else {
        return :: std :: forward < const _Ty2 > ( _Pr . second );
    }
}
#line 757
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr const _Ty1 && get ( const pair < _Ty1, _Ty2 > && _Pr ) noexcept {

    return :: std :: forward < const _Ty1 > ( _Pr . first );
}
#line 763
template < class _Ty2, class _Ty1 >
[ [ nodiscard ] ] constexpr const _Ty2 && get ( const pair < _Ty1, _Ty2 > && _Pr ) noexcept {

    return :: std :: forward < const _Ty2 > ( _Pr . second );
}
#line 769
template < class _Ty, class _Other = _Ty >
inline _Ty exchange ( _Ty & _Val, _Other && _New_val )
    noexcept ( conjunction_v < is_nothrow_move_constructible < _Ty >, is_nothrow_assignable < _Ty &, _Other >> ) {

    _Ty _Old_val = static_cast < _Ty && > ( _Val );
    _Val = static_cast < _Other && > ( _New_val );
    return _Old_val;
}
#line 778
template < class _Ty >
[ [ nodiscard ] ] [ [ msvc :: intrinsic ] ] constexpr add_const_t < _Ty > & as_const ( _Ty & _Val ) noexcept {
    return _Val;
}
#line 783
template < class _Ty >
void as_const ( const _Ty && ) = delete;
#line 807 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr bool _Cmp_equal ( const _Ty1 _Left, const _Ty2 _Right ) noexcept {
    ;
    if constexpr ( is_signed_v < _Ty1 > == is_signed_v < _Ty2 > ) {
        return _Left == _Right;
    } else if constexpr ( is_signed_v < _Ty2 > ) {
        return _Left == static_cast < make_unsigned_t < _Ty2 >> ( _Right ) && _Right >= 0;
    } else {
        return static_cast < make_unsigned_t < _Ty1 >> ( _Left ) == _Right && _Left >= 0;
    }
}
#line 819
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr bool _Cmp_not_equal ( const _Ty1 _Left, const _Ty2 _Right ) noexcept {
    return ! :: std :: _Cmp_equal ( _Left, _Right );
}
#line 824
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr bool _Cmp_less ( const _Ty1 _Left, const _Ty2 _Right ) noexcept {
    ;
    if constexpr ( is_signed_v < _Ty1 > == is_signed_v < _Ty2 > ) {
        return _Left < _Right;
    } else if constexpr ( is_signed_v < _Ty2 > ) {
        return _Right > 0 && _Left < static_cast < make_unsigned_t < _Ty2 >> ( _Right );
    } else {
        return _Left < 0 || static_cast < make_unsigned_t < _Ty1 >> ( _Left ) < _Right;
    }
}
#line 836
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr bool _Cmp_greater ( const _Ty1 _Left, const _Ty2 _Right ) noexcept {
    return :: std :: _Cmp_less ( _Right, _Left );
}
#line 841
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr bool _Cmp_less_equal ( const _Ty1 _Left, const _Ty2 _Right ) noexcept {
    return ! :: std :: _Cmp_less ( _Right, _Left );
}
#line 846
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr bool _Cmp_greater_equal ( const _Ty1 _Left, const _Ty2 _Right ) noexcept {
    return ! :: std :: _Cmp_less ( _Left, _Right );
}
#line 851
template < class _Ty >
[ [ nodiscard ] ] constexpr _Ty _Min_limit ( ) noexcept {
    ;
    if constexpr ( is_signed_v < _Ty > ) {
        constexpr auto _Unsigned_max = static_cast < make_unsigned_t < _Ty >> ( - 1 );
        return static_cast < _Ty > ( ( _Unsigned_max >> 1 ) + 1 );
    } else {
        return 0;
    }
}
#line 862
template < class _Ty >
[ [ nodiscard ] ] constexpr _Ty _Max_limit ( ) noexcept {
    ;
    if constexpr ( is_signed_v < _Ty > ) {
        constexpr auto _Unsigned_max = static_cast < make_unsigned_t < _Ty >> ( - 1 );
        return static_cast < _Ty > ( _Unsigned_max >> 1 );
    } else {
        return static_cast < _Ty > ( - 1 );
    }
}
#line 873
template < class _Rx, class _Ty >
[ [ nodiscard ] ] constexpr bool _In_range ( const _Ty _Value ) noexcept {
    ;

    constexpr auto _Ty_min = _Min_limit < _Ty > ( );
    constexpr auto _Rx_min = _Min_limit < _Rx > ( );

    if constexpr ( :: std :: _Cmp_less ( _Ty_min, _Rx_min ) ) {
        if ( _Value < _Ty { _Rx_min } ) {
            return false;
        }
    }

    constexpr auto _Ty_max = _Max_limit < _Ty > ( );
    constexpr auto _Rx_max = _Max_limit < _Rx > ( );

    if constexpr ( :: std :: _Cmp_greater ( _Ty_max, _Rx_max ) ) {
        if ( _Value > _Ty { _Rx_max } ) {
            return false;
        }
    }

    return true;
}
#line 977 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"
namespace [[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to suppress this warning.")]] tr1 { 
#line 978
using std::get;
#line 979
using std::tuple_element;
#line 980
using std::tuple_size;
#line 981
}
#line 984 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"
}
#line 994
#pragma warning(pop)
#pragma pack ( pop )
#line 207 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\bin/../include\\cuda_runtime.h"
template< class T> static __inline ::cudaError_t 
#line 208
cudaLaunchKernel(T *
#line 209
func, ::dim3 
#line 210
gridDim, ::dim3 
#line 211
blockDim, void **
#line 212
args, ::size_t 
#line 213
sharedMem = 0, ::cudaStream_t 
#line 214
stream = 0) 
#line 216
{ 
#line 217
return ::cudaLaunchKernel((const void *)func, gridDim, blockDim, args, sharedMem, stream); 
#line 218
} 
#line 279
template< class ...ExpTypes, class ...ActTypes> static __inline ::cudaError_t 
#line 280
cudaLaunchKernelEx(const ::cudaLaunchConfig_t *
#line 281
config, void (*
#line 282
kernel)(ExpTypes ...), ActTypes &&...
#line 283
args) 
#line 285
{ 
#line 286
return [&](ExpTypes ...coercedArgs) { 
#line 287
void *pArgs[] = {(&coercedArgs)...}; 
#line 288
return ::cudaLaunchKernelExC(config, (const void *)(kernel), pArgs); 
#line 289
} (std::forward< ActTypes> (args)...); 
#line 290
} 
#line 348
template< class ...ActTypes> static __inline ::cudaError_t 
#line 349
cudaLaunchKernelEx(const ::cudaLaunchConfig_t *
#line 350
config, const ::cudaKernel_t 
#line 351
kernel, ActTypes &&...
#line 352
args) 
#line 354
{ 
#line 355
void *pArgs[] = {(&args)...}; 
#line 356
return ::cudaLaunchKernelExC(config, (const void *)kernel, pArgs); 
#line 357
} 
#line 410 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\bin/../include\\cuda_runtime.h"
template< class T> static __inline ::cudaError_t 
#line 411
cudaLaunchCooperativeKernel(T *
#line 412
func, ::dim3 
#line 413
gridDim, ::dim3 
#line 414
blockDim, void **
#line 415
args, ::size_t 
#line 416
sharedMem = 0, ::cudaStream_t 
#line 417
stream = 0) 
#line 419
{ 
#line 420
return ::cudaLaunchCooperativeKernel((const void *)func, gridDim, blockDim, args, sharedMem, stream); 
#line 421
} 
#line 454
static __inline cudaError_t cudaEventCreate(cudaEvent_t *
#line 455
event, unsigned 
#line 456
flags) 
#line 458
{ 
#line 459
return ::cudaEventCreateWithFlags(event, flags); 
#line 460
} 
#line 498
static __inline cudaError_t cudaGraphInstantiate(cudaGraphExec_t *
#line 499
pGraphExec, cudaGraph_t 
#line 500
graph, cudaGraphNode_t *
#line 501
pErrorNode, char *
#line 502
pLogBuffer, size_t 
#line 503
bufferSize) 
#line 505
{ 
#line 506
(void)pErrorNode; 
#line 507
(void)pLogBuffer; 
#line 508
(void)bufferSize; 
#line 509
return ::cudaGraphInstantiate(pGraphExec, graph, 0); 
#line 510
} 
#line 569
static __inline cudaError_t cudaMallocHost(void **
#line 570
ptr, size_t 
#line 571
size, unsigned 
#line 572
flags) 
#line 574
{ 
#line 575
return ::cudaHostAlloc(ptr, size, flags); 
#line 576
} 
#line 578
template< class T> static __inline ::cudaError_t 
#line 579
cudaHostAlloc(T **
#line 580
ptr, ::size_t 
#line 581
size, unsigned 
#line 582
flags) 
#line 584
{ 
#line 585
return ::cudaHostAlloc((void **)((void *)ptr), size, flags); 
#line 586
} 
#line 588
template< class T> static __inline ::cudaError_t 
#line 589
cudaHostGetDevicePointer(T **
#line 590
pDevice, void *
#line 591
pHost, unsigned 
#line 592
flags) 
#line 594
{ 
#line 595
return ::cudaHostGetDevicePointer((void **)((void *)pDevice), pHost, flags); 
#line 596
} 
#line 698
template< class T> static __inline ::cudaError_t 
#line 699
cudaMallocManaged(T **
#line 700
devPtr, ::size_t 
#line 701
size, unsigned 
#line 702
flags = 1) 
#line 704
{ 
#line 705
return ::cudaMallocManaged((void **)((void *)devPtr), size, flags); 
#line 706
} 
#line 716
template< class T> ::cudaError_t 
#line 717
cudaMemAdvise(T *
#line 718
devPtr, ::size_t 
#line 719
count, ::cudaMemoryAdvise 
#line 720
advice, ::cudaMemLocation 
#line 721
location) 
#line 723
{ 
#line 724
return ::cudaMemAdvise_v2((const void *)devPtr, count, advice, location); 
#line 725
} 
#line 727
template< class T> static __inline ::cudaError_t 
#line 728
cudaMemPrefetchAsync(T *
#line 729
devPtr, ::size_t 
#line 730
count, ::cudaMemLocation 
#line 731
location, unsigned 
#line 732
flags, ::cudaStream_t 
#line 733
stream = 0) 
#line 735
{ 
#line 736
return ::cudaMemPrefetchAsync_v2((const void *)devPtr, count, location, flags, stream); 
#line 737
} 
#line 819
template< class T> static __inline ::cudaError_t 
#line 820
cudaStreamAttachMemAsync(::cudaStream_t 
#line 821
stream, T *
#line 822
devPtr, ::size_t 
#line 823
length = 0, unsigned 
#line 824
flags = 4) 
#line 826
{ 
#line 827
return ::cudaStreamAttachMemAsync(stream, (void *)devPtr, length, flags); 
#line 828
} 
#line 830
template< class T> __inline ::cudaError_t 
#line 831
cudaMalloc(T **
#line 832
devPtr, ::size_t 
#line 833
size) 
#line 835
{ 
#line 836
return ::cudaMalloc((void **)((void *)devPtr), size); 
#line 837
} 
#line 839
template< class T> static __inline ::cudaError_t 
#line 840
cudaMallocHost(T **
#line 841
ptr, ::size_t 
#line 842
size, unsigned 
#line 843
flags = 0) 
#line 845
{ 
#line 846
return cudaMallocHost((void **)((void *)ptr), size, flags); 
#line 847
} 
#line 849
template< class T> static __inline ::cudaError_t 
#line 850
cudaMallocPitch(T **
#line 851
devPtr, ::size_t *
#line 852
pitch, ::size_t 
#line 853
width, ::size_t 
#line 854
height) 
#line 856
{ 
#line 857
return ::cudaMallocPitch((void **)((void *)devPtr), pitch, width, height); 
#line 858
} 
#line 869
static __inline cudaError_t cudaMallocAsync(void **
#line 870
ptr, size_t 
#line 871
size, cudaMemPool_t 
#line 872
memPool, cudaStream_t 
#line 873
stream) 
#line 875
{ 
#line 876
return ::cudaMallocFromPoolAsync(ptr, size, memPool, stream); 
#line 877
} 
#line 879
template< class T> static __inline ::cudaError_t 
#line 880
cudaMallocAsync(T **
#line 881
ptr, ::size_t 
#line 882
size, ::cudaMemPool_t 
#line 883
memPool, ::cudaStream_t 
#line 884
stream) 
#line 886
{ 
#line 887
return ::cudaMallocFromPoolAsync((void **)((void *)ptr), size, memPool, stream); 
#line 888
} 
#line 890
template< class T> static __inline ::cudaError_t 
#line 891
cudaMallocAsync(T **
#line 892
ptr, ::size_t 
#line 893
size, ::cudaStream_t 
#line 894
stream) 
#line 896
{ 
#line 897
return ::cudaMallocAsync((void **)((void *)ptr), size, stream); 
#line 898
} 
#line 900
template< class T> static __inline ::cudaError_t 
#line 901
cudaMallocFromPoolAsync(T **
#line 902
ptr, ::size_t 
#line 903
size, ::cudaMemPool_t 
#line 904
memPool, ::cudaStream_t 
#line 905
stream) 
#line 907
{ 
#line 908
return ::cudaMallocFromPoolAsync((void **)((void *)ptr), size, memPool, stream); 
#line 909
} 
#line 919
template< class T, class U> static __inline ::cudaError_t 
#line 920
cudaMemcpyBatchAsync(T **
#line 921
dsts, U **srcs, ::size_t *sizes, ::size_t count, ::cudaMemcpyAttributes *attrs, ::size_t *
#line 922
attrsIdxs, ::size_t numAttrs, ::size_t *failIdx, ::cudaStream_t hStream) 
#line 924
{ 
#line 925
return ::cudaMemcpyBatchAsync((void **)dsts, (void **)srcs, sizes, count, attrs, attrsIdxs, numAttrs, failIdx, hStream); 
#line 926
} 
#line 938
template< class T, class U> static __inline ::cudaError_t 
#line 939
cudaMemcpyBatchAsync(T **
#line 940
dsts, U **srcs, ::size_t *sizes, ::size_t count, ::cudaMemcpyAttributes attr, ::size_t *failIdx, ::cudaStream_t hStream) 
#line 942
{ 
#line 943
::size_t attrsIdxs = (0); 
#line 944
return ::cudaMemcpyBatchAsync((void **)dsts, (void **)srcs, sizes, count, &attr, &attrsIdxs, 1, failIdx, hStream); 
#line 945
} 
#line 984
template< class T> static __inline ::cudaError_t 
#line 985
cudaMemcpyToSymbol(const T &
#line 986
symbol, const void *
#line 987
src, ::size_t 
#line 988
count, ::size_t 
#line 989
offset = 0, ::cudaMemcpyKind 
#line 990
kind = cudaMemcpyHostToDevice) 
#line 992
{ 
#line 993
return ::cudaMemcpyToSymbol((const void *)(&symbol), src, count, offset, kind); 
#line 994
} 
#line 1038
template< class T> static __inline ::cudaError_t 
#line 1039
cudaMemcpyToSymbolAsync(const T &
#line 1040
symbol, const void *
#line 1041
src, ::size_t 
#line 1042
count, ::size_t 
#line 1043
offset = 0, ::cudaMemcpyKind 
#line 1044
kind = cudaMemcpyHostToDevice, ::cudaStream_t 
#line 1045
stream = 0) 
#line 1047
{ 
#line 1048
return ::cudaMemcpyToSymbolAsync((const void *)(&symbol), src, count, offset, kind, stream); 
#line 1049
} 
#line 1086
template< class T> static __inline ::cudaError_t 
#line 1087
cudaMemcpyFromSymbol(void *
#line 1088
dst, const T &
#line 1089
symbol, ::size_t 
#line 1090
count, ::size_t 
#line 1091
offset = 0, ::cudaMemcpyKind 
#line 1092
kind = cudaMemcpyDeviceToHost) 
#line 1094
{ 
#line 1095
return ::cudaMemcpyFromSymbol(dst, (const void *)(&symbol), count, offset, kind); 
#line 1096
} 
#line 1140
template< class T> static __inline ::cudaError_t 
#line 1141
cudaMemcpyFromSymbolAsync(void *
#line 1142
dst, const T &
#line 1143
symbol, ::size_t 
#line 1144
count, ::size_t 
#line 1145
offset = 0, ::cudaMemcpyKind 
#line 1146
kind = cudaMemcpyDeviceToHost, ::cudaStream_t 
#line 1147
stream = 0) 
#line 1149
{ 
#line 1150
return ::cudaMemcpyFromSymbolAsync(dst, (const void *)(&symbol), count, offset, kind, stream); 
#line 1151
} 
#line 1209
template< class T> static __inline ::cudaError_t 
#line 1210
cudaGraphAddMemcpyNodeToSymbol(::cudaGraphNode_t *
#line 1211
pGraphNode, ::cudaGraph_t 
#line 1212
graph, const ::cudaGraphNode_t *
#line 1213
pDependencies, ::size_t 
#line 1214
numDependencies, const T &
#line 1215
symbol, const void *
#line 1216
src, ::size_t 
#line 1217
count, ::size_t 
#line 1218
offset, ::cudaMemcpyKind 
#line 1219
kind) 
#line 1220
{ 
#line 1221
return ::cudaGraphAddMemcpyNodeToSymbol(pGraphNode, graph, pDependencies, numDependencies, (const void *)(&symbol), src, count, offset, kind); 
#line 1222
} 
#line 1280
template< class T> static __inline ::cudaError_t 
#line 1281
cudaGraphAddMemcpyNodeFromSymbol(::cudaGraphNode_t *
#line 1282
pGraphNode, ::cudaGraph_t 
#line 1283
graph, const ::cudaGraphNode_t *
#line 1284
pDependencies, ::size_t 
#line 1285
numDependencies, void *
#line 1286
dst, const T &
#line 1287
symbol, ::size_t 
#line 1288
count, ::size_t 
#line 1289
offset, ::cudaMemcpyKind 
#line 1290
kind) 
#line 1291
{ 
#line 1292
return ::cudaGraphAddMemcpyNodeFromSymbol(pGraphNode, graph, pDependencies, numDependencies, dst, (const void *)(&symbol), count, offset, kind); 
#line 1293
} 
#line 1331
template< class T> static __inline ::cudaError_t 
#line 1332
cudaGraphMemcpyNodeSetParamsToSymbol(::cudaGraphNode_t 
#line 1333
node, const T &
#line 1334
symbol, const void *
#line 1335
src, ::size_t 
#line 1336
count, ::size_t 
#line 1337
offset, ::cudaMemcpyKind 
#line 1338
kind) 
#line 1339
{ 
#line 1340
return ::cudaGraphMemcpyNodeSetParamsToSymbol(node, (const void *)(&symbol), src, count, offset, kind); 
#line 1341
} 
#line 1379
template< class T> static __inline ::cudaError_t 
#line 1380
cudaGraphMemcpyNodeSetParamsFromSymbol(::cudaGraphNode_t 
#line 1381
node, void *
#line 1382
dst, const T &
#line 1383
symbol, ::size_t 
#line 1384
count, ::size_t 
#line 1385
offset, ::cudaMemcpyKind 
#line 1386
kind) 
#line 1387
{ 
#line 1388
return ::cudaGraphMemcpyNodeSetParamsFromSymbol(node, dst, (const void *)(&symbol), count, offset, kind); 
#line 1389
} 
#line 1437
template< class T> static __inline ::cudaError_t 
#line 1438
cudaGraphExecMemcpyNodeSetParamsToSymbol(::cudaGraphExec_t 
#line 1439
hGraphExec, ::cudaGraphNode_t 
#line 1440
node, const T &
#line 1441
symbol, const void *
#line 1442
src, ::size_t 
#line 1443
count, ::size_t 
#line 1444
offset, ::cudaMemcpyKind 
#line 1445
kind) 
#line 1446
{ 
#line 1447
return ::cudaGraphExecMemcpyNodeSetParamsToSymbol(hGraphExec, node, (const void *)(&symbol), src, count, offset, kind); 
#line 1448
} 
#line 1496
template< class T> static __inline ::cudaError_t 
#line 1497
cudaGraphExecMemcpyNodeSetParamsFromSymbol(::cudaGraphExec_t 
#line 1498
hGraphExec, ::cudaGraphNode_t 
#line 1499
node, void *
#line 1500
dst, const T &
#line 1501
symbol, ::size_t 
#line 1502
count, ::size_t 
#line 1503
offset, ::cudaMemcpyKind 
#line 1504
kind) 
#line 1505
{ 
#line 1506
return ::cudaGraphExecMemcpyNodeSetParamsFromSymbol(hGraphExec, node, dst, (const void *)(&symbol), count, offset, kind); 
#line 1507
} 
#line 1510
static __inline cudaError_t __stdcall cudaGraphExecUpdate(cudaGraphExec_t hGraphExec, cudaGraph_t hGraph, cudaGraphNode_t *hErrorNode_out, cudaGraphExecUpdateResult *updateResult_out) 
#line 1511
{ 
#line 1512
cudaGraphExecUpdateResultInfo resultInfo; 
#line 1513
cudaError_t status = cudaGraphExecUpdate(hGraphExec, hGraph, &resultInfo); 
#line 1514
if (hErrorNode_out) { 
#line 1515
(*hErrorNode_out) = (resultInfo.errorNode); 
#line 1516
}  
#line 1517
if (updateResult_out) { 
#line 1518
(*updateResult_out) = (resultInfo.result); 
#line 1519
}  
#line 1520
return status; 
#line 1521
} 
#line 1549
template< class T> static __inline ::cudaError_t 
#line 1550
cudaUserObjectCreate(::cudaUserObject_t *
#line 1551
object_out, T *
#line 1552
objectToWrap, unsigned 
#line 1553
initialRefcount, unsigned 
#line 1554
flags) 
#line 1555
{ 
#line 1556
return ::cudaUserObjectCreate(object_out, objectToWrap, [](void *
#line 1559
vpObj) { delete (reinterpret_cast< T *>(vpObj)); } , initialRefcount, flags); 
#line 1562
} 
#line 1564
template< class T> static __inline ::cudaError_t 
#line 1565
cudaUserObjectCreate(::cudaUserObject_t *
#line 1566
object_out, T *
#line 1567
objectToWrap, unsigned 
#line 1568
initialRefcount, ::cudaUserObjectFlags 
#line 1569
flags) 
#line 1570
{ 
#line 1571
return cudaUserObjectCreate(object_out, objectToWrap, initialRefcount, (unsigned)flags); 
#line 1572
} 
#line 1599 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\bin/../include\\cuda_runtime.h"
template< class T> static __inline ::cudaError_t 
#line 1600
cudaGetSymbolAddress(void **
#line 1601
devPtr, const T &
#line 1602
symbol) 
#line 1604
{ 
#line 1605
return ::cudaGetSymbolAddress(devPtr, (const void *)(&symbol)); 
#line 1606
} 
#line 1631
template< class T> static __inline ::cudaError_t 
#line 1632
cudaGetSymbolSize(::size_t *
#line 1633
size, const T &
#line 1634
symbol) 
#line 1636
{ 
#line 1637
return ::cudaGetSymbolSize(size, (const void *)(&symbol)); 
#line 1638
} 
#line 1683
template< class T> static __inline ::cudaError_t 
#line 1684
cudaFuncSetCacheConfig(T *
#line 1685
func, ::cudaFuncCache 
#line 1686
cacheConfig) 
#line 1688
{ 
#line 1689
return ::cudaFuncSetCacheConfig((const void *)func, cacheConfig); 
#line 1690
} 
#line 1692
template< class T> 
#line 1694
__declspec(deprecated) static __inline ::cudaError_t 
#line 1695
cudaFuncSetSharedMemConfig(T *
#line 1696
func, ::cudaSharedMemConfig 
#line 1697
config) 
#line 1699
{ 
#line 1704 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\bin/../include\\cuda_runtime.h"
#pragma warning(suppress: 4996)
#line 1706 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\bin/../include\\cuda_runtime.h"
return ::cudaFuncSetSharedMemConfig((const void *)func, config); 
#line 1710 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\bin/../include\\cuda_runtime.h"
} 
#line 1743 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\bin/../include\\cuda_runtime.h"
template< class T> __inline ::cudaError_t 
#line 1744
cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *
#line 1745
numBlocks, T 
#line 1746
func, int 
#line 1747
blockSize, ::size_t 
#line 1748
dynamicSMemSize) 
#line 1749
{ 
#line 1750
return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void *)func, blockSize, dynamicSMemSize, 0); 
#line 1751
} 
#line 1796
template< class T> __inline ::cudaError_t 
#line 1797
cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *
#line 1798
numBlocks, T 
#line 1799
func, int 
#line 1800
blockSize, ::size_t 
#line 1801
dynamicSMemSize, unsigned 
#line 1802
flags) 
#line 1803
{ 
#line 1804
return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void *)func, blockSize, dynamicSMemSize, flags); 
#line 1805
} 
#line 1810
class __cudaOccupancyB2DHelper { 
#line 1811
size_t n; 
#line 1813
public: __cudaOccupancyB2DHelper(size_t n_) : n(n_) { } 
#line 1814
size_t operator()(int) 
#line 1815
{ 
#line 1816
return n; 
#line 1817
} 
#line 1818
}; 
#line 1866
template< class UnaryFunction, class T> static __inline ::cudaError_t 
#line 1867
cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(int *
#line 1868
minGridSize, int *
#line 1869
blockSize, T 
#line 1870
func, UnaryFunction 
#line 1871
blockSizeToDynamicSMemSize, int 
#line 1872
blockSizeLimit = 0, unsigned 
#line 1873
flags = 0) 
#line 1874
{ 
#line 1875
::cudaError_t status; 
#line 1878
int device; 
#line 1879
::cudaFuncAttributes attr; 
#line 1882
int maxThreadsPerMultiProcessor; 
#line 1883
int warpSize; 
#line 1884
int devMaxThreadsPerBlock; 
#line 1885
int multiProcessorCount; 
#line 1886
int funcMaxThreadsPerBlock; 
#line 1887
int occupancyLimit; 
#line 1888
int granularity; 
#line 1891
int maxBlockSize = 0; 
#line 1892
int numBlocks = 0; 
#line 1893
int maxOccupancy = 0; 
#line 1896
int blockSizeToTryAligned; 
#line 1897
int blockSizeToTry; 
#line 1898
int blockSizeLimitAligned; 
#line 1899
int occupancyInBlocks; 
#line 1900
int occupancyInThreads; 
#line 1901
::size_t dynamicSMemSize; 
#line 1907
if (((!minGridSize) || (!blockSize)) || (!func)) { 
#line 1908
return cudaErrorInvalidValue; 
#line 1909
}  
#line 1915
status = ::cudaGetDevice(&device); 
#line 1916
if (status != (cudaSuccess)) { 
#line 1917
return status; 
#line 1918
}  
#line 1920
status = cudaDeviceGetAttribute(&maxThreadsPerMultiProcessor, cudaDevAttrMaxThreadsPerMultiProcessor, device); 
#line 1924
if (status != (cudaSuccess)) { 
#line 1925
return status; 
#line 1926
}  
#line 1928
status = cudaDeviceGetAttribute(&warpSize, cudaDevAttrWarpSize, device); 
#line 1932
if (status != (cudaSuccess)) { 
#line 1933
return status; 
#line 1934
}  
#line 1936
status = cudaDeviceGetAttribute(&devMaxThreadsPerBlock, cudaDevAttrMaxThreadsPerBlock, device); 
#line 1940
if (status != (cudaSuccess)) { 
#line 1941
return status; 
#line 1942
}  
#line 1944
status = cudaDeviceGetAttribute(&multiProcessorCount, cudaDevAttrMultiProcessorCount, device); 
#line 1948
if (status != (cudaSuccess)) { 
#line 1949
return status; 
#line 1950
}  
#line 1952
status = cudaFuncGetAttributes(&attr, func); 
#line 1953
if (status != (cudaSuccess)) { 
#line 1954
return status; 
#line 1955
}  
#line 1957
funcMaxThreadsPerBlock = (attr.maxThreadsPerBlock); 
#line 1963
occupancyLimit = maxThreadsPerMultiProcessor; 
#line 1964
granularity = warpSize; 
#line 1966
if (blockSizeLimit == 0) { 
#line 1967
blockSizeLimit = devMaxThreadsPerBlock; 
#line 1968
}  
#line 1970
if (devMaxThreadsPerBlock < blockSizeLimit) { 
#line 1971
blockSizeLimit = devMaxThreadsPerBlock; 
#line 1972
}  
#line 1974
if (funcMaxThreadsPerBlock < blockSizeLimit) { 
#line 1975
blockSizeLimit = funcMaxThreadsPerBlock; 
#line 1976
}  
#line 1978
blockSizeLimitAligned = (((blockSizeLimit + (granularity - 1)) / granularity) * granularity); 
#line 1980
for (blockSizeToTryAligned = blockSizeLimitAligned; blockSizeToTryAligned > 0; blockSizeToTryAligned -= granularity) { 
#line 1984
if (blockSizeLimit < blockSizeToTryAligned) { 
#line 1985
blockSizeToTry = blockSizeLimit; 
#line 1986
} else { 
#line 1987
blockSizeToTry = blockSizeToTryAligned; 
#line 1988
}  
#line 1990
dynamicSMemSize = blockSizeToDynamicSMemSize(blockSizeToTry); 
#line 1992
status = cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(&occupancyInBlocks, func, blockSizeToTry, dynamicSMemSize, flags); 
#line 1999
if (status != (cudaSuccess)) { 
#line 2000
return status; 
#line 2001
}  
#line 2003
occupancyInThreads = (blockSizeToTry * occupancyInBlocks); 
#line 2005
if (occupancyInThreads > maxOccupancy) { 
#line 2006
maxBlockSize = blockSizeToTry; 
#line 2007
numBlocks = occupancyInBlocks; 
#line 2008
maxOccupancy = occupancyInThreads; 
#line 2009
}  
#line 2013
if (occupancyLimit == maxOccupancy) { 
#line 2014
break; 
#line 2015
}  
#line 2016
}  
#line 2024
(*minGridSize) = (numBlocks * multiProcessorCount); 
#line 2025
(*blockSize) = maxBlockSize; 
#line 2027
return status; 
#line 2028
} 
#line 2062
template< class UnaryFunction, class T> static __inline ::cudaError_t 
#line 2063
cudaOccupancyMaxPotentialBlockSizeVariableSMem(int *
#line 2064
minGridSize, int *
#line 2065
blockSize, T 
#line 2066
func, UnaryFunction 
#line 2067
blockSizeToDynamicSMemSize, int 
#line 2068
blockSizeLimit = 0) 
#line 2069
{ 
#line 2070
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, blockSizeToDynamicSMemSize, blockSizeLimit, 0); 
#line 2071
} 
#line 2108
template< class T> static __inline ::cudaError_t 
#line 2109
cudaOccupancyMaxPotentialBlockSize(int *
#line 2110
minGridSize, int *
#line 2111
blockSize, T 
#line 2112
func, ::size_t 
#line 2113
dynamicSMemSize = 0, int 
#line 2114
blockSizeLimit = 0) 
#line 2115
{ 
#line 2116
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, ((::__cudaOccupancyB2DHelper)(dynamicSMemSize)), blockSizeLimit, 0); 
#line 2117
} 
#line 2147
template< class T> static __inline ::cudaError_t 
#line 2148
cudaOccupancyAvailableDynamicSMemPerBlock(::size_t *
#line 2149
dynamicSmemSize, T *
#line 2150
func, int 
#line 2151
numBlocks, int 
#line 2152
blockSize) 
#line 2153
{ 
#line 2154
return ::cudaOccupancyAvailableDynamicSMemPerBlock(dynamicSmemSize, (const void *)func, numBlocks, blockSize); 
#line 2155
} 
#line 2206
template< class T> static __inline ::cudaError_t 
#line 2207
cudaOccupancyMaxPotentialBlockSizeWithFlags(int *
#line 2208
minGridSize, int *
#line 2209
blockSize, T 
#line 2210
func, ::size_t 
#line 2211
dynamicSMemSize = 0, int 
#line 2212
blockSizeLimit = 0, unsigned 
#line 2213
flags = 0) 
#line 2214
{ 
#line 2215
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, ((::__cudaOccupancyB2DHelper)(dynamicSMemSize)), blockSizeLimit, flags); 
#line 2216
} 
#line 2251
template< class T> static __inline ::cudaError_t 
#line 2252
cudaOccupancyMaxPotentialClusterSize(int *
#line 2253
clusterSize, T *
#line 2254
func, const ::cudaLaunchConfig_t *
#line 2255
config) 
#line 2256
{ 
#line 2257
return ::cudaOccupancyMaxPotentialClusterSize(clusterSize, (const void *)func, config); 
#line 2258
} 
#line 2295
template< class T> static __inline ::cudaError_t 
#line 2296
cudaOccupancyMaxActiveClusters(int *
#line 2297
numClusters, T *
#line 2298
func, const ::cudaLaunchConfig_t *
#line 2299
config) 
#line 2300
{ 
#line 2301
return ::cudaOccupancyMaxActiveClusters(numClusters, (const void *)func, config); 
#line 2302
} 
#line 2336
template< class T> __inline ::cudaError_t 
#line 2337
cudaFuncGetAttributes(::cudaFuncAttributes *
#line 2338
attr, T *
#line 2339
entry) 
#line 2341
{ 
#line 2342
return ::cudaFuncGetAttributes(attr, (const void *)entry); 
#line 2343
} 
#line 2402
template< class T> static __inline ::cudaError_t 
#line 2403
cudaFuncSetAttribute(T *
#line 2404
func, ::cudaFuncAttribute 
#line 2405
attr, int 
#line 2406
value) 
#line 2408
{ 
#line 2409
return ::cudaFuncSetAttribute((const void *)func, attr, value); 
#line 2410
} 
#line 2435
template< class T> static __inline ::cudaError_t __stdcall 
#line 2436
cudaFuncGetName(const char **
#line 2437
name, T *
#line 2438
func) 
#line 2440
{ 
#line 2441
return ::cudaFuncGetName(name, (const void *)func); 
#line 2442
} 
#line 2458
template< class T> static __inline ::cudaError_t 
#line 2459
cudaGetKernel(::cudaKernel_t *
#line 2460
kernelPtr, T *
#line 2461
func) 
#line 2463
{ 
#line 2464
return ::cudaGetKernel(kernelPtr, (const void *)func); 
#line 2465
} 
#line 2496
template< class T> static __inline ::cudaError_t 
#line 2497
cudaLibraryGetGlobal(T **dptr, ::size_t *bytes, ::cudaLibrary_t library, const char *name) 
#line 2498
{ 
#line 2499
return ::cudaLibraryGetGlobal((void **)((void *)dptr), bytes, library, name); 
#line 2500
} 
#line 2530
template< class T> static __inline ::cudaError_t 
#line 2531
cudaLibraryGetManaged(T **dptr, ::size_t *bytes, ::cudaLibrary_t library, const char *name) 
#line 2532
{ 
#line 2533
return ::cudaLibraryGetManaged((void **)((void *)dptr), bytes, library, name); 
#line 2534
} 
#line 2560
template< class T> static __inline ::cudaError_t 
#line 2561
cudaLibraryGetUnifiedFunction(T **fptr, ::cudaLibrary_t library, const char *symbol) 
#line 2562
{ 
#line 2563
return ::cudaLibraryGetUnifiedFunction((void **)((void *)fptr), library, symbol); 
#line 2564
} 
#line 2579 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.9\\bin/../include\\cuda_runtime.h"
#pragma warning(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\float.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 19
__pragma( pack ( push, 8 )) extern "C" {
#line 231 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\float.h"
unsigned __cdecl _clearfp(); 
#line 233
#pragma warning(push)
#pragma warning(disable: 4141)
#line 237
unsigned __cdecl _controlfp(unsigned _NewValue, unsigned _Mask); 
#line 242
#pragma warning(pop)
#line 245
void __cdecl _set_controlfp(unsigned _NewValue, unsigned _Mask); 
#line 251
errno_t __cdecl _controlfp_s(unsigned * _CurrentState, unsigned _NewValue, unsigned _Mask); 
#line 258
unsigned __cdecl _statusfp(); 
#line 261
void __cdecl _fpreset(); 
#line 277
unsigned __cdecl _control87(unsigned _NewValue, unsigned _Mask); 
#line 294
int *__cdecl __fpecode(); 
#line 299
int __cdecl __fpe_flt_rounds(); 
#line 312
double __cdecl _copysign(double _Number, double _Sign); 
#line 313
double __cdecl _chgsign(double _X); 
#line 314
double __cdecl _scalb(double _X, long _Y); 
#line 315
double __cdecl _logb(double _X); 
#line 316
double __cdecl _nextafter(double _X, double _Y); 
#line 317
int __cdecl _finite(double _X); 
#line 318
int __cdecl _isnan(double _X); 
#line 319
int __cdecl _fpclass(double _X); 
#line 322
float __cdecl _scalbf(float _X, long _Y); 
#line 339 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\float.h"
void __cdecl fpreset(); 
#line 406 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\float.h"
}__pragma( pack ( pop )) 
#line 408
#pragma warning(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_stdio_config.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 16
__pragma( pack ( push, 8 )) extern "C" {
#line 72 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_stdio_config.h"
#pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
#line 89 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_stdio_config.h"
__declspec(noinline) __inline unsigned __int64 *__cdecl __local_stdio_printf_options() 
#line 90
{ 
#line 91
static unsigned __int64 _OptionsStorage; 
#line 92
return &_OptionsStorage; 
#line 93
} 
#line 99
__declspec(noinline) __inline unsigned __int64 *__cdecl __local_stdio_scanf_options() 
#line 100
{ 
#line 101
static unsigned __int64 _OptionsStorage; 
#line 102
return &_OptionsStorage; 
#line 103
} 
#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_stdio_config.h"
}__pragma( pack ( pop )) 
#line 131
#pragma warning(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 19
__pragma( pack ( push, 8 )) extern "C" {
#line 31
typedef 
#line 28
struct _iobuf { 
#line 30
void *_Placeholder; 
#line 31
} FILE; 
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
FILE *__cdecl __acrt_iob_func(unsigned _Ix); 
#line 51
wint_t __cdecl fgetwc(FILE * _Stream); 
#line 56
wint_t __cdecl _fgetwchar(); 
#line 59
wint_t __cdecl fputwc(__wchar_t _Character, FILE * _Stream); 
#line 64
wint_t __cdecl _fputwchar(__wchar_t _Character); 
#line 69
wint_t __cdecl getwc(FILE * _Stream); 
#line 74
wint_t __cdecl getwchar(); 
#line 79
__wchar_t *__cdecl fgetws(__wchar_t * _Buffer, int _BufferCount, FILE * _Stream); 
#line 86
int __cdecl fputws(const __wchar_t * _Buffer, FILE * _Stream); 
#line 93
__wchar_t *__cdecl _getws_s(__wchar_t * _Buffer, size_t _BufferCount); 
#line 98
extern "C++" {template < size_t _Size > inline wchar_t * __cdecl _getws_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _getws_s ( _Buffer, _Size ); }}
#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
wint_t __cdecl putwc(__wchar_t _Character, FILE * _Stream); 
#line 111
wint_t __cdecl putwchar(__wchar_t _Character); 
#line 116
int __cdecl _putws(const __wchar_t * _Buffer); 
#line 121
wint_t __cdecl ungetwc(wint_t _Character, FILE * _Stream); 
#line 127
FILE *__cdecl _wfdopen(int _FileHandle, const __wchar_t * _Mode); 
#line 133
FILE *__cdecl _wfopen(const __wchar_t * _FileName, const __wchar_t * _Mode); 
#line 139
errno_t __cdecl _wfopen_s(FILE ** _Stream, const __wchar_t * _FileName, const __wchar_t * _Mode); 
#line 147
FILE *__cdecl _wfreopen(const __wchar_t * _FileName, const __wchar_t * _Mode, FILE * _OldStream); 
#line 154
errno_t __cdecl _wfreopen_s(FILE ** _Stream, const __wchar_t * _FileName, const __wchar_t * _Mode, FILE * _OldStream); 
#line 162
FILE *__cdecl _wfsopen(const __wchar_t * _FileName, const __wchar_t * _Mode, int _ShFlag); 
#line 168
void __cdecl _wperror(const __wchar_t * _ErrorMessage); 
#line 175
FILE *__cdecl _wpopen(const __wchar_t * _Command, const __wchar_t * _Mode); 
#line 182 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
int __cdecl _wremove(const __wchar_t * _FileName); 
#line 190
__declspec(allocator) __wchar_t *__cdecl _wtempnam(const __wchar_t * _Directory, const __wchar_t * _FilePrefix); 
#line 199
errno_t __cdecl _wtmpnam_s(__wchar_t * _Buffer, size_t _BufferCount); 
#line 204
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wtmpnam_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wtmpnam_s ( _Buffer, _Size ); }}
#line 210 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__wchar_t *__cdecl _wtmpnam(__wchar_t * _Buffer); 
#line 224 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
wint_t __cdecl _fgetwc_nolock(FILE * _Stream); 
#line 229
wint_t __cdecl _fputwc_nolock(__wchar_t _Character, FILE * _Stream); 
#line 235
wint_t __cdecl _getwc_nolock(FILE * _Stream); 
#line 240
wint_t __cdecl _putwc_nolock(__wchar_t _Character, FILE * _Stream); 
#line 246
wint_t __cdecl _ungetwc_nolock(wint_t _Character, FILE * _Stream); 
#line 272 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
int __cdecl __stdio_common_vfwprintf(unsigned __int64 _Options, FILE * _Stream, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 281
int __cdecl __stdio_common_vfwprintf_s(unsigned __int64 _Options, FILE * _Stream, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 290
int __cdecl __stdio_common_vfwprintf_p(unsigned __int64 _Options, FILE * _Stream, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 299
__inline int __cdecl _vfwprintf_l(FILE *const 
#line 300
_Stream, const __wchar_t *const 
#line 301
_Format, const _locale_t 
#line 302
_Locale, va_list 
#line 303
_ArgList) 
#line 308 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 309
return __stdio_common_vfwprintf(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 310
} 
#line 314 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vfwprintf(FILE *const 
#line 315
_Stream, const __wchar_t *const 
#line 316
_Format, va_list 
#line 317
_ArgList) 
#line 322 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 323
return _vfwprintf_l(_Stream, _Format, 0, _ArgList); 
#line 324
} 
#line 328 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vfwprintf_s_l(FILE *const 
#line 329
_Stream, const __wchar_t *const 
#line 330
_Format, const _locale_t 
#line 331
_Locale, va_list 
#line 332
_ArgList) 
#line 337 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 338
return __stdio_common_vfwprintf_s(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 339
} 
#line 345 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vfwprintf_s(FILE *const 
#line 346
_Stream, const __wchar_t *const 
#line 347
_Format, va_list 
#line 348
_ArgList) 
#line 353 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 354
return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList); 
#line 355
} 
#line 361 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vfwprintf_p_l(FILE *const 
#line 362
_Stream, const __wchar_t *const 
#line 363
_Format, const _locale_t 
#line 364
_Locale, va_list 
#line 365
_ArgList) 
#line 370 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 371
return __stdio_common_vfwprintf_p(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 372
} 
#line 376 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vfwprintf_p(FILE *const 
#line 377
_Stream, const __wchar_t *const 
#line 378
_Format, va_list 
#line 379
_ArgList) 
#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 385
return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList); 
#line 386
} 
#line 390 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwprintf_l(const __wchar_t *const 
#line 391
_Format, const _locale_t 
#line 392
_Locale, va_list 
#line 393
_ArgList) 
#line 398 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 399
return _vfwprintf_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 400
} 
#line 404 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vwprintf(const __wchar_t *const 
#line 405
_Format, va_list 
#line 406
_ArgList) 
#line 411 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 412
return _vfwprintf_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 413
} 
#line 417 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwprintf_s_l(const __wchar_t *const 
#line 418
_Format, const _locale_t 
#line 419
_Locale, va_list 
#line 420
_ArgList) 
#line 425 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 426
return _vfwprintf_s_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 427
} 
#line 433 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vwprintf_s(const __wchar_t *const 
#line 434
_Format, va_list 
#line 435
_ArgList) 
#line 440 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 441
return _vfwprintf_s_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 442
} 
#line 448 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwprintf_p_l(const __wchar_t *const 
#line 449
_Format, const _locale_t 
#line 450
_Locale, va_list 
#line 451
_ArgList) 
#line 456 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 457
return _vfwprintf_p_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 458
} 
#line 462 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwprintf_p(const __wchar_t *const 
#line 463
_Format, va_list 
#line 464
_ArgList) 
#line 469 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 470
return _vfwprintf_p_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 471
} 
#line 475 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwprintf_l(FILE *const 
#line 476
_Stream, const __wchar_t *const 
#line 477
_Format, const _locale_t 
#line 478
_Locale, ...) 
#line 483 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 484
int _Result; 
#line 485
va_list _ArgList; 
#line 486
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 487
_Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList); 
#line 488
(void)(_ArgList = ((va_list)0)); 
#line 489
return _Result; 
#line 490
} 
#line 494 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl fwprintf(FILE *const 
#line 495
_Stream, const __wchar_t *const 
#line 496
_Format, ...) 
#line 501 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 502
int _Result; 
#line 503
va_list _ArgList; 
#line 504
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 505
_Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList); 
#line 506
(void)(_ArgList = ((va_list)0)); 
#line 507
return _Result; 
#line 508
} 
#line 512 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwprintf_s_l(FILE *const 
#line 513
_Stream, const __wchar_t *const 
#line 514
_Format, const _locale_t 
#line 515
_Locale, ...) 
#line 520 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 521
int _Result; 
#line 522
va_list _ArgList; 
#line 523
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 524
_Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList); 
#line 525
(void)(_ArgList = ((va_list)0)); 
#line 526
return _Result; 
#line 527
} 
#line 533 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl fwprintf_s(FILE *const 
#line 534
_Stream, const __wchar_t *const 
#line 535
_Format, ...) 
#line 540 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 541
int _Result; 
#line 542
va_list _ArgList; 
#line 543
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 544
_Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList); 
#line 545
(void)(_ArgList = ((va_list)0)); 
#line 546
return _Result; 
#line 547
} 
#line 553 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwprintf_p_l(FILE *const 
#line 554
_Stream, const __wchar_t *const 
#line 555
_Format, const _locale_t 
#line 556
_Locale, ...) 
#line 561 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 562
int _Result; 
#line 563
va_list _ArgList; 
#line 564
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 565
_Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList); 
#line 566
(void)(_ArgList = ((va_list)0)); 
#line 567
return _Result; 
#line 568
} 
#line 572 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwprintf_p(FILE *const 
#line 573
_Stream, const __wchar_t *const 
#line 574
_Format, ...) 
#line 579 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 580
int _Result; 
#line 581
va_list _ArgList; 
#line 582
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 583
_Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList); 
#line 584
(void)(_ArgList = ((va_list)0)); 
#line 585
return _Result; 
#line 586
} 
#line 590 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wprintf_l(const __wchar_t *const 
#line 591
_Format, const _locale_t 
#line 592
_Locale, ...) 
#line 597 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 598
int _Result; 
#line 599
va_list _ArgList; 
#line 600
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 601
_Result = _vfwprintf_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 602
(void)(_ArgList = ((va_list)0)); 
#line 603
return _Result; 
#line 604
} 
#line 608 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl wprintf(const __wchar_t *const 
#line 609
_Format, ...) 
#line 614 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 615
int _Result; 
#line 616
va_list _ArgList; 
#line 617
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 618
_Result = _vfwprintf_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 619
(void)(_ArgList = ((va_list)0)); 
#line 620
return _Result; 
#line 621
} 
#line 625 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wprintf_s_l(const __wchar_t *const 
#line 626
_Format, const _locale_t 
#line 627
_Locale, ...) 
#line 632 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 633
int _Result; 
#line 634
va_list _ArgList; 
#line 635
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 636
_Result = _vfwprintf_s_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 637
(void)(_ArgList = ((va_list)0)); 
#line 638
return _Result; 
#line 639
} 
#line 645 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl wprintf_s(const __wchar_t *const 
#line 646
_Format, ...) 
#line 651 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 652
int _Result; 
#line 653
va_list _ArgList; 
#line 654
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 655
_Result = _vfwprintf_s_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 656
(void)(_ArgList = ((va_list)0)); 
#line 657
return _Result; 
#line 658
} 
#line 664 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wprintf_p_l(const __wchar_t *const 
#line 665
_Format, const _locale_t 
#line 666
_Locale, ...) 
#line 671 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 672
int _Result; 
#line 673
va_list _ArgList; 
#line 674
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 675
_Result = _vfwprintf_p_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 676
(void)(_ArgList = ((va_list)0)); 
#line 677
return _Result; 
#line 678
} 
#line 682 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wprintf_p(const __wchar_t *const 
#line 683
_Format, ...) 
#line 688 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 689
int _Result; 
#line 690
va_list _ArgList; 
#line 691
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 692
_Result = _vfwprintf_p_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 693
(void)(_ArgList = ((va_list)0)); 
#line 694
return _Result; 
#line 695
} 
#line 705 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
int __cdecl __stdio_common_vfwscanf(unsigned __int64 _Options, FILE * _Stream, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 714
__inline int __cdecl _vfwscanf_l(FILE *const 
#line 715
_Stream, const __wchar_t *const 
#line 716
_Format, const _locale_t 
#line 717
_Locale, va_list 
#line 718
_ArgList) 
#line 723 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 724
return __stdio_common_vfwscanf(*__local_stdio_scanf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 727
} 
#line 731 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vfwscanf(FILE *const 
#line 732
_Stream, const __wchar_t *const 
#line 733
_Format, va_list 
#line 734
_ArgList) 
#line 739 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 740
return _vfwscanf_l(_Stream, _Format, 0, _ArgList); 
#line 741
} 
#line 745 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vfwscanf_s_l(FILE *const 
#line 746
_Stream, const __wchar_t *const 
#line 747
_Format, const _locale_t 
#line 748
_Locale, va_list 
#line 749
_ArgList) 
#line 754 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 755
return __stdio_common_vfwscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Stream, _Format, _Locale, _ArgList); 
#line 758
} 
#line 764 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vfwscanf_s(FILE *const 
#line 765
_Stream, const __wchar_t *const 
#line 766
_Format, va_list 
#line 767
_ArgList) 
#line 772 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 773
return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList); 
#line 774
} 
#line 779 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwscanf_l(const __wchar_t *const 
#line 780
_Format, const _locale_t 
#line 781
_Locale, va_list 
#line 782
_ArgList) 
#line 787 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 788
return _vfwscanf_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 789
} 
#line 793 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vwscanf(const __wchar_t *const 
#line 794
_Format, va_list 
#line 795
_ArgList) 
#line 800 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 801
return _vfwscanf_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 802
} 
#line 806 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwscanf_s_l(const __wchar_t *const 
#line 807
_Format, const _locale_t 
#line 808
_Locale, va_list 
#line 809
_ArgList) 
#line 814 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 815
return _vfwscanf_s_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 816
} 
#line 822 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vwscanf_s(const __wchar_t *const 
#line 823
_Format, va_list 
#line 824
_ArgList) 
#line 829 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 830
return _vfwscanf_s_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 831
} 
#line 837 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwscanf_l(FILE *const 
#line 838
_Stream, const __wchar_t *const 
#line 839
_Format, const _locale_t 
#line 840
_Locale, ...) 
#line 845 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 846
int _Result; 
#line 847
va_list _ArgList; 
#line 848
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 849
_Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList); 
#line 850
(void)(_ArgList = ((va_list)0)); 
#line 851
return _Result; 
#line 852
} 
#line 856 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl fwscanf(FILE *const 
#line 857
_Stream, const __wchar_t *const 
#line 858
_Format, ...) 
#line 863 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 864
int _Result; 
#line 865
va_list _ArgList; 
#line 866
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 867
_Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList); 
#line 868
(void)(_ArgList = ((va_list)0)); 
#line 869
return _Result; 
#line 870
} 
#line 874 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwscanf_s_l(FILE *const 
#line 875
_Stream, const __wchar_t *const 
#line 876
_Format, const _locale_t 
#line 877
_Locale, ...) 
#line 882 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 883
int _Result; 
#line 884
va_list _ArgList; 
#line 885
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 886
_Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList); 
#line 887
(void)(_ArgList = ((va_list)0)); 
#line 888
return _Result; 
#line 889
} 
#line 895 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl fwscanf_s(FILE *const 
#line 896
_Stream, const __wchar_t *const 
#line 897
_Format, ...) 
#line 902 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 903
int _Result; 
#line 904
va_list _ArgList; 
#line 905
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 906
_Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList); 
#line 907
(void)(_ArgList = ((va_list)0)); 
#line 908
return _Result; 
#line 909
} 
#line 915 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wscanf_l(const __wchar_t *const 
#line 916
_Format, const _locale_t 
#line 917
_Locale, ...) 
#line 922 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 923
int _Result; 
#line 924
va_list _ArgList; 
#line 925
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 926
_Result = _vfwscanf_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 927
(void)(_ArgList = ((va_list)0)); 
#line 928
return _Result; 
#line 929
} 
#line 933 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl wscanf(const __wchar_t *const 
#line 934
_Format, ...) 
#line 939 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 940
int _Result; 
#line 941
va_list _ArgList; 
#line 942
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 943
_Result = _vfwscanf_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 944
(void)(_ArgList = ((va_list)0)); 
#line 945
return _Result; 
#line 946
} 
#line 950 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wscanf_s_l(const __wchar_t *const 
#line 951
_Format, const _locale_t 
#line 952
_Locale, ...) 
#line 957 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 958
int _Result; 
#line 959
va_list _ArgList; 
#line 960
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 961
_Result = _vfwscanf_s_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 962
(void)(_ArgList = ((va_list)0)); 
#line 963
return _Result; 
#line 964
} 
#line 970 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl wscanf_s(const __wchar_t *const 
#line 971
_Format, ...) 
#line 976 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 977
int _Result; 
#line 978
va_list _ArgList; 
#line 979
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 980
_Result = _vfwscanf_s_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 981
(void)(_ArgList = ((va_list)0)); 
#line 982
return _Result; 
#line 983
} 
#line 1006 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
int __cdecl __stdio_common_vswprintf(unsigned __int64 _Options, __wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1017
int __cdecl __stdio_common_vswprintf_s(unsigned __int64 _Options, __wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1028
int __cdecl __stdio_common_vsnwprintf_s(unsigned __int64 _Options, __wchar_t * _Buffer, size_t _BufferCount, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1040
int __cdecl __stdio_common_vswprintf_p(unsigned __int64 _Options, __wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1051
__inline int __cdecl _vsnwprintf_l(__wchar_t *const 
#line 1052
_Buffer, const size_t 
#line 1053
_BufferCount, const __wchar_t *const 
#line 1054
_Format, const _locale_t 
#line 1055
_Locale, va_list 
#line 1056
_ArgList) 
#line 1061 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1062
const int _Result = __stdio_common_vswprintf((*__local_stdio_printf_options()) | (1Ui64 << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1066
return (_Result < 0) ? -1 : _Result; 
#line 1067
} 
#line 1072 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vsnwprintf_s_l(__wchar_t *const 
#line 1073
_Buffer, const size_t 
#line 1074
_BufferCount, const size_t 
#line 1075
_MaxCount, const __wchar_t *const 
#line 1076
_Format, const _locale_t 
#line 1077
_Locale, va_list 
#line 1078
_ArgList) 
#line 1083 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1084
const int _Result = __stdio_common_vsnwprintf_s(*__local_stdio_printf_options(), _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList); 
#line 1088
return (_Result < 0) ? -1 : _Result; 
#line 1089
} 
#line 1094 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vsnwprintf_s(__wchar_t *const 
#line 1095
_Buffer, const size_t 
#line 1096
_BufferCount, const size_t 
#line 1097
_MaxCount, const __wchar_t *const 
#line 1098
_Format, va_list 
#line 1099
_ArgList) 
#line 1104 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1105
return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList); 
#line 1106
} 
#line 1109 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwprintf(__wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, ...); __inline int __cdecl _vsnwprintf(__wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, va_list _Args); 
#line 1120 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vsnwprintf(__wchar_t *
#line 1121
_Buffer, size_t 
#line 1122
_BufferCount, const __wchar_t *
#line 1123
_Format, va_list 
#line 1124
_ArgList) 
#line 1129 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1130
return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1131
} 
#line 1134 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl _vsnwprintf_s ( wchar_t ( & _Buffer ) [ _Size ], size_t _BufferCount, wchar_t const * _Format, va_list _ArgList ) throw ( ) { return _vsnwprintf_s ( _Buffer, _Size, _BufferCount, _Format, _ArgList ); }}
#line 1145 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_c_l(__wchar_t *const 
#line 1146
_Buffer, const size_t 
#line 1147
_BufferCount, const __wchar_t *const 
#line 1148
_Format, const _locale_t 
#line 1149
_Locale, va_list 
#line 1150
_ArgList) 
#line 1155 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1156
const int _Result = __stdio_common_vswprintf(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1160
return (_Result < 0) ? -1 : _Result; 
#line 1161
} 
#line 1166 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_c(__wchar_t *const 
#line 1167
_Buffer, const size_t 
#line 1168
_BufferCount, const __wchar_t *const 
#line 1169
_Format, va_list 
#line 1170
_ArgList) 
#line 1175 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1176
return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1177
} 
#line 1182 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_l(__wchar_t *const 
#line 1183
_Buffer, const size_t 
#line 1184
_BufferCount, const __wchar_t *const 
#line 1185
_Format, const _locale_t 
#line 1186
_Locale, va_list 
#line 1187
_ArgList) 
#line 1192 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1193
return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1194
} 
#line 1199 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl __vswprintf_l(__wchar_t *const 
#line 1200
_Buffer, const __wchar_t *const 
#line 1201
_Format, const _locale_t 
#line 1202
_Locale, va_list 
#line 1203
_ArgList) 
#line 1208 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1209
return _vswprintf_l(_Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1210
} 
#line 1215 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf(__wchar_t *const 
#line 1216
_Buffer, const __wchar_t *const 
#line 1217
_Format, va_list 
#line 1218
_ArgList) 
#line 1223 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1224
return _vswprintf_l(_Buffer, (size_t)(-1), _Format, 0, _ArgList); 
#line 1225
} 
#line 1230 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vswprintf(__wchar_t *const 
#line 1231
_Buffer, const size_t 
#line 1232
_BufferCount, const __wchar_t *const 
#line 1233
_Format, va_list 
#line 1234
_ArgList) 
#line 1239 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1240
return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1241
} 
#line 1246 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_s_l(__wchar_t *const 
#line 1247
_Buffer, const size_t 
#line 1248
_BufferCount, const __wchar_t *const 
#line 1249
_Format, const _locale_t 
#line 1250
_Locale, va_list 
#line 1251
_ArgList) 
#line 1256 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1257
const int _Result = __stdio_common_vswprintf_s(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1261
return (_Result < 0) ? -1 : _Result; 
#line 1262
} 
#line 1268 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vswprintf_s(__wchar_t *const 
#line 1269
_Buffer, const size_t 
#line 1270
_BufferCount, const __wchar_t *const 
#line 1271
_Format, va_list 
#line 1272
_ArgList) 
#line 1277 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1278
return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1279
} 
#line 1284 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl vswprintf_s ( wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _Format, va_list _ArgList ) throw ( ) { return vswprintf_s ( _Buffer, _Size, _Format, _ArgList ); }}
#line 1294 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_p_l(__wchar_t *const 
#line 1295
_Buffer, const size_t 
#line 1296
_BufferCount, const __wchar_t *const 
#line 1297
_Format, const _locale_t 
#line 1298
_Locale, va_list 
#line 1299
_ArgList) 
#line 1304 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1305
const int _Result = __stdio_common_vswprintf_p(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1309
return (_Result < 0) ? -1 : _Result; 
#line 1310
} 
#line 1315 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_p(__wchar_t *const 
#line 1316
_Buffer, const size_t 
#line 1317
_BufferCount, const __wchar_t *const 
#line 1318
_Format, va_list 
#line 1319
_ArgList) 
#line 1324 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1325
return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1326
} 
#line 1331 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vscwprintf_l(const __wchar_t *const 
#line 1332
_Format, const _locale_t 
#line 1333
_Locale, va_list 
#line 1334
_ArgList) 
#line 1339 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1340
const int _Result = __stdio_common_vswprintf((*__local_stdio_printf_options()) | (1Ui64 << 1), 0, 0, _Format, _Locale, _ArgList); 
#line 1344
return (_Result < 0) ? -1 : _Result; 
#line 1345
} 
#line 1350 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vscwprintf(const __wchar_t *const 
#line 1351
_Format, va_list 
#line 1352
_ArgList) 
#line 1357 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1358
return _vscwprintf_l(_Format, 0, _ArgList); 
#line 1359
} 
#line 1364 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vscwprintf_p_l(const __wchar_t *const 
#line 1365
_Format, const _locale_t 
#line 1366
_Locale, va_list 
#line 1367
_ArgList) 
#line 1372 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1373
const int _Result = __stdio_common_vswprintf_p((*__local_stdio_printf_options()) | (1Ui64 << 1), 0, 0, _Format, _Locale, _ArgList); 
#line 1377
return (_Result < 0) ? -1 : _Result; 
#line 1378
} 
#line 1383 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vscwprintf_p(const __wchar_t *const 
#line 1384
_Format, va_list 
#line 1385
_ArgList) 
#line 1390 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1391
return _vscwprintf_p_l(_Format, 0, _ArgList); 
#line 1392
} 
#line 1397 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl __swprintf_l(__wchar_t *const 
#line 1398
_Buffer, const __wchar_t *const 
#line 1399
_Format, const _locale_t 
#line 1400
_Locale, ...) 
#line 1405 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1406
int _Result; 
#line 1407
va_list _ArgList; 
#line 1408
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1409
_Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList); 
#line 1410
(void)(_ArgList = ((va_list)0)); 
#line 1411
return _Result; 
#line 1412
} 
#line 1417 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_l(__wchar_t *const 
#line 1418
_Buffer, const size_t 
#line 1419
_BufferCount, const __wchar_t *const 
#line 1420
_Format, const _locale_t 
#line 1421
_Locale, ...) 
#line 1426 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1427
int _Result; 
#line 1428
va_list _ArgList; 
#line 1429
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1430
_Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1431
(void)(_ArgList = ((va_list)0)); 
#line 1432
return _Result; 
#line 1433
} 
#line 1438 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf(__wchar_t *const 
#line 1439
_Buffer, const __wchar_t *const 
#line 1440
_Format, ...) 
#line 1445 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1446
int _Result; 
#line 1447
va_list _ArgList; 
#line 1448
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1449
_Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList); 
#line 1450
(void)(_ArgList = ((va_list)0)); 
#line 1451
return _Result; 
#line 1452
} 
#line 1457 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl swprintf(__wchar_t *const 
#line 1458
_Buffer, const size_t 
#line 1459
_BufferCount, const __wchar_t *const 
#line 1460
_Format, ...) 
#line 1465 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1466
int _Result; 
#line 1467
va_list _ArgList; 
#line 1468
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1469
_Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1470
(void)(_ArgList = ((va_list)0)); 
#line 1471
return _Result; 
#line 1472
} 
#line 1475 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl __swprintf_l(__wchar_t * _Buffer, const __wchar_t * _Format, _locale_t _Locale, ...); __inline int __cdecl __vswprintf_l(__wchar_t * _Buffer, const __wchar_t * _Format, _locale_t _Locale, va_list _Args); 
#line 1484 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf(__wchar_t * _Buffer, const __wchar_t * _Format, ...); __inline int __cdecl _vswprintf(__wchar_t * _Buffer, const __wchar_t * _Format, va_list _Args); 
#line 1493 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_s_l(__wchar_t *const 
#line 1494
_Buffer, const size_t 
#line 1495
_BufferCount, const __wchar_t *const 
#line 1496
_Format, const _locale_t 
#line 1497
_Locale, ...) 
#line 1502 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1503
int _Result; 
#line 1504
va_list _ArgList; 
#line 1505
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1506
_Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1507
(void)(_ArgList = ((va_list)0)); 
#line 1508
return _Result; 
#line 1509
} 
#line 1515 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl swprintf_s(__wchar_t *const 
#line 1516
_Buffer, const size_t 
#line 1517
_BufferCount, const __wchar_t *const 
#line 1518
_Format, ...) 
#line 1523 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1524
int _Result; 
#line 1525
va_list _ArgList; 
#line 1526
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1527
_Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1528
(void)(_ArgList = ((va_list)0)); 
#line 1529
return _Result; 
#line 1530
} 
#line 1535 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl swprintf_s ( wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _Format, ... ) throw ( ) { va_list _ArgList; ( ( void ) ( __vcrt_assert_va_start_is_not_reference < decltype ( _Format ) > ( ), ( ( void ) ( __va_start ( & _ArgList, _Format ) ) ) ) ); return vswprintf_s ( _Buffer, _Size, _Format, _ArgList ); }}
#line 1544 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_p_l(__wchar_t *const 
#line 1545
_Buffer, const size_t 
#line 1546
_BufferCount, const __wchar_t *const 
#line 1547
_Format, const _locale_t 
#line 1548
_Locale, ...) 
#line 1553 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1554
int _Result; 
#line 1555
va_list _ArgList; 
#line 1556
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1557
_Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1558
(void)(_ArgList = ((va_list)0)); 
#line 1559
return _Result; 
#line 1560
} 
#line 1565 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_p(__wchar_t *const 
#line 1566
_Buffer, const size_t 
#line 1567
_BufferCount, const __wchar_t *const 
#line 1568
_Format, ...) 
#line 1573 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1574
int _Result; 
#line 1575
va_list _ArgList; 
#line 1576
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1577
_Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1578
(void)(_ArgList = ((va_list)0)); 
#line 1579
return _Result; 
#line 1580
} 
#line 1585 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_c_l(__wchar_t *const 
#line 1586
_Buffer, const size_t 
#line 1587
_BufferCount, const __wchar_t *const 
#line 1588
_Format, const _locale_t 
#line 1589
_Locale, ...) 
#line 1594 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1595
int _Result; 
#line 1596
va_list _ArgList; 
#line 1597
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1598
_Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1599
(void)(_ArgList = ((va_list)0)); 
#line 1600
return _Result; 
#line 1601
} 
#line 1606 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_c(__wchar_t *const 
#line 1607
_Buffer, const size_t 
#line 1608
_BufferCount, const __wchar_t *const 
#line 1609
_Format, ...) 
#line 1614 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1615
int _Result; 
#line 1616
va_list _ArgList; 
#line 1617
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1618
_Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1619
(void)(_ArgList = ((va_list)0)); 
#line 1620
return _Result; 
#line 1621
} 
#line 1626 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwprintf_l(__wchar_t *const 
#line 1627
_Buffer, const size_t 
#line 1628
_BufferCount, const __wchar_t *const 
#line 1629
_Format, const _locale_t 
#line 1630
_Locale, ...) 
#line 1635 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1636
int _Result; 
#line 1637
va_list _ArgList; 
#line 1638
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1640
_Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1642
(void)(_ArgList = ((va_list)0)); 
#line 1643
return _Result; 
#line 1644
} 
#line 1649 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwprintf(__wchar_t *
#line 1650
_Buffer, size_t 
#line 1651
_BufferCount, const __wchar_t *
#line 1652
_Format, ...) 
#line 1657 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1658
int _Result; 
#line 1659
va_list _ArgList; 
#line 1660
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1662
_Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1664
(void)(_ArgList = ((va_list)0)); 
#line 1665
return _Result; 
#line 1666
} 
#line 1671 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwprintf_s_l(__wchar_t *const 
#line 1672
_Buffer, const size_t 
#line 1673
_BufferCount, const size_t 
#line 1674
_MaxCount, const __wchar_t *const 
#line 1675
_Format, const _locale_t 
#line 1676
_Locale, ...) 
#line 1681 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1682
int _Result; 
#line 1683
va_list _ArgList; 
#line 1684
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1685
_Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList); 
#line 1686
(void)(_ArgList = ((va_list)0)); 
#line 1687
return _Result; 
#line 1688
} 
#line 1693 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwprintf_s(__wchar_t *const 
#line 1694
_Buffer, const size_t 
#line 1695
_BufferCount, const size_t 
#line 1696
_MaxCount, const __wchar_t *const 
#line 1697
_Format, ...) 
#line 1702 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1703
int _Result; 
#line 1704
va_list _ArgList; 
#line 1705
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1706
_Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList); 
#line 1707
(void)(_ArgList = ((va_list)0)); 
#line 1708
return _Result; 
#line 1709
} 
#line 1712 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl _snwprintf_s ( wchar_t ( & _Buffer ) [ _Size ], size_t _BufferCount, wchar_t const * _Format, ... ) throw ( ) { va_list _ArgList; ( ( void ) ( __vcrt_assert_va_start_is_not_reference < decltype ( _Format ) > ( ), ( ( void ) ( __va_start ( & _ArgList, _Format ) ) ) ) ); return _vsnwprintf_s ( _Buffer, _Size, _BufferCount, _Format, _ArgList ); }}
#line 1721 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _scwprintf_l(const __wchar_t *const 
#line 1722
_Format, const _locale_t 
#line 1723
_Locale, ...) 
#line 1728 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1729
int _Result; 
#line 1730
va_list _ArgList; 
#line 1731
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1732
_Result = _vscwprintf_l(_Format, _Locale, _ArgList); 
#line 1733
(void)(_ArgList = ((va_list)0)); 
#line 1734
return _Result; 
#line 1735
} 
#line 1740 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _scwprintf(const __wchar_t *const 
#line 1741
_Format, ...) 
#line 1746 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1747
int _Result; 
#line 1748
va_list _ArgList; 
#line 1749
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1750
_Result = _vscwprintf_l(_Format, 0, _ArgList); 
#line 1751
(void)(_ArgList = ((va_list)0)); 
#line 1752
return _Result; 
#line 1753
} 
#line 1758 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _scwprintf_p_l(const __wchar_t *const 
#line 1759
_Format, const _locale_t 
#line 1760
_Locale, ...) 
#line 1765 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1766
int _Result; 
#line 1767
va_list _ArgList; 
#line 1768
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1769
_Result = _vscwprintf_p_l(_Format, _Locale, _ArgList); 
#line 1770
(void)(_ArgList = ((va_list)0)); 
#line 1771
return _Result; 
#line 1772
} 
#line 1777 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _scwprintf_p(const __wchar_t *const 
#line 1778
_Format, ...) 
#line 1783 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1784
int _Result; 
#line 1785
va_list _ArgList; 
#line 1786
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1787
_Result = _vscwprintf_p_l(_Format, 0, _ArgList); 
#line 1788
(void)(_ArgList = ((va_list)0)); 
#line 1789
return _Result; 
#line 1790
} 
#line 1797 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
#pragma warning(push)
#pragma warning(disable: 4141 6054)
#line 1803
extern "C++" 
#line 1802
__declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) inline int 
#line 1803
swprintf(__wchar_t *const 
#line 1804
_Buffer, const __wchar_t *const 
#line 1805
_Format, ...) throw() 
#line 1807
{ 
#line 1808
int _Result; 
#line 1809
va_list _ArgList; 
#line 1810
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1811
_Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList); 
#line 1812
(void)(_ArgList = ((va_list)0)); 
#line 1813
return _Result; 
#line 1814
} 
#line 1817
extern "C++" 
#line 1816
__declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) inline int __cdecl 
#line 1817
vswprintf(__wchar_t *const 
#line 1818
_Buffer, const __wchar_t *const 
#line 1819
_Format, va_list 
#line 1820
_ArgList) throw() 
#line 1822
{ 
#line 1823
return vswprintf(_Buffer, 2147483647, _Format, _ArgList); 
#line 1824
} 
#line 1827
extern "C++" 
#line 1826
__declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) inline int 
#line 1827
_swprintf_l(__wchar_t *const 
#line 1828
_Buffer, const __wchar_t *const 
#line 1829
_Format, const _locale_t 
#line 1830
_Locale, ...) throw() 
#line 1832
{ 
#line 1833
int _Result; 
#line 1834
va_list _ArgList; 
#line 1835
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1836
_Result = _vswprintf_l(_Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1837
(void)(_ArgList = ((va_list)0)); 
#line 1838
return _Result; 
#line 1839
} 
#line 1842
extern "C++" 
#line 1841
__declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) inline int __cdecl 
#line 1842
_vswprintf_l(__wchar_t *const 
#line 1843
_Buffer, const __wchar_t *const 
#line 1844
_Format, const _locale_t 
#line 1845
_Locale, va_list 
#line 1846
_ArgList) throw() 
#line 1848
{ 
#line 1849
return _vswprintf_l(_Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1850
} 
#line 1854 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
#pragma warning(pop)
#line 1871 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
int __cdecl __stdio_common_vswscanf(unsigned __int64 _Options, const __wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1882
__inline int __cdecl _vswscanf_l(const __wchar_t *const 
#line 1883
_Buffer, const __wchar_t *const 
#line 1884
_Format, const _locale_t 
#line 1885
_Locale, va_list 
#line 1886
_ArgList) 
#line 1891 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1892
return __stdio_common_vswscanf(*__local_stdio_scanf_options(), _Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1895
} 
#line 1900 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vswscanf(const __wchar_t *
#line 1901
_Buffer, const __wchar_t *
#line 1902
_Format, va_list 
#line 1903
_ArgList) 
#line 1908 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1909
return _vswscanf_l(_Buffer, _Format, 0, _ArgList); 
#line 1910
} 
#line 1915 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswscanf_s_l(const __wchar_t *const 
#line 1916
_Buffer, const __wchar_t *const 
#line 1917
_Format, const _locale_t 
#line 1918
_Locale, va_list 
#line 1919
_ArgList) 
#line 1924 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1925
return __stdio_common_vswscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1928
} 
#line 1935 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vswscanf_s(const __wchar_t *const 
#line 1936
_Buffer, const __wchar_t *const 
#line 1937
_Format, va_list 
#line 1938
_ArgList) 
#line 1943 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1944
return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList); 
#line 1945
} 
#line 1950 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl vswscanf_s ( wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _Format, va_list _ArgList ) throw ( ) { return vswscanf_s ( _Buffer, _Size, _Format, _ArgList ); }}
#line 1960 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vsnwscanf_l(const __wchar_t *const 
#line 1961
_Buffer, const size_t 
#line 1962
_BufferCount, const __wchar_t *const 
#line 1963
_Format, const _locale_t 
#line 1964
_Locale, va_list 
#line 1965
_ArgList) 
#line 1970 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1971
return __stdio_common_vswscanf(*__local_stdio_scanf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1974
} 
#line 1979 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vsnwscanf_s_l(const __wchar_t *const 
#line 1980
_Buffer, const size_t 
#line 1981
_BufferCount, const __wchar_t *const 
#line 1982
_Format, const _locale_t 
#line 1983
_Locale, va_list 
#line 1984
_ArgList) 
#line 1989 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1990
return __stdio_common_vswscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1993
} 
#line 1998 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swscanf_l(const __wchar_t *const 
#line 1999
_Buffer, const __wchar_t *const 
#line 2000
_Format, _locale_t 
#line 2001
_Locale, ...) 
#line 2006 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2007
int _Result; 
#line 2008
va_list _ArgList; 
#line 2009
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2010
_Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList); 
#line 2011
(void)(_ArgList = ((va_list)0)); 
#line 2012
return _Result; 
#line 2013
} 
#line 2018 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl swscanf(const __wchar_t *const 
#line 2019
_Buffer, const __wchar_t *const 
#line 2020
_Format, ...) 
#line 2025 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2026
int _Result; 
#line 2027
va_list _ArgList; 
#line 2028
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2029
_Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList); 
#line 2030
(void)(_ArgList = ((va_list)0)); 
#line 2031
return _Result; 
#line 2032
} 
#line 2037 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swscanf_s_l(const __wchar_t *const 
#line 2038
_Buffer, const __wchar_t *const 
#line 2039
_Format, const _locale_t 
#line 2040
_Locale, ...) 
#line 2045 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2046
int _Result; 
#line 2047
va_list _ArgList; 
#line 2048
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2049
_Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList); 
#line 2050
(void)(_ArgList = ((va_list)0)); 
#line 2051
return _Result; 
#line 2052
} 
#line 2059 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl swscanf_s(const __wchar_t *const 
#line 2060
_Buffer, const __wchar_t *const 
#line 2061
_Format, ...) 
#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2067
int _Result; 
#line 2068
va_list _ArgList; 
#line 2069
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2070
_Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList); 
#line 2071
(void)(_ArgList = ((va_list)0)); 
#line 2072
return _Result; 
#line 2073
} 
#line 2080 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwscanf_l(const __wchar_t *const 
#line 2081
_Buffer, const size_t 
#line 2082
_BufferCount, const __wchar_t *const 
#line 2083
_Format, const _locale_t 
#line 2084
_Locale, ...) 
#line 2089 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2090
int _Result; 
#line 2091
va_list _ArgList; 
#line 2092
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2094
_Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 2096
(void)(_ArgList = ((va_list)0)); 
#line 2097
return _Result; 
#line 2098
} 
#line 2103 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwscanf(const __wchar_t *const 
#line 2104
_Buffer, const size_t 
#line 2105
_BufferCount, const __wchar_t *const 
#line 2106
_Format, ...) 
#line 2111 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2112
int _Result; 
#line 2113
va_list _ArgList; 
#line 2114
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2116
_Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 2118
(void)(_ArgList = ((va_list)0)); 
#line 2119
return _Result; 
#line 2120
} 
#line 2125 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwscanf_s_l(const __wchar_t *const 
#line 2126
_Buffer, const size_t 
#line 2127
_BufferCount, const __wchar_t *const 
#line 2128
_Format, const _locale_t 
#line 2129
_Locale, ...) 
#line 2134 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2135
int _Result; 
#line 2136
va_list _ArgList; 
#line 2137
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2138
_Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 2139
(void)(_ArgList = ((va_list)0)); 
#line 2140
return _Result; 
#line 2141
} 
#line 2146 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwscanf_s(const __wchar_t *const 
#line 2147
_Buffer, const size_t 
#line 2148
_BufferCount, const __wchar_t *const 
#line 2149
_Format, ...) 
#line 2154 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2155
int _Result; 
#line 2156
va_list _ArgList; 
#line 2157
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2158
_Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 2159
(void)(_ArgList = ((va_list)0)); 
#line 2160
return _Result; 
#line 2161
} 
#line 2169 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
}__pragma( pack ( pop )) 
#line 2171
#pragma warning(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 19
__pragma( pack ( push, 8 )) extern "C" {
#line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
typedef __int64 fpos_t; 
#line 80
errno_t __cdecl _get_stream_buffer_pointers(FILE * _Stream, char *** _Base, char *** _Pointer, int ** _Count); 
#line 96
errno_t __cdecl clearerr_s(FILE * _Stream); 
#line 102
errno_t __cdecl fopen_s(FILE ** _Stream, const char * _FileName, const char * _Mode); 
#line 110
size_t __cdecl fread_s(void * _Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 119
errno_t __cdecl freopen_s(FILE ** _Stream, const char * _FileName, const char * _Mode, FILE * _OldStream); 
#line 127
char *__cdecl gets_s(char * _Buffer, rsize_t _Size); 
#line 133
errno_t __cdecl tmpfile_s(FILE ** _Stream); 
#line 139
errno_t __cdecl tmpnam_s(char * _Buffer, rsize_t _Size); 
#line 146 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
void __cdecl clearerr(FILE * _Stream); 
#line 152
int __cdecl fclose(FILE * _Stream); 
#line 157
int __cdecl _fcloseall(); 
#line 160
FILE *__cdecl _fdopen(int _FileHandle, const char * _Mode); 
#line 166
int __cdecl feof(FILE * _Stream); 
#line 171
int __cdecl ferror(FILE * _Stream); 
#line 176
int __cdecl fflush(FILE * _Stream); 
#line 182
int __cdecl fgetc(FILE * _Stream); 
#line 187
int __cdecl _fgetchar(); 
#line 191
int __cdecl fgetpos(FILE * _Stream, fpos_t * _Position); 
#line 198
char *__cdecl fgets(char * _Buffer, int _MaxCount, FILE * _Stream); 
#line 205
int __cdecl _fileno(FILE * _Stream); 
#line 210
int __cdecl _flushall(); 
#line 213
FILE *__cdecl fopen(const char * _FileName, const char * _Mode); 
#line 221
int __cdecl fputc(int _Character, FILE * _Stream); 
#line 227
int __cdecl _fputchar(int _Character); 
#line 233
int __cdecl fputs(const char * _Buffer, FILE * _Stream); 
#line 239
size_t __cdecl fread(void * _Buffer, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 248
FILE *__cdecl freopen(const char * _FileName, const char * _Mode, FILE * _Stream); 
#line 255
FILE *__cdecl _fsopen(const char * _FileName, const char * _Mode, int _ShFlag); 
#line 263
int __cdecl fsetpos(FILE * _Stream, const fpos_t * _Position); 
#line 270
int __cdecl fseek(FILE * _Stream, long _Offset, int _Origin); 
#line 278
int __cdecl _fseeki64(FILE * _Stream, __int64 _Offset, int _Origin); 
#line 286
long __cdecl ftell(FILE * _Stream); 
#line 292
__int64 __cdecl _ftelli64(FILE * _Stream); 
#line 297
size_t __cdecl fwrite(const void * _Buffer, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 306
int __cdecl getc(FILE * _Stream); 
#line 311
int __cdecl getchar(); 
#line 314
int __cdecl _getmaxstdio(); 
#line 316
extern "C++" {template < size_t _Size > inline char * __cdecl gets_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return gets_s ( _Buffer, _Size ); }}
#line 321 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
int __cdecl _getw(FILE * _Stream); 
#line 325
void __cdecl perror(const char * _ErrorMessage); 
#line 333
int __cdecl _pclose(FILE * _Stream); 
#line 338
FILE *__cdecl _popen(const char * _Command, const char * _Mode); 
#line 347 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
int __cdecl putc(int _Character, FILE * _Stream); 
#line 353
int __cdecl putchar(int _Character); 
#line 358
int __cdecl puts(const char * _Buffer); 
#line 364
int __cdecl _putw(int _Word, FILE * _Stream); 
#line 369
int __cdecl remove(const char * _FileName); 
#line 374
int __cdecl rename(const char * _OldFileName, const char * _NewFileName); 
#line 379
int __cdecl _unlink(const char * _FileName); 
#line 386
int __cdecl unlink(const char * _FileName); 
#line 392 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
void __cdecl rewind(FILE * _Stream); 
#line 397
int __cdecl _rmtmp(); 
#line 400
void __cdecl setbuf(FILE * _Stream, char * _Buffer); 
#line 406
int __cdecl _setmaxstdio(int _Maximum); 
#line 412
int __cdecl setvbuf(FILE * _Stream, char * _Buffer, int _Mode, size_t _Size); 
#line 425 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__declspec(allocator) char *__cdecl _tempnam(const char * _DirectoryName, const char * _FilePrefix); 
#line 435 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
FILE *__cdecl tmpfile(); 
#line 437
extern "C++" {template < size_t _Size > inline errno_t __cdecl tmpnam_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return tmpnam_s ( _Buffer, _Size ); }}
#line 443 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
char *__cdecl tmpnam(char * _Buffer); 
#line 451 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
int __cdecl ungetc(int _Character, FILE * _Stream); 
#line 463
void __cdecl _lock_file(FILE * _Stream); 
#line 467
void __cdecl _unlock_file(FILE * _Stream); 
#line 473
int __cdecl _fclose_nolock(FILE * _Stream); 
#line 479
int __cdecl _fflush_nolock(FILE * _Stream); 
#line 485
int __cdecl _fgetc_nolock(FILE * _Stream); 
#line 491
int __cdecl _fputc_nolock(int _Character, FILE * _Stream); 
#line 497
size_t __cdecl _fread_nolock(void * _Buffer, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 506
size_t __cdecl _fread_nolock_s(void * _Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 515
int __cdecl _fseek_nolock(FILE * _Stream, long _Offset, int _Origin); 
#line 522
int __cdecl _fseeki64_nolock(FILE * _Stream, __int64 _Offset, int _Origin); 
#line 529
long __cdecl _ftell_nolock(FILE * _Stream); 
#line 534
__int64 __cdecl _ftelli64_nolock(FILE * _Stream); 
#line 539
size_t __cdecl _fwrite_nolock(const void * _Buffer, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 547
int __cdecl _getc_nolock(FILE * _Stream); 
#line 552
int __cdecl _putc_nolock(int _Character, FILE * _Stream); 
#line 558
int __cdecl _ungetc_nolock(int _Character, FILE * _Stream); 
#line 589 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
int *__cdecl __p__commode(); 
#line 609 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
int __cdecl __stdio_common_vfprintf(unsigned __int64 _Options, FILE * _Stream, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 617
int __cdecl __stdio_common_vfprintf_s(unsigned __int64 _Options, FILE * _Stream, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 626
int __cdecl __stdio_common_vfprintf_p(unsigned __int64 _Options, FILE * _Stream, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 635
__inline int __cdecl _vfprintf_l(FILE *const 
#line 636
_Stream, const char *const 
#line 637
_Format, const _locale_t 
#line 638
_Locale, va_list 
#line 639
_ArgList) 
#line 644 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 645
return __stdio_common_vfprintf(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 646
} 
#line 650 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl vfprintf(FILE *const 
#line 651
_Stream, const char *const 
#line 652
_Format, va_list 
#line 653
_ArgList) 
#line 658 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 659
return _vfprintf_l(_Stream, _Format, 0, _ArgList); 
#line 660
} 
#line 664 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vfprintf_s_l(FILE *const 
#line 665
_Stream, const char *const 
#line 666
_Format, const _locale_t 
#line 667
_Locale, va_list 
#line 668
_ArgList) 
#line 673 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 674
return __stdio_common_vfprintf_s(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 675
} 
#line 681 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl vfprintf_s(FILE *const 
#line 682
_Stream, const char *const 
#line 683
_Format, va_list 
#line 684
_ArgList) 
#line 689 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 690
return _vfprintf_s_l(_Stream, _Format, 0, _ArgList); 
#line 691
} 
#line 697 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vfprintf_p_l(FILE *const 
#line 698
_Stream, const char *const 
#line 699
_Format, const _locale_t 
#line 700
_Locale, va_list 
#line 701
_ArgList) 
#line 706 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 707
return __stdio_common_vfprintf_p(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 708
} 
#line 712 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vfprintf_p(FILE *const 
#line 713
_Stream, const char *const 
#line 714
_Format, va_list 
#line 715
_ArgList) 
#line 720 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 721
return _vfprintf_p_l(_Stream, _Format, 0, _ArgList); 
#line 722
} 
#line 726 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vprintf_l(const char *const 
#line 727
_Format, const _locale_t 
#line 728
_Locale, va_list 
#line 729
_ArgList) 
#line 734 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 735
return _vfprintf_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 736
} 
#line 740 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl vprintf(const char *const 
#line 741
_Format, va_list 
#line 742
_ArgList) 
#line 747 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 748
return _vfprintf_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 749
} 
#line 753 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vprintf_s_l(const char *const 
#line 754
_Format, const _locale_t 
#line 755
_Locale, va_list 
#line 756
_ArgList) 
#line 761 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 762
return _vfprintf_s_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 763
} 
#line 769 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl vprintf_s(const char *const 
#line 770
_Format, va_list 
#line 771
_ArgList) 
#line 776 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 777
return _vfprintf_s_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 778
} 
#line 784 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vprintf_p_l(const char *const 
#line 785
_Format, const _locale_t 
#line 786
_Locale, va_list 
#line 787
_ArgList) 
#line 792 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 793
return _vfprintf_p_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 794
} 
#line 798 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vprintf_p(const char *const 
#line 799
_Format, va_list 
#line 800
_ArgList) 
#line 805 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 806
return _vfprintf_p_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 807
} 
#line 811 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _fprintf_l(FILE *const 
#line 812
_Stream, const char *const 
#line 813
_Format, const _locale_t 
#line 814
_Locale, ...) 
#line 819 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 820
int _Result; 
#line 821
va_list _ArgList; 
#line 822
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 823
_Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList); 
#line 824
(void)(_ArgList = ((va_list)0)); 
#line 825
return _Result; 
#line 826
} 
#line 830 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl fprintf(FILE *const 
#line 831
_Stream, const char *const 
#line 832
_Format, ...) 
#line 837 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 838
int _Result; 
#line 839
va_list _ArgList; 
#line 840
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 841
_Result = _vfprintf_l(_Stream, _Format, 0, _ArgList); 
#line 842
(void)(_ArgList = ((va_list)0)); 
#line 843
return _Result; 
#line 844
} 
#line 847 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
int __cdecl _set_printf_count_output(int _Value); 
#line 851
int __cdecl _get_printf_count_output(); 
#line 854
__inline int __cdecl _fprintf_s_l(FILE *const 
#line 855
_Stream, const char *const 
#line 856
_Format, const _locale_t 
#line 857
_Locale, ...) 
#line 862 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 863
int _Result; 
#line 864
va_list _ArgList; 
#line 865
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 866
_Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList); 
#line 867
(void)(_ArgList = ((va_list)0)); 
#line 868
return _Result; 
#line 869
} 
#line 875 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl fprintf_s(FILE *const 
#line 876
_Stream, const char *const 
#line 877
_Format, ...) 
#line 882 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 883
int _Result; 
#line 884
va_list _ArgList; 
#line 885
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 886
_Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList); 
#line 887
(void)(_ArgList = ((va_list)0)); 
#line 888
return _Result; 
#line 889
} 
#line 895 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _fprintf_p_l(FILE *const 
#line 896
_Stream, const char *const 
#line 897
_Format, const _locale_t 
#line 898
_Locale, ...) 
#line 903 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 904
int _Result; 
#line 905
va_list _ArgList; 
#line 906
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 907
_Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList); 
#line 908
(void)(_ArgList = ((va_list)0)); 
#line 909
return _Result; 
#line 910
} 
#line 914 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _fprintf_p(FILE *const 
#line 915
_Stream, const char *const 
#line 916
_Format, ...) 
#line 921 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 922
int _Result; 
#line 923
va_list _ArgList; 
#line 924
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 925
_Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList); 
#line 926
(void)(_ArgList = ((va_list)0)); 
#line 927
return _Result; 
#line 928
} 
#line 932 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _printf_l(const char *const 
#line 933
_Format, const _locale_t 
#line 934
_Locale, ...) 
#line 939 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 940
int _Result; 
#line 941
va_list _ArgList; 
#line 942
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 943
_Result = _vfprintf_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 944
(void)(_ArgList = ((va_list)0)); 
#line 945
return _Result; 
#line 946
} 
#line 950 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl printf(const char *const 
#line 951
_Format, ...) 
#line 956 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 957
int _Result; 
#line 958
va_list _ArgList; 
#line 959
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 960
_Result = _vfprintf_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 961
(void)(_ArgList = ((va_list)0)); 
#line 962
return _Result; 
#line 963
} 
#line 967 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _printf_s_l(const char *const 
#line 968
_Format, const _locale_t 
#line 969
_Locale, ...) 
#line 974 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 975
int _Result; 
#line 976
va_list _ArgList; 
#line 977
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 978
_Result = _vfprintf_s_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 979
(void)(_ArgList = ((va_list)0)); 
#line 980
return _Result; 
#line 981
} 
#line 987 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl printf_s(const char *const 
#line 988
_Format, ...) 
#line 993 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 994
int _Result; 
#line 995
va_list _ArgList; 
#line 996
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 997
_Result = _vfprintf_s_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 998
(void)(_ArgList = ((va_list)0)); 
#line 999
return _Result; 
#line 1000
} 
#line 1006 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _printf_p_l(const char *const 
#line 1007
_Format, const _locale_t 
#line 1008
_Locale, ...) 
#line 1013 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1014
int _Result; 
#line 1015
va_list _ArgList; 
#line 1016
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1017
_Result = _vfprintf_p_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 1018
(void)(_ArgList = ((va_list)0)); 
#line 1019
return _Result; 
#line 1020
} 
#line 1024 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _printf_p(const char *const 
#line 1025
_Format, ...) 
#line 1030 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1031
int _Result; 
#line 1032
va_list _ArgList; 
#line 1033
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1034
_Result = _vfprintf_p_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 1035
(void)(_ArgList = ((va_list)0)); 
#line 1036
return _Result; 
#line 1037
} 
#line 1046 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
int __cdecl __stdio_common_vfscanf(unsigned __int64 _Options, FILE * _Stream, const char * _Format, _locale_t _Locale, va_list _Arglist); 
#line 1055
__inline int __cdecl _vfscanf_l(FILE *const 
#line 1056
_Stream, const char *const 
#line 1057
_Format, const _locale_t 
#line 1058
_Locale, va_list 
#line 1059
_ArgList) 
#line 1064 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1065
return __stdio_common_vfscanf(*__local_stdio_scanf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 1068
} 
#line 1072 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl vfscanf(FILE *const 
#line 1073
_Stream, const char *const 
#line 1074
_Format, va_list 
#line 1075
_ArgList) 
#line 1080 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1081
return _vfscanf_l(_Stream, _Format, 0, _ArgList); 
#line 1082
} 
#line 1086 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vfscanf_s_l(FILE *const 
#line 1087
_Stream, const char *const 
#line 1088
_Format, const _locale_t 
#line 1089
_Locale, va_list 
#line 1090
_ArgList) 
#line 1095 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1096
return __stdio_common_vfscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Stream, _Format, _Locale, _ArgList); 
#line 1099
} 
#line 1106 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl vfscanf_s(FILE *const 
#line 1107
_Stream, const char *const 
#line 1108
_Format, va_list 
#line 1109
_ArgList) 
#line 1114 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1115
return _vfscanf_s_l(_Stream, _Format, 0, _ArgList); 
#line 1116
} 
#line 1122 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vscanf_l(const char *const 
#line 1123
_Format, const _locale_t 
#line 1124
_Locale, va_list 
#line 1125
_ArgList) 
#line 1130 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1131
return _vfscanf_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 1132
} 
#line 1136 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl vscanf(const char *const 
#line 1137
_Format, va_list 
#line 1138
_ArgList) 
#line 1143 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1144
return _vfscanf_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 1145
} 
#line 1149 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vscanf_s_l(const char *const 
#line 1150
_Format, const _locale_t 
#line 1151
_Locale, va_list 
#line 1152
_ArgList) 
#line 1157 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1158
return _vfscanf_s_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 1159
} 
#line 1165 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl vscanf_s(const char *const 
#line 1166
_Format, va_list 
#line 1167
_ArgList) 
#line 1172 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1173
return _vfscanf_s_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 1174
} 
#line 1180 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _fscanf_l(FILE *const 
#line 1181
_Stream, const char *const 
#line 1182
_Format, const _locale_t 
#line 1183
_Locale, ...) 
#line 1188 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1189
int _Result; 
#line 1190
va_list _ArgList; 
#line 1191
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1192
_Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList); 
#line 1193
(void)(_ArgList = ((va_list)0)); 
#line 1194
return _Result; 
#line 1195
} 
#line 1199 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl fscanf(FILE *const 
#line 1200
_Stream, const char *const 
#line 1201
_Format, ...) 
#line 1206 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1207
int _Result; 
#line 1208
va_list _ArgList; 
#line 1209
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1210
_Result = _vfscanf_l(_Stream, _Format, 0, _ArgList); 
#line 1211
(void)(_ArgList = ((va_list)0)); 
#line 1212
return _Result; 
#line 1213
} 
#line 1217 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _fscanf_s_l(FILE *const 
#line 1218
_Stream, const char *const 
#line 1219
_Format, const _locale_t 
#line 1220
_Locale, ...) 
#line 1225 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1226
int _Result; 
#line 1227
va_list _ArgList; 
#line 1228
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1229
_Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList); 
#line 1230
(void)(_ArgList = ((va_list)0)); 
#line 1231
return _Result; 
#line 1232
} 
#line 1238 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl fscanf_s(FILE *const 
#line 1239
_Stream, const char *const 
#line 1240
_Format, ...) 
#line 1245 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1246
int _Result; 
#line 1247
va_list _ArgList; 
#line 1248
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1249
_Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList); 
#line 1250
(void)(_ArgList = ((va_list)0)); 
#line 1251
return _Result; 
#line 1252
} 
#line 1258 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _scanf_l(const char *const 
#line 1259
_Format, const _locale_t 
#line 1260
_Locale, ...) 
#line 1265 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1266
int _Result; 
#line 1267
va_list _ArgList; 
#line 1268
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1269
_Result = _vfscanf_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 1270
(void)(_ArgList = ((va_list)0)); 
#line 1271
return _Result; 
#line 1272
} 
#line 1276 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl scanf(const char *const 
#line 1277
_Format, ...) 
#line 1282 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1283
int _Result; 
#line 1284
va_list _ArgList; 
#line 1285
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1286
_Result = _vfscanf_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 1287
(void)(_ArgList = ((va_list)0)); 
#line 1288
return _Result; 
#line 1289
} 
#line 1293 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _scanf_s_l(const char *const 
#line 1294
_Format, const _locale_t 
#line 1295
_Locale, ...) 
#line 1300 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1301
int _Result; 
#line 1302
va_list _ArgList; 
#line 1303
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1304
_Result = _vfscanf_s_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 1305
(void)(_ArgList = ((va_list)0)); 
#line 1306
return _Result; 
#line 1307
} 
#line 1313 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl scanf_s(const char *const 
#line 1314
_Format, ...) 
#line 1319 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1320
int _Result; 
#line 1321
va_list _ArgList; 
#line 1322
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1323
_Result = _vfscanf_s_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 1324
(void)(_ArgList = ((va_list)0)); 
#line 1325
return _Result; 
#line 1326
} 
#line 1339 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
int __cdecl __stdio_common_vsprintf(unsigned __int64 _Options, char * _Buffer, size_t _BufferCount, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1349
int __cdecl __stdio_common_vsprintf_s(unsigned __int64 _Options, char * _Buffer, size_t _BufferCount, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1359
int __cdecl __stdio_common_vsnprintf_s(unsigned __int64 _Options, char * _Buffer, size_t _BufferCount, size_t _MaxCount, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1370
int __cdecl __stdio_common_vsprintf_p(unsigned __int64 _Options, char * _Buffer, size_t _BufferCount, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1381
__inline int __cdecl _vsnprintf_l(char *const 
#line 1382
_Buffer, const size_t 
#line 1383
_BufferCount, const char *const 
#line 1384
_Format, const _locale_t 
#line 1385
_Locale, va_list 
#line 1386
_ArgList) 
#line 1391 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1392
const int _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1Ui64 << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1396
return (_Result < 0) ? -1 : _Result; 
#line 1397
} 
#line 1402 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vsnprintf(char *const 
#line 1403
_Buffer, const size_t 
#line 1404
_BufferCount, const char *const 
#line 1405
_Format, va_list 
#line 1406
_ArgList) 
#line 1411 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1412
return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1413
} 
#line 1429 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl vsnprintf(char *const 
#line 1430
_Buffer, const size_t 
#line 1431
_BufferCount, const char *const 
#line 1432
_Format, va_list 
#line 1433
_ArgList) 
#line 1438 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1439
const int _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1Ui64 << 1), _Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1443
return (_Result < 0) ? -1 : _Result; 
#line 1444
} 
#line 1449 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vsprintf_l(char *const 
#line 1450
_Buffer, const char *const 
#line 1451
_Format, const _locale_t 
#line 1452
_Locale, va_list 
#line 1453
_ArgList) 
#line 1458 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1459
return _vsnprintf_l(_Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1460
} 
#line 1465 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl vsprintf(char *const 
#line 1466
_Buffer, const char *const 
#line 1467
_Format, va_list 
#line 1468
_ArgList) 
#line 1473 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1474
return _vsnprintf_l(_Buffer, (size_t)(-1), _Format, 0, _ArgList); 
#line 1475
} 
#line 1480 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vsprintf_s_l(char *const 
#line 1481
_Buffer, const size_t 
#line 1482
_BufferCount, const char *const 
#line 1483
_Format, const _locale_t 
#line 1484
_Locale, va_list 
#line 1485
_ArgList) 
#line 1490 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1491
const int _Result = __stdio_common_vsprintf_s(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1495
return (_Result < 0) ? -1 : _Result; 
#line 1496
} 
#line 1503 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl vsprintf_s(char *const 
#line 1504
_Buffer, const size_t 
#line 1505
_BufferCount, const char *const 
#line 1506
_Format, va_list 
#line 1507
_ArgList) 
#line 1512 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1513
return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1514
} 
#line 1517 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl vsprintf_s ( char ( & _Buffer ) [ _Size ], char const * _Format, va_list _ArgList ) throw ( ) { return vsprintf_s ( _Buffer, _Size, _Format, _ArgList ); }}
#line 1529 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vsprintf_p_l(char *const 
#line 1530
_Buffer, const size_t 
#line 1531
_BufferCount, const char *const 
#line 1532
_Format, const _locale_t 
#line 1533
_Locale, va_list 
#line 1534
_ArgList) 
#line 1539 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1540
const int _Result = __stdio_common_vsprintf_p(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1544
return (_Result < 0) ? -1 : _Result; 
#line 1545
} 
#line 1550 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vsprintf_p(char *const 
#line 1551
_Buffer, const size_t 
#line 1552
_BufferCount, const char *const 
#line 1553
_Format, va_list 
#line 1554
_ArgList) 
#line 1559 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1560
return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1561
} 
#line 1566 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vsnprintf_s_l(char *const 
#line 1567
_Buffer, const size_t 
#line 1568
_BufferCount, const size_t 
#line 1569
_MaxCount, const char *const 
#line 1570
_Format, const _locale_t 
#line 1571
_Locale, va_list 
#line 1572
_ArgList) 
#line 1577 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1578
const int _Result = __stdio_common_vsnprintf_s(*__local_stdio_printf_options(), _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList); 
#line 1582
return (_Result < 0) ? -1 : _Result; 
#line 1583
} 
#line 1588 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vsnprintf_s(char *const 
#line 1589
_Buffer, const size_t 
#line 1590
_BufferCount, const size_t 
#line 1591
_MaxCount, const char *const 
#line 1592
_Format, va_list 
#line 1593
_ArgList) 
#line 1598 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1599
return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList); 
#line 1600
} 
#line 1603 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl _vsnprintf_s ( char ( & _Buffer ) [ _Size ], size_t _BufferCount, char const * _Format, va_list _ArgList ) throw ( ) { return _vsnprintf_s ( _Buffer, _Size, _BufferCount, _Format, _ArgList ); }}
#line 1616 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl vsnprintf_s(char *const 
#line 1617
_Buffer, const size_t 
#line 1618
_BufferCount, const size_t 
#line 1619
_MaxCount, const char *const 
#line 1620
_Format, va_list 
#line 1621
_ArgList) 
#line 1626 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1627
return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList); 
#line 1628
} 
#line 1631 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl vsnprintf_s ( char ( & _Buffer ) [ _Size ], size_t _BufferCount, char const * _Format, va_list _ArgList ) throw ( ) { return vsnprintf_s ( _Buffer, _Size, _BufferCount, _Format, _ArgList ); }}
#line 1643 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vscprintf_l(const char *const 
#line 1644
_Format, const _locale_t 
#line 1645
_Locale, va_list 
#line 1646
_ArgList) 
#line 1651 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1652
const int _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1Ui64 << 1), 0, 0, _Format, _Locale, _ArgList); 
#line 1656
return (_Result < 0) ? -1 : _Result; 
#line 1657
} 
#line 1661 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vscprintf(const char *const 
#line 1662
_Format, va_list 
#line 1663
_ArgList) 
#line 1668 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1669
return _vscprintf_l(_Format, 0, _ArgList); 
#line 1670
} 
#line 1674 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vscprintf_p_l(const char *const 
#line 1675
_Format, const _locale_t 
#line 1676
_Locale, va_list 
#line 1677
_ArgList) 
#line 1682 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1683
const int _Result = __stdio_common_vsprintf_p((*__local_stdio_printf_options()) | (1Ui64 << 1), 0, 0, _Format, _Locale, _ArgList); 
#line 1687
return (_Result < 0) ? -1 : _Result; 
#line 1688
} 
#line 1692 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vscprintf_p(const char *const 
#line 1693
_Format, va_list 
#line 1694
_ArgList) 
#line 1699 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1700
return _vscprintf_p_l(_Format, 0, _ArgList); 
#line 1701
} 
#line 1705 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vsnprintf_c_l(char *const 
#line 1706
_Buffer, const size_t 
#line 1707
_BufferCount, const char *const 
#line 1708
_Format, const _locale_t 
#line 1709
_Locale, va_list 
#line 1710
_ArgList) 
#line 1715 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1716
const int _Result = __stdio_common_vsprintf(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1720
return (_Result < 0) ? -1 : _Result; 
#line 1721
} 
#line 1726 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vsnprintf_c(char *const 
#line 1727
_Buffer, const size_t 
#line 1728
_BufferCount, const char *const 
#line 1729
_Format, va_list 
#line 1730
_ArgList) 
#line 1735 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1736
return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1737
} 
#line 1742 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _sprintf_l(char *const 
#line 1743
_Buffer, const char *const 
#line 1744
_Format, const _locale_t 
#line 1745
_Locale, ...) 
#line 1750 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1751
int _Result; 
#line 1752
va_list _ArgList; 
#line 1753
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1755
_Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList); 
#line 1757
(void)(_ArgList = ((va_list)0)); 
#line 1758
return _Result; 
#line 1759
} 
#line 1764 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl sprintf(char *const 
#line 1765
_Buffer, const char *const 
#line 1766
_Format, ...) 
#line 1771 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1772
int _Result; 
#line 1773
va_list _ArgList; 
#line 1774
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1776
_Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList); 
#line 1778
(void)(_ArgList = ((va_list)0)); 
#line 1779
return _Result; 
#line 1780
} 
#line 1783 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl sprintf(char * _Buffer, const char * _Format, ...); __inline int __cdecl vsprintf(char * _Buffer, const char * _Format, va_list _Args); 
#line 1792 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _sprintf_s_l(char *const 
#line 1793
_Buffer, const size_t 
#line 1794
_BufferCount, const char *const 
#line 1795
_Format, const _locale_t 
#line 1796
_Locale, ...) 
#line 1801 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1802
int _Result; 
#line 1803
va_list _ArgList; 
#line 1804
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1805
_Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1806
(void)(_ArgList = ((va_list)0)); 
#line 1807
return _Result; 
#line 1808
} 
#line 1815 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl sprintf_s(char *const 
#line 1816
_Buffer, const size_t 
#line 1817
_BufferCount, const char *const 
#line 1818
_Format, ...) 
#line 1823 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1824
int _Result; 
#line 1825
va_list _ArgList; 
#line 1826
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1827
_Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1828
(void)(_ArgList = ((va_list)0)); 
#line 1829
return _Result; 
#line 1830
} 
#line 1835 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl sprintf_s ( char ( & _Buffer ) [ _Size ], char const * _Format, ... ) throw ( ) { va_list _ArgList; ( ( void ) ( __vcrt_assert_va_start_is_not_reference < decltype ( _Format ) > ( ), ( ( void ) ( __va_start ( & _ArgList, _Format ) ) ) ) ); return vsprintf_s ( _Buffer, _Size, _Format, _ArgList ); }}
#line 1844 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _sprintf_p_l(char *const 
#line 1845
_Buffer, const size_t 
#line 1846
_BufferCount, const char *const 
#line 1847
_Format, const _locale_t 
#line 1848
_Locale, ...) 
#line 1853 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1854
int _Result; 
#line 1855
va_list _ArgList; 
#line 1856
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1857
_Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1858
(void)(_ArgList = ((va_list)0)); 
#line 1859
return _Result; 
#line 1860
} 
#line 1865 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _sprintf_p(char *const 
#line 1866
_Buffer, const size_t 
#line 1867
_BufferCount, const char *const 
#line 1868
_Format, ...) 
#line 1873 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1874
int _Result; 
#line 1875
va_list _ArgList; 
#line 1876
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1877
_Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1878
(void)(_ArgList = ((va_list)0)); 
#line 1879
return _Result; 
#line 1880
} 
#line 1885 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf_l(char *const 
#line 1886
_Buffer, const size_t 
#line 1887
_BufferCount, const char *const 
#line 1888
_Format, const _locale_t 
#line 1889
_Locale, ...) 
#line 1894 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1895
int _Result; 
#line 1896
va_list _ArgList; 
#line 1897
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1899
_Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1901
(void)(_ArgList = ((va_list)0)); 
#line 1902
return _Result; 
#line 1903
} 
#line 1919 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl snprintf(char *const 
#line 1920
_Buffer, const size_t 
#line 1921
_BufferCount, const char *const 
#line 1922
_Format, ...) 
#line 1927 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1928
int _Result; 
#line 1929
va_list _ArgList; 
#line 1930
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1931
_Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList); 
#line 1932
(void)(_ArgList = ((va_list)0)); 
#line 1933
return _Result; 
#line 1934
} 
#line 1939 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf(char *const 
#line 1940
_Buffer, const size_t 
#line 1941
_BufferCount, const char *const 
#line 1942
_Format, ...) 
#line 1947 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1948
int _Result; 
#line 1949
va_list _ArgList; 
#line 1950
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1951
_Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList); 
#line 1952
(void)(_ArgList = ((va_list)0)); 
#line 1953
return _Result; 
#line 1954
} 
#line 1957 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf(char * _Buffer, size_t _BufferCount, const char * _Format, ...); __inline int __cdecl _vsnprintf(char * _Buffer, size_t _BufferCount, const char * _Format, va_list _Args); 
#line 1968 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf_c_l(char *const 
#line 1969
_Buffer, const size_t 
#line 1970
_BufferCount, const char *const 
#line 1971
_Format, const _locale_t 
#line 1972
_Locale, ...) 
#line 1977 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1978
int _Result; 
#line 1979
va_list _ArgList; 
#line 1980
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1981
_Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1982
(void)(_ArgList = ((va_list)0)); 
#line 1983
return _Result; 
#line 1984
} 
#line 1989 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf_c(char *const 
#line 1990
_Buffer, const size_t 
#line 1991
_BufferCount, const char *const 
#line 1992
_Format, ...) 
#line 1997 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 1998
int _Result; 
#line 1999
va_list _ArgList; 
#line 2000
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2001
_Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 2002
(void)(_ArgList = ((va_list)0)); 
#line 2003
return _Result; 
#line 2004
} 
#line 2009 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf_s_l(char *const 
#line 2010
_Buffer, const size_t 
#line 2011
_BufferCount, const size_t 
#line 2012
_MaxCount, const char *const 
#line 2013
_Format, const _locale_t 
#line 2014
_Locale, ...) 
#line 2019 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 2020
int _Result; 
#line 2021
va_list _ArgList; 
#line 2022
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2023
_Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList); 
#line 2024
(void)(_ArgList = ((va_list)0)); 
#line 2025
return _Result; 
#line 2026
} 
#line 2031 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf_s(char *const 
#line 2032
_Buffer, const size_t 
#line 2033
_BufferCount, const size_t 
#line 2034
_MaxCount, const char *const 
#line 2035
_Format, ...) 
#line 2040 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 2041
int _Result; 
#line 2042
va_list _ArgList; 
#line 2043
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2044
_Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList); 
#line 2045
(void)(_ArgList = ((va_list)0)); 
#line 2046
return _Result; 
#line 2047
} 
#line 2050 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl _snprintf_s ( char ( & _Buffer ) [ _Size ], size_t _BufferCount, char const * _Format, ... ) throw ( ) { va_list _ArgList; ( ( void ) ( __vcrt_assert_va_start_is_not_reference < decltype ( _Format ) > ( ), ( ( void ) ( __va_start ( & _ArgList, _Format ) ) ) ) ); return _vsnprintf_s ( _Buffer, _Size, _BufferCount, _Format, _ArgList ); }}
#line 2059 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _scprintf_l(const char *const 
#line 2060
_Format, const _locale_t 
#line 2061
_Locale, ...) 
#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 2067
int _Result; 
#line 2068
va_list _ArgList; 
#line 2069
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2070
_Result = _vscprintf_l(_Format, _Locale, _ArgList); 
#line 2071
(void)(_ArgList = ((va_list)0)); 
#line 2072
return _Result; 
#line 2073
} 
#line 2077 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _scprintf(const char *const 
#line 2078
_Format, ...) 
#line 2083 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 2084
int _Result; 
#line 2085
va_list _ArgList; 
#line 2086
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2087
_Result = _vscprintf_l(_Format, 0, _ArgList); 
#line 2088
(void)(_ArgList = ((va_list)0)); 
#line 2089
return _Result; 
#line 2090
} 
#line 2094 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _scprintf_p_l(const char *const 
#line 2095
_Format, const _locale_t 
#line 2096
_Locale, ...) 
#line 2101 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 2102
int _Result; 
#line 2103
va_list _ArgList; 
#line 2104
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2105
_Result = _vscprintf_p_l(_Format, _Locale, _ArgList); 
#line 2106
(void)(_ArgList = ((va_list)0)); 
#line 2107
return _Result; 
#line 2108
} 
#line 2112 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _scprintf_p(const char *const 
#line 2113
_Format, ...) 
#line 2118 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 2119
int _Result; 
#line 2120
va_list _ArgList; 
#line 2121
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2122
_Result = _vscprintf_p(_Format, _ArgList); 
#line 2123
(void)(_ArgList = ((va_list)0)); 
#line 2124
return _Result; 
#line 2125
} 
#line 2133 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
int __cdecl __stdio_common_vsscanf(unsigned __int64 _Options, const char * _Buffer, size_t _BufferCount, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 2143
__inline int __cdecl _vsscanf_l(const char *const 
#line 2144
_Buffer, const char *const 
#line 2145
_Format, const _locale_t 
#line 2146
_Locale, va_list 
#line 2147
_ArgList) 
#line 2152 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 2153
return __stdio_common_vsscanf(*__local_stdio_scanf_options(), _Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 2156
} 
#line 2160 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl vsscanf(const char *const 
#line 2161
_Buffer, const char *const 
#line 2162
_Format, va_list 
#line 2163
_ArgList) 
#line 2168 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 2169
return _vsscanf_l(_Buffer, _Format, 0, _ArgList); 
#line 2170
} 
#line 2174 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _vsscanf_s_l(const char *const 
#line 2175
_Buffer, const char *const 
#line 2176
_Format, const _locale_t 
#line 2177
_Locale, va_list 
#line 2178
_ArgList) 
#line 2183 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 2184
return __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 2187
} 
#line 2192 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
#pragma warning(push)
#pragma warning(disable: 6530)
#line 2196
__inline int __cdecl vsscanf_s(const char *const 
#line 2197
_Buffer, const char *const 
#line 2198
_Format, va_list 
#line 2199
_ArgList) 
#line 2204 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 2205
return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList); 
#line 2206
} 
#line 2209 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl vsscanf_s ( char const ( & _Buffer ) [ _Size ], char const * _Format, va_list _ArgList ) throw ( ) { return vsscanf_s ( _Buffer, _Size, _Format, _ArgList ); }}
#line 2216 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
#pragma warning(pop)
#line 2221 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _sscanf_l(const char *const 
#line 2222
_Buffer, const char *const 
#line 2223
_Format, const _locale_t 
#line 2224
_Locale, ...) 
#line 2229 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 2230
int _Result; 
#line 2231
va_list _ArgList; 
#line 2232
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2233
_Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList); 
#line 2234
(void)(_ArgList = ((va_list)0)); 
#line 2235
return _Result; 
#line 2236
} 
#line 2240 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl sscanf(const char *const 
#line 2241
_Buffer, const char *const 
#line 2242
_Format, ...) 
#line 2247 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 2248
int _Result; 
#line 2249
va_list _ArgList; 
#line 2250
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2251
_Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList); 
#line 2252
(void)(_ArgList = ((va_list)0)); 
#line 2253
return _Result; 
#line 2254
} 
#line 2258 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _sscanf_s_l(const char *const 
#line 2259
_Buffer, const char *const 
#line 2260
_Format, const _locale_t 
#line 2261
_Locale, ...) 
#line 2266 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 2267
int _Result; 
#line 2268
va_list _ArgList; 
#line 2269
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2270
_Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList); 
#line 2271
(void)(_ArgList = ((va_list)0)); 
#line 2272
return _Result; 
#line 2273
} 
#line 2279 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl sscanf_s(const char *const 
#line 2280
_Buffer, const char *const 
#line 2281
_Format, ...) 
#line 2286 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 2287
int _Result; 
#line 2288
va_list _ArgList; 
#line 2289
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2291
_Result = vsscanf_s(_Buffer, _Format, _ArgList); 
#line 2293
(void)(_ArgList = ((va_list)0)); 
#line 2294
return _Result; 
#line 2295
} 
#line 2300 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
#pragma warning(push)
#pragma warning(disable: 6530)
#line 2304
__inline int __cdecl _snscanf_l(const char *const 
#line 2305
_Buffer, const size_t 
#line 2306
_BufferCount, const char *const 
#line 2307
_Format, const _locale_t 
#line 2308
_Locale, ...) 
#line 2313 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 2314
int _Result; 
#line 2315
va_list _ArgList; 
#line 2316
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2318
_Result = __stdio_common_vsscanf(*__local_stdio_scanf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 2322
(void)(_ArgList = ((va_list)0)); 
#line 2323
return _Result; 
#line 2324
} 
#line 2328 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _snscanf(const char *const 
#line 2329
_Buffer, const size_t 
#line 2330
_BufferCount, const char *const 
#line 2331
_Format, ...) 
#line 2336 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 2337
int _Result; 
#line 2338
va_list _ArgList; 
#line 2339
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2341
_Result = __stdio_common_vsscanf(*__local_stdio_scanf_options(), _Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 2345
(void)(_ArgList = ((va_list)0)); 
#line 2346
return _Result; 
#line 2347
} 
#line 2352 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _snscanf_s_l(const char *const 
#line 2353
_Buffer, const size_t 
#line 2354
_BufferCount, const char *const 
#line 2355
_Format, const _locale_t 
#line 2356
_Locale, ...) 
#line 2361 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 2362
int _Result; 
#line 2363
va_list _ArgList; 
#line 2364
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2366
_Result = __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 2370
(void)(_ArgList = ((va_list)0)); 
#line 2371
return _Result; 
#line 2372
} 
#line 2376 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
__inline int __cdecl _snscanf_s(const char *const 
#line 2377
_Buffer, const size_t 
#line 2378
_BufferCount, const char *const 
#line 2379
_Format, ...) 
#line 2384 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
{ 
#line 2385
int _Result; 
#line 2386
va_list _ArgList; 
#line 2387
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2389
_Result = __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 2393
(void)(_ArgList = ((va_list)0)); 
#line 2394
return _Result; 
#line 2395
} 
#line 2398 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
#pragma warning(pop)
#line 2421 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
char *__cdecl tempnam(const char * _Directory, const char * _FilePrefix); 
#line 2430 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
int __cdecl fcloseall(); 
#line 2431
FILE *__cdecl fdopen(int _FileHandle, const char * _Format); 
#line 2432
int __cdecl fgetchar(); 
#line 2433
int __cdecl fileno(FILE * _Stream); 
#line 2434
int __cdecl flushall(); 
#line 2435
int __cdecl fputchar(int _Ch); 
#line 2436
int __cdecl getw(FILE * _Stream); 
#line 2437
int __cdecl putw(int _Ch, FILE * _Stream); 
#line 2438
int __cdecl rmtmp(); 
#line 2445 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\stdio.h"
}__pragma( pack ( pop )) 
#line 2447
#pragma warning(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstdio"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 29
namespace std { 
#pragma warning(push)
#pragma warning(disable : 4995)
#line 33
using ::_Mbstatet;
#line 36
using ::fpos_t;
#line 37
using ::FILE;
#line 38
using ::clearerr;
#line 39
using ::fclose;
#line 40
using ::feof;
#line 41
using ::ferror;
#line 42
using ::fflush;
#line 43
using ::fgetc;
#line 44
using ::fgetpos;
#line 45
using ::fgets;
#line 46
using ::fopen;
#line 47
using ::fprintf;
#line 48
using ::fputc;
#line 49
using ::fputs;
#line 50
using ::fread;
#line 51
using ::freopen;
#line 52
using ::fscanf;
#line 53
using ::fseek;
#line 54
using ::fsetpos;
#line 55
using ::ftell;
#line 56
using ::fwrite;
#line 57
using ::getc;
#line 58
using ::getchar;
#line 59
using ::perror;
#line 60
using ::putc;
#line 61
using ::putchar;
#line 62
using ::printf;
#line 63
using ::puts;
#line 64
using ::remove;
#line 65
using ::rename;
#line 66
using ::rewind;
#line 67
using ::scanf;
#line 68
using ::setbuf;
#line 69
using ::setvbuf;
#line 70
using ::sprintf;
#line 71
using ::sscanf;
#line 72
using ::tmpfile;
#line 73
using ::tmpnam;
#line 74
using ::ungetc;
#line 75
using ::vfprintf;
#line 76
using ::vprintf;
#line 77
using ::vsprintf;
#line 79
using ::snprintf;
#line 80
using ::vsnprintf;
#line 81
using ::vfscanf;
#line 82
using ::vscanf;
#line 83
using ::vsscanf;
#line 85
#pragma warning(pop)
}
#line 90
#pragma warning(pop)
#pragma pack ( pop )
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 18
__pragma( pack ( push, 8 )) extern "C" {
#line 28
errno_t __cdecl _cgetws_s(__wchar_t * _Buffer, size_t _BufferCount, size_t * _SizeRead); 
#line 34
extern "C++" {template < size_t _Size > inline errno_t __cdecl _cgetws_s ( wchar_t ( & _Buffer ) [ _Size ], size_t * _SizeRead ) throw ( ) { return _cgetws_s ( _Buffer, _Size, _SizeRead ); }}
#line 42 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
int __cdecl _cputws(const __wchar_t * _Buffer); 
#line 46
wint_t __cdecl _getwch(); 
#line 47
wint_t __cdecl _getwche(); 
#line 48
wint_t __cdecl _putwch(__wchar_t _Character); 
#line 49
wint_t __cdecl _ungetwch(wint_t _Character); 
#line 51
wint_t __cdecl _getwch_nolock(); 
#line 52
wint_t __cdecl _getwche_nolock(); 
#line 53
wint_t __cdecl _putwch_nolock(__wchar_t _Character); 
#line 54
wint_t __cdecl _ungetwch_nolock(wint_t _Character); 
#line 64
int __cdecl __conio_common_vcwprintf(unsigned __int64 _Options, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 72
int __cdecl __conio_common_vcwprintf_s(unsigned __int64 _Options, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 80
int __cdecl __conio_common_vcwprintf_p(unsigned __int64 _Options, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 88
__inline int __cdecl _vcwprintf_l(const __wchar_t *const 
#line 89
_Format, const _locale_t 
#line 90
_Locale, va_list 
#line 91
_ArgList) 
#line 96 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
{ 
#line 97
return __conio_common_vcwprintf(*__local_stdio_printf_options(), _Format, _Locale, _ArgList); 
#line 98
} 
#line 102 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwprintf(const __wchar_t *const 
#line 103
_Format, va_list 
#line 104
_ArgList) 
#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
{ 
#line 110
return _vcwprintf_l(_Format, 0, _ArgList); 
#line 111
} 
#line 115 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwprintf_s_l(const __wchar_t *const 
#line 116
_Format, const _locale_t 
#line 117
_Locale, va_list 
#line 118
_ArgList) 
#line 123 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
{ 
#line 124
return __conio_common_vcwprintf_s(*__local_stdio_printf_options(), _Format, _Locale, _ArgList); 
#line 125
} 
#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwprintf_s(const __wchar_t *const 
#line 130
_Format, va_list 
#line 131
_ArgList) 
#line 136 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
{ 
#line 137
return _vcwprintf_s_l(_Format, 0, _ArgList); 
#line 138
} 
#line 142 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwprintf_p_l(const __wchar_t *const 
#line 143
_Format, const _locale_t 
#line 144
_Locale, va_list 
#line 145
_ArgList) 
#line 150 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
{ 
#line 151
return __conio_common_vcwprintf_p(*__local_stdio_printf_options(), _Format, _Locale, _ArgList); 
#line 152
} 
#line 156 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwprintf_p(const __wchar_t *const 
#line 157
_Format, va_list 
#line 158
_ArgList) 
#line 163 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
{ 
#line 164
return _vcwprintf_p_l(_Format, 0, _ArgList); 
#line 165
} 
#line 169 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf_l(const __wchar_t *const 
#line 170
_Format, const _locale_t 
#line 171
_Locale, ...) 
#line 176 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
{ 
#line 177
int _Result; 
#line 178
va_list _ArgList; 
#line 179
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 180
_Result = _vcwprintf_l(_Format, _Locale, _ArgList); 
#line 181
(void)(_ArgList = ((va_list)0)); 
#line 182
return _Result; 
#line 183
} 
#line 187 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf(const __wchar_t *const 
#line 188
_Format, ...) 
#line 193 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
{ 
#line 194
int _Result; 
#line 195
va_list _ArgList; 
#line 196
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 197
_Result = _vcwprintf_l(_Format, 0, _ArgList); 
#line 198
(void)(_ArgList = ((va_list)0)); 
#line 199
return _Result; 
#line 200
} 
#line 204 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf_s_l(const __wchar_t *const 
#line 205
_Format, const _locale_t 
#line 206
_Locale, ...) 
#line 211 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
{ 
#line 212
int _Result; 
#line 213
va_list _ArgList; 
#line 214
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 215
_Result = _vcwprintf_s_l(_Format, _Locale, _ArgList); 
#line 216
(void)(_ArgList = ((va_list)0)); 
#line 217
return _Result; 
#line 218
} 
#line 222 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf_s(const __wchar_t *const 
#line 223
_Format, ...) 
#line 228 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
{ 
#line 229
int _Result; 
#line 230
va_list _ArgList; 
#line 231
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 232
_Result = _vcwprintf_s_l(_Format, 0, _ArgList); 
#line 233
(void)(_ArgList = ((va_list)0)); 
#line 234
return _Result; 
#line 235
} 
#line 239 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf_p_l(const __wchar_t *const 
#line 240
_Format, const _locale_t 
#line 241
_Locale, ...) 
#line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
{ 
#line 247
int _Result; 
#line 248
va_list _ArgList; 
#line 249
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 250
_Result = _vcwprintf_p_l(_Format, _Locale, _ArgList); 
#line 251
(void)(_ArgList = ((va_list)0)); 
#line 252
return _Result; 
#line 253
} 
#line 257 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf_p(const __wchar_t *const 
#line 258
_Format, ...) 
#line 263 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
{ 
#line 264
int _Result; 
#line 265
va_list _ArgList; 
#line 266
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 267
_Result = _vcwprintf_p_l(_Format, 0, _ArgList); 
#line 268
(void)(_ArgList = ((va_list)0)); 
#line 269
return _Result; 
#line 270
} 
#line 281 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
int __cdecl __conio_common_vcwscanf(unsigned __int64 _Options, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 289
__inline int __cdecl _vcwscanf_l(const __wchar_t *const 
#line 290
_Format, const _locale_t 
#line 291
_Locale, va_list 
#line 292
_ArgList) 
#line 297 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
{ 
#line 298
return __conio_common_vcwscanf(*__local_stdio_scanf_options(), _Format, _Locale, _ArgList); 
#line 301
} 
#line 305 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwscanf(const __wchar_t *const 
#line 306
_Format, va_list 
#line 307
_ArgList) 
#line 312 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
{ 
#line 313
return _vcwscanf_l(_Format, 0, _ArgList); 
#line 314
} 
#line 318 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwscanf_s_l(const __wchar_t *const 
#line 319
_Format, const _locale_t 
#line 320
_Locale, va_list 
#line 321
_ArgList) 
#line 326 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
{ 
#line 327
return __conio_common_vcwscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Format, _Locale, _ArgList); 
#line 330
} 
#line 334 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwscanf_s(const __wchar_t *const 
#line 335
_Format, va_list 
#line 336
_ArgList) 
#line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
{ 
#line 342
return _vcwscanf_s_l(_Format, 0, _ArgList); 
#line 343
} 
#line 347 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwscanf_l(const __wchar_t *const 
#line 348
_Format, const _locale_t 
#line 349
_Locale, ...) 
#line 354 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
{ 
#line 355
int _Result; 
#line 356
va_list _ArgList; 
#line 357
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 359
_Result = _vcwscanf_l(_Format, _Locale, _ArgList); 
#line 361
(void)(_ArgList = ((va_list)0)); 
#line 362
return _Result; 
#line 363
} 
#line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwscanf(const __wchar_t *const 
#line 368
_Format, ...) 
#line 373 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
{ 
#line 374
int _Result; 
#line 375
va_list _ArgList; 
#line 376
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 378
_Result = _vcwscanf_l(_Format, 0, _ArgList); 
#line 380
(void)(_ArgList = ((va_list)0)); 
#line 381
return _Result; 
#line 382
} 
#line 386 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwscanf_s_l(const __wchar_t *const 
#line 387
_Format, const _locale_t 
#line 388
_Locale, ...) 
#line 393 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
{ 
#line 394
int _Result; 
#line 395
va_list _ArgList; 
#line 396
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 397
_Result = _vcwscanf_s_l(_Format, _Locale, _ArgList); 
#line 398
(void)(_ArgList = ((va_list)0)); 
#line 399
return _Result; 
#line 400
} 
#line 404 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwscanf_s(const __wchar_t *const 
#line 405
_Format, ...) 
#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
{ 
#line 411
int _Result; 
#line 412
va_list _ArgList; 
#line 413
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 414
_Result = _vcwscanf_s_l(_Format, 0, _ArgList); 
#line 415
(void)(_ArgList = ((va_list)0)); 
#line 416
return _Result; 
#line 417
} 
#line 422 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
}__pragma( pack ( pop )) 
#line 424
#pragma warning(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wdirect.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 17
__pragma( pack ( push, 8 )) extern "C" {
#line 26
__declspec(allocator) __wchar_t *__cdecl _wgetcwd(__wchar_t * _DstBuf, int _SizeInWords); 
#line 33
__declspec(allocator) __wchar_t *__cdecl _wgetdcwd(int _Drive, __wchar_t * _DstBuf, int _SizeInWords); 
#line 45
int __cdecl _wchdir(const __wchar_t * _Path); 
#line 50
int __cdecl _wmkdir(const __wchar_t * _Path); 
#line 55
int __cdecl _wrmdir(const __wchar_t * _Path); 
#line 61
}__pragma( pack ( pop )) 
#line 63
#pragma warning(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_share.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_share.h"
#pragma warning(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wio.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 18
__pragma( pack ( push, 8 )) extern "C" {
#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wio.h"
typedef unsigned long _fsize_t; 
#line 35
struct _wfinddata32_t { 
#line 37
unsigned attrib; 
#line 38
__time32_t time_create; 
#line 39
__time32_t time_access; 
#line 40
__time32_t time_write; 
#line 41
_fsize_t size; 
#line 42
__wchar_t name[260]; 
#line 43
}; 
#line 45
struct _wfinddata32i64_t { 
#line 47
unsigned attrib; 
#line 48
__time32_t time_create; 
#line 49
__time32_t time_access; 
#line 50
__time32_t time_write; 
#line 51
__int64 size; 
#line 52
__wchar_t name[260]; 
#line 53
}; 
#line 55
struct _wfinddata64i32_t { 
#line 57
unsigned attrib; 
#line 58
__time64_t time_create; 
#line 59
__time64_t time_access; 
#line 60
__time64_t time_write; 
#line 61
_fsize_t size; 
#line 62
__wchar_t name[260]; 
#line 63
}; 
#line 65
struct _wfinddata64_t { 
#line 67
unsigned attrib; 
#line 68
__time64_t time_create; 
#line 69
__time64_t time_access; 
#line 70
__time64_t time_write; 
#line 71
__int64 size; 
#line 72
__wchar_t name[260]; 
#line 73
}; 
#line 95 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wio.h"
int __cdecl _waccess(const __wchar_t * _FileName, int _AccessMode); 
#line 101
errno_t __cdecl _waccess_s(const __wchar_t * _FileName, int _AccessMode); 
#line 107
int __cdecl _wchmod(const __wchar_t * _FileName, int _Mode); 
#line 113
int __cdecl _wcreat(const __wchar_t * _FileName, int _PermissionMode); 
#line 120
intptr_t __cdecl _wfindfirst32(const __wchar_t * _FileName, _wfinddata32_t * _FindData); 
#line 127
int __cdecl _wfindnext32(intptr_t _FindHandle, _wfinddata32_t * _FindData); 
#line 132
int __cdecl _wunlink(const __wchar_t * _FileName); 
#line 137
int __cdecl _wrename(const __wchar_t * _OldFileName, const __wchar_t * _NewFileName); 
#line 142
errno_t __cdecl _wmktemp_s(__wchar_t * _TemplateName, size_t _SizeInWords); 
#line 147
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wmktemp_s ( wchar_t ( & _TemplateName ) [ _Size ] ) throw ( ) { return _wmktemp_s ( _TemplateName, _Size ); }}
#line 153 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wio.h"
__wchar_t *__cdecl _wmktemp(__wchar_t * _TemplateName); 
#line 160 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wio.h"
intptr_t __cdecl _wfindfirst32i64(const __wchar_t * _FileName, _wfinddata32i64_t * _FindData); 
#line 167
intptr_t __cdecl _wfindfirst64i32(const __wchar_t * _FileName, _wfinddata64i32_t * _FindData); 
#line 174
intptr_t __cdecl _wfindfirst64(const __wchar_t * _FileName, _wfinddata64_t * _FindData); 
#line 181
int __cdecl _wfindnext32i64(intptr_t _FindHandle, _wfinddata32i64_t * _FindData); 
#line 188
int __cdecl _wfindnext64i32(intptr_t _FindHandle, _wfinddata64i32_t * _FindData); 
#line 195
int __cdecl _wfindnext64(intptr_t _FindHandle, _wfinddata64_t * _FindData); 
#line 201
errno_t __cdecl _wsopen_s(int * _FileHandle, const __wchar_t * _FileName, int _OpenFlag, int _ShareFlag, int _PermissionFlag); 
#line 209
errno_t __cdecl _wsopen_dispatch(const __wchar_t * _FileName, int _OFlag, int _ShFlag, int _PMode, int * _PFileHandle, int _BSecure); 
#line 224
extern "C++" inline int __cdecl _wopen(const __wchar_t *
#line 225
_FileName, int 
#line 226
_OFlag, int 
#line 227
_PMode = 0) 
#line 229
{ 
#line 230
int _FileHandle; 
#line 232
const errno_t _Result = _wsopen_dispatch(_FileName, _OFlag, 64, _PMode, &_FileHandle, 0); 
#line 233
return (_Result) ? -1 : _FileHandle; 
#line 234
} 
#line 237
extern "C++" inline int __cdecl _wsopen(const __wchar_t *
#line 238
_FileName, int 
#line 239
_OFlag, int 
#line 240
_ShFlag, int 
#line 241
_PMode = 0) 
#line 243
{ 
#line 244
int _FileHandle; 
#line 246
const errno_t _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0); 
#line 247
return (_Result) ? -1 : _FileHandle; 
#line 248
} 
#line 268 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wio.h"
}__pragma( pack ( pop )) 
#line 270
#pragma warning(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wprocess.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 17
__pragma( pack ( push, 8 )) extern "C" {
#line 24
intptr_t __cdecl _wexecl(const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 29
intptr_t __cdecl _wexecle(const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 34
intptr_t __cdecl _wexeclp(const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 39
intptr_t __cdecl _wexeclpe(const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 44
intptr_t __cdecl _wexecv(const __wchar_t * _FileName, const __wchar_t *const * _ArgList); 
#line 49
intptr_t __cdecl _wexecve(const __wchar_t * _FileName, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); 
#line 55
intptr_t __cdecl _wexecvp(const __wchar_t * _FileName, const __wchar_t *const * _ArgList); 
#line 60
intptr_t __cdecl _wexecvpe(const __wchar_t * _FileName, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); 
#line 66
intptr_t __cdecl _wspawnl(int _Mode, const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 72
intptr_t __cdecl _wspawnle(int _Mode, const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 78
intptr_t __cdecl _wspawnlp(int _Mode, const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 84
intptr_t __cdecl _wspawnlpe(int _Mode, const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 90
intptr_t __cdecl _wspawnv(int _Mode, const __wchar_t * _FileName, const __wchar_t *const * _ArgList); 
#line 96
intptr_t __cdecl _wspawnve(int _Mode, const __wchar_t * _FileName, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); 
#line 103
intptr_t __cdecl _wspawnvp(int _Mode, const __wchar_t * _FileName, const __wchar_t *const * _ArgList); 
#line 109
intptr_t __cdecl _wspawnvpe(int _Mode, const __wchar_t * _FileName, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); 
#line 116
int __cdecl _wsystem(const __wchar_t * _Command); 
#line 125 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_wprocess.h"
}__pragma( pack ( pop )) 
#line 127
#pragma warning(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\sys/types.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 19
typedef unsigned short _ino_t; 
#line 22
typedef _ino_t ino_t; 
#line 31 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\sys/types.h"
typedef unsigned _dev_t; 
#line 34
typedef _dev_t dev_t; 
#line 43 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\sys/types.h"
typedef long _off_t; 
#line 46
typedef _off_t off_t; 
#line 51 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\sys/types.h"
#pragma warning(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\sys/stat.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 17
__pragma( pack ( push, 8 )) extern "C" {
#line 24
struct _stat32 { 
#line 26
_dev_t st_dev; 
#line 27
_ino_t st_ino; 
#line 28
unsigned short st_mode; 
#line 29
short st_nlink; 
#line 30
short st_uid; 
#line 31
short st_gid; 
#line 32
_dev_t st_rdev; 
#line 33
_off_t st_size; 
#line 34
__time32_t st_atime; 
#line 35
__time32_t st_mtime; 
#line 36
__time32_t st_ctime; 
#line 37
}; 
#line 39
struct _stat32i64 { 
#line 41
_dev_t st_dev; 
#line 42
_ino_t st_ino; 
#line 43
unsigned short st_mode; 
#line 44
short st_nlink; 
#line 45
short st_uid; 
#line 46
short st_gid; 
#line 47
_dev_t st_rdev; 
#line 48
__int64 st_size; 
#line 49
__time32_t st_atime; 
#line 50
__time32_t st_mtime; 
#line 51
__time32_t st_ctime; 
#line 52
}; 
#line 54
struct _stat64i32 { 
#line 56
_dev_t st_dev; 
#line 57
_ino_t st_ino; 
#line 58
unsigned short st_mode; 
#line 59
short st_nlink; 
#line 60
short st_uid; 
#line 61
short st_gid; 
#line 62
_dev_t st_rdev; 
#line 63
_off_t st_size; 
#line 64
__time64_t st_atime; 
#line 65
__time64_t st_mtime; 
#line 66
__time64_t st_ctime; 
#line 67
}; 
#line 69
struct _stat64 { 
#line 71
_dev_t st_dev; 
#line 72
_ino_t st_ino; 
#line 73
unsigned short st_mode; 
#line 74
short st_nlink; 
#line 75
short st_uid; 
#line 76
short st_gid; 
#line 77
_dev_t st_rdev; 
#line 78
__int64 st_size; 
#line 79
__time64_t st_atime; 
#line 80
__time64_t st_mtime; 
#line 81
__time64_t st_ctime; 
#line 82
}; 
#line 87
struct stat { 
#line 89
_dev_t st_dev; 
#line 90
_ino_t st_ino; 
#line 91
unsigned short st_mode; 
#line 92
short st_nlink; 
#line 93
short st_uid; 
#line 94
short st_gid; 
#line 95
_dev_t st_rdev; 
#line 96
_off_t st_size; 
#line 97
time_t st_atime; 
#line 98
time_t st_mtime; 
#line 99
time_t st_ctime; 
#line 100
}; 
#line 154 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\sys/stat.h"
int __cdecl _fstat32(int _FileHandle, struct _stat32 * _Stat); 
#line 159
int __cdecl _fstat32i64(int _FileHandle, struct _stat32i64 * _Stat); 
#line 164
int __cdecl _fstat64i32(int _FileHandle, struct _stat64i32 * _Stat); 
#line 169
int __cdecl _fstat64(int _FileHandle, struct _stat64 * _Stat); 
#line 174
int __cdecl _stat32(const char * _FileName, struct _stat32 * _Stat); 
#line 179
int __cdecl _stat32i64(const char * _FileName, struct _stat32i64 * _Stat); 
#line 184
int __cdecl _stat64i32(const char * _FileName, struct _stat64i32 * _Stat); 
#line 189
int __cdecl _stat64(const char * _FileName, struct _stat64 * _Stat); 
#line 194
int __cdecl _wstat32(const __wchar_t * _FileName, struct _stat32 * _Stat); 
#line 199
int __cdecl _wstat32i64(const __wchar_t * _FileName, struct _stat32i64 * _Stat); 
#line 204
int __cdecl _wstat64i32(const __wchar_t * _FileName, struct _stat64i32 * _Stat); 
#line 209
int __cdecl _wstat64(const __wchar_t * _FileName, struct _stat64 * _Stat); 
#line 233
static __inline int __cdecl fstat(const int _FileHandle, struct stat *const _Stat) 
#line 234
{ 
#line 235
static_assert((sizeof(struct stat) == sizeof(struct _stat64i32)), "sizeof(struct stat) == sizeof(struct _stat64i32)");
#line 236
return _fstat64i32(_FileHandle, (struct _stat64i32 *)_Stat); 
#line 237
} 
#line 238
static __inline int __cdecl stat(const char *const _FileName, struct stat *const _Stat) 
#line 239
{ 
#line 240
static_assert((sizeof(struct stat) == sizeof(struct _stat64i32)), "sizeof(struct stat) == sizeof(struct _stat64i32)");
#line 241
return _stat64i32(_FileName, (struct _stat64i32 *)_Stat); 
#line 242
} 
#line 247 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\sys/stat.h"
}__pragma( pack ( pop )) 
#line 249
#pragma warning(pop)
#line 22 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 20 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 25
#pragma warning(disable: 28251)
#line 28
extern "C" {
#line 140 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"
unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask); 
#line 141
unsigned char _BitScanForward64(unsigned long * _Index, unsigned __int64 _Mask); 
#line 143
unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask); 
#line 144
unsigned char _BitScanReverse64(unsigned long * _Index, unsigned __int64 _Mask); 
#line 146
unsigned char _bittest(const long *, long); 
#line 151
long _InterlockedAnd(volatile long * _Value, long _Mask); 
#line 152
short _InterlockedAnd16(volatile short * _Value, short _Mask); 
#line 156
__int64 _InterlockedAnd64(volatile __int64 * _Value, __int64 _Mask); 
#line 157
__int64 _interlockedand64(volatile __int64 * _Value, __int64 _Mask); 
#line 161
char _InterlockedAnd8(volatile char * _Value, char _Mask); 
#line 168
long _InterlockedCompareExchange(volatile long * _Destination, long _Exchange, long _Comparand); 
#line 170
short _InterlockedCompareExchange16(volatile short * _Destination, short _Exchange, short _Comparand); 
#line 174
__int64 _InterlockedCompareExchange64(volatile __int64 * _Destination, __int64 _Exchange, __int64 _Comparand); 
#line 178
char _InterlockedCompareExchange8(volatile char * _Destination, char _Exchange, char _Comparand); 
#line 185
unsigned char _InterlockedCompareExchange128(volatile __int64 * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult); 
#line 189
long _InterlockedDecrement(volatile long * _Addend); 
#line 191
short _InterlockedDecrement16(volatile short * _Addend); 
#line 192
__int64 _InterlockedDecrement64(volatile __int64 * _Addend); 
#line 193
__int64 _interlockeddecrement64(volatile __int64 * _Addend); 
#line 194
long _InterlockedExchange(volatile long * _Target, long _Value); 
#line 196
short _InterlockedExchange16(volatile short * _Target, short _Value); 
#line 200
__int64 _InterlockedExchange64(volatile __int64 * _Target, __int64 _Value); 
#line 201
__int64 _interlockedexchange64(volatile __int64 * _Target, __int64 _Value); 
#line 205
char _InterlockedExchange8(volatile char * _Target, char _Value); 
#line 209
long _InterlockedExchangeAdd(volatile long * _Addend, long _Value); 
#line 210
short _InterlockedExchangeAdd16(volatile short * _Addend, short _Value); 
#line 214
__int64 _InterlockedExchangeAdd64(volatile __int64 * _Addend, __int64 _Value); 
#line 215
__int64 _interlockedexchangeadd64(volatile __int64 * _Addend, __int64 _Value); 
#line 219
char _InterlockedExchangeAdd8(volatile char * _Addend, char _Value); 
#line 229
long _InterlockedIncrement(volatile long * _Addend); 
#line 231
short _InterlockedIncrement16(volatile short * _Addend); 
#line 232
__int64 _InterlockedIncrement64(volatile __int64 * _Addend); 
#line 233
__int64 _interlockedincrement64(volatile __int64 * _Addend); 
#line 235
long _InterlockedOr(volatile long * _Value, long _Mask); 
#line 236
short _InterlockedOr16(volatile short * _Value, short _Mask); 
#line 240
__int64 _InterlockedOr64(volatile __int64 * _Value, __int64 _Mask); 
#line 241
__int64 _interlockedor64(volatile __int64 * _Value, __int64 _Mask); 
#line 245
char _InterlockedOr8(volatile char * _Value, char _Mask); 
#line 252
long _InterlockedXor(volatile long * _Value, long _Mask); 
#line 253
short _InterlockedXor16(volatile short * _Value, short _Mask); 
#line 257
__int64 _InterlockedXor64(volatile __int64 * _Value, __int64 _Mask); 
#line 258
__int64 _interlockedxor64(volatile __int64 * _Value, __int64 _Mask); 
#line 262
char _InterlockedXor8(volatile char * _Value, char _Mask); 
#line 269
void _ReadWriteBarrier(); 
#line 270
short __iso_volatile_load16(const volatile short *); 
#line 271
int __iso_volatile_load32(const volatile int *); 
#line 272
__int64 __iso_volatile_load64(const volatile __int64 *); 
#line 273
char __iso_volatile_load8(const volatile char *); 
#line 274
void __iso_volatile_store16(volatile short *, short); 
#line 275
void __iso_volatile_store32(volatile int *, int); 
#line 276
void __iso_volatile_store64(volatile __int64 *, __int64); 
#line 277
void __iso_volatile_store8(volatile char *, char); 
#line 280
void _mm_pause(); 
#line 281
unsigned __lzcnt(unsigned); 
#line 282
unsigned short __lzcnt16(unsigned short); 
#line 283
unsigned __int64 __lzcnt64(unsigned __int64); 
#line 284
unsigned __popcnt(unsigned); 
#line 285
unsigned short __popcnt16(unsigned short); 
#line 286
unsigned __int64 __popcnt64(unsigned __int64); 
#line 287
unsigned __cdecl _rotl(unsigned _Value, int _Shift); 
#line 288
unsigned short __cdecl _rotl16(unsigned short _Value, unsigned char _Shift); 
#line 289
unsigned __int64 __cdecl _rotl64(unsigned __int64 _Value, int _Shift); 
#line 290
unsigned char __cdecl _rotl8(unsigned char _Value, unsigned char _Shift); 
#line 291
unsigned __cdecl _rotr(unsigned _Value, int _Shift); 
#line 292
unsigned short __cdecl _rotr16(unsigned short _Value, unsigned char _Shift); 
#line 293
unsigned __int64 __cdecl _rotr64(unsigned __int64 _Value, int _Shift); 
#line 294
unsigned char __cdecl _rotr8(unsigned char _Value, unsigned char _Shift); 
#line 295
unsigned __int64 __shiftleft128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift); 
#line 296
unsigned __int64 __shiftright128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift); 
#line 298
unsigned _tzcnt_u32(unsigned); 
#line 299
unsigned __int64 _tzcnt_u64(unsigned __int64); 
#line 301 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"
unsigned __int64 _umul128(unsigned __int64 _Multiplier, unsigned __int64 _Multiplicand, unsigned __int64 * _HighProduct); 
#line 302
unsigned __int64 __umulh(unsigned __int64, unsigned __int64); 
#line 304
unsigned __int64 __cdecl _udiv128(unsigned __int64 _HighDividend, unsigned __int64 _LowDividend, unsigned __int64 _Divisor, unsigned __int64 * _Remainder); 
#line 305
unsigned char __cdecl _addcarry_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64 *); 
#line 306
unsigned char __cdecl _subborrow_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64 *); 
#line 307
double __ceil(double); 
#line 308
float __ceilf(float); 
#line 309
double __floor(double); 
#line 310
float __floorf(float); 
#line 311
double __round(double); 
#line 312
float __roundf(float); 
#line 313
double __trunc(double); 
#line 314
float __truncf(float); 
#line 315
double __copysign(double, double); 
#line 316
float __copysignf(float, float); 
#line 317
unsigned __signbitvalue(double); 
#line 318
unsigned __signbitvaluef(float); 
#line 336 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"
void *__cdecl __builtin_assume_aligned(const void *, size_t, ...) noexcept; 
#line 347 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"
}
#line 349 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"
#pragma warning(pop)
#line 21 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\setjmp.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 24
__pragma( pack ( push, 8 )) extern "C" {
#line 54 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\setjmp.h"
typedef 
#line 51
struct __declspec(align(16)) _SETJMP_FLOAT128 { 
#line 53
unsigned __int64 Part[2]; 
#line 54
} SETJMP_FLOAT128; 
#line 57
typedef SETJMP_FLOAT128 _JBTYPE; 
#line 86
typedef 
#line 59
struct _JUMP_BUFFER { 
#line 61
unsigned __int64 Frame; 
#line 62
unsigned __int64 Rbx; 
#line 63
unsigned __int64 Rsp; 
#line 64
unsigned __int64 Rbp; 
#line 65
unsigned __int64 Rsi; 
#line 66
unsigned __int64 Rdi; 
#line 67
unsigned __int64 R12; 
#line 68
unsigned __int64 R13; 
#line 69
unsigned __int64 R14; 
#line 70
unsigned __int64 R15; 
#line 71
unsigned __int64 Rip; 
#line 72
unsigned long MxCsr; 
#line 73
unsigned short FpCsr; 
#line 74
unsigned short Spare; 
#line 76
SETJMP_FLOAT128 Xmm6; 
#line 77
SETJMP_FLOAT128 Xmm7; 
#line 78
SETJMP_FLOAT128 Xmm8; 
#line 79
SETJMP_FLOAT128 Xmm9; 
#line 80
SETJMP_FLOAT128 Xmm10; 
#line 81
SETJMP_FLOAT128 Xmm11; 
#line 82
SETJMP_FLOAT128 Xmm12; 
#line 83
SETJMP_FLOAT128 Xmm13; 
#line 84
SETJMP_FLOAT128 Xmm14; 
#line 85
SETJMP_FLOAT128 Xmm15; 
#line 86
} _JUMP_BUFFER; 
#line 148 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\setjmp.h"
typedef _JBTYPE jmp_buf[16]; 
#line 160 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\setjmp.h"
int __cdecl _setjmp(jmp_buf _Buf); 
#line 165
__declspec(noreturn) void __cdecl longjmp(jmp_buf _Buf, int _Value) noexcept(false); 
#line 177 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\setjmp.h"
}__pragma( pack ( pop )) 
#line 179
#pragma warning(pop)
#line 29 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\mmintrin.h"
extern "C" {
#line 45 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\mmintrin.h"
typedef 
#line 34
union __declspec(intrin_type) __declspec(align(8)) __m64 { 
#line 36
unsigned __int64 m64_u64; 
#line 37
float m64_f32[2]; 
#line 38
char m64_i8[8]; 
#line 39
short m64_i16[4]; 
#line 40
int m64_i32[2]; 
#line 41
__int64 m64_i64; 
#line 42
unsigned char m64_u8[8]; 
#line 43
unsigned short m64_u16[4]; 
#line 44
unsigned m64_u32[2]; 
#line 45
} __m64; 
#line 186 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\mmintrin.h"
}
#line 75 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"
typedef 
#line 65
union __declspec(intrin_type) __declspec(align(16)) __m128 { 
#line 66
float m128_f32[4]; 
#line 67
unsigned __int64 m128_u64[2]; 
#line 68
char m128_i8[16]; 
#line 69
short m128_i16[8]; 
#line 70
int m128_i32[4]; 
#line 71
__int64 m128_i64[2]; 
#line 72
unsigned char m128_u8[16]; 
#line 73
unsigned short m128_u16[8]; 
#line 74
unsigned m128_u32[4]; 
#line 75
} __m128; 
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\malloc.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 19
__pragma( pack ( push, 8 )) extern "C" {
#line 47 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\malloc.h"
typedef 
#line 42
struct _heapinfo { 
#line 44
int *_pentry; 
#line 45
size_t _size; 
#line 46
int _useflag; 
#line 47
} _HEAPINFO; 
#line 55
void *__cdecl _alloca(size_t _Size); 
#line 61
intptr_t __cdecl _get_heap_handle(); 
#line 64
int __cdecl _heapmin(); 
#line 67
int __cdecl _heapwalk(_HEAPINFO * _EntryInfo); 
#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\malloc.h"
int __cdecl _heapchk(); 
#line 74 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\malloc.h"
int __cdecl _resetstkoflw(); 
#line 86 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\malloc.h"
static_assert((sizeof(unsigned) <= (16)), "sizeof(unsigned int) <= _ALLOCA_S_MARKER_SIZE");
#line 89
#pragma warning(push)
#pragma warning(disable: 6540)
#line 93
__inline void *_MarkAllocaS(void *_Ptr, unsigned _Marker) 
#line 94
{ 
#line 95
if (_Ptr) 
#line 96
{ 
#line 97
(*((unsigned *)_Ptr)) = _Marker; 
#line 98
_Ptr = (((char *)_Ptr) + 16); 
#line 99
}  
#line 100
return _Ptr; 
#line 101
} 
#line 103
__inline size_t _MallocaComputeSize(size_t _Size) 
#line 104
{ 
#line 105
size_t _MarkedSize = _Size + (16); 
#line 106
return (_MarkedSize > _Size) ? _MarkedSize : (0); 
#line 107
} 
#line 109
#pragma warning(pop)
#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\malloc.h"
#pragma warning(push)
#pragma warning(disable: 6014)
__inline void __cdecl _freea(void *_Memory) 
#line 151
{ 
#line 152
unsigned _Marker; 
#line 153
if (_Memory) 
#line 154
{ 
#line 155
_Memory = (((char *)_Memory) - 16); 
#line 156
_Marker = (*((unsigned *)_Memory)); 
#line 157
if (_Marker == (56797)) 
#line 158
{ 
#line 159
free(_Memory); 
#line 160
} else { 
#line 162
if (_Marker != (52428)) 
#line 163
{ 
#line 164
(void)0; 
#line 165
}  }  
#line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\malloc.h"
}  
#line 168
} 
#line 181 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\malloc.h"
}
#line 169 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\malloc.h"
#pragma warning(pop)
#line 181 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\malloc.h"
__pragma( pack ( pop )) 
#line 183
#pragma warning(pop)
#line 193 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"
extern "C" {
#line 200 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"
#pragma warning(push)
#pragma warning(disable: 28251)
#line 207
extern __m128 _mm_add_ss(__m128 _A, __m128 _B); 
#line 208
extern __m128 _mm_add_ps(__m128 _A, __m128 _B); 
#line 209
extern __m128 _mm_sub_ss(__m128 _A, __m128 _B); 
#line 210
extern __m128 _mm_sub_ps(__m128 _A, __m128 _B); 
#line 211
extern __m128 _mm_mul_ss(__m128 _A, __m128 _B); 
#line 212
extern __m128 _mm_mul_ps(__m128 _A, __m128 _B); 
#line 213
extern __m128 _mm_div_ss(__m128 _A, __m128 _B); 
#line 214
extern __m128 _mm_div_ps(__m128 _A, __m128 _B); 
#line 215
extern __m128 _mm_sqrt_ss(__m128 _A); 
#line 216
extern __m128 _mm_sqrt_ps(__m128 _A); 
#line 217
extern __m128 _mm_rcp_ss(__m128 _A); 
#line 218
extern __m128 _mm_rcp_ps(__m128 _A); 
#line 219
extern __m128 _mm_rsqrt_ss(__m128 _A); 
#line 220
extern __m128 _mm_rsqrt_ps(__m128 _A); 
#line 221
extern __m128 _mm_min_ss(__m128 _A, __m128 _B); 
#line 222
extern __m128 _mm_min_ps(__m128 _A, __m128 _B); 
#line 223
extern __m128 _mm_max_ss(__m128 _A, __m128 _B); 
#line 224
extern __m128 _mm_max_ps(__m128 _A, __m128 _B); 
#line 230
extern __m128 _mm_and_ps(__m128 _A, __m128 _B); 
#line 231
extern __m128 _mm_andnot_ps(__m128 _A, __m128 _B); 
#line 232
extern __m128 _mm_or_ps(__m128 _A, __m128 _B); 
#line 233
extern __m128 _mm_xor_ps(__m128 _A, __m128 _B); 
#line 239
extern __m128 _mm_cmpeq_ss(__m128 _A, __m128 _B); 
#line 240
extern __m128 _mm_cmpeq_ps(__m128 _A, __m128 _B); 
#line 241
extern __m128 _mm_cmplt_ss(__m128 _A, __m128 _B); 
#line 242
extern __m128 _mm_cmplt_ps(__m128 _A, __m128 _B); 
#line 243
extern __m128 _mm_cmple_ss(__m128 _A, __m128 _B); 
#line 244
extern __m128 _mm_cmple_ps(__m128 _A, __m128 _B); 
#line 245
extern __m128 _mm_cmpgt_ss(__m128 _A, __m128 _B); 
#line 246
extern __m128 _mm_cmpgt_ps(__m128 _A, __m128 _B); 
#line 247
extern __m128 _mm_cmpge_ss(__m128 _A, __m128 _B); 
#line 248
extern __m128 _mm_cmpge_ps(__m128 _A, __m128 _B); 
#line 249
extern __m128 _mm_cmpneq_ss(__m128 _A, __m128 _B); 
#line 250
extern __m128 _mm_cmpneq_ps(__m128 _A, __m128 _B); 
#line 251
extern __m128 _mm_cmpnlt_ss(__m128 _A, __m128 _B); 
#line 252
extern __m128 _mm_cmpnlt_ps(__m128 _A, __m128 _B); 
#line 253
extern __m128 _mm_cmpnle_ss(__m128 _A, __m128 _B); 
#line 254
extern __m128 _mm_cmpnle_ps(__m128 _A, __m128 _B); 
#line 255
extern __m128 _mm_cmpngt_ss(__m128 _A, __m128 _B); 
#line 256
extern __m128 _mm_cmpngt_ps(__m128 _A, __m128 _B); 
#line 257
extern __m128 _mm_cmpnge_ss(__m128 _A, __m128 _B); 
#line 258
extern __m128 _mm_cmpnge_ps(__m128 _A, __m128 _B); 
#line 259
extern __m128 _mm_cmpord_ss(__m128 _A, __m128 _B); 
#line 260
extern __m128 _mm_cmpord_ps(__m128 _A, __m128 _B); 
#line 261
extern __m128 _mm_cmpunord_ss(__m128 _A, __m128 _B); 
#line 262
extern __m128 _mm_cmpunord_ps(__m128 _A, __m128 _B); 
#line 263
extern int _mm_comieq_ss(__m128 _A, __m128 _B); 
#line 264
extern int _mm_comilt_ss(__m128 _A, __m128 _B); 
#line 265
extern int _mm_comile_ss(__m128 _A, __m128 _B); 
#line 266
extern int _mm_comigt_ss(__m128 _A, __m128 _B); 
#line 267
extern int _mm_comige_ss(__m128 _A, __m128 _B); 
#line 268
extern int _mm_comineq_ss(__m128 _A, __m128 _B); 
#line 269
extern int _mm_ucomieq_ss(__m128 _A, __m128 _B); 
#line 270
extern int _mm_ucomilt_ss(__m128 _A, __m128 _B); 
#line 271
extern int _mm_ucomile_ss(__m128 _A, __m128 _B); 
#line 272
extern int _mm_ucomigt_ss(__m128 _A, __m128 _B); 
#line 273
extern int _mm_ucomige_ss(__m128 _A, __m128 _B); 
#line 274
extern int _mm_ucomineq_ss(__m128 _A, __m128 _B); 
#line 280
extern int _mm_cvt_ss2si(__m128 _A); 
#line 281
extern int _mm_cvtt_ss2si(__m128 _A); 
#line 282
extern __m128 _mm_cvt_si2ss(__m128, int); 
#line 283
extern float _mm_cvtss_f32(__m128 _A); 
#line 298 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"
extern __int64 _mm_cvtss_si64(__m128 _A); 
#line 299
extern __int64 _mm_cvttss_si64(__m128 _A); 
#line 300
extern __m128 _mm_cvtsi64_ss(__m128 _A, __int64 _B); 
#line 307 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"
extern __m128 _mm_shuffle_ps(__m128 _A, __m128 _B, unsigned _Imm8); 
#line 308
extern __m128 _mm_unpackhi_ps(__m128 _A, __m128 _B); 
#line 309
extern __m128 _mm_unpacklo_ps(__m128 _A, __m128 _B); 
#line 310
extern __m128 _mm_loadh_pi(__m128, const __m64 *); 
#line 311
extern __m128 _mm_movehl_ps(__m128, __m128); 
#line 312
extern __m128 _mm_movelh_ps(__m128, __m128); 
#line 313
extern void _mm_storeh_pi(__m64 *, __m128); 
#line 314
extern __m128 _mm_loadl_pi(__m128, const __m64 *); 
#line 315
extern void _mm_storel_pi(__m64 *, __m128); 
#line 316
extern int _mm_movemask_ps(__m128 _A); 
#line 342 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"
extern __m128 _mm_set_ss(float _A); 
#line 343
extern __m128 _mm_set_ps1(float _A); 
#line 344
extern __m128 _mm_set_ps(float _A, float _B, float _C, float _D); 
#line 345
extern __m128 _mm_setr_ps(float _A, float _B, float _C, float _D); 
#line 346
extern __m128 _mm_setzero_ps(); 
#line 347
extern __m128 _mm_load_ss(const float * _A); 
#line 348
extern __m128 _mm_load_ps1(const float * _A); 
#line 349
extern __m128 _mm_load_ps(const float * _A); 
#line 350
extern __m128 _mm_loadr_ps(const float * _A); 
#line 351
extern __m128 _mm_loadu_ps(const float * _A); 
#line 352
extern void _mm_store_ss(float * _V, __m128 _A); 
#line 353
extern void _mm_store_ps1(float * _V, __m128 _A); 
#line 354
extern void _mm_store_ps(float * _V, __m128 _A); 
#line 355
extern void _mm_storer_ps(float * _V, __m128 _A); 
#line 356
extern void _mm_storeu_ps(float * _V, __m128 _A); 
#line 357
extern void _mm_prefetch(const char * _A, int _Sel); 
#line 359
extern void _m_prefetchit0(const void *); 
#line 360
extern void _m_prefetchit1(const void *); 
#line 365 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"
extern void _mm_stream_ps(float *, __m128); 
#line 366
extern __m128 _mm_move_ss(__m128 _A, __m128 _B); 
#line 368
extern void _mm_sfence(); 
#line 369
extern unsigned _mm_getcsr(); 
#line 370
extern void _mm_setcsr(unsigned); 
#line 528 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"
}
#line 525
#pragma warning(pop)
#line 49 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
typedef 
#line 40
union __declspec(intrin_type) __declspec(align(16)) __m128i { 
#line 41
char m128i_i8[16]; 
#line 42
short m128i_i16[8]; 
#line 43
int m128i_i32[4]; 
#line 44
__int64 m128i_i64[2]; 
#line 45
unsigned char m128i_u8[16]; 
#line 46
unsigned short m128i_u16[8]; 
#line 47
unsigned m128i_u32[4]; 
#line 48
unsigned __int64 m128i_u64[2]; 
#line 49
} __m128i; 
#line 53
typedef 
#line 51
struct __declspec(intrin_type) __declspec(align(16)) __m128d { 
#line 52
double m128d_f64[2]; 
#line 53
} __m128d; 
#line 65
extern "C" {
#line 72 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
#pragma warning(push)
#pragma warning(disable: 28251)
#line 79
extern __m128d _mm_add_sd(__m128d _A, __m128d _B); 
#line 80
extern __m128d _mm_add_pd(__m128d _A, __m128d _B); 
#line 81
extern __m128d _mm_sub_sd(__m128d _A, __m128d _B); 
#line 82
extern __m128d _mm_sub_pd(__m128d _A, __m128d _B); 
#line 83
extern __m128d _mm_mul_sd(__m128d _A, __m128d _B); 
#line 84
extern __m128d _mm_mul_pd(__m128d _A, __m128d _B); 
#line 85
extern __m128d _mm_sqrt_sd(__m128d _A, __m128d _B); 
#line 86
extern __m128d _mm_sqrt_pd(__m128d _A); 
#line 87
extern __m128d _mm_div_sd(__m128d _A, __m128d _B); 
#line 88
extern __m128d _mm_div_pd(__m128d _A, __m128d _B); 
#line 89
extern __m128d _mm_min_sd(__m128d _A, __m128d _B); 
#line 90
extern __m128d _mm_min_pd(__m128d _A, __m128d _B); 
#line 91
extern __m128d _mm_max_sd(__m128d _A, __m128d _B); 
#line 92
extern __m128d _mm_max_pd(__m128d _A, __m128d _B); 
#line 98
extern __m128d _mm_and_pd(__m128d _A, __m128d _B); 
#line 99
extern __m128d _mm_andnot_pd(__m128d _A, __m128d _B); 
#line 100
extern __m128d _mm_or_pd(__m128d _A, __m128d _B); 
#line 101
extern __m128d _mm_xor_pd(__m128d _A, __m128d _B); 
#line 107
extern __m128d _mm_cmpeq_sd(__m128d _A, __m128d _B); 
#line 108
extern __m128d _mm_cmpeq_pd(__m128d _A, __m128d _B); 
#line 109
extern __m128d _mm_cmplt_sd(__m128d _A, __m128d _B); 
#line 110
extern __m128d _mm_cmplt_pd(__m128d _A, __m128d _B); 
#line 111
extern __m128d _mm_cmple_sd(__m128d _A, __m128d _B); 
#line 112
extern __m128d _mm_cmple_pd(__m128d _A, __m128d _B); 
#line 113
extern __m128d _mm_cmpgt_sd(__m128d _A, __m128d _B); 
#line 114
extern __m128d _mm_cmpgt_pd(__m128d _A, __m128d _B); 
#line 115
extern __m128d _mm_cmpge_sd(__m128d _A, __m128d _B); 
#line 116
extern __m128d _mm_cmpge_pd(__m128d _A, __m128d _B); 
#line 117
extern __m128d _mm_cmpneq_sd(__m128d _A, __m128d _B); 
#line 118
extern __m128d _mm_cmpneq_pd(__m128d _A, __m128d _B); 
#line 119
extern __m128d _mm_cmpnlt_sd(__m128d _A, __m128d _B); 
#line 120
extern __m128d _mm_cmpnlt_pd(__m128d _A, __m128d _B); 
#line 121
extern __m128d _mm_cmpnle_sd(__m128d _A, __m128d _B); 
#line 122
extern __m128d _mm_cmpnle_pd(__m128d _A, __m128d _B); 
#line 123
extern __m128d _mm_cmpngt_sd(__m128d _A, __m128d _B); 
#line 124
extern __m128d _mm_cmpngt_pd(__m128d _A, __m128d _B); 
#line 125
extern __m128d _mm_cmpnge_sd(__m128d _A, __m128d _B); 
#line 126
extern __m128d _mm_cmpnge_pd(__m128d _A, __m128d _B); 
#line 127
extern __m128d _mm_cmpord_pd(__m128d _A, __m128d _B); 
#line 128
extern __m128d _mm_cmpord_sd(__m128d _A, __m128d _B); 
#line 129
extern __m128d _mm_cmpunord_pd(__m128d _A, __m128d _B); 
#line 130
extern __m128d _mm_cmpunord_sd(__m128d _A, __m128d _B); 
#line 131
extern int _mm_comieq_sd(__m128d _A, __m128d _B); 
#line 132
extern int _mm_comilt_sd(__m128d _A, __m128d _B); 
#line 133
extern int _mm_comile_sd(__m128d _A, __m128d _B); 
#line 134
extern int _mm_comigt_sd(__m128d _A, __m128d _B); 
#line 135
extern int _mm_comige_sd(__m128d _A, __m128d _B); 
#line 136
extern int _mm_comineq_sd(__m128d _A, __m128d _B); 
#line 137
extern int _mm_ucomieq_sd(__m128d _A, __m128d _B); 
#line 138
extern int _mm_ucomilt_sd(__m128d _A, __m128d _B); 
#line 139
extern int _mm_ucomile_sd(__m128d _A, __m128d _B); 
#line 140
extern int _mm_ucomigt_sd(__m128d _A, __m128d _B); 
#line 141
extern int _mm_ucomige_sd(__m128d _A, __m128d _B); 
#line 142
extern int _mm_ucomineq_sd(__m128d _A, __m128d _B); 
#line 148
extern __m128d _mm_cvtepi32_pd(__m128i _A); 
#line 149
extern __m128i _mm_cvtpd_epi32(__m128d _A); 
#line 150
extern __m128i _mm_cvttpd_epi32(__m128d _A); 
#line 151
extern __m128 _mm_cvtepi32_ps(__m128i _A); 
#line 152
extern __m128i _mm_cvtps_epi32(__m128 _A); 
#line 153
extern __m128i _mm_cvttps_epi32(__m128 _A); 
#line 154
extern __m128 _mm_cvtpd_ps(__m128d _A); 
#line 155
extern __m128d _mm_cvtps_pd(__m128 _A); 
#line 156
extern __m128 _mm_cvtsd_ss(__m128 _A, __m128d _B); 
#line 157
extern __m128d _mm_cvtss_sd(__m128d _A, __m128 _B); 
#line 159
extern int _mm_cvtsd_si32(__m128d _A); 
#line 160
extern int _mm_cvttsd_si32(__m128d _A); 
#line 161
extern __m128d _mm_cvtsi32_sd(__m128d _A, int _B); 
#line 173 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
extern __m128d _mm_unpackhi_pd(__m128d _A, __m128d _B); 
#line 174
extern __m128d _mm_unpacklo_pd(__m128d _A, __m128d _B); 
#line 175
extern int _mm_movemask_pd(__m128d _A); 
#line 176
extern __m128d _mm_shuffle_pd(__m128d _A, __m128d _B, int _I); 
#line 182
extern __m128d _mm_load_pd(const double * _Dp); 
#line 183
extern __m128d _mm_load1_pd(const double * _Dp); 
#line 184
extern __m128d _mm_loadr_pd(const double * _Dp); 
#line 185
extern __m128d _mm_loadu_pd(const double * _Dp); 
#line 186
extern __m128d _mm_load_sd(const double * _Dp); 
#line 187
extern __m128d _mm_loadh_pd(__m128d _A, const double * _Dp); 
#line 188
extern __m128d _mm_loadl_pd(__m128d _A, const double * _Dp); 
#line 194
extern __m128d _mm_set_sd(double _W); 
#line 195
extern __m128d _mm_set1_pd(double _A); 
#line 196
extern __m128d _mm_set_pd(double _Z, double _Y); 
#line 197
extern __m128d _mm_setr_pd(double _Y, double _Z); 
#line 198
extern __m128d _mm_setzero_pd(); 
#line 199
extern __m128d _mm_move_sd(__m128d _A, __m128d _B); 
#line 205
extern void _mm_store_sd(double * _Dp, __m128d _A); 
#line 206
extern void _mm_store1_pd(double * _Dp, __m128d _A); 
#line 207
extern void _mm_store_pd(double * _Dp, __m128d _A); 
#line 208
extern void _mm_storeu_pd(double * _Dp, __m128d _A); 
#line 209
extern void _mm_storer_pd(double * _Dp, __m128d _A); 
#line 210
extern void _mm_storeh_pd(double * _Dp, __m128d _A); 
#line 211
extern void _mm_storel_pd(double * _Dp, __m128d _A); 
#line 222
extern __m128i _mm_add_epi8(__m128i _A, __m128i _B); 
#line 223
extern __m128i _mm_add_epi16(__m128i _A, __m128i _B); 
#line 224
extern __m128i _mm_add_epi32(__m128i _A, __m128i _B); 
#line 228 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
extern __m128i _mm_add_epi64(__m128i _A, __m128i _B); 
#line 229
extern __m128i _mm_adds_epi8(__m128i _A, __m128i _B); 
#line 230
extern __m128i _mm_adds_epi16(__m128i _A, __m128i _B); 
#line 231
extern __m128i _mm_adds_epu8(__m128i _A, __m128i _B); 
#line 232
extern __m128i _mm_adds_epu16(__m128i _A, __m128i _B); 
#line 233
extern __m128i _mm_avg_epu8(__m128i _A, __m128i _B); 
#line 234
extern __m128i _mm_avg_epu16(__m128i _A, __m128i _B); 
#line 235
extern __m128i _mm_madd_epi16(__m128i _A, __m128i _B); 
#line 236
extern __m128i _mm_max_epi16(__m128i _A, __m128i _B); 
#line 237
extern __m128i _mm_max_epu8(__m128i _A, __m128i _B); 
#line 238
extern __m128i _mm_min_epi16(__m128i _A, __m128i _B); 
#line 239
extern __m128i _mm_min_epu8(__m128i _A, __m128i _B); 
#line 240
extern __m128i _mm_mulhi_epi16(__m128i _A, __m128i _B); 
#line 241
extern __m128i _mm_mulhi_epu16(__m128i _A, __m128i _B); 
#line 242
extern __m128i _mm_mullo_epi16(__m128i _A, __m128i _B); 
#line 246 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
extern __m128i _mm_mul_epu32(__m128i _A, __m128i _B); 
#line 247
extern __m128i _mm_sad_epu8(__m128i _A, __m128i _B); 
#line 248
extern __m128i _mm_sub_epi8(__m128i _A, __m128i _B); 
#line 249
extern __m128i _mm_sub_epi16(__m128i _A, __m128i _B); 
#line 250
extern __m128i _mm_sub_epi32(__m128i _A, __m128i _B); 
#line 254 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
extern __m128i _mm_sub_epi64(__m128i _A, __m128i _B); 
#line 255
extern __m128i _mm_subs_epi8(__m128i _A, __m128i _B); 
#line 256
extern __m128i _mm_subs_epi16(__m128i _A, __m128i _B); 
#line 257
extern __m128i _mm_subs_epu8(__m128i _A, __m128i _B); 
#line 258
extern __m128i _mm_subs_epu16(__m128i _A, __m128i _B); 
#line 264
extern __m128i _mm_and_si128(__m128i _A, __m128i _B); 
#line 265
extern __m128i _mm_andnot_si128(__m128i _A, __m128i _B); 
#line 266
extern __m128i _mm_or_si128(__m128i _A, __m128i _B); 
#line 267
extern __m128i _mm_xor_si128(__m128i _A, __m128i _B); 
#line 273
extern __m128i _mm_slli_si128(__m128i _A, int _Imm); 
#line 275
extern __m128i _mm_slli_epi16(__m128i _A, int _Count); 
#line 276
extern __m128i _mm_sll_epi16(__m128i _A, __m128i _Count); 
#line 277
extern __m128i _mm_slli_epi32(__m128i _A, int _Count); 
#line 278
extern __m128i _mm_sll_epi32(__m128i _A, __m128i _Count); 
#line 279
extern __m128i _mm_slli_epi64(__m128i _A, int _Count); 
#line 280
extern __m128i _mm_sll_epi64(__m128i _A, __m128i _Count); 
#line 281
extern __m128i _mm_srai_epi16(__m128i _A, int _Count); 
#line 282
extern __m128i _mm_sra_epi16(__m128i _A, __m128i _Count); 
#line 283
extern __m128i _mm_srai_epi32(__m128i _A, int _Count); 
#line 284
extern __m128i _mm_sra_epi32(__m128i _A, __m128i _Count); 
#line 285
extern __m128i _mm_srli_si128(__m128i _A, int _Imm); 
#line 287
extern __m128i _mm_srli_epi16(__m128i _A, int _Count); 
#line 288
extern __m128i _mm_srl_epi16(__m128i _A, __m128i _Count); 
#line 289
extern __m128i _mm_srli_epi32(__m128i _A, int _Count); 
#line 290
extern __m128i _mm_srl_epi32(__m128i _A, __m128i _Count); 
#line 291
extern __m128i _mm_srli_epi64(__m128i _A, int _Count); 
#line 292
extern __m128i _mm_srl_epi64(__m128i _A, __m128i _Count); 
#line 298
extern __m128i _mm_cmpeq_epi8(__m128i _A, __m128i _B); 
#line 299
extern __m128i _mm_cmpeq_epi16(__m128i _A, __m128i _B); 
#line 300
extern __m128i _mm_cmpeq_epi32(__m128i _A, __m128i _B); 
#line 301
extern __m128i _mm_cmpgt_epi8(__m128i _A, __m128i _B); 
#line 302
extern __m128i _mm_cmpgt_epi16(__m128i _A, __m128i _B); 
#line 303
extern __m128i _mm_cmpgt_epi32(__m128i _A, __m128i _B); 
#line 304
extern __m128i _mm_cmplt_epi8(__m128i _A, __m128i _B); 
#line 305
extern __m128i _mm_cmplt_epi16(__m128i _A, __m128i _B); 
#line 306
extern __m128i _mm_cmplt_epi32(__m128i _A, __m128i _B); 
#line 312
extern __m128i _mm_cvtsi32_si128(int _A); 
#line 313
extern int _mm_cvtsi128_si32(__m128i _A); 
#line 319
extern __m128i _mm_packs_epi16(__m128i _A, __m128i _B); 
#line 320
extern __m128i _mm_packs_epi32(__m128i _A, __m128i _B); 
#line 321
extern __m128i _mm_packus_epi16(__m128i _A, __m128i _B); 
#line 322
extern int _mm_extract_epi16(__m128i _A, int _Imm); 
#line 323
extern __m128i _mm_insert_epi16(__m128i _A, int _B, int _Imm); 
#line 324
extern int _mm_movemask_epi8(__m128i _A); 
#line 325
extern __m128i _mm_shuffle_epi32(__m128i _A, int _Imm); 
#line 326
extern __m128i _mm_shufflehi_epi16(__m128i _A, int _Imm); 
#line 327
extern __m128i _mm_shufflelo_epi16(__m128i _A, int _Imm); 
#line 328
extern __m128i _mm_unpackhi_epi8(__m128i _A, __m128i _B); 
#line 329
extern __m128i _mm_unpackhi_epi16(__m128i _A, __m128i _B); 
#line 330
extern __m128i _mm_unpackhi_epi32(__m128i _A, __m128i _B); 
#line 331
extern __m128i _mm_unpackhi_epi64(__m128i _A, __m128i _B); 
#line 332
extern __m128i _mm_unpacklo_epi8(__m128i _A, __m128i _B); 
#line 333
extern __m128i _mm_unpacklo_epi16(__m128i _A, __m128i _B); 
#line 334
extern __m128i _mm_unpacklo_epi32(__m128i _A, __m128i _B); 
#line 335
extern __m128i _mm_unpacklo_epi64(__m128i _A, __m128i _B); 
#line 341
extern __m128i _mm_load_si128(const __m128i * _P); 
#line 342
extern __m128i _mm_loadu_si128(const __m128i * _P); 
#line 343
extern __m128i _mm_loadl_epi64(const __m128i * _P); 
#line 352 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
extern __m128i _mm_set_epi64x(__int64 _I1, __int64 _I0); 
#line 353
extern __m128i _mm_set_epi32(int _I3, int _I2, int _I1, int _I0); 
#line 354
extern __m128i _mm_set_epi16(short _W7, short _W6, short _W5, short _W4, short _W3, short _W2, short _W1, short _W0); 
#line 356
extern __m128i _mm_set_epi8(char _B15, char _B14, char _B13, char _B12, char _B11, char _B10, char _B9, char _B8, char _B7, char _B6, char _B5, char _B4, char _B3, char _B2, char _B1, char _B0); 
#line 363 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
extern __m128i _mm_set1_epi64x(__int64 i); 
#line 364
extern __m128i _mm_set1_epi32(int _I); 
#line 365
extern __m128i _mm_set1_epi16(short _W); 
#line 366
extern __m128i _mm_set1_epi8(char _B); 
#line 367
extern __m128i _mm_setl_epi64(__m128i _Q); 
#line 371 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
extern __m128i _mm_setr_epi32(int _I0, int _I1, int _I2, int _I3); 
#line 372
extern __m128i _mm_setr_epi16(short _W0, short _W1, short _W2, short _W3, short _W4, short _W5, short _W6, short _W7); 
#line 374
extern __m128i _mm_setr_epi8(char _B15, char _B14, char _B13, char _B12, char _B11, char _B10, char _B9, char _B8, char _B7, char _B6, char _B5, char _B4, char _B3, char _B2, char _B1, char _B0); 
#line 378
extern __m128i _mm_setzero_si128(); 
#line 384
extern void _mm_store_si128(__m128i * _P, __m128i _B); 
#line 385
extern void _mm_storeu_si128(__m128i * _P, __m128i _B); 
#line 386
extern void _mm_storel_epi64(__m128i * _P, __m128i _Q); 
#line 387
extern void _mm_maskmoveu_si128(__m128i _D, __m128i _N, char * _P); 
#line 393
extern __m128i _mm_move_epi64(__m128i _Q); 
#line 403 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
extern void _mm_stream_pd(double * _Dp, __m128d _A); 
#line 404
extern void _mm_stream_si128(__m128i * _P, __m128i _A); 
#line 405
extern void _mm_clflush(const void * _P); 
#line 406
extern void _mm_lfence(); 
#line 407
extern void _mm_mfence(); 
#line 408
extern void _mm_stream_si32(int * _P, int _I); 
#line 409
extern void _mm_pause(); 
#line 415
extern double _mm_cvtsd_f64(__m128d _A); 
#line 423
extern __m128 _mm_castpd_ps(__m128d); 
#line 424
extern __m128i _mm_castpd_si128(__m128d); 
#line 425
extern __m128d _mm_castps_pd(__m128); 
#line 426
extern __m128i _mm_castps_si128(__m128); 
#line 427
extern __m128 _mm_castsi128_ps(__m128i); 
#line 428
extern __m128d _mm_castsi128_pd(__m128i); 
#line 435
extern __int64 _mm_cvtsd_si64(__m128d); 
#line 436
extern __int64 _mm_cvttsd_si64(__m128d); 
#line 437
extern __m128d _mm_cvtsi64_sd(__m128d, __int64); 
#line 438
extern __m128i _mm_cvtsi64_si128(__int64); 
#line 439
extern __int64 _mm_cvtsi128_si64(__m128i); 
#line 447 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
}
#line 444
#pragma warning(pop)
#line 58 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\pmmintrin.h"
extern "C" {
#line 66 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\pmmintrin.h"
extern __m128 _mm_addsub_ps(__m128, __m128); 
#line 67
extern __m128 _mm_hadd_ps(__m128, __m128); 
#line 68
extern __m128 _mm_hsub_ps(__m128, __m128); 
#line 69
extern __m128 _mm_movehdup_ps(__m128); 
#line 70
extern __m128 _mm_moveldup_ps(__m128); 
#line 76
extern __m128d _mm_addsub_pd(__m128d, __m128d); 
#line 77
extern __m128d _mm_hadd_pd(__m128d, __m128d); 
#line 78
extern __m128d _mm_hsub_pd(__m128d, __m128d); 
#line 79
extern __m128d _mm_loaddup_pd(const double *); 
#line 80
extern __m128d _mm_movedup_pd(__m128d); 
#line 85
extern __m128i _mm_lddqu_si128(const __m128i *); 
#line 93
extern void _mm_monitor(const void *, unsigned, unsigned); 
#line 98
extern void _mm_mwait(unsigned, unsigned); 
#line 101
}
#line 35 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"
extern "C" {
#line 45 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"
extern __m128i _mm_hadd_epi16(__m128i, __m128i); 
#line 46
extern __m128i _mm_hadd_epi32(__m128i, __m128i); 
#line 47
extern __m128i _mm_hadds_epi16(__m128i, __m128i); 
#line 63 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"
extern __m128i _mm_hsub_epi16(__m128i, __m128i); 
#line 64
extern __m128i _mm_hsub_epi32(__m128i, __m128i); 
#line 65
extern __m128i _mm_hsubs_epi16(__m128i, __m128i); 
#line 82 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"
extern __m128i _mm_maddubs_epi16(__m128i, __m128i); 
#line 91 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"
extern __m128i _mm_mulhrs_epi16(__m128i, __m128i); 
#line 100 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"
extern __m128i _mm_shuffle_epi8(__m128i, __m128i); 
#line 109 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"
extern __m128i _mm_sign_epi8(__m128i, __m128i); 
#line 110
extern __m128i _mm_sign_epi16(__m128i, __m128i); 
#line 111
extern __m128i _mm_sign_epi32(__m128i, __m128i); 
#line 122 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"
extern __m128i _mm_alignr_epi8(__m128i, __m128i, int); 
#line 131 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"
extern __m128i _mm_abs_epi8(__m128i); 
#line 132
extern __m128i _mm_abs_epi16(__m128i); 
#line 133
extern __m128i _mm_abs_epi32(__m128i); 
#line 142 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"
}
#line 83 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\smmintrin.h"
extern "C" {
#line 89 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\smmintrin.h"
extern __m128i _mm_blend_epi16(__m128i, __m128i, const int); 
#line 90
extern __m128i _mm_blendv_epi8(__m128i, __m128i, __m128i mask); 
#line 95
extern __m128 _mm_blend_ps(__m128, __m128, const int); 
#line 96
extern __m128 _mm_blendv_ps(__m128, __m128, __m128); 
#line 101
extern __m128d _mm_blend_pd(__m128d, __m128d, const int); 
#line 102
extern __m128d _mm_blendv_pd(__m128d, __m128d, __m128d); 
#line 107
extern __m128 _mm_dp_ps(__m128, __m128, const int); 
#line 108
extern __m128d _mm_dp_pd(__m128d, __m128d, const int); 
#line 113
extern __m128i _mm_cmpeq_epi64(__m128i, __m128i); 
#line 117
extern __m128i _mm_min_epi8(__m128i, __m128i); 
#line 118
extern __m128i _mm_max_epi8(__m128i, __m128i); 
#line 120
extern __m128i _mm_min_epu16(__m128i, __m128i); 
#line 121
extern __m128i _mm_max_epu16(__m128i, __m128i); 
#line 123
extern __m128i _mm_min_epi32(__m128i, __m128i); 
#line 124
extern __m128i _mm_max_epi32(__m128i, __m128i); 
#line 125
extern __m128i _mm_min_epu32(__m128i, __m128i); 
#line 126
extern __m128i _mm_max_epu32(__m128i, __m128i); 
#line 131
extern __m128i _mm_mullo_epi32(__m128i, __m128i); 
#line 136
extern __m128i _mm_mul_epi32(__m128i, __m128i); 
#line 141
extern int _mm_testz_si128(__m128i, __m128i); 
#line 146
extern int _mm_testc_si128(__m128i, __m128i); 
#line 152
extern int _mm_testnzc_si128(__m128i, __m128i); 
#line 160
extern __m128 _mm_insert_ps(__m128, __m128, const int); 
#line 170
extern int _mm_extract_ps(__m128, const int); 
#line 188
extern __m128i _mm_insert_epi8(__m128i, int, const int); 
#line 189
extern __m128i _mm_insert_epi32(__m128i, int, const int); 
#line 192
extern __m128i _mm_insert_epi64(__m128i, __int64, const int); 
#line 197 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\smmintrin.h"
extern int _mm_extract_epi8(__m128i, const int); 
#line 198
extern int _mm_extract_epi32(__m128i, const int); 
#line 201
extern __int64 _mm_extract_epi64(__m128i, const int); 
#line 207 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\smmintrin.h"
extern __m128i _mm_minpos_epu16(__m128i); 
#line 211
extern __m128d _mm_round_pd(__m128d, int); 
#line 212
extern __m128d _mm_round_sd(__m128d, __m128d, int); 
#line 216
extern __m128 _mm_round_ps(__m128, int); 
#line 217
extern __m128 _mm_round_ss(__m128, __m128, int); 
#line 221
extern __m128i _mm_cvtepi8_epi32(__m128i); 
#line 222
extern __m128i _mm_cvtepi16_epi32(__m128i); 
#line 223
extern __m128i _mm_cvtepi8_epi64(__m128i); 
#line 224
extern __m128i _mm_cvtepi32_epi64(__m128i); 
#line 225
extern __m128i _mm_cvtepi16_epi64(__m128i); 
#line 226
extern __m128i _mm_cvtepi8_epi16(__m128i); 
#line 230
extern __m128i _mm_cvtepu8_epi32(__m128i); 
#line 231
extern __m128i _mm_cvtepu16_epi32(__m128i); 
#line 232
extern __m128i _mm_cvtepu8_epi64(__m128i); 
#line 233
extern __m128i _mm_cvtepu32_epi64(__m128i); 
#line 234
extern __m128i _mm_cvtepu16_epi64(__m128i); 
#line 235
extern __m128i _mm_cvtepu8_epi16(__m128i); 
#line 241
extern __m128i _mm_packus_epi32(__m128i, __m128i); 
#line 247
extern __m128i _mm_mpsadbw_epu8(__m128i, __m128i, const int); 
#line 256 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\smmintrin.h"
extern __m128i _mm_stream_load_si128(const __m128i *); 
#line 260 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\smmintrin.h"
}
#line 36 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\nmmintrin.h"
extern "C" {
#line 83 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\nmmintrin.h"
extern __m128i _mm_cmpistrm(__m128i, __m128i, const int); 
#line 84
extern int _mm_cmpistri(__m128i, __m128i, const int); 
#line 86
extern __m128i _mm_cmpestrm(__m128i, int, __m128i, int, const int); 
#line 87
extern int _mm_cmpestri(__m128i, int, __m128i, int, const int); 
#line 93
extern int _mm_cmpistrz(__m128i, __m128i, const int); 
#line 94
extern int _mm_cmpistrc(__m128i, __m128i, const int); 
#line 95
extern int _mm_cmpistrs(__m128i, __m128i, const int); 
#line 96
extern int _mm_cmpistro(__m128i, __m128i, const int); 
#line 97
extern int _mm_cmpistra(__m128i, __m128i, const int); 
#line 99
extern int _mm_cmpestrz(__m128i, int, __m128i, int, const int); 
#line 100
extern int _mm_cmpestrc(__m128i, int, __m128i, int, const int); 
#line 101
extern int _mm_cmpestrs(__m128i, int, __m128i, int, const int); 
#line 102
extern int _mm_cmpestro(__m128i, int, __m128i, int, const int); 
#line 103
extern int _mm_cmpestra(__m128i, int, __m128i, int, const int); 
#line 110
extern __m128i _mm_cmpgt_epi64(__m128i, __m128i); 
#line 116
extern int _mm_popcnt_u32(unsigned); 
#line 119
extern __int64 _mm_popcnt_u64(unsigned __int64); 
#line 126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\nmmintrin.h"
extern unsigned _mm_crc32_u8(unsigned, unsigned char); 
#line 127
extern unsigned _mm_crc32_u16(unsigned, unsigned short); 
#line 128
extern unsigned _mm_crc32_u32(unsigned, unsigned); 
#line 131
extern unsigned __int64 _mm_crc32_u64(unsigned __int64, unsigned __int64); 
#line 135 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\nmmintrin.h"
}
#line 35 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\wmmintrin.h"
extern "C" {
#line 42 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\wmmintrin.h"
extern __m128i _mm_aesdec_si128(__m128i, __m128i); 
#line 48
extern __m128i _mm_aesdeclast_si128(__m128i, __m128i); 
#line 54
extern __m128i _mm_aesenc_si128(__m128i, __m128i); 
#line 60
extern __m128i _mm_aesenclast_si128(__m128i, __m128i); 
#line 66
extern __m128i _mm_aesimc_si128(__m128i); 
#line 73
extern __m128i _mm_aeskeygenassist_si128(__m128i, const int); 
#line 81
extern __m128i _mm_clmulepi64_si128(__m128i, __m128i, const int); 
#line 86
}
#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern "C" {
#line 41 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
typedef 
#line 39
union __declspec(intrin_type) __declspec(align(32)) __m256 { 
#line 40
float m256_f32[8]; 
#line 41
} __m256; 
#line 45
typedef 
#line 43
struct __declspec(intrin_type) __declspec(align(32)) __m256d { 
#line 44
double m256d_f64[4]; 
#line 45
} __m256d; 
#line 56
typedef 
#line 47
union __declspec(intrin_type) __declspec(align(32)) __m256i { 
#line 48
char m256i_i8[32]; 
#line 49
short m256i_i16[16]; 
#line 50
int m256i_i32[8]; 
#line 51
__int64 m256i_i64[4]; 
#line 52
unsigned char m256i_u8[32]; 
#line 53
unsigned short m256i_u16[16]; 
#line 54
unsigned m256i_u32[8]; 
#line 55
unsigned __int64 m256i_u64[4]; 
#line 56
} __m256i; 
#line 105
extern unsigned __int64 __isa_inverted; 
#line 106
extern unsigned __avx10_version; 
#line 108
inline bool __check_isa_support(unsigned __x, unsigned __v = 0) 
#line 112 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
{ return ((__x & __isa_inverted) == (0)) && (((unsigned char)__avx10_version) >= __v); } 
#line 121 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
inline bool __check_isa_avx10_512(unsigned __v) { return (__avx10_version >= (__v | (262144))); } 
#line 125
extern unsigned __arch_inverted(); 
#line 126
extern unsigned __arch_avx10ver(); 
#line 128
inline bool __check_arch_support(unsigned __x, unsigned __v = 0) 
#line 132 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
{ return ((__x & __arch_inverted()) == (0)) && (__arch_avx10ver() >= __v); } 
#line 141 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
inline unsigned _get_vlen() 
#line 145 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
{ 
#line 146
unsigned arch_inverted = __arch_inverted(); 
#line 147
if ((arch_inverted & (4)) == (0)) { 
#line 148
return 512; } else { 
#line 149
if ((arch_inverted & (2)) == (0)) { 
#line 150
return 256; } else { 
#line 151
if ((arch_inverted & (1)) == (0)) { 
#line 152
return 128; } else { 
#line 154
return 0; }  }  }  
#line 155
} 
#line 168 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern __m256d __cdecl _mm256_add_pd(__m256d, __m256d); 
#line 178
extern __m256 __cdecl _mm256_add_ps(__m256, __m256); 
#line 191
extern __m256d __cdecl _mm256_addsub_pd(__m256d, __m256d); 
#line 204
extern __m256 __cdecl _mm256_addsub_ps(__m256, __m256); 
#line 213
extern __m256d __cdecl _mm256_and_pd(__m256d, __m256d); 
#line 222
extern __m256 __cdecl _mm256_and_ps(__m256, __m256); 
#line 231
extern __m256d __cdecl _mm256_andnot_pd(__m256d, __m256d); 
#line 240
extern __m256 __cdecl _mm256_andnot_ps(__m256, __m256); 
#line 254
extern __m256d __cdecl _mm256_blend_pd(__m256d, __m256d, const int); 
#line 268
extern __m256 __cdecl _mm256_blend_ps(__m256, __m256, const int); 
#line 278
extern __m256d __cdecl _mm256_blendv_pd(__m256d, __m256d, __m256d); 
#line 288
extern __m256 __cdecl _mm256_blendv_ps(__m256, __m256, __m256); 
#line 297
extern __m256d __cdecl _mm256_div_pd(__m256d, __m256d); 
#line 306
extern __m256 __cdecl _mm256_div_ps(__m256, __m256); 
#line 321
extern __m256 __cdecl _mm256_dp_ps(__m256, __m256, const int); 
#line 330
extern __m256d __cdecl _mm256_hadd_pd(__m256d, __m256d); 
#line 339
extern __m256 __cdecl _mm256_hadd_ps(__m256, __m256); 
#line 348
extern __m256d __cdecl _mm256_hsub_pd(__m256d, __m256d); 
#line 357
extern __m256 __cdecl _mm256_hsub_ps(__m256, __m256); 
#line 366
extern __m256d __cdecl _mm256_max_pd(__m256d, __m256d); 
#line 375
extern __m256 __cdecl _mm256_max_ps(__m256, __m256); 
#line 384
extern __m256d __cdecl _mm256_min_pd(__m256d, __m256d); 
#line 393
extern __m256 __cdecl _mm256_min_ps(__m256, __m256); 
#line 403
extern __m256d __cdecl _mm256_mul_pd(__m256d, __m256d); 
#line 413
extern __m256 __cdecl _mm256_mul_ps(__m256, __m256); 
#line 422
extern __m256d __cdecl _mm256_or_pd(__m256d, __m256d); 
#line 431
extern __m256 __cdecl _mm256_or_ps(__m256, __m256); 
#line 443
extern __m256d __cdecl _mm256_shuffle_pd(__m256d, __m256d, const int); 
#line 456
extern __m256 __cdecl _mm256_shuffle_ps(__m256, __m256, const int); 
#line 465
extern __m256d __cdecl _mm256_sub_pd(__m256d, __m256d); 
#line 475
extern __m256 __cdecl _mm256_sub_ps(__m256, __m256); 
#line 484
extern __m256d __cdecl _mm256_xor_pd(__m256d, __m256d); 
#line 493
extern __m256 __cdecl _mm256_xor_ps(__m256, __m256); 
#line 509
extern __m128d __cdecl _mm_cmp_pd(__m128d, __m128d, const int); 
#line 510
extern __m256d __cdecl _mm256_cmp_pd(__m256d, __m256d, const int); 
#line 526
extern __m128 __cdecl _mm_cmp_ps(__m128, __m128, const int); 
#line 527
extern __m256 __cdecl _mm256_cmp_ps(__m256, __m256, const int); 
#line 540
extern __m128d __cdecl _mm_cmp_sd(__m128d, __m128d, const int); 
#line 546
extern int __cdecl _mm_comi_sd(__m128d, __m128d, const int); 
#line 559
extern __m128 __cdecl _mm_cmp_ss(__m128, __m128, const int); 
#line 565
extern int __cdecl _mm_comi_ss(__m128, __m128, const int); 
#line 574
extern __m256d __cdecl _mm256_cvtepi32_pd(__m128i); 
#line 583
extern __m256 __cdecl _mm256_cvtepi32_ps(__m256i); 
#line 593
extern __m128 __cdecl _mm256_cvtpd_ps(__m256d); 
#line 602
extern __m256i __cdecl _mm256_cvtps_epi32(__m256); 
#line 612
extern __m256d __cdecl _mm256_cvtps_pd(__m128); 
#line 625
extern __m128i __cdecl _mm256_cvttpd_epi32(__m256d); 
#line 634
extern __m128i __cdecl _mm256_cvtpd_epi32(__m256d); 
#line 647
extern __m256i __cdecl _mm256_cvttps_epi32(__m256); 
#line 684 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern __m128 __cdecl _mm256_extractf128_ps(__m256, const int); 
#line 685
extern __m128d __cdecl _mm256_extractf128_pd(__m256d, const int); 
#line 686
extern __m128i __cdecl _mm256_extractf128_si256(__m256i, const int); 
#line 693
extern void __cdecl _mm256_zeroall(); 
#line 701
extern void __cdecl _mm256_zeroupper(); 
#line 711
extern __m256 __cdecl _mm256_permutevar_ps(__m256, __m256i); 
#line 712
extern __m128 __cdecl _mm_permutevar_ps(__m128, __m128i); 
#line 722
extern __m256 __cdecl _mm256_permute_ps(__m256, int); 
#line 723
extern __m128 __cdecl _mm_permute_ps(__m128, int); 
#line 733
extern __m256d __cdecl _mm256_permutevar_pd(__m256d, __m256i); 
#line 734
extern __m128d __cdecl _mm_permutevar_pd(__m128d, __m128i); 
#line 744
extern __m256d __cdecl _mm256_permute_pd(__m256d, int); 
#line 745
extern __m128d __cdecl _mm_permute_pd(__m128d, int); 
#line 754
extern __m256 __cdecl _mm256_permute2f128_ps(__m256, __m256, int); 
#line 755
extern __m256d __cdecl _mm256_permute2f128_pd(__m256d, __m256d, int); 
#line 756
extern __m256i __cdecl _mm256_permute2f128_si256(__m256i, __m256i, int); 
#line 765
extern __m256 __cdecl _mm256_broadcast_ss(const float *); 
#line 766
extern __m128 __cdecl _mm_broadcast_ss(const float *); 
#line 774
extern __m256d __cdecl _mm256_broadcast_sd(const double *); 
#line 782
extern __m256 __cdecl _mm256_broadcast_ps(const __m128 *); 
#line 783
extern __m256d __cdecl _mm256_broadcast_pd(const __m128d *); 
#line 793
extern __m256 __cdecl _mm256_insertf128_ps(__m256, __m128, int); 
#line 794
extern __m256d __cdecl _mm256_insertf128_pd(__m256d, __m128d, int); 
#line 795
extern __m256i __cdecl _mm256_insertf128_si256(__m256i, __m128i, int); 
#line 804
extern __m256d __cdecl _mm256_load_pd(const double *); 
#line 805
extern void __cdecl _mm256_store_pd(double *, __m256d); 
#line 814
extern __m256 __cdecl _mm256_load_ps(const float *); 
#line 815
extern void __cdecl _mm256_store_ps(float *, __m256); 
#line 824
extern __m256d __cdecl _mm256_loadu_pd(const double *); 
#line 825
extern void __cdecl _mm256_storeu_pd(double *, __m256d); 
#line 834
extern __m256 __cdecl _mm256_loadu_ps(const float *); 
#line 835
extern void __cdecl _mm256_storeu_ps(float *, __m256); 
#line 844
extern __m256i __cdecl _mm256_load_si256(const __m256i *); 
#line 845
extern void __cdecl _mm256_store_si256(__m256i *, __m256i); 
#line 854
extern __m256i __cdecl _mm256_loadu_si256(const __m256i *); 
#line 855
extern void __cdecl _mm256_storeu_si256(__m256i *, __m256i); 
#line 927
extern __m256d __cdecl _mm256_maskload_pd(const double *, __m256i); 
#line 928
extern void __cdecl _mm256_maskstore_pd(double *, __m256i, __m256d); 
#line 929
extern __m128d __cdecl _mm_maskload_pd(const double *, __m128i); 
#line 930
extern void __cdecl _mm_maskstore_pd(double *, __m128i, __m128d); 
#line 950
extern __m256 __cdecl _mm256_maskload_ps(const float *, __m256i); 
#line 951
extern void __cdecl _mm256_maskstore_ps(float *, __m256i, __m256); 
#line 952
extern __m128 __cdecl _mm_maskload_ps(const float *, __m128i); 
#line 953
extern void __cdecl _mm_maskstore_ps(float *, __m128i, __m128); 
#line 961
extern __m256 __cdecl _mm256_movehdup_ps(__m256); 
#line 969
extern __m256 __cdecl _mm256_moveldup_ps(__m256); 
#line 977
extern __m256d __cdecl _mm256_movedup_pd(__m256d); 
#line 987
extern __m256i __cdecl _mm256_lddqu_si256(const __m256i *); 
#line 995
extern void __cdecl _mm256_stream_si256(__m256i *, __m256i); 
#line 1004
extern void __cdecl _mm256_stream_pd(double *, __m256d); 
#line 1013
extern void __cdecl _mm256_stream_ps(float *, __m256); 
#line 1023
extern __m256 __cdecl _mm256_rcp_ps(__m256); 
#line 1034
extern __m256 __cdecl _mm256_rsqrt_ps(__m256); 
#line 1043
extern __m256d __cdecl _mm256_sqrt_pd(__m256d); 
#line 1052
extern __m256 __cdecl _mm256_sqrt_ps(__m256); 
#line 1065
extern __m256d __cdecl _mm256_round_pd(__m256d, int); 
#line 1080
extern __m256 __cdecl _mm256_round_ps(__m256, int); 
#line 1090
extern __m256d __cdecl _mm256_unpackhi_pd(__m256d, __m256d); 
#line 1098
extern __m256 __cdecl _mm256_unpackhi_ps(__m256, __m256); 
#line 1106
extern __m256d __cdecl _mm256_unpacklo_pd(__m256d, __m256d); 
#line 1114
extern __m256 __cdecl _mm256_unpacklo_ps(__m256, __m256); 
#line 1124
extern int __cdecl _mm256_testz_si256(__m256i, __m256i); 
#line 1128
extern int __cdecl _mm256_testc_si256(__m256i, __m256i); 
#line 1132
extern int __cdecl _mm256_testnzc_si256(__m256i, __m256i); 
#line 1147
extern int __cdecl _mm256_testz_pd(__m256d, __m256d); 
#line 1148
extern int __cdecl _mm256_testc_pd(__m256d, __m256d); 
#line 1149
extern int __cdecl _mm256_testnzc_pd(__m256d, __m256d); 
#line 1150
extern int __cdecl _mm_testz_pd(__m128d, __m128d); 
#line 1151
extern int __cdecl _mm_testc_pd(__m128d, __m128d); 
#line 1152
extern int __cdecl _mm_testnzc_pd(__m128d, __m128d); 
#line 1165
extern int __cdecl _mm256_testz_ps(__m256, __m256); 
#line 1166
extern int __cdecl _mm256_testc_ps(__m256, __m256); 
#line 1167
extern int __cdecl _mm256_testnzc_ps(__m256, __m256); 
#line 1168
extern int __cdecl _mm_testz_ps(__m128, __m128); 
#line 1169
extern int __cdecl _mm_testc_ps(__m128, __m128); 
#line 1170
extern int __cdecl _mm_testnzc_ps(__m128, __m128); 
#line 1179
extern int __cdecl _mm256_movemask_pd(__m256d); 
#line 1188
extern int __cdecl _mm256_movemask_ps(__m256); 
#line 1193
extern __m256d __cdecl _mm256_setzero_pd(); 
#line 1194
extern __m256 __cdecl _mm256_setzero_ps(); 
#line 1195
extern __m256i __cdecl _mm256_setzero_si256(); 
#line 1200
extern __m256d __cdecl _mm256_set_pd(double, double, double, double); 
#line 1201
extern __m256 __cdecl _mm256_set_ps(float, float, float, float, float, float, float, float); 
#line 1203
extern __m256i __cdecl _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char); 
#line 1211
extern __m256i __cdecl _mm256_set_epi16(short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short); 
#line 1215
extern __m256i __cdecl _mm256_set_epi32(int, int, int, int, int, int, int, int); 
#line 1217
extern __m256i __cdecl _mm256_set_epi64x(__int64, __int64, __int64, __int64); 
#line 1229
extern __m256d __cdecl _mm256_setr_pd(double, double, double, double); 
#line 1230
extern __m256 __cdecl _mm256_setr_ps(float, float, float, float, float, float, float, float); 
#line 1232
extern __m256i __cdecl _mm256_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char); 
#line 1240
extern __m256i __cdecl _mm256_setr_epi16(short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short); 
#line 1244
extern __m256i __cdecl _mm256_setr_epi32(int, int, int, int, int, int, int, int); 
#line 1246
extern __m256i __cdecl _mm256_setr_epi64x(__int64, __int64, __int64, __int64); 
#line 1255
extern __m256d __cdecl _mm256_set1_pd(double); 
#line 1256
extern __m256 __cdecl _mm256_set1_ps(float); 
#line 1257
extern __m256i __cdecl _mm256_set1_epi8(char); 
#line 1258
extern __m256i __cdecl _mm256_set1_epi16(short); 
#line 1259
extern __m256i __cdecl _mm256_set1_epi32(int); 
#line 1260
extern __m256i __cdecl _mm256_set1_epi64x(__int64); 
#line 1268
extern __m256 __cdecl _mm256_castpd_ps(__m256d); 
#line 1269
extern __m256d __cdecl _mm256_castps_pd(__m256); 
#line 1270
extern __m256i __cdecl _mm256_castps_si256(__m256); 
#line 1271
extern __m256i __cdecl _mm256_castpd_si256(__m256d); 
#line 1272
extern __m256 __cdecl _mm256_castsi256_ps(__m256i); 
#line 1273
extern __m256d __cdecl _mm256_castsi256_pd(__m256i); 
#line 1274
extern __m128 __cdecl _mm256_castps256_ps128(__m256); 
#line 1275
extern __m128d __cdecl _mm256_castpd256_pd128(__m256d); 
#line 1276
extern __m128i __cdecl _mm256_castsi256_si128(__m256i); 
#line 1277
extern __m256 __cdecl _mm256_castps128_ps256(__m128); 
#line 1278
extern __m256d __cdecl _mm256_castpd128_pd256(__m128d); 
#line 1279
extern __m256i __cdecl _mm256_castsi128_si256(__m128i); 
#line 1286
extern __m128 __cdecl _mm_cvtph_ps(__m128i); 
#line 1287
extern __m256 __cdecl _mm256_cvtph_ps(__m128i); 
#line 1288
extern __m128i __cdecl _mm_cvtps_ph(__m128, const int); 
#line 1289
extern __m128i __cdecl _mm256_cvtps_ph(__m256, int); 
#line 1310
extern unsigned __int64 __cdecl _xgetbv(unsigned); 
#line 1313
extern void __cdecl _xsetbv(unsigned, unsigned __int64); 
#line 1320
extern void __cdecl _xsave(void *, unsigned __int64); 
#line 1322
extern void __cdecl _xsave64(void *, unsigned __int64); 
#line 1330 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern void __cdecl _xsaveopt(void *, unsigned __int64); 
#line 1332
extern void __cdecl _xsaveopt64(void *, unsigned __int64); 
#line 1339 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern void __cdecl _xsavec(void *, unsigned __int64); 
#line 1341
extern void __cdecl _xsavec64(void *, unsigned __int64); 
#line 1349 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern void __cdecl _xrstor(const void *, unsigned __int64); 
#line 1351
extern void __cdecl _xrstor64(const void *, unsigned __int64); 
#line 1359 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern void __cdecl _xsaves(void *, unsigned __int64); 
#line 1361
extern void __cdecl _xsaves64(void *, unsigned __int64); 
#line 1369 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern void __cdecl _xrstors(const void *, unsigned __int64); 
#line 1371
extern void __cdecl _xrstors64(const void *, unsigned __int64); 
#line 1378 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern void __cdecl _fxsave(void *); 
#line 1380
extern void __cdecl _fxsave64(void *); 
#line 1387 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern void __cdecl _fxrstor(const void *); 
#line 1389
extern void __cdecl _fxrstor64(const void *); 
#line 1398 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern int __cdecl _rdrand16_step(unsigned short *); 
#line 1399
extern int __cdecl _rdrand32_step(unsigned *); 
#line 1401
extern int __cdecl _rdrand64_step(unsigned __int64 *); 
#line 1408 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern unsigned __cdecl _readfsbase_u32(); 
#line 1409
extern unsigned __cdecl _readgsbase_u32(); 
#line 1410
extern unsigned __int64 __cdecl _readfsbase_u64(); 
#line 1411
extern unsigned __int64 __cdecl _readgsbase_u64(); 
#line 1416
extern void __cdecl _writefsbase_u32(unsigned); 
#line 1417
extern void __cdecl _writegsbase_u32(unsigned); 
#line 1418
extern void __cdecl _writefsbase_u64(unsigned __int64); 
#line 1419
extern void __cdecl _writegsbase_u64(unsigned __int64); 
#line 1425 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern __m128 __cdecl _mm_fmadd_ps(__m128, __m128, __m128); 
#line 1426
extern __m128d __cdecl _mm_fmadd_pd(__m128d, __m128d, __m128d); 
#line 1427
extern __m128 __cdecl _mm_fmadd_ss(__m128, __m128, __m128); 
#line 1428
extern __m128d __cdecl _mm_fmadd_sd(__m128d, __m128d, __m128d); 
#line 1429
extern __m128 __cdecl _mm_fmsub_ps(__m128, __m128, __m128); 
#line 1430
extern __m128d __cdecl _mm_fmsub_pd(__m128d, __m128d, __m128d); 
#line 1431
extern __m128 __cdecl _mm_fmsub_ss(__m128, __m128, __m128); 
#line 1432
extern __m128d __cdecl _mm_fmsub_sd(__m128d, __m128d, __m128d); 
#line 1433
extern __m128 __cdecl _mm_fnmadd_ps(__m128, __m128, __m128); 
#line 1434
extern __m128d __cdecl _mm_fnmadd_pd(__m128d, __m128d, __m128d); 
#line 1435
extern __m128 __cdecl _mm_fnmadd_ss(__m128, __m128, __m128); 
#line 1436
extern __m128d __cdecl _mm_fnmadd_sd(__m128d, __m128d, __m128d); 
#line 1437
extern __m128 __cdecl _mm_fnmsub_ps(__m128, __m128, __m128); 
#line 1438
extern __m128d __cdecl _mm_fnmsub_pd(__m128d, __m128d, __m128d); 
#line 1439
extern __m128 __cdecl _mm_fnmsub_ss(__m128, __m128, __m128); 
#line 1440
extern __m128d __cdecl _mm_fnmsub_sd(__m128d, __m128d, __m128d); 
#line 1442
extern __m256 __cdecl _mm256_fmadd_ps(__m256, __m256, __m256); 
#line 1443
extern __m256d __cdecl _mm256_fmadd_pd(__m256d, __m256d, __m256d); 
#line 1444
extern __m256 __cdecl _mm256_fmsub_ps(__m256, __m256, __m256); 
#line 1445
extern __m256d __cdecl _mm256_fmsub_pd(__m256d, __m256d, __m256d); 
#line 1446
extern __m256 __cdecl _mm256_fnmadd_ps(__m256, __m256, __m256); 
#line 1447
extern __m256d __cdecl _mm256_fnmadd_pd(__m256d, __m256d, __m256d); 
#line 1448
extern __m256 __cdecl _mm256_fnmsub_ps(__m256, __m256, __m256); 
#line 1449
extern __m256d __cdecl _mm256_fnmsub_pd(__m256d, __m256d, __m256d); 
#line 1455
extern __m128 __cdecl _mm_fmaddsub_ps(__m128, __m128, __m128); 
#line 1456
extern __m128d __cdecl _mm_fmaddsub_pd(__m128d, __m128d, __m128d); 
#line 1457
extern __m128 __cdecl _mm_fmsubadd_ps(__m128, __m128, __m128); 
#line 1458
extern __m128d __cdecl _mm_fmsubadd_pd(__m128d, __m128d, __m128d); 
#line 1460
extern __m256 __cdecl _mm256_fmaddsub_ps(__m256, __m256, __m256); 
#line 1461
extern __m256d __cdecl _mm256_fmaddsub_pd(__m256d, __m256d, __m256d); 
#line 1462
extern __m256 __cdecl _mm256_fmsubadd_ps(__m256, __m256, __m256); 
#line 1463
extern __m256d __cdecl _mm256_fmsubadd_pd(__m256d, __m256d, __m256d); 
#line 1468
extern float __cdecl __fmadd_ss(float, float, float); 
#line 1469
extern double __cdecl __fmadd_sd(double, double, double); 
#line 1470
extern float __cdecl __fmsub_ss(float, float, float); 
#line 1471
extern double __cdecl __fmsub_sd(double, double, double); 
#line 1472
extern float __cdecl __fnmadd_ss(float, float, float); 
#line 1473
extern double __cdecl __fnmadd_sd(double, double, double); 
#line 1474
extern float __cdecl __fnmsub_ss(float, float, float); 
#line 1475
extern double __cdecl __fnmsub_sd(double, double, double); 
#line 1480
extern __m256i __cdecl _mm256_cmpeq_epi8(__m256i, __m256i); 
#line 1481
extern __m256i __cdecl _mm256_cmpeq_epi16(__m256i, __m256i); 
#line 1482
extern __m256i __cdecl _mm256_cmpeq_epi32(__m256i, __m256i); 
#line 1483
extern __m256i __cdecl _mm256_cmpeq_epi64(__m256i, __m256i); 
#line 1485
extern __m256i __cdecl _mm256_cmpgt_epi8(__m256i, __m256i); 
#line 1486
extern __m256i __cdecl _mm256_cmpgt_epi16(__m256i, __m256i); 
#line 1487
extern __m256i __cdecl _mm256_cmpgt_epi32(__m256i, __m256i); 
#line 1488
extern __m256i __cdecl _mm256_cmpgt_epi64(__m256i, __m256i); 
#line 1494
extern __m256i __cdecl _mm256_max_epi8(__m256i, __m256i); 
#line 1495
extern __m256i __cdecl _mm256_max_epi16(__m256i, __m256i); 
#line 1496
extern __m256i __cdecl _mm256_max_epi32(__m256i, __m256i); 
#line 1497
extern __m256i __cdecl _mm256_max_epu8(__m256i, __m256i); 
#line 1498
extern __m256i __cdecl _mm256_max_epu16(__m256i, __m256i); 
#line 1499
extern __m256i __cdecl _mm256_max_epu32(__m256i, __m256i); 
#line 1501
extern __m256i __cdecl _mm256_min_epi8(__m256i, __m256i); 
#line 1502
extern __m256i __cdecl _mm256_min_epi16(__m256i, __m256i); 
#line 1503
extern __m256i __cdecl _mm256_min_epi32(__m256i, __m256i); 
#line 1504
extern __m256i __cdecl _mm256_min_epu8(__m256i, __m256i); 
#line 1505
extern __m256i __cdecl _mm256_min_epu16(__m256i, __m256i); 
#line 1506
extern __m256i __cdecl _mm256_min_epu32(__m256i, __m256i); 
#line 1512
extern __m256i __cdecl _mm256_and_si256(__m256i, __m256i); 
#line 1513
extern __m256i __cdecl _mm256_andnot_si256(__m256i, __m256i); 
#line 1514
extern __m256i __cdecl _mm256_or_si256(__m256i, __m256i); 
#line 1515
extern __m256i __cdecl _mm256_xor_si256(__m256i, __m256i); 
#line 1521
extern __m256i __cdecl _mm256_abs_epi8(__m256i); 
#line 1522
extern __m256i __cdecl _mm256_abs_epi16(__m256i); 
#line 1523
extern __m256i __cdecl _mm256_abs_epi32(__m256i); 
#line 1525
extern __m256i __cdecl _mm256_add_epi8(__m256i, __m256i); 
#line 1526
extern __m256i __cdecl _mm256_add_epi16(__m256i, __m256i); 
#line 1527
extern __m256i __cdecl _mm256_add_epi32(__m256i, __m256i); 
#line 1528
extern __m256i __cdecl _mm256_add_epi64(__m256i, __m256i); 
#line 1530
extern __m256i __cdecl _mm256_adds_epi8(__m256i, __m256i); 
#line 1531
extern __m256i __cdecl _mm256_adds_epi16(__m256i, __m256i); 
#line 1532
extern __m256i __cdecl _mm256_adds_epu8(__m256i, __m256i); 
#line 1533
extern __m256i __cdecl _mm256_adds_epu16(__m256i, __m256i); 
#line 1535
extern __m256i __cdecl _mm256_sub_epi8(__m256i, __m256i); 
#line 1536
extern __m256i __cdecl _mm256_sub_epi16(__m256i, __m256i); 
#line 1537
extern __m256i __cdecl _mm256_sub_epi32(__m256i, __m256i); 
#line 1538
extern __m256i __cdecl _mm256_sub_epi64(__m256i, __m256i); 
#line 1540
extern __m256i __cdecl _mm256_subs_epi8(__m256i, __m256i); 
#line 1541
extern __m256i __cdecl _mm256_subs_epi16(__m256i, __m256i); 
#line 1542
extern __m256i __cdecl _mm256_subs_epu8(__m256i, __m256i); 
#line 1543
extern __m256i __cdecl _mm256_subs_epu16(__m256i, __m256i); 
#line 1545
extern __m256i __cdecl _mm256_avg_epu8(__m256i, __m256i); 
#line 1546
extern __m256i __cdecl _mm256_avg_epu16(__m256i, __m256i); 
#line 1548
extern __m256i __cdecl _mm256_hadd_epi16(__m256i, __m256i); 
#line 1549
extern __m256i __cdecl _mm256_hadd_epi32(__m256i, __m256i); 
#line 1550
extern __m256i __cdecl _mm256_hadds_epi16(__m256i, __m256i); 
#line 1552
extern __m256i __cdecl _mm256_hsub_epi16(__m256i, __m256i); 
#line 1553
extern __m256i __cdecl _mm256_hsub_epi32(__m256i, __m256i); 
#line 1554
extern __m256i __cdecl _mm256_hsubs_epi16(__m256i, __m256i); 
#line 1556
extern __m256i __cdecl _mm256_madd_epi16(__m256i, __m256i); 
#line 1557
extern __m256i __cdecl _mm256_maddubs_epi16(__m256i, __m256i); 
#line 1559
extern __m256i __cdecl _mm256_mulhi_epi16(__m256i, __m256i); 
#line 1560
extern __m256i __cdecl _mm256_mulhi_epu16(__m256i, __m256i); 
#line 1562
extern __m256i __cdecl _mm256_mullo_epi16(__m256i, __m256i); 
#line 1563
extern __m256i __cdecl _mm256_mullo_epi32(__m256i, __m256i); 
#line 1565
extern __m256i __cdecl _mm256_mul_epu32(__m256i, __m256i); 
#line 1566
extern __m256i __cdecl _mm256_mul_epi32(__m256i, __m256i); 
#line 1568
extern __m256i __cdecl _mm256_sign_epi8(__m256i, __m256i); 
#line 1569
extern __m256i __cdecl _mm256_sign_epi16(__m256i, __m256i); 
#line 1570
extern __m256i __cdecl _mm256_sign_epi32(__m256i, __m256i); 
#line 1572
extern __m256i __cdecl _mm256_mulhrs_epi16(__m256i, __m256i); 
#line 1574
extern __m256i __cdecl _mm256_sad_epu8(__m256i, __m256i); 
#line 1575
extern __m256i __cdecl _mm256_mpsadbw_epu8(__m256i, __m256i, const int); 
#line 1581
extern __m256i __cdecl _mm256_slli_si256(__m256i, const int); 
#line 1583
extern __m256i __cdecl _mm256_srli_si256(__m256i, const int); 
#line 1586
extern __m256i __cdecl _mm256_sll_epi16(__m256i, __m128i); 
#line 1587
extern __m256i __cdecl _mm256_sll_epi32(__m256i, __m128i); 
#line 1588
extern __m256i __cdecl _mm256_sll_epi64(__m256i, __m128i); 
#line 1590
extern __m256i __cdecl _mm256_slli_epi16(__m256i, int); 
#line 1591
extern __m256i __cdecl _mm256_slli_epi32(__m256i, int); 
#line 1592
extern __m256i __cdecl _mm256_slli_epi64(__m256i, int); 
#line 1594
extern __m256i __cdecl _mm256_sllv_epi32(__m256i, __m256i); 
#line 1595
extern __m256i __cdecl _mm256_sllv_epi64(__m256i, __m256i); 
#line 1597
extern __m128i __cdecl _mm_sllv_epi32(__m128i, __m128i); 
#line 1598
extern __m128i __cdecl _mm_sllv_epi64(__m128i, __m128i); 
#line 1600
extern __m256i __cdecl _mm256_sra_epi16(__m256i, __m128i); 
#line 1601
extern __m256i __cdecl _mm256_sra_epi32(__m256i, __m128i); 
#line 1603
extern __m256i __cdecl _mm256_srai_epi16(__m256i, int); 
#line 1604
extern __m256i __cdecl _mm256_srai_epi32(__m256i, int); 
#line 1606
extern __m256i __cdecl _mm256_srav_epi32(__m256i, __m256i); 
#line 1608
extern __m128i __cdecl _mm_srav_epi32(__m128i, __m128i); 
#line 1610
extern __m256i __cdecl _mm256_srl_epi16(__m256i, __m128i); 
#line 1611
extern __m256i __cdecl _mm256_srl_epi32(__m256i, __m128i); 
#line 1612
extern __m256i __cdecl _mm256_srl_epi64(__m256i, __m128i); 
#line 1614
extern __m256i __cdecl _mm256_srli_epi16(__m256i, int); 
#line 1615
extern __m256i __cdecl _mm256_srli_epi32(__m256i, int); 
#line 1616
extern __m256i __cdecl _mm256_srli_epi64(__m256i, int); 
#line 1618
extern __m256i __cdecl _mm256_srlv_epi32(__m256i, __m256i); 
#line 1619
extern __m256i __cdecl _mm256_srlv_epi64(__m256i, __m256i); 
#line 1621
extern __m128i __cdecl _mm_srlv_epi32(__m128i, __m128i); 
#line 1622
extern __m128i __cdecl _mm_srlv_epi64(__m128i, __m128i); 
#line 1628
extern __m128i __cdecl _mm_blend_epi32(__m128i, __m128i, const int); 
#line 1630
extern __m256i __cdecl _mm256_blend_epi32(__m256i, __m256i, const int); 
#line 1632
extern __m256i __cdecl _mm256_alignr_epi8(__m256i, __m256i, const int); 
#line 1634
extern __m256i __cdecl _mm256_blendv_epi8(__m256i, __m256i, __m256i); 
#line 1635
extern __m256i __cdecl _mm256_blend_epi16(__m256i, __m256i, const int); 
#line 1637
extern __m256i __cdecl _mm256_packs_epi16(__m256i, __m256i); 
#line 1638
extern __m256i __cdecl _mm256_packs_epi32(__m256i, __m256i); 
#line 1639
extern __m256i __cdecl _mm256_packus_epi16(__m256i, __m256i); 
#line 1640
extern __m256i __cdecl _mm256_packus_epi32(__m256i, __m256i); 
#line 1642
extern __m256i __cdecl _mm256_unpackhi_epi8(__m256i, __m256i); 
#line 1643
extern __m256i __cdecl _mm256_unpackhi_epi16(__m256i, __m256i); 
#line 1644
extern __m256i __cdecl _mm256_unpackhi_epi32(__m256i, __m256i); 
#line 1645
extern __m256i __cdecl _mm256_unpackhi_epi64(__m256i, __m256i); 
#line 1647
extern __m256i __cdecl _mm256_unpacklo_epi8(__m256i, __m256i); 
#line 1648
extern __m256i __cdecl _mm256_unpacklo_epi16(__m256i, __m256i); 
#line 1649
extern __m256i __cdecl _mm256_unpacklo_epi32(__m256i, __m256i); 
#line 1650
extern __m256i __cdecl _mm256_unpacklo_epi64(__m256i, __m256i); 
#line 1652
extern __m256i __cdecl _mm256_shuffle_epi8(__m256i, __m256i); 
#line 1653
extern __m256i __cdecl _mm256_shuffle_epi32(__m256i, const int); 
#line 1655
extern __m256i __cdecl _mm256_shufflehi_epi16(__m256i, const int); 
#line 1656
extern __m256i __cdecl _mm256_shufflelo_epi16(__m256i, const int); 
#line 1658
extern __m128i __cdecl _mm256_extracti128_si256(__m256i, const int); 
#line 1659
extern __m256i __cdecl _mm256_inserti128_si256(__m256i, __m128i, const int); 
#line 1665
extern __m128 __cdecl _mm_broadcastss_ps(__m128); 
#line 1666
extern __m128d __cdecl _mm_broadcastsd_pd(__m128d); 
#line 1668
extern __m128i __cdecl _mm_broadcastb_epi8(__m128i); 
#line 1669
extern __m128i __cdecl _mm_broadcastw_epi16(__m128i); 
#line 1670
extern __m128i __cdecl _mm_broadcastd_epi32(__m128i); 
#line 1671
extern __m128i __cdecl _mm_broadcastq_epi64(__m128i); 
#line 1673
extern __m256 __cdecl _mm256_broadcastss_ps(__m128); 
#line 1674
extern __m256d __cdecl _mm256_broadcastsd_pd(__m128d); 
#line 1676
extern __m256i __cdecl _mm256_broadcastb_epi8(__m128i); 
#line 1677
extern __m256i __cdecl _mm256_broadcastw_epi16(__m128i); 
#line 1678
extern __m256i __cdecl _mm256_broadcastd_epi32(__m128i); 
#line 1679
extern __m256i __cdecl _mm256_broadcastq_epi64(__m128i); 
#line 1681
extern __m256i __cdecl _mm256_broadcastsi128_si256(__m128i); 
#line 1688
extern __m256i __cdecl _mm256_cvtepi8_epi16(__m128i); 
#line 1689
extern __m256i __cdecl _mm256_cvtepi8_epi32(__m128i); 
#line 1690
extern __m256i __cdecl _mm256_cvtepi8_epi64(__m128i); 
#line 1691
extern __m256i __cdecl _mm256_cvtepi16_epi32(__m128i); 
#line 1692
extern __m256i __cdecl _mm256_cvtepi16_epi64(__m128i); 
#line 1693
extern __m256i __cdecl _mm256_cvtepi32_epi64(__m128i); 
#line 1695
extern __m256i __cdecl _mm256_cvtepu8_epi16(__m128i); 
#line 1696
extern __m256i __cdecl _mm256_cvtepu8_epi32(__m128i); 
#line 1697
extern __m256i __cdecl _mm256_cvtepu8_epi64(__m128i); 
#line 1698
extern __m256i __cdecl _mm256_cvtepu16_epi32(__m128i); 
#line 1699
extern __m256i __cdecl _mm256_cvtepu16_epi64(__m128i); 
#line 1700
extern __m256i __cdecl _mm256_cvtepu32_epi64(__m128i); 
#line 1707
extern int __cdecl _mm256_movemask_epi8(__m256i); 
#line 1713
extern __m128i __cdecl _mm_maskload_epi32(const int *, __m128i); 
#line 1715
extern __m128i __cdecl _mm_maskload_epi64(const __int64 *, __m128i); 
#line 1718
extern void __cdecl _mm_maskstore_epi32(int *, __m128i, __m128i); 
#line 1721
extern void __cdecl _mm_maskstore_epi64(__int64 *, __m128i, __m128i); 
#line 1725
extern __m256i __cdecl _mm256_maskload_epi32(const int *, __m256i); 
#line 1727
extern __m256i __cdecl _mm256_maskload_epi64(const __int64 *, __m256i); 
#line 1730
extern void __cdecl _mm256_maskstore_epi32(int *, __m256i, __m256i); 
#line 1733
extern void __cdecl _mm256_maskstore_epi64(__int64 *, __m256i, __m256i); 
#line 1741
extern __m256i __cdecl _mm256_permutevar8x32_epi32(__m256i, __m256i); 
#line 1742
extern __m256 __cdecl _mm256_permutevar8x32_ps(__m256, __m256i); 
#line 1744
extern __m256i __cdecl _mm256_permute4x64_epi64(__m256i, const int); 
#line 1745
extern __m256d __cdecl _mm256_permute4x64_pd(__m256d, const int); 
#line 1747
extern __m256i __cdecl _mm256_permute2x128_si256(__m256i, __m256i, const int); 
#line 1753
extern __m256i __cdecl _mm256_stream_load_si256(const __m256i *); 
#line 1760
extern __m256d __cdecl _mm256_mask_i32gather_pd(__m256d, const double *, __m128i, __m256d, const int); 
#line 1765
extern __m256 __cdecl _mm256_mask_i32gather_ps(__m256, const float *, __m256i, __m256, const int); 
#line 1770
extern __m256d __cdecl _mm256_mask_i64gather_pd(__m256d, const double *, __m256i, __m256d, const int); 
#line 1775
extern __m128 __cdecl _mm256_mask_i64gather_ps(__m128, const float *, __m256i, __m128, const int); 
#line 1781
extern __m128d __cdecl _mm_mask_i32gather_pd(__m128d, const double *, __m128i, __m128d, const int); 
#line 1786
extern __m128 __cdecl _mm_mask_i32gather_ps(__m128, const float *, __m128i, __m128, const int); 
#line 1791
extern __m128d __cdecl _mm_mask_i64gather_pd(__m128d, const double *, __m128i, __m128d, const int); 
#line 1796
extern __m128 __cdecl _mm_mask_i64gather_ps(__m128, const float *, __m128i, __m128, const int); 
#line 1803
extern __m256i __cdecl _mm256_mask_i32gather_epi32(__m256i, const int *, __m256i, __m256i, const int); 
#line 1808
extern __m256i __cdecl _mm256_mask_i32gather_epi64(__m256i, const __int64 *, __m128i, __m256i, const int); 
#line 1813
extern __m128i __cdecl _mm256_mask_i64gather_epi32(__m128i, const int *, __m256i, __m128i, const int); 
#line 1818
extern __m256i __cdecl _mm256_mask_i64gather_epi64(__m256i, const __int64 *, __m256i, __m256i, const int); 
#line 1824
extern __m128i __cdecl _mm_mask_i32gather_epi32(__m128i, const int *, __m128i, __m128i, const int); 
#line 1829
extern __m128i __cdecl _mm_mask_i32gather_epi64(__m128i, const __int64 *, __m128i, __m128i, const int); 
#line 1834
extern __m128i __cdecl _mm_mask_i64gather_epi32(__m128i, const int *, __m128i, __m128i, const int); 
#line 1839
extern __m128i __cdecl _mm_mask_i64gather_epi64(__m128i, const __int64 *, __m128i, __m128i, const int); 
#line 1849
extern __m256d __cdecl _mm256_i32gather_pd(const double *, __m128i, const int); 
#line 1852
extern __m256 __cdecl _mm256_i32gather_ps(const float *, __m256i, const int); 
#line 1855
extern __m256d __cdecl _mm256_i64gather_pd(const double *, __m256i, const int); 
#line 1858
extern __m128 __cdecl _mm256_i64gather_ps(const float *, __m256i, const int); 
#line 1862
extern __m128d __cdecl _mm_i32gather_pd(const double *, __m128i, const int); 
#line 1865
extern __m128 __cdecl _mm_i32gather_ps(const float *, __m128i, const int); 
#line 1868
extern __m128d __cdecl _mm_i64gather_pd(const double *, __m128i, const int); 
#line 1871
extern __m128 __cdecl _mm_i64gather_ps(const float *, __m128i, const int); 
#line 1875
extern __m256i __cdecl _mm256_i32gather_epi32(const int *, __m256i, const int); 
#line 1878
extern __m256i __cdecl _mm256_i32gather_epi64(const __int64 *, __m128i, const int); 
#line 1881
extern __m128i __cdecl _mm256_i64gather_epi32(const int *, __m256i, const int); 
#line 1884
extern __m256i __cdecl _mm256_i64gather_epi64(const __int64 *, __m256i, const int); 
#line 1888
extern __m128i __cdecl _mm_i32gather_epi32(const int *, __m128i, const int); 
#line 1891
extern __m128i __cdecl _mm_i32gather_epi64(const __int64 *, __m128i, const int); 
#line 1894
extern __m128i __cdecl _mm_i64gather_epi32(const int *, __m128i, const int); 
#line 1897
extern __m128i __cdecl _mm_i64gather_epi64(const __int64 *, __m128i, const int); 
#line 1916
extern unsigned _bextr_u32(unsigned, unsigned, unsigned); 
#line 1919
extern unsigned _bextr2_u32(unsigned, unsigned); 
#line 1921
extern unsigned _blsi_u32(unsigned); 
#line 1922
extern unsigned _blsmsk_u32(unsigned); 
#line 1923
extern unsigned _blsr_u32(unsigned); 
#line 1924
extern unsigned _bzhi_u32(unsigned, unsigned); 
#line 1926
extern unsigned _mulx_u32(unsigned, unsigned, unsigned *); 
#line 1929
extern unsigned _pdep_u32(unsigned, unsigned); 
#line 1931
extern unsigned _pext_u32(unsigned, unsigned); 
#line 1933
extern unsigned _rorx_u32(unsigned, const unsigned); 
#line 1935
extern int _sarx_i32(int, unsigned); 
#line 1937
extern unsigned _shlx_u32(unsigned, unsigned); 
#line 1939
extern unsigned _shrx_u32(unsigned, unsigned); 
#line 1943
extern unsigned __int64 _bextr_u64(unsigned __int64, unsigned, unsigned); 
#line 1946
extern unsigned __int64 _bextr2_u64(unsigned __int64, unsigned __int64); 
#line 1948
extern unsigned __int64 _blsi_u64(unsigned __int64); 
#line 1949
extern unsigned __int64 _blsmsk_u64(unsigned __int64); 
#line 1950
extern unsigned __int64 _blsr_u64(unsigned __int64); 
#line 1951
extern unsigned __int64 _bzhi_u64(unsigned __int64, unsigned); 
#line 1953
extern unsigned __int64 _mulx_u64(unsigned __int64, unsigned __int64, unsigned __int64 *); 
#line 1956
extern unsigned __int64 _pdep_u64(unsigned __int64, unsigned __int64); 
#line 1958
extern unsigned __int64 _pext_u64(unsigned __int64, unsigned __int64); 
#line 1960
extern unsigned __int64 _rorx_u64(unsigned __int64, const unsigned); 
#line 1962
extern __int64 _sarx_i64(__int64, unsigned); 
#line 1964
extern unsigned __int64 _shlx_u64(unsigned __int64, unsigned); 
#line 1966
extern unsigned __int64 _shrx_u64(unsigned __int64, unsigned); 
#line 1977 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern unsigned _lzcnt_u32(unsigned); 
#line 1979
extern unsigned __int64 _lzcnt_u64(unsigned __int64); 
#line 1989 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern unsigned short _tzcnt_u16(unsigned short); 
#line 1990
extern unsigned _tzcnt_u32(unsigned); 
#line 1992
extern unsigned __int64 _tzcnt_u64(unsigned __int64); 
#line 2000 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern void __cdecl _invpcid(unsigned, void *); 
#line 2003
extern void _Store_HLERelease(volatile long *, long); 
#line 2004
extern void _StorePointer_HLERelease(void *volatile *, void *); 
#line 2006
extern long _InterlockedExchange_HLEAcquire(volatile long *, long); 
#line 2007
extern long _InterlockedExchange_HLERelease(volatile long *, long); 
#line 2008
extern void *_InterlockedExchangePointer_HLEAcquire(void *volatile *, void *); 
#line 2009
extern void *_InterlockedExchangePointer_HLERelease(void *volatile *, void *); 
#line 2011
extern long _InterlockedCompareExchange_HLEAcquire(volatile long *, long, long); 
#line 2012
extern long _InterlockedCompareExchange_HLERelease(volatile long *, long, long); 
#line 2013
extern __int64 _InterlockedCompareExchange64_HLEAcquire(volatile __int64 *, __int64, __int64); 
#line 2014
extern __int64 _InterlockedCompareExchange64_HLERelease(volatile __int64 *, __int64, __int64); 
#line 2015
extern void *_InterlockedCompareExchangePointer_HLEAcquire(void *volatile *, void *, void *); 
#line 2016
extern void *_InterlockedCompareExchangePointer_HLERelease(void *volatile *, void *, void *); 
#line 2018
extern long _InterlockedExchangeAdd_HLEAcquire(volatile long *, long); 
#line 2019
extern long _InterlockedExchangeAdd_HLERelease(volatile long *, long); 
#line 2021
extern long _InterlockedAnd_HLEAcquire(volatile long *, long); 
#line 2022
extern long _InterlockedAnd_HLERelease(volatile long *, long); 
#line 2023
extern long _InterlockedOr_HLEAcquire(volatile long *, long); 
#line 2024
extern long _InterlockedOr_HLERelease(volatile long *, long); 
#line 2025
extern long _InterlockedXor_HLEAcquire(volatile long *, long); 
#line 2026
extern long _InterlockedXor_HLERelease(volatile long *, long); 
#line 2028
extern unsigned char _interlockedbittestandset_HLEAcquire(long *, long); 
#line 2029
extern unsigned char _interlockedbittestandset_HLERelease(long *, long); 
#line 2030
extern unsigned char _interlockedbittestandreset_HLEAcquire(long *, long); 
#line 2031
extern unsigned char _interlockedbittestandreset_HLERelease(long *, long); 
#line 2034
extern void _Store64_HLERelease(volatile __int64 *, __int64); 
#line 2035
extern __int64 _InterlockedExchange64_HLEAcquire(volatile __int64 *, __int64); 
#line 2036
extern __int64 _InterlockedExchange64_HLERelease(volatile __int64 *, __int64); 
#line 2038
extern __int64 _InterlockedExchangeAdd64_HLEAcquire(volatile __int64 *, __int64); 
#line 2039
extern __int64 _InterlockedExchangeAdd64_HLERelease(volatile __int64 *, __int64); 
#line 2041
extern __int64 _InterlockedAnd64_HLEAcquire(volatile __int64 *, __int64); 
#line 2042
extern __int64 _InterlockedAnd64_HLERelease(volatile __int64 *, __int64); 
#line 2043
extern __int64 _InterlockedOr64_HLEAcquire(volatile __int64 *, __int64); 
#line 2044
extern __int64 _InterlockedOr64_HLERelease(volatile __int64 *, __int64); 
#line 2045
extern __int64 _InterlockedXor64_HLEAcquire(volatile __int64 *, __int64); 
#line 2046
extern __int64 _InterlockedXor64_HLERelease(volatile __int64 *, __int64); 
#line 2048
extern unsigned char _interlockedbittestandset64_HLEAcquire(__int64 *, __int64); 
#line 2049
extern unsigned char _interlockedbittestandset64_HLERelease(__int64 *, __int64); 
#line 2050
extern unsigned char _interlockedbittestandreset64_HLEAcquire(__int64 *, __int64); 
#line 2051
extern unsigned char _interlockedbittestandreset64_HLERelease(__int64 *, __int64); 
#line 2064 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern unsigned __cdecl _xbegin(); 
#line 2065
extern void __cdecl _xend(); 
#line 2066
extern void __cdecl _xabort(const unsigned); 
#line 2067
extern unsigned char __cdecl _xtest(); 
#line 2076
extern int __cdecl _rdseed16_step(unsigned short *); 
#line 2077
extern int __cdecl _rdseed32_step(unsigned *); 
#line 2079
extern int __cdecl _rdseed64_step(unsigned __int64 *); 
#line 2091 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern unsigned char __cdecl _addcarryx_u32(unsigned char, unsigned, unsigned, unsigned *); 
#line 2098
extern unsigned char __cdecl _addcarryx_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64 *); 
#line 2108 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern unsigned short __cdecl _load_be_u16(const void *); 
#line 2109
extern unsigned __cdecl _load_be_u32(const void *); 
#line 2110
extern unsigned __int64 __cdecl _load_be_u64(const void *); 
#line 2118
extern void __cdecl _store_be_u16(void *, unsigned short); 
#line 2119
extern void __cdecl _store_be_u32(void *, unsigned); 
#line 2120
extern void __cdecl _store_be_u64(void *, unsigned __int64); 
#line 2128
extern __m128i __cdecl _mm_sha1msg1_epu32(__m128i, __m128i); 
#line 2129
extern __m128i __cdecl _mm_sha1msg2_epu32(__m128i, __m128i); 
#line 2130
extern __m128i __cdecl _mm_sha1nexte_epu32(__m128i, __m128i); 
#line 2131
extern __m128i __cdecl _mm_sha1rnds4_epu32(__m128i, __m128i, const int); 
#line 2133
extern __m128i __cdecl _mm_sha256msg1_epu32(__m128i, __m128i); 
#line 2134
extern __m128i __cdecl _mm_sha256msg2_epu32(__m128i, __m128i); 
#line 2135
extern __m128i __cdecl _mm_sha256rnds2_epu32(__m128i, __m128i, __m128i); 
#line 2140
extern void *__cdecl _bnd_set_ptr_bounds(const void *, size_t); 
#line 2141
extern void *__cdecl _bnd_narrow_ptr_bounds(const void *, const void *, size_t); 
#line 2142
extern void *__cdecl _bnd_copy_ptr_bounds(const void *, const void *); 
#line 2143
extern void *__cdecl _bnd_init_ptr_bounds(const void *); 
#line 2144
extern void __cdecl _bnd_store_ptr_bounds(const void **, const void *); 
#line 2145
extern void __cdecl _bnd_chk_ptr_lbounds(const void *); 
#line 2146
extern void __cdecl _bnd_chk_ptr_ubounds(const void *); 
#line 2147
extern void __cdecl _bnd_chk_ptr_bounds(const void *, size_t); 
#line 2148
extern void *__cdecl _bnd_load_ptr_bounds(const void **, const void *); 
#line 2149
extern const void *__cdecl _bnd_get_ptr_lbound(const void *); 
#line 2150
extern const void *__cdecl _bnd_get_ptr_ubound(const void *); 
#line 2153
extern __m256i __cdecl _mm256_insert_epi8(__m256i, int, const int); 
#line 2154
extern __m256i __cdecl _mm256_insert_epi16(__m256i, int, const int); 
#line 2155
extern __m256i __cdecl _mm256_insert_epi32(__m256i, int, const int); 
#line 2157
extern __m256i __cdecl _mm256_insert_epi64(__m256i, __int64, const int); 
#line 2161 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern int __cdecl _mm256_extract_epi8(__m256i, const int); 
#line 2162
extern int __cdecl _mm256_extract_epi16(__m256i, const int); 
#line 2163
extern int __cdecl _mm256_extract_epi32(__m256i, const int); 
#line 2165
extern __int64 __cdecl _mm256_extract_epi64(__m256i, const int); 
#line 2169 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern __m256d __cdecl _mm256_zextpd128_pd256(__m128d); 
#line 2170
extern __m256 __cdecl _mm256_zextps128_ps256(__m128); 
#line 2171
extern __m256i __cdecl _mm256_zextsi128_si256(__m128i); 
#line 2174
extern unsigned __cdecl _rdpid_u32(); 
#line 2176
extern void __cdecl _ptwrite32(unsigned); 
#line 2178
extern void __cdecl _ptwrite64(unsigned __int64); 
#line 2182 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern __m128i __cdecl _mm_dpbusd_avx_epi32(__m128i, __m128i, __m128i); 
#line 2183
extern __m256i __cdecl _mm256_dpbusd_avx_epi32(__m256i, __m256i, __m256i); 
#line 2184
extern __m128i __cdecl _mm_dpbusds_avx_epi32(__m128i, __m128i, __m128i); 
#line 2185
extern __m256i __cdecl _mm256_dpbusds_avx_epi32(__m256i, __m256i, __m256i); 
#line 2186
extern __m128i __cdecl _mm_dpwssd_avx_epi32(__m128i, __m128i, __m128i); 
#line 2187
extern __m256i __cdecl _mm256_dpwssd_avx_epi32(__m256i, __m256i, __m256i); 
#line 2188
extern __m128i __cdecl _mm_dpwssds_avx_epi32(__m128i, __m128i, __m128i); 
#line 2189
extern __m256i __cdecl _mm256_dpwssds_avx_epi32(__m256i, __m256i, __m256i); 
#line 2192
extern unsigned __cdecl _pconfig_u32(const int, size_t  __data[]); 
#line 2193
extern void __cdecl _wbnoinvd(); 
#line 2196
extern unsigned __cdecl _encls_u32(const int, size_t  __data[]); 
#line 2197
extern unsigned __cdecl _enclu_u32(const int, size_t  __data[]); 
#line 2198
extern unsigned __cdecl _enclv_u32(const int, size_t  __data[]); 
#line 2203
extern unsigned __int64 __cdecl _udiv128(unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64 *); 
#line 2204
extern __int64 __cdecl _div128(__int64, __int64, __int64, __int64 *); 
#line 2206 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern unsigned __cdecl _udiv64(unsigned __int64, unsigned, unsigned *); 
#line 2207
extern int __cdecl _div64(__int64, int, int *); 
#line 2210
extern unsigned char _mm_aesdec128kl_u8(__m128i *, __m128i, const void *); 
#line 2211
extern unsigned char _mm_aesdec256kl_u8(__m128i *, __m128i, const void *); 
#line 2212
extern unsigned char _mm_aesdecwide128kl_u8(__m128i *, const __m128i *, const void *); 
#line 2213
extern unsigned char _mm_aesdecwide256kl_u8(__m128i *, const __m128i *, const void *); 
#line 2214
extern unsigned char _mm_aesenc128kl_u8(__m128i *, __m128i, const void *); 
#line 2215
extern unsigned char _mm_aesenc256kl_u8(__m128i *, __m128i, const void *); 
#line 2216
extern unsigned char _mm_aesencwide128kl_u8(__m128i *, const __m128i *, const void *); 
#line 2217
extern unsigned char _mm_aesencwide256kl_u8(__m128i *, const __m128i *, const void *); 
#line 2218
extern unsigned _mm_encodekey128_u32(unsigned, __m128i, void *); 
#line 2219
extern unsigned _mm_encodekey256_u32(unsigned, __m128i, __m128i, void *); 
#line 2220
extern void _mm_loadiwkey(unsigned, __m128i, __m128i, __m128i); 
#line 2223
extern unsigned __cdecl _rdpkru_u32(); 
#line 2224
extern void __cdecl _wrpkru(unsigned); 
#line 2227
extern int __cdecl _enqcmd(void *, const void *); 
#line 2228
extern int __cdecl _enqcmds(void *, const void *); 
#line 2233
extern void __cdecl _incsspd(unsigned); 
#line 2234
extern unsigned __cdecl _rdsspd(); 
#line 2235
extern void __cdecl _saveprevssp(); 
#line 2236
extern void __cdecl _rstorssp(void *); 
#line 2237
extern void __cdecl _wrssd(unsigned, void *); 
#line 2238
extern void __cdecl _wrussd(unsigned, void *); 
#line 2239
extern void __cdecl _setssbsy(); 
#line 2240
extern void __cdecl _clrssbsy(void *); 
#line 2241
extern void *__cdecl _switchssp(void *); 
#line 2243
extern void __cdecl _incsspq(unsigned __int64); 
#line 2244
extern unsigned __int64 __cdecl _rdsspq(); 
#line 2245
extern void __cdecl _wrssq(unsigned __int64, void *); 
#line 2246
extern void __cdecl _wrussq(unsigned __int64, void *); 
#line 2254 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern __m128i _mm_div_epi8(__m128i, __m128i); 
#line 2255
extern __m128i _mm_div_epi16(__m128i, __m128i); 
#line 2256
extern __m128i _mm_div_epi32(__m128i, __m128i); 
#line 2257
extern __m128i _mm_div_epi64(__m128i, __m128i); 
#line 2258
extern __m128i _mm_div_epu8(__m128i, __m128i); 
#line 2259
extern __m128i _mm_div_epu16(__m128i, __m128i); 
#line 2260
extern __m128i _mm_div_epu32(__m128i, __m128i); 
#line 2261
extern __m128i _mm_div_epu64(__m128i, __m128i); 
#line 2262
extern __m128i _mm_rem_epi8(__m128i, __m128i); 
#line 2263
extern __m128i _mm_rem_epi16(__m128i, __m128i); 
#line 2264
extern __m128i _mm_rem_epi32(__m128i, __m128i); 
#line 2265
extern __m128i _mm_rem_epi64(__m128i, __m128i); 
#line 2266
extern __m128i _mm_rem_epu8(__m128i, __m128i); 
#line 2267
extern __m128i _mm_rem_epu16(__m128i, __m128i); 
#line 2268
extern __m128i _mm_rem_epu32(__m128i, __m128i); 
#line 2269
extern __m128i _mm_rem_epu64(__m128i, __m128i); 
#line 2270
extern __m256i _mm256_div_epi8(__m256i, __m256i); 
#line 2271
extern __m256i _mm256_div_epi16(__m256i, __m256i); 
#line 2272
extern __m256i _mm256_div_epi32(__m256i, __m256i); 
#line 2273
extern __m256i _mm256_div_epi64(__m256i, __m256i); 
#line 2274
extern __m256i _mm256_div_epu8(__m256i, __m256i); 
#line 2275
extern __m256i _mm256_div_epu16(__m256i, __m256i); 
#line 2276
extern __m256i _mm256_div_epu32(__m256i, __m256i); 
#line 2277
extern __m256i _mm256_div_epu64(__m256i, __m256i); 
#line 2278
extern __m256i _mm256_rem_epi8(__m256i, __m256i); 
#line 2279
extern __m256i _mm256_rem_epi16(__m256i, __m256i); 
#line 2280
extern __m256i _mm256_rem_epi32(__m256i, __m256i); 
#line 2281
extern __m256i _mm256_rem_epi64(__m256i, __m256i); 
#line 2282
extern __m256i _mm256_rem_epu8(__m256i, __m256i); 
#line 2283
extern __m256i _mm256_rem_epu16(__m256i, __m256i); 
#line 2284
extern __m256i _mm256_rem_epu32(__m256i, __m256i); 
#line 2285
extern __m256i _mm256_rem_epu64(__m256i, __m256i); 
#line 2296
extern __m128i _mm_divrem_epi32(__m128i *, __m128i, __m128i); 
#line 2297
extern __m128i _mm_divrem_epu32(__m128i *, __m128i, __m128i); 
#line 2298
extern __m256i _mm256_divrem_epi32(__m256i *, __m256i, __m256i); 
#line 2299
extern __m256i _mm256_divrem_epu32(__m256i *, __m256i, __m256i); 
#line 2307
extern __m128 _mm_sin_ps(__m128); 
#line 2308
extern __m128d _mm_sin_pd(__m128d); 
#line 2309
extern __m256 _mm256_sin_ps(__m256); 
#line 2310
extern __m256d _mm256_sin_pd(__m256d); 
#line 2311
extern __m128 _mm_cos_ps(__m128); 
#line 2312
extern __m128d _mm_cos_pd(__m128d); 
#line 2313
extern __m256 _mm256_cos_ps(__m256); 
#line 2314
extern __m256d _mm256_cos_pd(__m256d); 
#line 2315
extern __m128 _mm_sincos_ps(__m128 *, __m128); 
#line 2316
extern __m128d _mm_sincos_pd(__m128d *, __m128d); 
#line 2317
extern __m256 _mm256_sincos_ps(__m256 *, __m256); 
#line 2318
extern __m256d _mm256_sincos_pd(__m256d *, __m256d); 
#line 2319
extern __m128 _mm_tan_ps(__m128); 
#line 2320
extern __m128d _mm_tan_pd(__m128d); 
#line 2321
extern __m256 _mm256_tan_ps(__m256); 
#line 2322
extern __m256d _mm256_tan_pd(__m256d); 
#line 2323
extern __m128 _mm_asin_ps(__m128); 
#line 2324
extern __m128d _mm_asin_pd(__m128d); 
#line 2325
extern __m256 _mm256_asin_ps(__m256); 
#line 2326
extern __m256d _mm256_asin_pd(__m256d); 
#line 2327
extern __m128 _mm_acos_ps(__m128); 
#line 2328
extern __m128d _mm_acos_pd(__m128d); 
#line 2329
extern __m256 _mm256_acos_ps(__m256); 
#line 2330
extern __m256d _mm256_acos_pd(__m256d); 
#line 2331
extern __m128 _mm_atan_ps(__m128); 
#line 2332
extern __m128d _mm_atan_pd(__m128d); 
#line 2333
extern __m256 _mm256_atan_ps(__m256); 
#line 2334
extern __m256d _mm256_atan_pd(__m256d); 
#line 2335
extern __m128 _mm_atan2_ps(__m128, __m128); 
#line 2336
extern __m128d _mm_atan2_pd(__m128d, __m128d); 
#line 2337
extern __m256 _mm256_atan2_ps(__m256, __m256); 
#line 2338
extern __m256d _mm256_atan2_pd(__m256d, __m256d); 
#line 2339
extern __m128 _mm_sind_ps(__m128); 
#line 2340
extern __m128d _mm_sind_pd(__m128d); 
#line 2341
extern __m256 _mm256_sind_ps(__m256); 
#line 2342
extern __m256d _mm256_sind_pd(__m256d); 
#line 2343
extern __m128 _mm_cosd_ps(__m128); 
#line 2344
extern __m128d _mm_cosd_pd(__m128d); 
#line 2345
extern __m256 _mm256_cosd_ps(__m256); 
#line 2346
extern __m256d _mm256_cosd_pd(__m256d); 
#line 2347
extern __m128 _mm_tand_ps(__m128); 
#line 2348
extern __m128d _mm_tand_pd(__m128d); 
#line 2349
extern __m256 _mm256_tand_ps(__m256); 
#line 2350
extern __m256d _mm256_tand_pd(__m256d); 
#line 2351
extern __m128 _mm_sinh_ps(__m128); 
#line 2352
extern __m128d _mm_sinh_pd(__m128d); 
#line 2353
extern __m256 _mm256_sinh_ps(__m256); 
#line 2354
extern __m256d _mm256_sinh_pd(__m256d); 
#line 2355
extern __m128 _mm_cosh_ps(__m128); 
#line 2356
extern __m128d _mm_cosh_pd(__m128d); 
#line 2357
extern __m256 _mm256_cosh_ps(__m256); 
#line 2358
extern __m256d _mm256_cosh_pd(__m256d); 
#line 2359
extern __m128 _mm_tanh_ps(__m128); 
#line 2360
extern __m128d _mm_tanh_pd(__m128d); 
#line 2361
extern __m256 _mm256_tanh_ps(__m256); 
#line 2362
extern __m256d _mm256_tanh_pd(__m256d); 
#line 2363
extern __m128 _mm_asinh_ps(__m128); 
#line 2364
extern __m128d _mm_asinh_pd(__m128d); 
#line 2365
extern __m256 _mm256_asinh_ps(__m256); 
#line 2366
extern __m256d _mm256_asinh_pd(__m256d); 
#line 2367
extern __m128 _mm_acosh_ps(__m128); 
#line 2368
extern __m128d _mm_acosh_pd(__m128d); 
#line 2369
extern __m256 _mm256_acosh_ps(__m256); 
#line 2370
extern __m256d _mm256_acosh_pd(__m256d); 
#line 2371
extern __m128 _mm_atanh_ps(__m128); 
#line 2372
extern __m128d _mm_atanh_pd(__m128d); 
#line 2373
extern __m256 _mm256_atanh_ps(__m256); 
#line 2374
extern __m256d _mm256_atanh_pd(__m256d); 
#line 2375
extern __m128 _mm_log_ps(__m128); 
#line 2376
extern __m128d _mm_log_pd(__m128d); 
#line 2377
extern __m256 _mm256_log_ps(__m256); 
#line 2378
extern __m256d _mm256_log_pd(__m256d); 
#line 2379
extern __m128 _mm_log1p_ps(__m128); 
#line 2380
extern __m128d _mm_log1p_pd(__m128d); 
#line 2381
extern __m256 _mm256_log1p_ps(__m256); 
#line 2382
extern __m256d _mm256_log1p_pd(__m256d); 
#line 2383
extern __m128 _mm_log10_ps(__m128); 
#line 2384
extern __m128d _mm_log10_pd(__m128d); 
#line 2385
extern __m256 _mm256_log10_ps(__m256); 
#line 2386
extern __m256d _mm256_log10_pd(__m256d); 
#line 2387
extern __m128 _mm_log2_ps(__m128); 
#line 2388
extern __m128d _mm_log2_pd(__m128d); 
#line 2389
extern __m256 _mm256_log2_ps(__m256); 
#line 2390
extern __m256d _mm256_log2_pd(__m256d); 
#line 2391
extern __m128 _mm_logb_ps(__m128); 
#line 2392
extern __m128d _mm_logb_pd(__m128d); 
#line 2393
extern __m256 _mm256_logb_ps(__m256); 
#line 2394
extern __m256d _mm256_logb_pd(__m256d); 
#line 2395
extern __m128 _mm_exp_ps(__m128); 
#line 2396
extern __m128d _mm_exp_pd(__m128d); 
#line 2397
extern __m256 _mm256_exp_ps(__m256); 
#line 2398
extern __m256d _mm256_exp_pd(__m256d); 
#line 2399
extern __m128 _mm_exp10_ps(__m128); 
#line 2400
extern __m128d _mm_exp10_pd(__m128d); 
#line 2401
extern __m256 _mm256_exp10_ps(__m256); 
#line 2402
extern __m256d _mm256_exp10_pd(__m256d); 
#line 2403
extern __m128 _mm_exp2_ps(__m128); 
#line 2404
extern __m128d _mm_exp2_pd(__m128d); 
#line 2405
extern __m256 _mm256_exp2_ps(__m256); 
#line 2406
extern __m256d _mm256_exp2_pd(__m256d); 
#line 2407
extern __m128 _mm_expm1_ps(__m128); 
#line 2408
extern __m128d _mm_expm1_pd(__m128d); 
#line 2409
extern __m256 _mm256_expm1_ps(__m256); 
#line 2410
extern __m256d _mm256_expm1_pd(__m256d); 
#line 2411
extern __m128 _mm_pow_ps(__m128, __m128); 
#line 2412
extern __m128d _mm_pow_pd(__m128d, __m128d); 
#line 2413
extern __m256 _mm256_pow_ps(__m256, __m256); 
#line 2414
extern __m256d _mm256_pow_pd(__m256d, __m256d); 
#line 2415
extern __m128 _mm_trunc_ps(__m128); 
#line 2416
extern __m128d _mm_trunc_pd(__m128d); 
#line 2417
extern __m256 _mm256_trunc_ps(__m256); 
#line 2418
extern __m256d _mm256_trunc_pd(__m256d); 
#line 2419
extern __m128 _mm_svml_floor_ps(__m128); 
#line 2420
extern __m128d _mm_svml_floor_pd(__m128d); 
#line 2421
extern __m256 _mm256_svml_floor_ps(__m256); 
#line 2422
extern __m256d _mm256_svml_floor_pd(__m256d); 
#line 2423
extern __m128 _mm_svml_ceil_ps(__m128); 
#line 2424
extern __m128d _mm_svml_ceil_pd(__m128d); 
#line 2425
extern __m256 _mm256_svml_ceil_ps(__m256); 
#line 2426
extern __m256d _mm256_svml_ceil_pd(__m256d); 
#line 2427
extern __m128 _mm_svml_round_ps(__m128); 
#line 2428
extern __m128d _mm_svml_round_pd(__m128d); 
#line 2429
extern __m256 _mm256_svml_round_ps(__m256); 
#line 2430
extern __m256d _mm256_svml_round_pd(__m256d); 
#line 2431
extern __m128 _mm_fmod_ps(__m128, __m128); 
#line 2432
extern __m128d _mm_fmod_pd(__m128d, __m128d); 
#line 2433
extern __m256 _mm256_fmod_ps(__m256, __m256); 
#line 2434
extern __m256d _mm256_fmod_pd(__m256d, __m256d); 
#line 2435
extern __m128 _mm_svml_sqrt_ps(__m128); 
#line 2436
extern __m128d _mm_svml_sqrt_pd(__m128d); 
#line 2437
extern __m256 _mm256_svml_sqrt_ps(__m256); 
#line 2438
extern __m256d _mm256_svml_sqrt_pd(__m256d); 
#line 2439
extern __m128 _mm_invsqrt_ps(__m128); 
#line 2440
extern __m128d _mm_invsqrt_pd(__m128d); 
#line 2441
extern __m256 _mm256_invsqrt_ps(__m256); 
#line 2442
extern __m256d _mm256_invsqrt_pd(__m256d); 
#line 2443
extern __m128 _mm_cbrt_ps(__m128); 
#line 2444
extern __m128d _mm_cbrt_pd(__m128d); 
#line 2445
extern __m256 _mm256_cbrt_ps(__m256); 
#line 2446
extern __m256d _mm256_cbrt_pd(__m256d); 
#line 2447
extern __m128 _mm_invcbrt_ps(__m128); 
#line 2448
extern __m128d _mm_invcbrt_pd(__m128d); 
#line 2449
extern __m256 _mm256_invcbrt_ps(__m256); 
#line 2450
extern __m256d _mm256_invcbrt_pd(__m256d); 
#line 2451
extern __m128 _mm_hypot_ps(__m128, __m128); 
#line 2452
extern __m128d _mm_hypot_pd(__m128d, __m128d); 
#line 2453
extern __m256 _mm256_hypot_ps(__m256, __m256); 
#line 2454
extern __m256d _mm256_hypot_pd(__m256d, __m256d); 
#line 2455
extern __m128 _mm_cdfnorm_ps(__m128); 
#line 2456
extern __m128d _mm_cdfnorm_pd(__m128d); 
#line 2457
extern __m256 _mm256_cdfnorm_ps(__m256); 
#line 2458
extern __m256d _mm256_cdfnorm_pd(__m256d); 
#line 2459
extern __m128 _mm_cdfnorminv_ps(__m128); 
#line 2460
extern __m128d _mm_cdfnorminv_pd(__m128d); 
#line 2461
extern __m256 _mm256_cdfnorminv_ps(__m256); 
#line 2462
extern __m256d _mm256_cdfnorminv_pd(__m256d); 
#line 2463
extern __m128 _mm_cexp_ps(__m128); 
#line 2464
extern __m256 _mm256_cexp_ps(__m256); 
#line 2465
extern __m128 _mm_clog_ps(__m128); 
#line 2466
extern __m256 _mm256_clog_ps(__m256); 
#line 2467
extern __m128 _mm_csqrt_ps(__m128); 
#line 2468
extern __m256 _mm256_csqrt_ps(__m256); 
#line 2469
extern __m128 _mm_erf_ps(__m128); 
#line 2470
extern __m128d _mm_erf_pd(__m128d); 
#line 2471
extern __m256 _mm256_erf_ps(__m256); 
#line 2472
extern __m256d _mm256_erf_pd(__m256d); 
#line 2473
extern __m128 _mm_erfc_ps(__m128); 
#line 2474
extern __m128d _mm_erfc_pd(__m128d); 
#line 2475
extern __m256 _mm256_erfc_ps(__m256); 
#line 2476
extern __m256d _mm256_erfc_pd(__m256d); 
#line 2477
extern __m128 _mm_erfcinv_ps(__m128); 
#line 2478
extern __m128d _mm_erfcinv_pd(__m128d); 
#line 2479
extern __m256 _mm256_erfcinv_ps(__m256); 
#line 2480
extern __m256d _mm256_erfcinv_pd(__m256d); 
#line 2481
extern __m128 _mm_erfinv_ps(__m128); 
#line 2482
extern __m128d _mm_erfinv_pd(__m128d); 
#line 2483
extern __m256 _mm256_erfinv_ps(__m256); 
#line 2484
extern __m256d _mm256_erfinv_pd(__m256d); 
#line 2487
extern void _mm_cldemote(const void *); 
#line 2491
extern void _directstoreu_u32(void *, unsigned); 
#line 2493
extern void _directstoreu_u64(void *, unsigned __int64); 
#line 2495 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern void _movdir64b(void *, const void *); 
#line 2498
extern void __cdecl _serialize(); 
#line 2499
extern void __cdecl _xsusldtrk(); 
#line 2500
extern void __cdecl _xresldtrk(); 
#line 2503
extern void _umonitor(void *); 
#line 2504
extern unsigned char _umwait(unsigned, unsigned __int64); 
#line 2505
extern unsigned char _tpause(unsigned, unsigned __int64); 
#line 2509
extern void _clui(); 
#line 2510
extern void _stui(); 
#line 2511
extern unsigned char _testui(); 
#line 2512
extern void _senduipi(unsigned __int64); 
#line 2516 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern void _hreset(unsigned); 
#line 2519
extern __m128 _mm_svml_cvtepu32_ps(__m128i); 
#line 2520
extern __m256 _mm256_svml_cvtepu32_ps(__m256i); 
#line 2521
extern __m128d _mm_svml_cvtepu32_pd(__m128i); 
#line 2522
extern __m256d _mm256_svml_cvtepu32_pd(__m128i); 
#line 2523
extern __m128d _mm_svml_cvtepi64_pd(__m128i); 
#line 2524
extern __m256d _mm256_svml_cvtepi64_pd(__m256i); 
#line 2525
extern __m128d _mm_svml_cvtepu64_pd(__m128i); 
#line 2526
extern __m256d _mm256_svml_cvtepu64_pd(__m256i); 
#line 2529
extern unsigned _castf32_u32(float); 
#line 2530
extern unsigned __int64 _castf64_u64(double); 
#line 2531
extern float _castu32_f32(unsigned); 
#line 2532
extern double _castu64_f64(unsigned __int64); 
#line 2535
}
#line 42 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"
typedef unsigned char __mmask8; 
#line 43
typedef unsigned short __mmask16; 
#line 44
typedef unsigned __mmask32; 
#line 45
typedef unsigned __int64 __mmask64; 
#line 49
typedef 
#line 47
union __declspec(intrin_type) __declspec(align(64)) __m512 { 
#line 48
float m512_f32[16]; 
#line 49
} __m512; 
#line 53
typedef 
#line 51
struct __declspec(intrin_type) __declspec(align(64)) __m512d { 
#line 52
double m512d_f64[8]; 
#line 53
} __m512d; 
#line 64
typedef 
#line 55
union __declspec(intrin_type) __declspec(align(64)) __m512i { 
#line 56
char m512i_i8[64]; 
#line 57
short m512i_i16[32]; 
#line 58
int m512i_i32[16]; 
#line 59
__int64 m512i_i64[8]; 
#line 60
unsigned char m512i_u8[64]; 
#line 61
unsigned short m512i_u16[32]; 
#line 62
unsigned m512i_u32[16]; 
#line 63
unsigned __int64 m512i_u64[8]; 
#line 64
} __m512i; 
#line 68
extern "C" {
#line 73 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"
extern __m256 __cdecl _mm512_castps512_ps256(__m512); 
#line 74
extern __m512 __cdecl _mm512_castpd_ps(__m512d); 
#line 75
extern __m512 __cdecl _mm512_castps256_ps512(__m256); 
#line 76
extern __m512 __cdecl _mm512_castsi512_ps(__m512i); 
#line 77
extern __m512 __cdecl _mm512_castps128_ps512(__m128); 
#line 79
extern __m256d __cdecl _mm512_castpd512_pd256(__m512d); 
#line 80
extern __m512d __cdecl _mm512_castpd256_pd512(__m256d); 
#line 81
extern __m512d __cdecl _mm512_castps_pd(__m512); 
#line 82
extern __m512d __cdecl _mm512_castsi512_pd(__m512i); 
#line 83
extern __m512d __cdecl _mm512_castpd128_pd512(__m128d); 
#line 85
extern __m256i __cdecl _mm512_castsi512_si256(__m512i); 
#line 86
extern __m512i __cdecl _mm512_castpd_si512(__m512d); 
#line 87
extern __m512i __cdecl _mm512_castps_si512(__m512); 
#line 88
extern __m512i __cdecl _mm512_castsi256_si512(__m256i); 
#line 102
typedef 
#line 97
enum { 
#line 98
_MM_BROADCAST32_NONE, 
#line 100
_MM_BROADCAST_1X16, 
#line 101
_MM_BROADCAST_4X16
#line 102
} _MM_BROADCAST32_ENUM; 
#line 110
typedef 
#line 105
enum { 
#line 106
_MM_BROADCAST64_NONE, 
#line 108
_MM_BROADCAST_1X8, 
#line 109
_MM_BROADCAST_4X8
#line 110
} _MM_BROADCAST64_ENUM; 
#line 124
typedef 
#line 117
enum { 
#line 118
_MM_ROUND_MODE_NEAREST, 
#line 119
_MM_ROUND_MODE_DOWN, 
#line 120
_MM_ROUND_MODE_UP, 
#line 121
_MM_ROUND_MODE_TOWARD_ZERO, 
#line 122
_MM_ROUND_MODE_DEFAULT, 
#line 123
_MM_ROUND_MODE_NO_EXC = 8
#line 124
} _MM_ROUND_MODE_ENUM; 
#line 136
typedef 
#line 127
enum { 
#line 128
_MM_EXPADJ_NONE, 
#line 129
_MM_EXPADJ_4, 
#line 130
_MM_EXPADJ_5, 
#line 131
_MM_EXPADJ_8, 
#line 132
_MM_EXPADJ_16, 
#line 133
_MM_EXPADJ_24, 
#line 134
_MM_EXPADJ_31, 
#line 135
_MM_EXPADJ_32
#line 136
} _MM_EXP_ADJ_ENUM; 
#line 144
typedef 
#line 139
enum { 
#line 140
_MM_SCALE_1 = 1, 
#line 141
_MM_SCALE_2, 
#line 142
_MM_SCALE_4 = 4, 
#line 143
_MM_SCALE_8 = 8
#line 144
} _MM_INDEX_SCALE_ENUM; 
#line 234
typedef 
#line 147
enum { 
#line 148
_MM_PERM_AAAA, _MM_PERM_AAAB, _MM_PERM_AAAC, 
#line 149
_MM_PERM_AAAD, _MM_PERM_AABA, _MM_PERM_AABB, 
#line 150
_MM_PERM_AABC, _MM_PERM_AABD, _MM_PERM_AACA, 
#line 151
_MM_PERM_AACB, _MM_PERM_AACC, _MM_PERM_AACD, 
#line 152
_MM_PERM_AADA, _MM_PERM_AADB, _MM_PERM_AADC, 
#line 153
_MM_PERM_AADD, _MM_PERM_ABAA, _MM_PERM_ABAB, 
#line 154
_MM_PERM_ABAC, _MM_PERM_ABAD, _MM_PERM_ABBA, 
#line 155
_MM_PERM_ABBB, _MM_PERM_ABBC, _MM_PERM_ABBD, 
#line 156
_MM_PERM_ABCA, _MM_PERM_ABCB, _MM_PERM_ABCC, 
#line 157
_MM_PERM_ABCD, _MM_PERM_ABDA, _MM_PERM_ABDB, 
#line 158
_MM_PERM_ABDC, _MM_PERM_ABDD, _MM_PERM_ACAA, 
#line 159
_MM_PERM_ACAB, _MM_PERM_ACAC, _MM_PERM_ACAD, 
#line 160
_MM_PERM_ACBA, _MM_PERM_ACBB, _MM_PERM_ACBC, 
#line 161
_MM_PERM_ACBD, _MM_PERM_ACCA, _MM_PERM_ACCB, 
#line 162
_MM_PERM_ACCC, _MM_PERM_ACCD, _MM_PERM_ACDA, 
#line 163
_MM_PERM_ACDB, _MM_PERM_ACDC, _MM_PERM_ACDD, 
#line 164
_MM_PERM_ADAA, _MM_PERM_ADAB, _MM_PERM_ADAC, 
#line 165
_MM_PERM_ADAD, _MM_PERM_ADBA, _MM_PERM_ADBB, 
#line 166
_MM_PERM_ADBC, _MM_PERM_ADBD, _MM_PERM_ADCA, 
#line 167
_MM_PERM_ADCB, _MM_PERM_ADCC, _MM_PERM_ADCD, 
#line 168
_MM_PERM_ADDA, _MM_PERM_ADDB, _MM_PERM_ADDC, 
#line 169
_MM_PERM_ADDD, _MM_PERM_BAAA, _MM_PERM_BAAB, 
#line 170
_MM_PERM_BAAC, _MM_PERM_BAAD, _MM_PERM_BABA, 
#line 171
_MM_PERM_BABB, _MM_PERM_BABC, _MM_PERM_BABD, 
#line 172
_MM_PERM_BACA, _MM_PERM_BACB, _MM_PERM_BACC, 
#line 173
_MM_PERM_BACD, _MM_PERM_BADA, _MM_PERM_BADB, 
#line 174
_MM_PERM_BADC, _MM_PERM_BADD, _MM_PERM_BBAA, 
#line 175
_MM_PERM_BBAB, _MM_PERM_BBAC, _MM_PERM_BBAD, 
#line 176
_MM_PERM_BBBA, _MM_PERM_BBBB, _MM_PERM_BBBC, 
#line 177
_MM_PERM_BBBD, _MM_PERM_BBCA, _MM_PERM_BBCB, 
#line 178
_MM_PERM_BBCC, _MM_PERM_BBCD, _MM_PERM_BBDA, 
#line 179
_MM_PERM_BBDB, _MM_PERM_BBDC, _MM_PERM_BBDD, 
#line 180
_MM_PERM_BCAA, _MM_PERM_BCAB, _MM_PERM_BCAC, 
#line 181
_MM_PERM_BCAD, _MM_PERM_BCBA, _MM_PERM_BCBB, 
#line 182
_MM_PERM_BCBC, _MM_PERM_BCBD, _MM_PERM_BCCA, 
#line 183
_MM_PERM_BCCB, _MM_PERM_BCCC, _MM_PERM_BCCD, 
#line 184
_MM_PERM_BCDA, _MM_PERM_BCDB, _MM_PERM_BCDC, 
#line 185
_MM_PERM_BCDD, _MM_PERM_BDAA, _MM_PERM_BDAB, 
#line 186
_MM_PERM_BDAC, _MM_PERM_BDAD, _MM_PERM_BDBA, 
#line 187
_MM_PERM_BDBB, _MM_PERM_BDBC, _MM_PERM_BDBD, 
#line 188
_MM_PERM_BDCA, _MM_PERM_BDCB, _MM_PERM_BDCC, 
#line 189
_MM_PERM_BDCD, _MM_PERM_BDDA, _MM_PERM_BDDB, 
#line 190
_MM_PERM_BDDC, _MM_PERM_BDDD, _MM_PERM_CAAA, 
#line 191
_MM_PERM_CAAB, _MM_PERM_CAAC, _MM_PERM_CAAD, 
#line 192
_MM_PERM_CABA, _MM_PERM_CABB, _MM_PERM_CABC, 
#line 193
_MM_PERM_CABD, _MM_PERM_CACA, _MM_PERM_CACB, 
#line 194
_MM_PERM_CACC, _MM_PERM_CACD, _MM_PERM_CADA, 
#line 195
_MM_PERM_CADB, _MM_PERM_CADC, _MM_PERM_CADD, 
#line 196
_MM_PERM_CBAA, _MM_PERM_CBAB, _MM_PERM_CBAC, 
#line 197
_MM_PERM_CBAD, _MM_PERM_CBBA, _MM_PERM_CBBB, 
#line 198
_MM_PERM_CBBC, _MM_PERM_CBBD, _MM_PERM_CBCA, 
#line 199
_MM_PERM_CBCB, _MM_PERM_CBCC, _MM_PERM_CBCD, 
#line 200
_MM_PERM_CBDA, _MM_PERM_CBDB, _MM_PERM_CBDC, 
#line 201
_MM_PERM_CBDD, _MM_PERM_CCAA, _MM_PERM_CCAB, 
#line 202
_MM_PERM_CCAC, _MM_PERM_CCAD, _MM_PERM_CCBA, 
#line 203
_MM_PERM_CCBB, _MM_PERM_CCBC, _MM_PERM_CCBD, 
#line 204
_MM_PERM_CCCA, _MM_PERM_CCCB, _MM_PERM_CCCC, 
#line 205
_MM_PERM_CCCD, _MM_PERM_CCDA, _MM_PERM_CCDB, 
#line 206
_MM_PERM_CCDC, _MM_PERM_CCDD, _MM_PERM_CDAA, 
#line 207
_MM_PERM_CDAB, _MM_PERM_CDAC, _MM_PERM_CDAD, 
#line 208
_MM_PERM_CDBA, _MM_PERM_CDBB, _MM_PERM_CDBC, 
#line 209
_MM_PERM_CDBD, _MM_PERM_CDCA, _MM_PERM_CDCB, 
#line 210
_MM_PERM_CDCC, _MM_PERM_CDCD, _MM_PERM_CDDA, 
#line 211
_MM_PERM_CDDB, _MM_PERM_CDDC, _MM_PERM_CDDD, 
#line 212
_MM_PERM_DAAA, _MM_PERM_DAAB, _MM_PERM_DAAC, 
#line 213
_MM_PERM_DAAD, _MM_PERM_DABA, _MM_PERM_DABB, 
#line 214
_MM_PERM_DABC, _MM_PERM_DABD, _MM_PERM_DACA, 
#line 215
_MM_PERM_DACB, _MM_PERM_DACC, _MM_PERM_DACD, 
#line 216
_MM_PERM_DADA, _MM_PERM_DADB, _MM_PERM_DADC, 
#line 217
_MM_PERM_DADD, _MM_PERM_DBAA, _MM_PERM_DBAB, 
#line 218
_MM_PERM_DBAC, _MM_PERM_DBAD, _MM_PERM_DBBA, 
#line 219
_MM_PERM_DBBB, _MM_PERM_DBBC, _MM_PERM_DBBD, 
#line 220
_MM_PERM_DBCA, _MM_PERM_DBCB, _MM_PERM_DBCC, 
#line 221
_MM_PERM_DBCD, _MM_PERM_DBDA, _MM_PERM_DBDB, 
#line 222
_MM_PERM_DBDC, _MM_PERM_DBDD, _MM_PERM_DCAA, 
#line 223
_MM_PERM_DCAB, _MM_PERM_DCAC, _MM_PERM_DCAD, 
#line 224
_MM_PERM_DCBA, _MM_PERM_DCBB, _MM_PERM_DCBC, 
#line 225
_MM_PERM_DCBD, _MM_PERM_DCCA, _MM_PERM_DCCB, 
#line 226
_MM_PERM_DCCC, _MM_PERM_DCCD, _MM_PERM_DCDA, 
#line 227
_MM_PERM_DCDB, _MM_PERM_DCDC, _MM_PERM_DCDD, 
#line 228
_MM_PERM_DDAA, _MM_PERM_DDAB, _MM_PERM_DDAC, 
#line 229
_MM_PERM_DDAD, _MM_PERM_DDBA, _MM_PERM_DDBB, 
#line 230
_MM_PERM_DDBC, _MM_PERM_DDBD, _MM_PERM_DDCA, 
#line 231
_MM_PERM_DDCB, _MM_PERM_DDCC, _MM_PERM_DDCD, 
#line 232
_MM_PERM_DDDA, _MM_PERM_DDDB, _MM_PERM_DDDC, 
#line 233
_MM_PERM_DDDD
#line 234
} _MM_PERM_ENUM; 
#line 249
typedef 
#line 240
enum { 
#line 241
_MM_FIXUP_NO_CHANGE, 
#line 242
_MM_FIXUP_NEG_INF, 
#line 243
_MM_FIXUP_NEG_ZERO, 
#line 244
_MM_FIXUP_POS_ZERO, 
#line 245
_MM_FIXUP_POS_INF, 
#line 246
_MM_FIXUP_NAN, 
#line 247
_MM_FIXUP_MAX_FLOAT, 
#line 248
_MM_FIXUP_MIN_FLOAT
#line 249
} _MM_FIXUPRESULT_ENUM; 
#line 276
typedef 
#line 271
enum { 
#line 272
_MM_MANT_NORM_1_2, 
#line 273
_MM_MANT_NORM_p5_2, 
#line 274
_MM_MANT_NORM_p5_1, 
#line 275
_MM_MANT_NORM_p75_1p5
#line 276
} _MM_MANTISSA_NORM_ENUM; 
#line 282
typedef 
#line 278
enum { 
#line 279
_MM_MANT_SIGN_src, 
#line 280
_MM_MANT_SIGN_zero, 
#line 281
_MM_MANT_SIGN_nan
#line 282
} _MM_MANTISSA_SIGN_ENUM; 
#line 299
typedef 
#line 289
enum { 
#line 290
_MM_CMPINT_EQ, 
#line 291
_MM_CMPINT_LT, 
#line 292
_MM_CMPINT_LE, 
#line 293
_MM_CMPINT_UNUSED, 
#line 294
_MM_CMPINT_NE, 
#line 295
_MM_CMPINT_NLT, 
#line 297
_MM_CMPINT_NLE
#line 299
} _MM_CMPINT_ENUM; 
#line 305
extern __m512 __cdecl _mm512_setzero_ps(); 
#line 306
extern __m512d __cdecl _mm512_setzero_pd(); 
#line 308
extern __m512 __cdecl _mm512_set_ps(float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float); 
#line 309
extern __m512d __cdecl _mm512_set_pd(double, double, double, double, double, double, double, double); 
#line 311
extern __m512 __cdecl _mm512_setr_ps(float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float); 
#line 312
extern __m512d __cdecl _mm512_setr_pd(double, double, double, double, double, double, double, double); 
#line 314
extern __m512 __cdecl _mm512_set1_ps(float); 
#line 315
extern __m512d __cdecl _mm512_set1_pd(double); 
#line 317
extern __m512 __cdecl _mm512_load_ps(const void *); 
#line 318
extern __m512d __cdecl _mm512_load_pd(const void *); 
#line 319
extern __m512 __cdecl _mm512_maskz_load_ps(__mmask16, const void *); 
#line 320
extern __m512d __cdecl _mm512_maskz_load_pd(__mmask8, const void *); 
#line 321
extern __m512 __cdecl _mm512_mask_load_ps(__m512, __mmask16, const void *); 
#line 322
extern __m512d __cdecl _mm512_mask_load_pd(__m512d, __mmask8, const void *); 
#line 323
extern __m512 __cdecl _mm512_loadu_ps(const void *); 
#line 324
extern __m512d __cdecl _mm512_loadu_pd(const void *); 
#line 325
extern __m512 __cdecl _mm512_maskz_loadu_ps(__mmask16, const void *); 
#line 326
extern __m512d __cdecl _mm512_maskz_loadu_pd(__mmask8, const void *); 
#line 327
extern __m512 __cdecl _mm512_mask_loadu_ps(__m512, __mmask16, const void *); 
#line 328
extern __m512d __cdecl _mm512_mask_loadu_pd(__m512d, __mmask8, const void *); 
#line 330
extern void __cdecl _mm512_store_ps(void *, __m512); 
#line 331
extern void __cdecl _mm512_store_pd(void *, __m512d); 
#line 332
extern void __cdecl _mm512_storeu_ps(void *, __m512); 
#line 333
extern void __cdecl _mm512_storeu_pd(void *, __m512d); 
#line 334
extern void __cdecl _mm512_mask_store_ps(void *, __mmask16, __m512); 
#line 335
extern void __cdecl _mm512_mask_store_pd(void *, __mmask8, __m512d); 
#line 336
extern void __cdecl _mm512_mask_storeu_ps(void *, __mmask16, __m512); 
#line 337
extern void __cdecl _mm512_mask_storeu_pd(void *, __mmask8, __m512d); 
#line 339
extern __m512 __cdecl _mm512_add_ps(__m512, __m512); 
#line 340
extern __m512 __cdecl _mm512_maskz_add_ps(__mmask16, __m512, __m512); 
#line 341
extern __m512 __cdecl _mm512_mask_add_ps(__m512, __mmask16, __m512, __m512); 
#line 342
extern __m512 __cdecl _mm512_add_round_ps(__m512, __m512, const int); 
#line 343
extern __m512 __cdecl _mm512_maskz_add_round_ps(__mmask16, __m512, __m512, const int); 
#line 344
extern __m512 __cdecl _mm512_mask_add_round_ps(__m512, __mmask16, __m512, __m512, const int); 
#line 345
extern __m512d __cdecl _mm512_add_pd(__m512d, __m512d); 
#line 346
extern __m512d __cdecl _mm512_maskz_add_pd(__mmask8, __m512d, __m512d); 
#line 347
extern __m512d __cdecl _mm512_mask_add_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 348
extern __m512d __cdecl _mm512_add_round_pd(__m512d, __m512d, const int); 
#line 349
extern __m512d __cdecl _mm512_maskz_add_round_pd(__mmask8, __m512d, __m512d, const int); 
#line 350
extern __m512d __cdecl _mm512_mask_add_round_pd(__m512d, __mmask8, __m512d, __m512d, const int); 
#line 352
extern __m512 __cdecl _mm512_sub_ps(__m512, __m512); 
#line 353
extern __m512 __cdecl _mm512_maskz_sub_ps(__mmask16, __m512, __m512); 
#line 354
extern __m512 __cdecl _mm512_mask_sub_ps(__m512, __mmask16, __m512, __m512); 
#line 355
extern __m512 __cdecl _mm512_sub_round_ps(__m512, __m512, const int); 
#line 356
extern __m512 __cdecl _mm512_maskz_sub_round_ps(__mmask16, __m512, __m512, const int); 
#line 357
extern __m512 __cdecl _mm512_mask_sub_round_ps(__m512, __mmask16, __m512, __m512, const int); 
#line 358
extern __m512d __cdecl _mm512_sub_pd(__m512d, __m512d); 
#line 359
extern __m512d __cdecl _mm512_maskz_sub_pd(__mmask8, __m512d, __m512d); 
#line 360
extern __m512d __cdecl _mm512_mask_sub_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 361
extern __m512d __cdecl _mm512_sub_round_pd(__m512d, __m512d, const int); 
#line 362
extern __m512d __cdecl _mm512_maskz_sub_round_pd(__mmask8, __m512d, __m512d, const int); 
#line 363
extern __m512d __cdecl _mm512_mask_sub_round_pd(__m512d, __mmask8, __m512d, __m512d, const int); 
#line 365
extern __m512 __cdecl _mm512_mul_ps(__m512, __m512); 
#line 366
extern __m512 __cdecl _mm512_maskz_mul_ps(__mmask16, __m512, __m512); 
#line 367
extern __m512 __cdecl _mm512_mask_mul_ps(__m512, __mmask16, __m512, __m512); 
#line 368
extern __m512 __cdecl _mm512_mul_round_ps(__m512, __m512, const int); 
#line 369
extern __m512 __cdecl _mm512_maskz_mul_round_ps(__mmask16, __m512, __m512, const int); 
#line 370
extern __m512 __cdecl _mm512_mask_mul_round_ps(__m512, __mmask16, __m512, __m512, const int); 
#line 371
extern __m512d __cdecl _mm512_mul_pd(__m512d, __m512d); 
#line 372
extern __m512d __cdecl _mm512_maskz_mul_pd(__mmask8, __m512d, __m512d); 
#line 373
extern __m512d __cdecl _mm512_mask_mul_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 374
extern __m512d __cdecl _mm512_mul_round_pd(__m512d, __m512d, const int); 
#line 375
extern __m512d __cdecl _mm512_maskz_mul_round_pd(__mmask8, __m512d, __m512d, const int); 
#line 376
extern __m512d __cdecl _mm512_mask_mul_round_pd(__m512d, __mmask8, __m512d, __m512d, const int); 
#line 378
extern __m512 __cdecl _mm512_div_ps(__m512, __m512); 
#line 379
extern __m512 __cdecl _mm512_maskz_div_ps(__mmask16, __m512, __m512); 
#line 380
extern __m512 __cdecl _mm512_mask_div_ps(__m512, __mmask16, __m512, __m512); 
#line 381
extern __m512 __cdecl _mm512_div_round_ps(__m512, __m512, const int); 
#line 382
extern __m512 __cdecl _mm512_maskz_div_round_ps(__mmask16, __m512, __m512, const int); 
#line 383
extern __m512 __cdecl _mm512_mask_div_round_ps(__m512, __mmask16, __m512, __m512, const int); 
#line 384
extern __m512d __cdecl _mm512_div_pd(__m512d, __m512d); 
#line 385
extern __m512d __cdecl _mm512_maskz_div_pd(__mmask8, __m512d, __m512d); 
#line 386
extern __m512d __cdecl _mm512_mask_div_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 387
extern __m512d __cdecl _mm512_div_round_pd(__m512d, __m512d, const int); 
#line 388
extern __m512d __cdecl _mm512_maskz_div_round_pd(__mmask8, __m512d, __m512d, const int); 
#line 389
extern __m512d __cdecl _mm512_mask_div_round_pd(__m512d, __mmask8, __m512d, __m512d, const int); 
#line 391
extern __m512 __cdecl _mm512_fmadd_ps(__m512, __m512, __m512); 
#line 392
extern __m512 __cdecl _mm512_mask_fmadd_ps(__m512, __mmask16, __m512, __m512); 
#line 393
extern __m512 __cdecl _mm512_mask3_fmadd_ps(__m512, __m512, __m512, __mmask16); 
#line 394
extern __m512 __cdecl _mm512_maskz_fmadd_ps(__mmask16, __m512, __m512, __m512); 
#line 395
extern __m512 __cdecl _mm512_fmadd_round_ps(__m512, __m512, __m512, const int); 
#line 396
extern __m512 __cdecl _mm512_mask_fmadd_round_ps(__m512, __mmask16, __m512, __m512, const int); 
#line 397
extern __m512 __cdecl _mm512_mask3_fmadd_round_ps(__m512, __m512, __m512, __mmask16, const int); 
#line 398
extern __m512 __cdecl _mm512_maskz_fmadd_round_ps(__mmask16, __m512, __m512, __m512, const int); 
#line 399
extern __m512d __cdecl _mm512_fmadd_pd(__m512d, __m512d, __m512d); 
#line 400
extern __m512d __cdecl _mm512_mask_fmadd_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 401
extern __m512d __cdecl _mm512_mask3_fmadd_pd(__m512d, __m512d, __m512d, __mmask8); 
#line 402
extern __m512d __cdecl _mm512_maskz_fmadd_pd(__mmask8, __m512d, __m512d, __m512d); 
#line 403
extern __m512d __cdecl _mm512_fmadd_round_pd(__m512d, __m512d, __m512d, const int); 
#line 404
extern __m512d __cdecl _mm512_mask_fmadd_round_pd(__m512d, __mmask8, __m512d, __m512d, const int); 
#line 405
extern __m512d __cdecl _mm512_mask3_fmadd_round_pd(__m512d, __m512d, __m512d, __mmask8, const int); 
#line 406
extern __m512d __cdecl _mm512_maskz_fmadd_round_pd(__mmask8, __m512d, __m512d, __m512d, const int); 
#line 408
extern __m512 __cdecl _mm512_fmsub_ps(__m512, __m512, __m512); 
#line 409
extern __m512 __cdecl _mm512_mask_fmsub_ps(__m512, __mmask16, __m512, __m512); 
#line 410
extern __m512 __cdecl _mm512_mask3_fmsub_ps(__m512, __m512, __m512, __mmask16); 
#line 411
extern __m512 __cdecl _mm512_maskz_fmsub_ps(__mmask16, __m512, __m512, __m512); 
#line 412
extern __m512 __cdecl _mm512_fmsub_round_ps(__m512, __m512, __m512, const int); 
#line 413
extern __m512 __cdecl _mm512_mask_fmsub_round_ps(__m512, __mmask16, __m512, __m512, const int); 
#line 414
extern __m512 __cdecl _mm512_mask3_fmsub_round_ps(__m512, __m512, __m512, __mmask16, const int); 
#line 415
extern __m512 __cdecl _mm512_maskz_fmsub_round_ps(__mmask16, __m512, __m512, __m512, const int); 
#line 416
extern __m512d __cdecl _mm512_fmsub_pd(__m512d, __m512d, __m512d); 
#line 417
extern __m512d __cdecl _mm512_mask_fmsub_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 418
extern __m512d __cdecl _mm512_mask3_fmsub_pd(__m512d, __m512d, __m512d, __mmask8); 
#line 419
extern __m512d __cdecl _mm512_maskz_fmsub_pd(__mmask8, __m512d, __m512d, __m512d); 
#line 420
extern __m512d __cdecl _mm512_fmsub_round_pd(__m512d, __m512d, __m512d, const int); 
#line 421
extern __m512d __cdecl _mm512_mask_fmsub_round_pd(__m512d, __mmask8, __m512d, __m512d, const int); 
#line 422
extern __m512d __cdecl _mm512_mask3_fmsub_round_pd(__m512d, __m512d, __m512d, __mmask8, const int); 
#line 423
extern __m512d __cdecl _mm512_maskz_fmsub_round_pd(__mmask8, __m512d, __m512d, __m512d, const int); 
#line 425
extern __m512 __cdecl _mm512_fmaddsub_ps(__m512, __m512, __m512); 
#line 426
extern __m512 __cdecl _mm512_mask_fmaddsub_ps(__m512, __mmask16, __m512, __m512); 
#line 427
extern __m512 __cdecl _mm512_mask3_fmaddsub_ps(__m512, __m512, __m512, __mmask16); 
#line 428
extern __m512 __cdecl _mm512_maskz_fmaddsub_ps(__mmask16, __m512, __m512, __m512); 
#line 429
extern __m512 __cdecl _mm512_fmaddsub_round_ps(__m512, __m512, __m512, const int); 
#line 430
extern __m512 __cdecl _mm512_mask_fmaddsub_round_ps(__m512, __mmask16, __m512, __m512, const int); 
#line 431
extern __m512 __cdecl _mm512_mask3_fmaddsub_round_ps(__m512, __m512, __m512, __mmask16, const int); 
#line 432
extern __m512 __cdecl _mm512_maskz_fmaddsub_round_ps(__mmask16, __m512, __m512, __m512, const int); 
#line 433
extern __m512d __cdecl _mm512_fmaddsub_pd(__m512d, __m512d, __m512d); 
#line 434
extern __m512d __cdecl _mm512_mask_fmaddsub_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 435
extern __m512d __cdecl _mm512_mask3_fmaddsub_pd(__m512d, __m512d, __m512d, __mmask8); 
#line 436
extern __m512d __cdecl _mm512_maskz_fmaddsub_pd(__mmask8, __m512d, __m512d, __m512d); 
#line 437
extern __m512d __cdecl _mm512_fmaddsub_round_pd(__m512d, __m512d, __m512d, const int); 
#line 438
extern __m512d __cdecl _mm512_mask_fmaddsub_round_pd(__m512d, __mmask8, __m512d, __m512d, const int); 
#line 439
extern __m512d __cdecl _mm512_mask3_fmaddsub_round_pd(__m512d, __m512d, __m512d, __mmask8, const int); 
#line 440
extern __m512d __cdecl _mm512_maskz_fmaddsub_round_pd(__mmask8, __m512d, __m512d, __m512d, const int); 
#line 442
extern __m512 __cdecl _mm512_fmsubadd_ps(__m512, __m512, __m512); 
#line 443
extern __m512 __cdecl _mm512_mask_fmsubadd_ps(__m512, __mmask16, __m512, __m512); 
#line 444
extern __m512 __cdecl _mm512_mask3_fmsubadd_ps(__m512, __m512, __m512, __mmask16); 
#line 445
extern __m512 __cdecl _mm512_maskz_fmsubadd_ps(__mmask16, __m512, __m512, __m512); 
#line 446
extern __m512 __cdecl _mm512_fmsubadd_round_ps(__m512, __m512, __m512, const int); 
#line 447
extern __m512 __cdecl _mm512_mask_fmsubadd_round_ps(__m512, __mmask16, __m512, __m512, const int); 
#line 448
extern __m512 __cdecl _mm512_mask3_fmsubadd_round_ps(__m512, __m512, __m512, __mmask16, const int); 
#line 449
extern __m512 __cdecl _mm512_maskz_fmsubadd_round_ps(__mmask16, __m512, __m512, __m512, const int); 
#line 450
extern __m512d __cdecl _mm512_fmsubadd_pd(__m512d, __m512d, __m512d); 
#line 451
extern __m512d __cdecl _mm512_mask_fmsubadd_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 452
extern __m512d __cdecl _mm512_mask3_fmsubadd_pd(__m512d, __m512d, __m512d, __mmask8); 
#line 453
extern __m512d __cdecl _mm512_maskz_fmsubadd_pd(__mmask8, __m512d, __m512d, __m512d); 
#line 454
extern __m512d __cdecl _mm512_fmsubadd_round_pd(__m512d, __m512d, __m512d, const int); 
#line 455
extern __m512d __cdecl _mm512_mask_fmsubadd_round_pd(__m512d, __mmask8, __m512d, __m512d, const int); 
#line 456
extern __m512d __cdecl _mm512_mask3_fmsubadd_round_pd(__m512d, __m512d, __m512d, __mmask8, const int); 
#line 457
extern __m512d __cdecl _mm512_maskz_fmsubadd_round_pd(__mmask8, __m512d, __m512d, __m512d, const int); 
#line 459
extern __m512 __cdecl _mm512_fnmadd_ps(__m512, __m512, __m512); 
#line 460
extern __m512 __cdecl _mm512_mask_fnmadd_ps(__m512, __mmask16, __m512, __m512); 
#line 461
extern __m512 __cdecl _mm512_mask3_fnmadd_ps(__m512, __m512, __m512, __mmask16); 
#line 462
extern __m512 __cdecl _mm512_maskz_fnmadd_ps(__mmask16, __m512, __m512, __m512); 
#line 463
extern __m512 __cdecl _mm512_fnmadd_round_ps(__m512, __m512, __m512, const int); 
#line 464
extern __m512 __cdecl _mm512_mask_fnmadd_round_ps(__m512, __mmask16, __m512, __m512, const int); 
#line 465
extern __m512 __cdecl _mm512_mask3_fnmadd_round_ps(__m512, __m512, __m512, __mmask16, const int); 
#line 466
extern __m512 __cdecl _mm512_maskz_fnmadd_round_ps(__mmask16, __m512, __m512, __m512, const int); 
#line 467
extern __m512d __cdecl _mm512_fnmadd_pd(__m512d, __m512d, __m512d); 
#line 468
extern __m512d __cdecl _mm512_mask_fnmadd_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 469
extern __m512d __cdecl _mm512_mask3_fnmadd_pd(__m512d, __m512d, __m512d, __mmask8); 
#line 470
extern __m512d __cdecl _mm512_maskz_fnmadd_pd(__mmask8, __m512d, __m512d, __m512d); 
#line 471
extern __m512d __cdecl _mm512_fnmadd_round_pd(__m512d, __m512d, __m512d, const int); 
#line 472
extern __m512d __cdecl _mm512_mask_fnmadd_round_pd(__m512d, __mmask8, __m512d, __m512d, const int); 
#line 473
extern __m512d __cdecl _mm512_mask3_fnmadd_round_pd(__m512d, __m512d, __m512d, __mmask8, const int); 
#line 474
extern __m512d __cdecl _mm512_maskz_fnmadd_round_pd(__mmask8, __m512d, __m512d, __m512d, const int); 
#line 476
extern __m512 __cdecl _mm512_fnmsub_ps(__m512, __m512, __m512); 
#line 477
extern __m512 __cdecl _mm512_mask_fnmsub_ps(__m512, __mmask16, __m512, __m512); 
#line 478
extern __m512 __cdecl _mm512_mask3_fnmsub_ps(__m512, __m512, __m512, __mmask16); 
#line 479
extern __m512 __cdecl _mm512_maskz_fnmsub_ps(__mmask16, __m512, __m512, __m512); 
#line 480
extern __m512 __cdecl _mm512_fnmsub_round_ps(__m512, __m512, __m512, const int); 
#line 481
extern __m512 __cdecl _mm512_mask_fnmsub_round_ps(__m512, __mmask16, __m512, __m512, const int); 
#line 482
extern __m512 __cdecl _mm512_mask3_fnmsub_round_ps(__m512, __m512, __m512, __mmask16, const int); 
#line 483
extern __m512 __cdecl _mm512_maskz_fnmsub_round_ps(__mmask16, __m512, __m512, __m512, const int); 
#line 484
extern __m512d __cdecl _mm512_fnmsub_pd(__m512d, __m512d, __m512d); 
#line 485
extern __m512d __cdecl _mm512_mask_fnmsub_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 486
extern __m512d __cdecl _mm512_mask3_fnmsub_pd(__m512d, __m512d, __m512d, __mmask8); 
#line 487
extern __m512d __cdecl _mm512_maskz_fnmsub_pd(__mmask8, __m512d, __m512d, __m512d); 
#line 488
extern __m512d __cdecl _mm512_fnmsub_round_pd(__m512d, __m512d, __m512d, const int); 
#line 489
extern __m512d __cdecl _mm512_mask_fnmsub_round_pd(__m512d, __mmask8, __m512d, __m512d, const int); 
#line 490
extern __m512d __cdecl _mm512_mask3_fnmsub_round_pd(__m512d, __m512d, __m512d, __mmask8, const int); 
#line 491
extern __m512d __cdecl _mm512_maskz_fnmsub_round_pd(__mmask8, __m512d, __m512d, __m512d, const int); 
#line 493
extern __m512 __cdecl _mm512_sqrt_ps(__m512); 
#line 494
extern __m512d __cdecl _mm512_sqrt_pd(__m512d); 
#line 495
extern __m512 __cdecl _mm512_maskz_sqrt_ps(__mmask16, __m512); 
#line 496
extern __m512d __cdecl _mm512_maskz_sqrt_pd(__mmask8, __m512d); 
#line 497
extern __m512 __cdecl _mm512_mask_sqrt_ps(__m512, __mmask16, __m512); 
#line 498
extern __m512d __cdecl _mm512_mask_sqrt_pd(__m512d, __mmask8, __m512d); 
#line 499
extern __m512 __cdecl _mm512_sqrt_round_ps(__m512, const int); 
#line 500
extern __m512d __cdecl _mm512_sqrt_round_pd(__m512d, const int); 
#line 501
extern __m512 __cdecl _mm512_maskz_sqrt_round_ps(__mmask16, __m512, const int); 
#line 502
extern __m512d __cdecl _mm512_maskz_sqrt_round_pd(__mmask8, __m512d, const int); 
#line 503
extern __m512 __cdecl _mm512_mask_sqrt_round_ps(__m512, __mmask16, __m512, const int); 
#line 504
extern __m512d __cdecl _mm512_mask_sqrt_round_pd(__m512d, __mmask8, __m512d, const int); 
#line 506
extern __m512 __cdecl _mm512_abs_ps(__m512); 
#line 507
extern __m512 __cdecl _mm512_maskz_abs_ps(__mmask16, __m512); 
#line 508
extern __m512 __cdecl _mm512_mask_abs_ps(__m512, __mmask16, __m512); 
#line 509
extern __m512d __cdecl _mm512_abs_pd(__m512d); 
#line 510
extern __m512d __cdecl _mm512_maskz_abs_pd(__mmask8, __m512d); 
#line 511
extern __m512d __cdecl _mm512_mask_abs_pd(__m512d, __mmask8, __m512d); 
#line 513
extern __m512 __cdecl _mm512_max_ps(__m512, __m512); 
#line 514
extern __m512d __cdecl _mm512_max_pd(__m512d, __m512d); 
#line 515
extern __m512 __cdecl _mm512_maskz_max_ps(__mmask16, __m512, __m512); 
#line 516
extern __m512d __cdecl _mm512_maskz_max_pd(__mmask8, __m512d, __m512d); 
#line 517
extern __m512 __cdecl _mm512_mask_max_ps(__m512, __mmask16, __m512, __m512); 
#line 518
extern __m512d __cdecl _mm512_mask_max_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 519
extern __m512 __cdecl _mm512_max_round_ps(__m512, __m512, const int); 
#line 520
extern __m512d __cdecl _mm512_max_round_pd(__m512d, __m512d, const int); 
#line 521
extern __m512 __cdecl _mm512_maskz_max_round_ps(__mmask16, __m512, __m512, const int); 
#line 522
extern __m512d __cdecl _mm512_maskz_max_round_pd(__mmask8, __m512d, __m512d, const int); 
#line 523
extern __m512 __cdecl _mm512_mask_max_round_ps(__m512, __mmask16, __m512, __m512, const int); 
#line 524
extern __m512d __cdecl _mm512_mask_max_round_pd(__m512d, __mmask8, __m512d, __m512d, const int); 
#line 526
extern __m512 __cdecl _mm512_min_ps(__m512, __m512); 
#line 527
extern __m512d __cdecl _mm512_min_pd(__m512d, __m512d); 
#line 528
extern __m512 __cdecl _mm512_maskz_min_ps(__mmask16, __m512, __m512); 
#line 529
extern __m512d __cdecl _mm512_maskz_min_pd(__mmask8, __m512d, __m512d); 
#line 530
extern __m512 __cdecl _mm512_mask_min_ps(__m512, __mmask16, __m512, __m512); 
#line 531
extern __m512d __cdecl _mm512_mask_min_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 532
extern __m512 __cdecl _mm512_min_round_ps(__m512, __m512, const int); 
#line 533
extern __m512d __cdecl _mm512_min_round_pd(__m512d, __m512d, const int); 
#line 534
extern __m512 __cdecl _mm512_maskz_min_round_ps(__mmask16, __m512, __m512, const int); 
#line 535
extern __m512d __cdecl _mm512_maskz_min_round_pd(__mmask8, __m512d, __m512d, const int); 
#line 536
extern __m512 __cdecl _mm512_mask_min_round_ps(__m512, __mmask16, __m512, __m512, const int); 
#line 537
extern __m512d __cdecl _mm512_mask_min_round_pd(__m512d, __mmask8, __m512d, __m512d, const int); 
#line 539
extern __m512 __cdecl _mm512_rcp14_ps(__m512); 
#line 540
extern __m512d __cdecl _mm512_rcp14_pd(__m512d); 
#line 541
extern __m512 __cdecl _mm512_maskz_rcp14_ps(__mmask16, __m512); 
#line 542
extern __m512d __cdecl _mm512_maskz_rcp14_pd(__mmask8, __m512d); 
#line 543
extern __m512 __cdecl _mm512_mask_rcp14_ps(__m512, __mmask16, __m512); 
#line 544
extern __m512d __cdecl _mm512_mask_rcp14_pd(__m512d, __mmask8, __m512d); 
#line 546
extern __m512 __cdecl _mm512_rsqrt14_ps(__m512); 
#line 547
extern __m512d __cdecl _mm512_rsqrt14_pd(__m512d); 
#line 548
extern __m512 __cdecl _mm512_maskz_rsqrt14_ps(__mmask16, __m512); 
#line 549
extern __m512d __cdecl _mm512_maskz_rsqrt14_pd(__mmask8, __m512d); 
#line 550
extern __m512 __cdecl _mm512_mask_rsqrt14_ps(__m512, __mmask16, __m512); 
#line 551
extern __m512d __cdecl _mm512_mask_rsqrt14_pd(__m512d, __mmask8, __m512d); 
#line 553
extern __m512d __cdecl _mm512_cvtps_pd(__m256); 
#line 554
extern __m256 __cdecl _mm512_cvtpd_ps(__m512d); 
#line 555
extern __m512d __cdecl _mm512_maskz_cvtps_pd(__mmask8, __m256); 
#line 556
extern __m256 __cdecl _mm512_maskz_cvtpd_ps(__mmask8, __m512d); 
#line 557
extern __m512d __cdecl _mm512_mask_cvtps_pd(__m512d, __mmask8, __m256); 
#line 558
extern __m256 __cdecl _mm512_mask_cvtpd_ps(__m256, __mmask8, __m512d); 
#line 559
extern __m512d __cdecl _mm512_cvt_roundps_pd(__m256, const int); 
#line 560
extern __m256 __cdecl _mm512_cvt_roundpd_ps(__m512d, const int); 
#line 561
extern __m512d __cdecl _mm512_maskz_cvt_roundps_pd(__mmask8, __m256, const int); 
#line 562
extern __m256 __cdecl _mm512_maskz_cvt_roundpd_ps(__mmask8, __m512d, const int); 
#line 563
extern __m512d __cdecl _mm512_mask_cvt_roundps_pd(__m512d, __mmask8, __m256, const int); 
#line 564
extern __m256 __cdecl _mm512_mask_cvt_roundpd_ps(__m256, __mmask8, __m512d, const int); 
#line 566
extern __mmask16 __cdecl _mm512_cmp_ps_mask(__m512, __m512, const int); 
#line 567
extern __mmask16 __cdecl _mm512_mask_cmp_ps_mask(__mmask16, __m512, __m512, const int); 
#line 568
extern __mmask16 __cdecl _mm512_cmp_round_ps_mask(__m512, __m512, const int, const int); 
#line 569
extern __mmask16 __cdecl _mm512_mask_cmp_round_ps_mask(__mmask16, __m512, __m512, const int, const int); 
#line 570
extern __mmask8 __cdecl _mm512_cmp_pd_mask(__m512d, __m512d, const int); 
#line 571
extern __mmask8 __cdecl _mm512_mask_cmp_pd_mask(__mmask8, __m512d, __m512d, const int); 
#line 572
extern __mmask8 __cdecl _mm512_cmp_round_pd_mask(__m512d, __m512d, const int, const int); 
#line 573
extern __mmask8 __cdecl _mm512_mask_cmp_round_pd_mask(__mmask8, __m512d, __m512d, const int, const int); 
#line 575
extern __m512 __cdecl _mm512_broadcast_f32x2(__m128); 
#line 576
extern __m512 __cdecl _mm512_mask_broadcast_f32x2(__m512, __mmask16, __m128); 
#line 577
extern __m512 __cdecl _mm512_maskz_broadcast_f32x2(__mmask16, __m128); 
#line 578
extern __m512 __cdecl _mm512_broadcast_f32x4(__m128); 
#line 579
extern __m512 __cdecl _mm512_mask_broadcast_f32x4(__m512, __mmask16, __m128); 
#line 580
extern __m512 __cdecl _mm512_maskz_broadcast_f32x4(__mmask16, __m128); 
#line 581
extern __m512 __cdecl _mm512_broadcast_f32x8(__m256); 
#line 582
extern __m512 __cdecl _mm512_mask_broadcast_f32x8(__m512, __mmask16, __m256); 
#line 583
extern __m512 __cdecl _mm512_maskz_broadcast_f32x8(__mmask16, __m256); 
#line 584
extern __m512d __cdecl _mm512_broadcast_f64x2(__m128d); 
#line 585
extern __m512d __cdecl _mm512_mask_broadcast_f64x2(__m512d, __mmask8, __m128d); 
#line 586
extern __m512d __cdecl _mm512_maskz_broadcast_f64x2(__mmask8, __m128d); 
#line 587
extern __m512d __cdecl _mm512_broadcast_f64x4(__m256d); 
#line 588
extern __m512d __cdecl _mm512_mask_broadcast_f64x4(__m512d, __mmask8, __m256d); 
#line 589
extern __m512d __cdecl _mm512_maskz_broadcast_f64x4(__mmask8, __m256d); 
#line 590
extern __m512d __cdecl _mm512_broadcastsd_pd(__m128d); 
#line 591
extern __m512d __cdecl _mm512_mask_broadcastsd_pd(__m512d, __mmask8, __m128d); 
#line 592
extern __m512d __cdecl _mm512_maskz_broadcastsd_pd(__mmask8, __m128d); 
#line 593
extern __m512 __cdecl _mm512_broadcastss_ps(__m128); 
#line 594
extern __m512 __cdecl _mm512_mask_broadcastss_ps(__m512, __mmask16, __m128); 
#line 595
extern __m512 __cdecl _mm512_maskz_broadcastss_ps(__mmask16, __m128); 
#line 597
extern __m128 __cdecl _mm512_extractf32x4_ps(__m512, int); 
#line 598
extern __m128 __cdecl _mm512_mask_extractf32x4_ps(__m128, __mmask8, __m512, const int); 
#line 599
extern __m128 __cdecl _mm512_maskz_extractf32x4_ps(__mmask8, __m512, int); 
#line 600
extern __m256 __cdecl _mm512_extractf32x8_ps(__m512, int); 
#line 601
extern __m256 __cdecl _mm512_mask_extractf32x8_ps(__m256, __mmask8, __m512, const int); 
#line 602
extern __m256 __cdecl _mm512_maskz_extractf32x8_ps(__mmask8, __m512, int); 
#line 603
extern __m128d __cdecl _mm512_extractf64x2_pd(__m512d, int); 
#line 604
extern __m128d __cdecl _mm512_mask_extractf64x2_pd(__m128d, __mmask8, __m512d, const int); 
#line 605
extern __m128d __cdecl _mm512_maskz_extractf64x2_pd(__mmask8, __m512d, int); 
#line 606
extern __m256d __cdecl _mm512_extractf64x4_pd(__m512d, int); 
#line 607
extern __m256d __cdecl _mm512_mask_extractf64x4_pd(__m256d, __mmask8, __m512d, const int); 
#line 608
extern __m256d __cdecl _mm512_maskz_extractf64x4_pd(__mmask8, __m512d, int); 
#line 610
extern __m512 __cdecl _mm512_insertf32x4(__m512, __m128, int); 
#line 611
extern __m512 __cdecl _mm512_mask_insertf32x4(__m512, __mmask16, __m512, __m128, const int); 
#line 612
extern __m512 __cdecl _mm512_maskz_insertf32x4(__mmask16, __m512, __m128, int); 
#line 613
extern __m512 __cdecl _mm512_insertf32x8(__m512, __m256, int); 
#line 614
extern __m512 __cdecl _mm512_mask_insertf32x8(__m512, __mmask16, __m512, __m256, const int); 
#line 615
extern __m512 __cdecl _mm512_maskz_insertf32x8(__mmask16, __m512, __m256, int); 
#line 616
extern __m512d __cdecl _mm512_insertf64x2(__m512d, __m128d, int); 
#line 617
extern __m512d __cdecl _mm512_mask_insertf64x2(__m512d, __mmask8, __m512d, __m128d, const int); 
#line 618
extern __m512d __cdecl _mm512_maskz_insertf64x2(__mmask8, __m512d, __m128d, int); 
#line 619
extern __m512d __cdecl _mm512_insertf64x4(__m512d, __m256d, int); 
#line 620
extern __m512d __cdecl _mm512_mask_insertf64x4(__m512d, __mmask8, __m512d, __m256d, const int); 
#line 621
extern __m512d __cdecl _mm512_maskz_insertf64x4(__mmask8, __m512d, __m256d, int); 
#line 623
extern __m512 __cdecl _mm512_shuffle_f32x4(__m512, __m512, const int); 
#line 624
extern __m512 __cdecl _mm512_mask_shuffle_f32x4(__m512, __mmask16, __m512, __m512, const int); 
#line 625
extern __m512 __cdecl _mm512_maskz_shuffle_f32x4(__mmask16, __m512, __m512, const int); 
#line 626
extern __m512d __cdecl _mm512_shuffle_f64x2(__m512d, __m512d, const int); 
#line 627
extern __m512d __cdecl _mm512_mask_shuffle_f64x2(__m512d, __mmask8, __m512d, __m512d, const int); 
#line 628
extern __m512d __cdecl _mm512_maskz_shuffle_f64x2(__mmask8, __m512d, __m512d, const int); 
#line 629
extern __m512d __cdecl _mm512_shuffle_pd(__m512d, __m512d, const int); 
#line 630
extern __m512d __cdecl _mm512_mask_shuffle_pd(__m512d, __mmask8, __m512d, __m512d, const int); 
#line 631
extern __m512d __cdecl _mm512_maskz_shuffle_pd(__mmask8, __m512d, __m512d, const int); 
#line 632
extern __m512 __cdecl _mm512_shuffle_ps(__m512, __m512, const int); 
#line 633
extern __m512 __cdecl _mm512_mask_shuffle_ps(__m512, __mmask16, __m512, __m512, const int); 
#line 634
extern __m512 __cdecl _mm512_maskz_shuffle_ps(__mmask16, __m512, __m512, const int); 
#line 636
extern __mmask16 _mm512_cmpeq_ps_mask(__m512, __m512); 
#line 637
extern __mmask16 _mm512_cmple_ps_mask(__m512, __m512); 
#line 638
extern __mmask16 _mm512_cmplt_ps_mask(__m512, __m512); 
#line 639
extern __mmask16 _mm512_cmpneq_ps_mask(__m512, __m512); 
#line 640
extern __mmask16 _mm512_cmpnle_ps_mask(__m512, __m512); 
#line 641
extern __mmask16 _mm512_cmpnlt_ps_mask(__m512, __m512); 
#line 642
extern __mmask16 _mm512_cmpord_ps_mask(__m512, __m512); 
#line 643
extern __mmask16 _mm512_cmpunord_ps_mask(__m512, __m512); 
#line 645
extern __mmask16 _mm512_mask_cmpeq_ps_mask(__mmask16, __m512, __m512); 
#line 646
extern __mmask16 _mm512_mask_cmple_ps_mask(__mmask16, __m512, __m512); 
#line 647
extern __mmask16 _mm512_mask_cmplt_ps_mask(__mmask16, __m512, __m512); 
#line 648
extern __mmask16 _mm512_mask_cmpneq_ps_mask(__mmask16, __m512, __m512); 
#line 649
extern __mmask16 _mm512_mask_cmpnle_ps_mask(__mmask16, __m512, __m512); 
#line 650
extern __mmask16 _mm512_mask_cmpnlt_ps_mask(__mmask16, __m512, __m512); 
#line 651
extern __mmask16 _mm512_mask_cmpord_ps_mask(__mmask16, __m512, __m512); 
#line 652
extern __mmask16 _mm512_mask_cmpunord_ps_mask(__mmask16, __m512, __m512); 
#line 654
extern __mmask8 _mm512_cmpeq_pd_mask(__m512d, __m512d); 
#line 655
extern __mmask8 _mm512_cmple_pd_mask(__m512d, __m512d); 
#line 656
extern __mmask8 _mm512_cmplt_pd_mask(__m512d, __m512d); 
#line 657
extern __mmask8 _mm512_cmpneq_pd_mask(__m512d, __m512d); 
#line 658
extern __mmask8 _mm512_cmpnle_pd_mask(__m512d, __m512d); 
#line 659
extern __mmask8 _mm512_cmpnlt_pd_mask(__m512d, __m512d); 
#line 660
extern __mmask8 _mm512_cmpord_pd_mask(__m512d, __m512d); 
#line 661
extern __mmask8 _mm512_cmpunord_pd_mask(__m512d, __m512d); 
#line 663
extern __mmask8 _mm512_mask_cmpeq_pd_mask(__mmask8, __m512d, __m512d); 
#line 664
extern __mmask8 _mm512_mask_cmple_pd_mask(__mmask8, __m512d, __m512d); 
#line 665
extern __mmask8 _mm512_mask_cmplt_pd_mask(__mmask8, __m512d, __m512d); 
#line 666
extern __mmask8 _mm512_mask_cmpneq_pd_mask(__mmask8, __m512d, __m512d); 
#line 667
extern __mmask8 _mm512_mask_cmpnle_pd_mask(__mmask8, __m512d, __m512d); 
#line 668
extern __mmask8 _mm512_mask_cmpnlt_pd_mask(__mmask8, __m512d, __m512d); 
#line 669
extern __mmask8 _mm512_mask_cmpord_pd_mask(__mmask8, __m512d, __m512d); 
#line 670
extern __mmask8 _mm512_mask_cmpunord_pd_mask(__mmask8, __m512d, __m512d); 
#line 708
extern __m512i __cdecl _mm512_setzero_si512(); 
#line 710
extern __m512i __cdecl _mm512_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char); 
#line 714
extern __m512i __cdecl _mm512_set_epi16(short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short); 
#line 716
extern __m512i __cdecl _mm512_set_epi32(int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int); 
#line 717
extern __m512i __cdecl _mm512_set_epi64(__int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64); 
#line 719
extern __m512i __cdecl _mm512_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char); 
#line 723
extern __m512i __cdecl _mm512_setr_epi16(short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short); 
#line 725
extern __m512i __cdecl _mm512_setr_epi32(int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int); 
#line 726
extern __m512i __cdecl _mm512_setr_epi64(__int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64); 
#line 728
extern __m512i __cdecl _mm512_set1_epi8(char); 
#line 729
extern __m512i __cdecl _mm512_mask_set1_epi8(__m512i, __mmask64, char); 
#line 730
extern __m512i __cdecl _mm512_maskz_set1_epi8(__mmask64, char); 
#line 731
extern __m512i __cdecl _mm512_set1_epi16(short); 
#line 732
extern __m512i __cdecl _mm512_mask_set1_epi16(__m512i, __mmask32, short); 
#line 733
extern __m512i __cdecl _mm512_maskz_set1_epi16(__mmask32, short); 
#line 734
extern __m512i __cdecl _mm512_set1_epi32(int); 
#line 735
extern __m512i __cdecl _mm512_mask_set1_epi32(__m512i, __mmask16, int); 
#line 736
extern __m512i __cdecl _mm512_maskz_set1_epi32(__mmask16, int); 
#line 737
extern __m512i __cdecl _mm512_set1_epi64(__int64); 
#line 738
extern __m512i __cdecl _mm512_mask_set1_epi64(__m512i, __mmask8, __int64); 
#line 739
extern __m512i __cdecl _mm512_maskz_set1_epi64(__mmask8, __int64); 
#line 741
extern __m512i __cdecl _mm512_add_epi8(__m512i, __m512i); 
#line 742
extern __m512i __cdecl _mm512_mask_add_epi8(__m512i, __mmask64, __m512i, __m512i); 
#line 743
extern __m512i __cdecl _mm512_maskz_add_epi8(__mmask64, __m512i, __m512i); 
#line 744
extern __m512i __cdecl _mm512_add_epi16(__m512i, __m512i); 
#line 745
extern __m512i __cdecl _mm512_mask_add_epi16(__m512i, __mmask32, __m512i, __m512i); 
#line 746
extern __m512i __cdecl _mm512_maskz_add_epi16(__mmask32, __m512i, __m512i); 
#line 747
extern __m512i __cdecl _mm512_add_epi32(__m512i, __m512i); 
#line 748
extern __m512i __cdecl _mm512_mask_add_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 749
extern __m512i __cdecl _mm512_maskz_add_epi32(__mmask16, __m512i, __m512i); 
#line 750
extern __m512i __cdecl _mm512_add_epi64(__m512i, __m512i); 
#line 751
extern __m512i __cdecl _mm512_mask_add_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 752
extern __m512i __cdecl _mm512_maskz_add_epi64(__mmask8, __m512i, __m512i); 
#line 753
extern __m512i __cdecl _mm512_adds_epi8(__m512i, __m512i); 
#line 754
extern __m512i __cdecl _mm512_mask_adds_epi8(__m512i, __mmask64, __m512i, __m512i); 
#line 755
extern __m512i __cdecl _mm512_maskz_adds_epi8(__mmask64, __m512i, __m512i); 
#line 756
extern __m512i __cdecl _mm512_adds_epi16(__m512i, __m512i); 
#line 757
extern __m512i __cdecl _mm512_mask_adds_epi16(__m512i, __mmask32, __m512i, __m512i); 
#line 758
extern __m512i __cdecl _mm512_maskz_adds_epi16(__mmask32, __m512i, __m512i); 
#line 759
extern __m512i __cdecl _mm512_adds_epu8(__m512i, __m512i); 
#line 760
extern __m512i __cdecl _mm512_mask_adds_epu8(__m512i, __mmask64, __m512i, __m512i); 
#line 761
extern __m512i __cdecl _mm512_maskz_adds_epu8(__mmask64, __m512i, __m512i); 
#line 762
extern __m512i __cdecl _mm512_adds_epu16(__m512i, __m512i); 
#line 763
extern __m512i __cdecl _mm512_mask_adds_epu16(__m512i, __mmask32, __m512i, __m512i); 
#line 764
extern __m512i __cdecl _mm512_maskz_adds_epu16(__mmask32, __m512i, __m512i); 
#line 766
extern __m512i __cdecl _mm512_abs_epi8(__m512i); 
#line 767
extern __m512i __cdecl _mm512_mask_abs_epi8(__m512i, __mmask64, __m512i); 
#line 768
extern __m512i __cdecl _mm512_maskz_abs_epi8(__mmask64, __m512i); 
#line 769
extern __m512i __cdecl _mm512_abs_epi16(__m512i); 
#line 770
extern __m512i __cdecl _mm512_mask_abs_epi16(__m512i, __mmask32, __m512i); 
#line 771
extern __m512i __cdecl _mm512_maskz_abs_epi16(__mmask32, __m512i); 
#line 772
extern __m512i __cdecl _mm512_abs_epi32(__m512i); 
#line 773
extern __m512i __cdecl _mm512_mask_abs_epi32(__m512i, __mmask16, __m512i); 
#line 774
extern __m512i __cdecl _mm512_maskz_abs_epi32(__mmask16, __m512i); 
#line 775
extern __m512i __cdecl _mm512_abs_epi64(__m512i); 
#line 776
extern __m512i __cdecl _mm512_mask_abs_epi64(__m512i, __mmask8, __m512i); 
#line 777
extern __m512i __cdecl _mm512_maskz_abs_epi64(__mmask8, __m512i); 
#line 779
extern __m512i __cdecl _mm512_broadcast_i32x2(__m128i); 
#line 780
extern __m512i __cdecl _mm512_mask_broadcast_i32x2(__m512i, __mmask16, __m128i); 
#line 781
extern __m512i __cdecl _mm512_maskz_broadcast_i32x2(__mmask16, __m128i); 
#line 782
extern __m512i __cdecl _mm512_broadcast_i32x4(__m128i); 
#line 783
extern __m512i __cdecl _mm512_mask_broadcast_i32x4(__m512i, __mmask16, __m128i); 
#line 784
extern __m512i __cdecl _mm512_maskz_broadcast_i32x4(__mmask16, __m128i); 
#line 785
extern __m512i __cdecl _mm512_broadcast_i32x8(__m256i); 
#line 786
extern __m512i __cdecl _mm512_mask_broadcast_i32x8(__m512i, __mmask16, __m256i); 
#line 787
extern __m512i __cdecl _mm512_maskz_broadcast_i32x8(__mmask16, __m256i); 
#line 788
extern __m512i __cdecl _mm512_broadcast_i64x2(__m128i); 
#line 789
extern __m512i __cdecl _mm512_mask_broadcast_i64x2(__m512i, __mmask8, __m128i); 
#line 790
extern __m512i __cdecl _mm512_maskz_broadcast_i64x2(__mmask8, __m128i); 
#line 791
extern __m512i __cdecl _mm512_broadcast_i64x4(__m256i); 
#line 792
extern __m512i __cdecl _mm512_mask_broadcast_i64x4(__m512i, __mmask8, __m256i); 
#line 793
extern __m512i __cdecl _mm512_maskz_broadcast_i64x4(__mmask8, __m256i); 
#line 794
extern __m512i __cdecl _mm512_broadcastb_epi8(__m128i); 
#line 795
extern __m512i __cdecl _mm512_mask_broadcastb_epi8(__m512i, __mmask64, __m128i); 
#line 796
extern __m512i __cdecl _mm512_maskz_broadcastb_epi8(__mmask64, __m128i); 
#line 797
extern __m512i __cdecl _mm512_broadcastw_epi16(__m128i); 
#line 798
extern __m512i __cdecl _mm512_mask_broadcastw_epi16(__m512i, __mmask32, __m128i); 
#line 799
extern __m512i __cdecl _mm512_maskz_broadcastw_epi16(__mmask32, __m128i); 
#line 800
extern __m512i __cdecl _mm512_broadcastd_epi32(__m128i); 
#line 801
extern __m512i __cdecl _mm512_mask_broadcastd_epi32(__m512i, __mmask16, __m128i); 
#line 802
extern __m512i __cdecl _mm512_maskz_broadcastd_epi32(__mmask16, __m128i); 
#line 803
extern __m512i __cdecl _mm512_broadcastq_epi64(__m128i); 
#line 804
extern __m512i __cdecl _mm512_mask_broadcastq_epi64(__m512i, __mmask8, __m128i); 
#line 805
extern __m512i __cdecl _mm512_maskz_broadcastq_epi64(__mmask8, __m128i); 
#line 806
extern __m512i __cdecl _mm512_broadcastmw_epi32(__mmask16); 
#line 807
extern __m512i __cdecl _mm512_broadcastmb_epi64(__mmask8); 
#line 809
extern __m512i __cdecl _mm512_sub_epi8(__m512i, __m512i); 
#line 810
extern __m512i __cdecl _mm512_mask_sub_epi8(__m512i, __mmask64, __m512i, __m512i); 
#line 811
extern __m512i __cdecl _mm512_maskz_sub_epi8(__mmask64, __m512i, __m512i); 
#line 812
extern __m512i __cdecl _mm512_sub_epi16(__m512i, __m512i); 
#line 813
extern __m512i __cdecl _mm512_mask_sub_epi16(__m512i, __mmask32, __m512i, __m512i); 
#line 814
extern __m512i __cdecl _mm512_maskz_sub_epi16(__mmask32, __m512i, __m512i); 
#line 815
extern __m512i __cdecl _mm512_sub_epi32(__m512i, __m512i); 
#line 816
extern __m512i __cdecl _mm512_mask_sub_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 817
extern __m512i __cdecl _mm512_maskz_sub_epi32(__mmask16, __m512i, __m512i); 
#line 818
extern __m512i __cdecl _mm512_sub_epi64(__m512i, __m512i); 
#line 819
extern __m512i __cdecl _mm512_mask_sub_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 820
extern __m512i __cdecl _mm512_maskz_sub_epi64(__mmask8, __m512i, __m512i); 
#line 821
extern __m512i __cdecl _mm512_subs_epi8(__m512i, __m512i); 
#line 822
extern __m512i __cdecl _mm512_mask_subs_epi8(__m512i, __mmask64, __m512i, __m512i); 
#line 823
extern __m512i __cdecl _mm512_maskz_subs_epi8(__mmask64, __m512i, __m512i); 
#line 824
extern __m512i __cdecl _mm512_subs_epi16(__m512i, __m512i); 
#line 825
extern __m512i __cdecl _mm512_mask_subs_epi16(__m512i, __mmask32, __m512i, __m512i); 
#line 826
extern __m512i __cdecl _mm512_maskz_subs_epi16(__mmask32, __m512i, __m512i); 
#line 827
extern __m512i __cdecl _mm512_subs_epu8(__m512i, __m512i); 
#line 828
extern __m512i __cdecl _mm512_mask_subs_epu8(__m512i, __mmask64, __m512i, __m512i); 
#line 829
extern __m512i __cdecl _mm512_maskz_subs_epu8(__mmask64, __m512i, __m512i); 
#line 830
extern __m512i __cdecl _mm512_subs_epu16(__m512i, __m512i); 
#line 831
extern __m512i __cdecl _mm512_mask_subs_epu16(__m512i, __mmask32, __m512i, __m512i); 
#line 832
extern __m512i __cdecl _mm512_maskz_subs_epu16(__mmask32, __m512i, __m512i); 
#line 834
extern __m512i __cdecl _mm512_max_epi8(__m512i, __m512i); 
#line 835
extern __m512i __cdecl _mm512_mask_max_epi8(__m512i, __mmask64, __m512i, __m512i); 
#line 836
extern __m512i __cdecl _mm512_maskz_max_epi8(__mmask64, __m512i, __m512i); 
#line 837
extern __m512i __cdecl _mm512_max_epi16(__m512i, __m512i); 
#line 838
extern __m512i __cdecl _mm512_mask_max_epi16(__m512i, __mmask32, __m512i, __m512i); 
#line 839
extern __m512i __cdecl _mm512_maskz_max_epi16(__mmask32, __m512i, __m512i); 
#line 840
extern __m512i __cdecl _mm512_max_epi32(__m512i, __m512i); 
#line 841
extern __m512i __cdecl _mm512_mask_max_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 842
extern __m512i __cdecl _mm512_maskz_max_epi32(__mmask16, __m512i, __m512i); 
#line 843
extern __m512i __cdecl _mm512_max_epi64(__m512i, __m512i); 
#line 844
extern __m512i __cdecl _mm512_mask_max_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 845
extern __m512i __cdecl _mm512_maskz_max_epi64(__mmask8, __m512i, __m512i); 
#line 846
extern __m512i __cdecl _mm512_max_epu8(__m512i, __m512i); 
#line 847
extern __m512i __cdecl _mm512_mask_max_epu8(__m512i, __mmask64, __m512i, __m512i); 
#line 848
extern __m512i __cdecl _mm512_maskz_max_epu8(__mmask64, __m512i, __m512i); 
#line 849
extern __m512i __cdecl _mm512_max_epu16(__m512i, __m512i); 
#line 850
extern __m512i __cdecl _mm512_mask_max_epu16(__m512i, __mmask32, __m512i, __m512i); 
#line 851
extern __m512i __cdecl _mm512_maskz_max_epu16(__mmask32, __m512i, __m512i); 
#line 852
extern __m512i __cdecl _mm512_max_epu32(__m512i, __m512i); 
#line 853
extern __m512i __cdecl _mm512_mask_max_epu32(__m512i, __mmask16, __m512i, __m512i); 
#line 854
extern __m512i __cdecl _mm512_maskz_max_epu32(__mmask16, __m512i, __m512i); 
#line 855
extern __m512i __cdecl _mm512_max_epu64(__m512i, __m512i); 
#line 856
extern __m512i __cdecl _mm512_mask_max_epu64(__m512i, __mmask8, __m512i, __m512i); 
#line 857
extern __m512i __cdecl _mm512_maskz_max_epu64(__mmask8, __m512i, __m512i); 
#line 859
extern __m512i __cdecl _mm512_min_epi8(__m512i, __m512i); 
#line 860
extern __m512i __cdecl _mm512_mask_min_epi8(__m512i, __mmask64, __m512i, __m512i); 
#line 861
extern __m512i __cdecl _mm512_maskz_min_epi8(__mmask64, __m512i, __m512i); 
#line 862
extern __m512i __cdecl _mm512_min_epi16(__m512i, __m512i); 
#line 863
extern __m512i __cdecl _mm512_mask_min_epi16(__m512i, __mmask32, __m512i, __m512i); 
#line 864
extern __m512i __cdecl _mm512_maskz_min_epi16(__mmask32, __m512i, __m512i); 
#line 865
extern __m512i __cdecl _mm512_min_epi32(__m512i, __m512i); 
#line 866
extern __m512i __cdecl _mm512_mask_min_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 867
extern __m512i __cdecl _mm512_maskz_min_epi32(__mmask16, __m512i, __m512i); 
#line 868
extern __m512i __cdecl _mm512_min_epi64(__m512i, __m512i); 
#line 869
extern __m512i __cdecl _mm512_mask_min_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 870
extern __m512i __cdecl _mm512_maskz_min_epi64(__mmask8, __m512i, __m512i); 
#line 871
extern __m512i __cdecl _mm512_min_epu8(__m512i, __m512i); 
#line 872
extern __m512i __cdecl _mm512_mask_min_epu8(__m512i, __mmask64, __m512i, __m512i); 
#line 873
extern __m512i __cdecl _mm512_maskz_min_epu8(__mmask64, __m512i, __m512i); 
#line 874
extern __m512i __cdecl _mm512_min_epu16(__m512i, __m512i); 
#line 875
extern __m512i __cdecl _mm512_mask_min_epu16(__m512i, __mmask32, __m512i, __m512i); 
#line 876
extern __m512i __cdecl _mm512_maskz_min_epu16(__mmask32, __m512i, __m512i); 
#line 877
extern __m512i __cdecl _mm512_min_epu32(__m512i, __m512i); 
#line 878
extern __m512i __cdecl _mm512_mask_min_epu32(__m512i, __mmask16, __m512i, __m512i); 
#line 879
extern __m512i __cdecl _mm512_maskz_min_epu32(__mmask16, __m512i, __m512i); 
#line 880
extern __m512i __cdecl _mm512_min_epu64(__m512i, __m512i); 
#line 881
extern __m512i __cdecl _mm512_mask_min_epu64(__m512i, __mmask8, __m512i, __m512i); 
#line 882
extern __m512i __cdecl _mm512_maskz_min_epu64(__mmask8, __m512i, __m512i); 
#line 884
extern __m512i __cdecl _mm512_mul_epi32(__m512i, __m512i); 
#line 885
extern __m512i __cdecl _mm512_mask_mul_epi32(__m512i, __mmask8, __m512i, __m512i); 
#line 886
extern __m512i __cdecl _mm512_maskz_mul_epi32(__mmask8, __m512i, __m512i); 
#line 887
extern __m512i __cdecl _mm512_mul_epu32(__m512i, __m512i); 
#line 888
extern __m512i __cdecl _mm512_mask_mul_epu32(__m512i, __mmask8, __m512i, __m512i); 
#line 889
extern __m512i __cdecl _mm512_maskz_mul_epu32(__mmask8, __m512i, __m512i); 
#line 890
extern __m512i __cdecl _mm512_mulhi_epi16(__m512i, __m512i); 
#line 891
extern __m512i __cdecl _mm512_mask_mulhi_epi16(__m512i, __mmask32, __m512i, __m512i); 
#line 892
extern __m512i __cdecl _mm512_maskz_mulhi_epi16(__mmask32, __m512i, __m512i); 
#line 893
extern __m512i __cdecl _mm512_mulhi_epu16(__m512i, __m512i); 
#line 894
extern __m512i __cdecl _mm512_mask_mulhi_epu16(__m512i, __mmask32, __m512i, __m512i); 
#line 895
extern __m512i __cdecl _mm512_maskz_mulhi_epu16(__mmask32, __m512i, __m512i); 
#line 896
extern __m512i __cdecl _mm512_mullo_epi16(__m512i, __m512i); 
#line 897
extern __m512i __cdecl _mm512_mask_mullo_epi16(__m512i, __mmask32, __m512i, __m512i); 
#line 898
extern __m512i __cdecl _mm512_maskz_mullo_epi16(__mmask32, __m512i, __m512i); 
#line 899
extern __m512i __cdecl _mm512_mullo_epi32(__m512i, __m512i); 
#line 900
extern __m512i __cdecl _mm512_mask_mullo_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 901
extern __m512i __cdecl _mm512_maskz_mullo_epi32(__mmask16, __m512i, __m512i); 
#line 902
extern __m512i __cdecl _mm512_mullo_epi64(__m512i, __m512i); 
#line 903
extern __m512i __cdecl _mm512_mask_mullo_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 904
extern __m512i __cdecl _mm512_maskz_mullo_epi64(__mmask8, __m512i, __m512i); 
#line 905
extern __m512i __cdecl _mm512_mullox_epi64(__m512i, __m512i); 
#line 906
extern __m512i __cdecl _mm512_mask_mullox_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 907
extern __m512i __cdecl _mm512_mulhrs_epi16(__m512i, __m512i); 
#line 908
extern __m512i __cdecl _mm512_mask_mulhrs_epi16(__m512i, __mmask32, __m512i, __m512i); 
#line 909
extern __m512i __cdecl _mm512_maskz_mulhrs_epi16(__mmask32, __m512i, __m512i); 
#line 911
extern __m512i __cdecl _mm512_load_epi32(const void *); 
#line 912
extern __m512i __cdecl _mm512_mask_load_epi32(__m512i, __mmask16, const void *); 
#line 913
extern __m512i __cdecl _mm512_maskz_load_epi32(__mmask16, const void *); 
#line 914
extern __m512i __cdecl _mm512_load_epi64(const void *); 
#line 915
extern __m512i __cdecl _mm512_mask_load_epi64(__m512i, __mmask8, const void *); 
#line 916
extern __m512i __cdecl _mm512_maskz_load_epi64(__mmask8, const void *); 
#line 917
extern __m512i __cdecl _mm512_loadu_epi8(const void *); 
#line 918
extern __m512i __cdecl _mm512_mask_loadu_epi8(__m512i, __mmask64, const void *); 
#line 919
extern __m512i __cdecl _mm512_maskz_loadu_epi8(__mmask64, const void *); 
#line 920
extern __m512i __cdecl _mm512_loadu_epi16(const void *); 
#line 921
extern __m512i __cdecl _mm512_mask_loadu_epi16(__m512i, __mmask32, const void *); 
#line 922
extern __m512i __cdecl _mm512_maskz_loadu_epi16(__mmask32, const void *); 
#line 923
extern __m512i __cdecl _mm512_loadu_epi32(const void *); 
#line 924
extern __m512i __cdecl _mm512_mask_loadu_epi32(__m512i, __mmask16, const void *); 
#line 925
extern __m512i __cdecl _mm512_maskz_loadu_epi32(__mmask16, const void *); 
#line 926
extern __m512i __cdecl _mm512_loadu_epi64(const void *); 
#line 927
extern __m512i __cdecl _mm512_mask_loadu_epi64(__m512i, __mmask8, const void *); 
#line 928
extern __m512i __cdecl _mm512_maskz_loadu_epi64(__mmask8, const void *); 
#line 930
extern void __cdecl _mm512_store_epi32(void *, __m512i); 
#line 931
extern void __cdecl _mm512_mask_store_epi32(void *, __mmask16, __m512i); 
#line 932
extern void __cdecl _mm512_store_epi64(void *, __m512i); 
#line 933
extern void __cdecl _mm512_mask_store_epi64(void *, __mmask8, __m512i); 
#line 934
extern void __cdecl _mm512_storeu_epi8(void *, __m512i); 
#line 935
extern void __cdecl _mm512_mask_storeu_epi8(void *, __mmask64, __m512i); 
#line 936
extern void __cdecl _mm512_storeu_epi16(void *, __m512i); 
#line 937
extern void __cdecl _mm512_mask_storeu_epi16(void *, __mmask32, __m512i); 
#line 938
extern void __cdecl _mm512_storeu_epi32(void *, __m512i); 
#line 939
extern void __cdecl _mm512_mask_storeu_epi32(void *, __mmask16, __m512i); 
#line 940
extern void __cdecl _mm512_storeu_epi64(void *, __m512i); 
#line 941
extern void __cdecl _mm512_mask_storeu_epi64(void *, __mmask8, __m512i); 
#line 943
extern __m128i __cdecl _mm512_extracti32x4_epi32(__m512i, int); 
#line 944
extern __m128i __cdecl _mm512_mask_extracti32x4_epi32(__m128i, __mmask8, __m512i, int); 
#line 945
extern __m128i __cdecl _mm512_maskz_extracti32x4_epi32(__mmask8, __m512i, int); 
#line 946
extern __m256i __cdecl _mm512_extracti32x8_epi32(__m512i, int); 
#line 947
extern __m256i __cdecl _mm512_mask_extracti32x8_epi32(__m256i, __mmask8, __m512i, int); 
#line 948
extern __m256i __cdecl _mm512_maskz_extracti32x8_epi32(__mmask8, __m512i, int); 
#line 949
extern __m128i __cdecl _mm512_extracti64x2_epi64(__m512i, int); 
#line 950
extern __m128i __cdecl _mm512_mask_extracti64x2_epi64(__m128i, __mmask8, __m512i, int); 
#line 951
extern __m128i __cdecl _mm512_maskz_extracti64x2_epi64(__mmask8, __m512i, int); 
#line 952
extern __m256i __cdecl _mm512_extracti64x4_epi64(__m512i, int); 
#line 953
extern __m256i __cdecl _mm512_mask_extracti64x4_epi64(__m256i, __mmask8, __m512i, int); 
#line 954
extern __m256i __cdecl _mm512_maskz_extracti64x4_epi64(__mmask8, __m512i, int); 
#line 956
extern __m512i __cdecl _mm512_inserti32x4(__m512i, __m128i, int); 
#line 957
extern __m512i __cdecl _mm512_mask_inserti32x4(__m512i, __mmask16, __m512i, __m128i, int); 
#line 958
extern __m512i __cdecl _mm512_maskz_inserti32x4(__mmask16, __m512i, __m128i, int); 
#line 959
extern __m512i __cdecl _mm512_inserti32x8(__m512i, __m256i, int); 
#line 960
extern __m512i __cdecl _mm512_mask_inserti32x8(__m512i, __mmask16, __m512i, __m256i, int); 
#line 961
extern __m512i __cdecl _mm512_maskz_inserti32x8(__mmask16, __m512i, __m256i, int); 
#line 962
extern __m512i __cdecl _mm512_inserti64x2(__m512i, __m128i, int); 
#line 963
extern __m512i __cdecl _mm512_mask_inserti64x2(__m512i, __mmask8, __m512i, __m128i, int); 
#line 964
extern __m512i __cdecl _mm512_maskz_inserti64x2(__mmask8, __m512i, __m128i, int); 
#line 965
extern __m512i __cdecl _mm512_inserti64x4(__m512i, __m256i, int); 
#line 966
extern __m512i __cdecl _mm512_mask_inserti64x4(__m512i, __mmask8, __m512i, __m256i, int); 
#line 967
extern __m512i __cdecl _mm512_maskz_inserti64x4(__mmask8, __m512i, __m256i, int); 
#line 969
extern __m512i __cdecl _mm512_shuffle_epi8(__m512i, __m512i); 
#line 970
extern __m512i __cdecl _mm512_mask_shuffle_epi8(__m512i, __mmask64, __m512i, __m512i); 
#line 971
extern __m512i __cdecl _mm512_maskz_shuffle_epi8(__mmask64, __m512i, __m512i); 
#line 972
extern __m512i __cdecl _mm512_shuffle_epi32(__m512i, int); 
#line 973
extern __m512i __cdecl _mm512_mask_shuffle_epi32(__m512i, __mmask16, __m512i, int); 
#line 974
extern __m512i __cdecl _mm512_maskz_shuffle_epi32(__mmask16, __m512i, int); 
#line 975
extern __m512i __cdecl _mm512_shuffle_i32x4(__m512i, __m512i, const int); 
#line 976
extern __m512i __cdecl _mm512_mask_shuffle_i32x4(__m512i, __mmask16, __m512i, __m512i, const int); 
#line 977
extern __m512i __cdecl _mm512_maskz_shuffle_i32x4(__mmask16, __m512i, __m512i, const int); 
#line 978
extern __m512i __cdecl _mm512_shuffle_i64x2(__m512i, __m512i, const int); 
#line 979
extern __m512i __cdecl _mm512_mask_shuffle_i64x2(__m512i, __mmask8, __m512i, __m512i, const int); 
#line 980
extern __m512i __cdecl _mm512_maskz_shuffle_i64x2(__mmask8, __m512i, __m512i, const int); 
#line 981
extern __m512i __cdecl _mm512_shufflehi_epi16(__m512i, int); 
#line 982
extern __m512i __cdecl _mm512_mask_shufflehi_epi16(__m512i, __mmask32, __m512i, int); 
#line 983
extern __m512i __cdecl _mm512_maskz_shufflehi_epi16(__mmask32, __m512i, int); 
#line 984
extern __m512i __cdecl _mm512_shufflelo_epi16(__m512i, int); 
#line 985
extern __m512i __cdecl _mm512_mask_shufflelo_epi16(__m512i, __mmask32, __m512i, int); 
#line 986
extern __m512i __cdecl _mm512_maskz_shufflelo_epi16(__mmask32, __m512i, int); 
#line 988
extern __m512 __cdecl _mm512_mask_mov_ps(__m512, __mmask16, __m512); 
#line 989
extern __m512 __cdecl _mm512_maskz_mov_ps(__mmask16, __m512); 
#line 990
extern __m512d __cdecl _mm512_mask_mov_pd(__m512d, __mmask8, __m512d); 
#line 991
extern __m512d __cdecl _mm512_maskz_mov_pd(__mmask8, __m512d); 
#line 992
extern __m512i __cdecl _mm512_mask_mov_epi8(__m512i, __mmask64, __m512i); 
#line 993
extern __m512i __cdecl _mm512_maskz_mov_epi8(__mmask64, __m512i); 
#line 994
extern __m512i __cdecl _mm512_mask_mov_epi16(__m512i, __mmask32, __m512i); 
#line 995
extern __m512i __cdecl _mm512_maskz_mov_epi16(__mmask32, __m512i); 
#line 996
extern __m512i __cdecl _mm512_mask_mov_epi32(__m512i, __mmask16, __m512i); 
#line 997
extern __m512i __cdecl _mm512_maskz_mov_epi32(__mmask16, __m512i); 
#line 998
extern __m512i __cdecl _mm512_mask_mov_epi64(__m512i, __mmask8, __m512i); 
#line 999
extern __m512i __cdecl _mm512_maskz_mov_epi64(__mmask8, __m512i); 
#line 1000
extern __m512d __cdecl _mm512_movedup_pd(__m512d); 
#line 1001
extern __m512d __cdecl _mm512_mask_movedup_pd(__m512d, __mmask8, __m512d); 
#line 1002
extern __m512d __cdecl _mm512_maskz_movedup_pd(__mmask8, __m512d); 
#line 1003
extern __m512 __cdecl _mm512_movehdup_ps(__m512); 
#line 1004
extern __m512 __cdecl _mm512_mask_movehdup_ps(__m512, __mmask16, __m512); 
#line 1005
extern __m512 __cdecl _mm512_maskz_movehdup_ps(__mmask16, __m512); 
#line 1006
extern __m512 __cdecl _mm512_moveldup_ps(__m512); 
#line 1007
extern __m512 __cdecl _mm512_mask_moveldup_ps(__m512, __mmask16, __m512); 
#line 1008
extern __m512 __cdecl _mm512_maskz_moveldup_ps(__mmask16, __m512); 
#line 1010
extern __m512i __cdecl _mm512_movm_epi8(__mmask64); 
#line 1011
extern __m512i __cdecl _mm512_movm_epi16(__mmask32); 
#line 1012
extern __m512i __cdecl _mm512_movm_epi32(__mmask16); 
#line 1013
extern __m512i __cdecl _mm512_movm_epi64(__mmask8); 
#line 1014
extern __mmask64 __cdecl _mm512_movepi8_mask(__m512i); 
#line 1015
extern __mmask32 __cdecl _mm512_movepi16_mask(__m512i); 
#line 1016
extern __mmask16 __cdecl _mm512_movepi32_mask(__m512i); 
#line 1017
extern __mmask8 __cdecl _mm512_movepi64_mask(__m512i); 
#line 1019
extern __m512i __cdecl _mm512_alignr_epi8(__m512i, __m512i, const int); 
#line 1020
extern __m512i __cdecl _mm512_mask_alignr_epi8(__m512i, __mmask64, __m512i, __m512i, const int); 
#line 1021
extern __m512i __cdecl _mm512_maskz_alignr_epi8(__mmask64, __m512i, __m512i, const int); 
#line 1022
extern __m512i __cdecl _mm512_alignr_epi32(__m512i, __m512i, const int); 
#line 1023
extern __m512i __cdecl _mm512_mask_alignr_epi32(__m512i, __mmask16, __m512i, __m512i, const int); 
#line 1024
extern __m512i __cdecl _mm512_maskz_alignr_epi32(__mmask16, __m512i, __m512i, const int); 
#line 1025
extern __m512i __cdecl _mm512_alignr_epi64(__m512i, __m512i, const int); 
#line 1026
extern __m512i __cdecl _mm512_mask_alignr_epi64(__m512i, __mmask8, __m512i, __m512i, const int); 
#line 1027
extern __m512i __cdecl _mm512_maskz_alignr_epi64(__mmask8, __m512i, __m512i, const int); 
#line 1029
extern __m512d __cdecl _mm512_and_pd(__m512d, __m512d); 
#line 1030
extern __m512d __cdecl _mm512_mask_and_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 1031
extern __m512d __cdecl _mm512_maskz_and_pd(__mmask8, __m512d, __m512d); 
#line 1032
extern __m512 __cdecl _mm512_and_ps(__m512, __m512); 
#line 1033
extern __m512 __cdecl _mm512_mask_and_ps(__m512, __mmask16, __m512, __m512); 
#line 1034
extern __m512 __cdecl _mm512_maskz_and_ps(__mmask16, __m512, __m512); 
#line 1035
extern __m512i __cdecl _mm512_and_epi32(__m512i, __m512i); 
#line 1036
extern __m512i __cdecl _mm512_mask_and_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 1037
extern __m512i __cdecl _mm512_maskz_and_epi32(__mmask16, __m512i, __m512i); 
#line 1038
extern __m512i __cdecl _mm512_and_epi64(__m512i, __m512i); 
#line 1039
extern __m512i __cdecl _mm512_mask_and_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 1040
extern __m512i __cdecl _mm512_maskz_and_epi64(__mmask8, __m512i, __m512i); 
#line 1042
extern __m512d __cdecl _mm512_andnot_pd(__m512d, __m512d); 
#line 1043
extern __m512d __cdecl _mm512_mask_andnot_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 1044
extern __m512d __cdecl _mm512_maskz_andnot_pd(__mmask8, __m512d, __m512d); 
#line 1045
extern __m512 __cdecl _mm512_andnot_ps(__m512, __m512); 
#line 1046
extern __m512 __cdecl _mm512_mask_andnot_ps(__m512, __mmask16, __m512, __m512); 
#line 1047
extern __m512 __cdecl _mm512_maskz_andnot_ps(__mmask16, __m512, __m512); 
#line 1048
extern __m512i __cdecl _mm512_andnot_epi32(__m512i, __m512i); 
#line 1049
extern __m512i __cdecl _mm512_mask_andnot_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 1050
extern __m512i __cdecl _mm512_maskz_andnot_epi32(__mmask16, __m512i, __m512i); 
#line 1051
extern __m512i __cdecl _mm512_andnot_epi64(__m512i, __m512i); 
#line 1052
extern __m512i __cdecl _mm512_mask_andnot_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 1053
extern __m512i __cdecl _mm512_maskz_andnot_epi64(__mmask8, __m512i, __m512i); 
#line 1055
extern __m512d __cdecl _mm512_or_pd(__m512d, __m512d); 
#line 1056
extern __m512d __cdecl _mm512_mask_or_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 1057
extern __m512d __cdecl _mm512_maskz_or_pd(__mmask8, __m512d, __m512d); 
#line 1058
extern __m512 __cdecl _mm512_or_ps(__m512, __m512); 
#line 1059
extern __m512 __cdecl _mm512_mask_or_ps(__m512, __mmask16, __m512, __m512); 
#line 1060
extern __m512 __cdecl _mm512_maskz_or_ps(__mmask16, __m512, __m512); 
#line 1061
extern __m512i __cdecl _mm512_or_epi32(__m512i, __m512i); 
#line 1062
extern __m512i __cdecl _mm512_mask_or_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 1063
extern __m512i __cdecl _mm512_maskz_or_epi32(__mmask16, __m512i, __m512i); 
#line 1064
extern __m512i __cdecl _mm512_or_epi64(__m512i, __m512i); 
#line 1065
extern __m512i __cdecl _mm512_mask_or_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 1066
extern __m512i __cdecl _mm512_maskz_or_epi64(__mmask8, __m512i, __m512i); 
#line 1068
extern __m512d __cdecl _mm512_xor_pd(__m512d, __m512d); 
#line 1069
extern __m512d __cdecl _mm512_mask_xor_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 1070
extern __m512d __cdecl _mm512_maskz_xor_pd(__mmask8, __m512d, __m512d); 
#line 1071
extern __m512 __cdecl _mm512_xor_ps(__m512, __m512); 
#line 1072
extern __m512 __cdecl _mm512_mask_xor_ps(__m512, __mmask16, __m512, __m512); 
#line 1073
extern __m512 __cdecl _mm512_maskz_xor_ps(__mmask16, __m512, __m512); 
#line 1074
extern __m512i __cdecl _mm512_xor_epi32(__m512i, __m512i); 
#line 1075
extern __m512i __cdecl _mm512_mask_xor_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 1076
extern __m512i __cdecl _mm512_maskz_xor_epi32(__mmask16, __m512i, __m512i); 
#line 1077
extern __m512i __cdecl _mm512_xor_epi64(__m512i, __m512i); 
#line 1078
extern __m512i __cdecl _mm512_mask_xor_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 1079
extern __m512i __cdecl _mm512_maskz_xor_epi64(__mmask8, __m512i, __m512i); 
#line 1081
extern __m512 __cdecl _mm512_mask_blend_ps(__mmask16, __m512, __m512); 
#line 1082
extern __m512d __cdecl _mm512_mask_blend_pd(__mmask8, __m512d, __m512d); 
#line 1083
extern __m512i __cdecl _mm512_mask_blend_epi8(__mmask64, __m512i, __m512i); 
#line 1084
extern __m512i __cdecl _mm512_mask_blend_epi16(__mmask32, __m512i, __m512i); 
#line 1085
extern __m512i __cdecl _mm512_mask_blend_epi32(__mmask16, __m512i, __m512i); 
#line 1086
extern __m512i __cdecl _mm512_mask_blend_epi64(__mmask8, __m512i, __m512i); 
#line 1088
extern __m512i __cdecl _mm512_sll_epi16(__m512i, __m128i); 
#line 1089
extern __m512i __cdecl _mm512_sll_epi32(__m512i, __m128i); 
#line 1090
extern __m512i __cdecl _mm512_sll_epi64(__m512i, __m128i); 
#line 1091
extern __m512i __cdecl _mm512_slli_epi16(__m512i, unsigned); 
#line 1092
extern __m512i __cdecl _mm512_slli_epi32(__m512i, unsigned); 
#line 1093
extern __m512i __cdecl _mm512_slli_epi64(__m512i, unsigned); 
#line 1094
extern __m512i __cdecl _mm512_sllv_epi16(__m512i, __m512i); 
#line 1095
extern __m512i __cdecl _mm512_sllv_epi32(__m512i, __m512i); 
#line 1096
extern __m512i __cdecl _mm512_sllv_epi64(__m512i, __m512i); 
#line 1098
extern __m512i __cdecl _mm512_mask_sll_epi16(__m512i, __mmask32, __m512i, __m128i); 
#line 1099
extern __m512i __cdecl _mm512_maskz_sll_epi16(__mmask32, __m512i, __m128i); 
#line 1100
extern __m512i __cdecl _mm512_mask_sll_epi32(__m512i, __mmask16, __m512i, __m128i); 
#line 1101
extern __m512i __cdecl _mm512_maskz_sll_epi32(__mmask16, __m512i, __m128i); 
#line 1102
extern __m512i __cdecl _mm512_mask_sll_epi64(__m512i, __mmask8, __m512i, __m128i); 
#line 1103
extern __m512i __cdecl _mm512_maskz_sll_epi64(__mmask8, __m512i, __m128i); 
#line 1104
extern __m512i __cdecl _mm512_mask_slli_epi16(__m512i, __mmask32, __m512i, unsigned); 
#line 1105
extern __m512i __cdecl _mm512_maskz_slli_epi16(__mmask32, __m512i, unsigned); 
#line 1106
extern __m512i __cdecl _mm512_mask_slli_epi32(__m512i, __mmask16, __m512i, unsigned); 
#line 1107
extern __m512i __cdecl _mm512_maskz_slli_epi32(__mmask16, __m512i, unsigned); 
#line 1108
extern __m512i __cdecl _mm512_mask_slli_epi64(__m512i, __mmask8, __m512i, unsigned); 
#line 1109
extern __m512i __cdecl _mm512_maskz_slli_epi64(__mmask8, __m512i, unsigned); 
#line 1110
extern __m512i __cdecl _mm512_mask_sllv_epi16(__m512i, __mmask32, __m512i, __m512i); 
#line 1111
extern __m512i __cdecl _mm512_maskz_sllv_epi16(__mmask32, __m512i, __m512i); 
#line 1112
extern __m512i __cdecl _mm512_mask_sllv_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 1113
extern __m512i __cdecl _mm512_maskz_sllv_epi32(__mmask16, __m512i, __m512i); 
#line 1114
extern __m512i __cdecl _mm512_mask_sllv_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 1115
extern __m512i __cdecl _mm512_maskz_sllv_epi64(__mmask8, __m512i, __m512i); 
#line 1117
extern __m512i __cdecl _mm512_srl_epi16(__m512i, __m128i); 
#line 1118
extern __m512i __cdecl _mm512_srl_epi32(__m512i, __m128i); 
#line 1119
extern __m512i __cdecl _mm512_srl_epi64(__m512i, __m128i); 
#line 1120
extern __m512i __cdecl _mm512_srli_epi16(__m512i, int); 
#line 1121
extern __m512i __cdecl _mm512_srli_epi32(__m512i, unsigned); 
#line 1122
extern __m512i __cdecl _mm512_srli_epi64(__m512i, unsigned); 
#line 1123
extern __m512i __cdecl _mm512_srlv_epi16(__m512i, __m512i); 
#line 1124
extern __m512i __cdecl _mm512_srlv_epi32(__m512i, __m512i); 
#line 1125
extern __m512i __cdecl _mm512_srlv_epi64(__m512i, __m512i); 
#line 1127
extern __m512i __cdecl _mm512_mask_srl_epi16(__m512i, __mmask32, __m512i, __m128i); 
#line 1128
extern __m512i __cdecl _mm512_maskz_srl_epi16(__mmask32, __m512i, __m128i); 
#line 1129
extern __m512i __cdecl _mm512_mask_srl_epi32(__m512i, __mmask16, __m512i, __m128i); 
#line 1130
extern __m512i __cdecl _mm512_maskz_srl_epi32(__mmask16, __m512i, __m128i); 
#line 1131
extern __m512i __cdecl _mm512_mask_srl_epi64(__m512i, __mmask8, __m512i, __m128i); 
#line 1132
extern __m512i __cdecl _mm512_maskz_srl_epi64(__mmask8, __m512i, __m128i); 
#line 1133
extern __m512i __cdecl _mm512_mask_srli_epi16(__m512i, __mmask32, __m512i, unsigned); 
#line 1134
extern __m512i __cdecl _mm512_maskz_srli_epi16(__mmask32, __m512i, int); 
#line 1135
extern __m512i __cdecl _mm512_mask_srli_epi32(__m512i, __mmask16, __m512i, unsigned); 
#line 1136
extern __m512i __cdecl _mm512_maskz_srli_epi32(__mmask16, __m512i, unsigned); 
#line 1137
extern __m512i __cdecl _mm512_mask_srli_epi64(__m512i, __mmask8, __m512i, unsigned); 
#line 1138
extern __m512i __cdecl _mm512_maskz_srli_epi64(__mmask8, __m512i, unsigned); 
#line 1139
extern __m512i __cdecl _mm512_mask_srlv_epi16(__m512i, __mmask32, __m512i, __m512i); 
#line 1140
extern __m512i __cdecl _mm512_maskz_srlv_epi16(__mmask32, __m512i, __m512i); 
#line 1141
extern __m512i __cdecl _mm512_mask_srlv_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 1142
extern __m512i __cdecl _mm512_maskz_srlv_epi32(__mmask16, __m512i, __m512i); 
#line 1143
extern __m512i __cdecl _mm512_mask_srlv_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 1144
extern __m512i __cdecl _mm512_maskz_srlv_epi64(__mmask8, __m512i, __m512i); 
#line 1146
extern __m512i __cdecl _mm512_sra_epi16(__m512i, __m128i); 
#line 1147
extern __m512i __cdecl _mm512_sra_epi32(__m512i, __m128i); 
#line 1148
extern __m512i __cdecl _mm512_sra_epi64(__m512i, __m128i); 
#line 1149
extern __m512i __cdecl _mm512_srai_epi16(__m512i, unsigned); 
#line 1150
extern __m512i __cdecl _mm512_srai_epi32(__m512i, unsigned); 
#line 1151
extern __m512i __cdecl _mm512_srai_epi64(__m512i, unsigned); 
#line 1152
extern __m512i __cdecl _mm512_srav_epi16(__m512i, __m512i); 
#line 1153
extern __m512i __cdecl _mm512_srav_epi32(__m512i, __m512i); 
#line 1154
extern __m512i __cdecl _mm512_srav_epi64(__m512i, __m512i); 
#line 1156
extern __m512i __cdecl _mm512_mask_sra_epi16(__m512i, __mmask32, __m512i, __m128i); 
#line 1157
extern __m512i __cdecl _mm512_maskz_sra_epi16(__mmask32, __m512i, __m128i); 
#line 1158
extern __m512i __cdecl _mm512_mask_sra_epi32(__m512i, __mmask16, __m512i, __m128i); 
#line 1159
extern __m512i __cdecl _mm512_maskz_sra_epi32(__mmask16, __m512i, __m128i); 
#line 1160
extern __m512i __cdecl _mm512_mask_sra_epi64(__m512i, __mmask8, __m512i, __m128i); 
#line 1161
extern __m512i __cdecl _mm512_maskz_sra_epi64(__mmask8, __m512i, __m128i); 
#line 1162
extern __m512i __cdecl _mm512_mask_srai_epi16(__m512i, __mmask32, __m512i, unsigned); 
#line 1163
extern __m512i __cdecl _mm512_maskz_srai_epi16(__mmask32, __m512i, unsigned); 
#line 1164
extern __m512i __cdecl _mm512_mask_srai_epi32(__m512i, __mmask16, __m512i, unsigned); 
#line 1165
extern __m512i __cdecl _mm512_maskz_srai_epi32(__mmask16, __m512i, unsigned); 
#line 1166
extern __m512i __cdecl _mm512_mask_srai_epi64(__m512i, __mmask8, __m512i, unsigned); 
#line 1167
extern __m512i __cdecl _mm512_maskz_srai_epi64(__mmask8, __m512i, unsigned); 
#line 1168
extern __m512i __cdecl _mm512_mask_srav_epi16(__m512i, __mmask32, __m512i, __m512i); 
#line 1169
extern __m512i __cdecl _mm512_maskz_srav_epi16(__mmask32, __m512i, __m512i); 
#line 1170
extern __m512i __cdecl _mm512_mask_srav_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 1171
extern __m512i __cdecl _mm512_maskz_srav_epi32(__mmask16, __m512i, __m512i); 
#line 1172
extern __m512i __cdecl _mm512_mask_srav_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 1173
extern __m512i __cdecl _mm512_maskz_srav_epi64(__mmask8, __m512i, __m512i); 
#line 1175
extern __m512i __cdecl _mm512_bslli_epi128(__m512i, int); 
#line 1176
extern __m512i __cdecl _mm512_bsrli_epi128(__m512i, int); 
#line 1178
extern __m512i __cdecl _mm512_rol_epi32(__m512i, const int); 
#line 1179
extern __m512i __cdecl _mm512_mask_rol_epi32(__m512i, __mmask16, __m512i, const int); 
#line 1180
extern __m512i __cdecl _mm512_maskz_rol_epi32(__mmask16, __m512i, const int); 
#line 1181
extern __m512i __cdecl _mm512_rol_epi64(__m512i, const int); 
#line 1182
extern __m512i __cdecl _mm512_mask_rol_epi64(__m512i, __mmask8, __m512i, const int); 
#line 1183
extern __m512i __cdecl _mm512_maskz_rol_epi64(__mmask8, __m512i, const int); 
#line 1184
extern __m512i __cdecl _mm512_rolv_epi32(__m512i, __m512i); 
#line 1185
extern __m512i __cdecl _mm512_mask_rolv_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 1186
extern __m512i __cdecl _mm512_maskz_rolv_epi32(__mmask16, __m512i, __m512i); 
#line 1187
extern __m512i __cdecl _mm512_rolv_epi64(__m512i, __m512i); 
#line 1188
extern __m512i __cdecl _mm512_mask_rolv_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 1189
extern __m512i __cdecl _mm512_maskz_rolv_epi64(__mmask8, __m512i, __m512i); 
#line 1191
extern __m512i __cdecl _mm512_ror_epi32(__m512i, int); 
#line 1192
extern __m512i __cdecl _mm512_mask_ror_epi32(__m512i, __mmask16, __m512i, int); 
#line 1193
extern __m512i __cdecl _mm512_maskz_ror_epi32(__mmask16, __m512i, int); 
#line 1194
extern __m512i __cdecl _mm512_ror_epi64(__m512i, int); 
#line 1195
extern __m512i __cdecl _mm512_mask_ror_epi64(__m512i, __mmask8, __m512i, int); 
#line 1196
extern __m512i __cdecl _mm512_maskz_ror_epi64(__mmask8, __m512i, int); 
#line 1197
extern __m512i __cdecl _mm512_rorv_epi32(__m512i, __m512i); 
#line 1198
extern __m512i __cdecl _mm512_mask_rorv_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 1199
extern __m512i __cdecl _mm512_maskz_rorv_epi32(__mmask16, __m512i, __m512i); 
#line 1200
extern __m512i __cdecl _mm512_rorv_epi64(__m512i, __m512i); 
#line 1201
extern __m512i __cdecl _mm512_mask_rorv_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 1202
extern __m512i __cdecl _mm512_maskz_rorv_epi64(__mmask8, __m512i, __m512i); 
#line 1204
extern __m512d __cdecl _mm512_unpackhi_pd(__m512d, __m512d); 
#line 1205
extern __m512d __cdecl _mm512_mask_unpackhi_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 1206
extern __m512d __cdecl _mm512_maskz_unpackhi_pd(__mmask8, __m512d, __m512d); 
#line 1207
extern __m512 __cdecl _mm512_unpackhi_ps(__m512, __m512); 
#line 1208
extern __m512 __cdecl _mm512_mask_unpackhi_ps(__m512, __mmask16, __m512, __m512); 
#line 1209
extern __m512 __cdecl _mm512_maskz_unpackhi_ps(__mmask16, __m512, __m512); 
#line 1210
extern __m512d __cdecl _mm512_unpacklo_pd(__m512d, __m512d); 
#line 1211
extern __m512d __cdecl _mm512_mask_unpacklo_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 1212
extern __m512d __cdecl _mm512_maskz_unpacklo_pd(__mmask8, __m512d, __m512d); 
#line 1213
extern __m512 __cdecl _mm512_unpacklo_ps(__m512, __m512); 
#line 1214
extern __m512 __cdecl _mm512_mask_unpacklo_ps(__m512, __mmask16, __m512, __m512); 
#line 1215
extern __m512 __cdecl _mm512_maskz_unpacklo_ps(__mmask16, __m512, __m512); 
#line 1216
extern __m512i __cdecl _mm512_unpackhi_epi8(__m512i, __m512i); 
#line 1217
extern __m512i __cdecl _mm512_mask_unpackhi_epi8(__m512i, __mmask64, __m512i, __m512i); 
#line 1218
extern __m512i __cdecl _mm512_maskz_unpackhi_epi8(__mmask64, __m512i, __m512i); 
#line 1219
extern __m512i __cdecl _mm512_unpackhi_epi16(__m512i, __m512i); 
#line 1220
extern __m512i __cdecl _mm512_mask_unpackhi_epi16(__m512i, __mmask32, __m512i, __m512i); 
#line 1221
extern __m512i __cdecl _mm512_maskz_unpackhi_epi16(__mmask32, __m512i, __m512i); 
#line 1222
extern __m512i __cdecl _mm512_unpackhi_epi32(__m512i, __m512i); 
#line 1223
extern __m512i __cdecl _mm512_mask_unpackhi_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 1224
extern __m512i __cdecl _mm512_maskz_unpackhi_epi32(__mmask16, __m512i, __m512i); 
#line 1225
extern __m512i __cdecl _mm512_unpackhi_epi64(__m512i, __m512i); 
#line 1226
extern __m512i __cdecl _mm512_mask_unpackhi_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 1227
extern __m512i __cdecl _mm512_maskz_unpackhi_epi64(__mmask8, __m512i, __m512i); 
#line 1228
extern __m512i __cdecl _mm512_unpacklo_epi8(__m512i, __m512i); 
#line 1229
extern __m512i __cdecl _mm512_mask_unpacklo_epi8(__m512i, __mmask64, __m512i, __m512i); 
#line 1230
extern __m512i __cdecl _mm512_maskz_unpacklo_epi8(__mmask64, __m512i, __m512i); 
#line 1231
extern __m512i __cdecl _mm512_unpacklo_epi16(__m512i, __m512i); 
#line 1232
extern __m512i __cdecl _mm512_mask_unpacklo_epi16(__m512i, __mmask32, __m512i, __m512i); 
#line 1233
extern __m512i __cdecl _mm512_maskz_unpacklo_epi16(__mmask32, __m512i, __m512i); 
#line 1234
extern __m512i __cdecl _mm512_unpacklo_epi32(__m512i, __m512i); 
#line 1235
extern __m512i __cdecl _mm512_mask_unpacklo_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 1236
extern __m512i __cdecl _mm512_maskz_unpacklo_epi32(__mmask16, __m512i, __m512i); 
#line 1237
extern __m512i __cdecl _mm512_unpacklo_epi64(__m512i, __m512i); 
#line 1238
extern __m512i __cdecl _mm512_mask_unpacklo_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 1239
extern __m512i __cdecl _mm512_maskz_unpacklo_epi64(__mmask8, __m512i, __m512i); 
#line 1241
extern __m512 __cdecl _mm512_getexp_ps(__m512); 
#line 1242
extern __m512 __cdecl _mm512_mask_getexp_ps(__m512, __mmask16, __m512); 
#line 1243
extern __m512 __cdecl _mm512_maskz_getexp_ps(__mmask16, __m512); 
#line 1244
extern __m512 __cdecl _mm512_getexp_round_ps(__m512, int); 
#line 1245
extern __m512 __cdecl _mm512_mask_getexp_round_ps(__m512, __mmask16, __m512, int); 
#line 1246
extern __m512 __cdecl _mm512_maskz_getexp_round_ps(__mmask16, __m512, int); 
#line 1247
extern __m512d __cdecl _mm512_getexp_pd(__m512d); 
#line 1248
extern __m512d __cdecl _mm512_mask_getexp_pd(__m512d, __mmask8, __m512d); 
#line 1249
extern __m512d __cdecl _mm512_maskz_getexp_pd(__mmask8, __m512d); 
#line 1250
extern __m512d __cdecl _mm512_getexp_round_pd(__m512d, int); 
#line 1251
extern __m512d __cdecl _mm512_mask_getexp_round_pd(__m512d, __mmask8, __m512d, int); 
#line 1252
extern __m512d __cdecl _mm512_maskz_getexp_round_pd(__mmask8, __m512d, int); 
#line 1254
extern __m512 __cdecl _mm512_getmant_ps(__m512, int, int); 
#line 1255
extern __m512 __cdecl _mm512_mask_getmant_ps(__m512, __mmask16, __m512, int, int); 
#line 1256
extern __m512 __cdecl _mm512_maskz_getmant_ps(__mmask16, __m512, int, int); 
#line 1257
extern __m512 __cdecl _mm512_getmant_round_ps(__m512, int, int, int); 
#line 1258
extern __m512 __cdecl _mm512_mask_getmant_round_ps(__m512, __mmask16, __m512, int, int, int); 
#line 1259
extern __m512 __cdecl _mm512_maskz_getmant_round_ps(__mmask16, __m512, int, int, int); 
#line 1260
extern __m512d __cdecl _mm512_getmant_pd(__m512d, int, int); 
#line 1261
extern __m512d __cdecl _mm512_mask_getmant_pd(__m512d, __mmask8, __m512d, int, int); 
#line 1262
extern __m512d __cdecl _mm512_maskz_getmant_pd(__mmask8, __m512d, int, int); 
#line 1263
extern __m512d __cdecl _mm512_getmant_round_pd(__m512d, int, int, int); 
#line 1264
extern __m512d __cdecl _mm512_mask_getmant_round_pd(__m512d, __mmask8, __m512d, int, int, int); 
#line 1265
extern __m512d __cdecl _mm512_maskz_getmant_round_pd(__mmask8, __m512d, int, int, int); 
#line 1267
extern __m512d __cdecl _mm512_permute_pd(__m512d, const int); 
#line 1268
extern __m512d __cdecl _mm512_mask_permute_pd(__m512d, __mmask8, __m512d, const int); 
#line 1269
extern __m512d __cdecl _mm512_maskz_permute_pd(__mmask8, __m512d, const int); 
#line 1270
extern __m512 __cdecl _mm512_permute_ps(__m512, const int); 
#line 1271
extern __m512 __cdecl _mm512_mask_permute_ps(__m512, __mmask16, __m512, const int); 
#line 1272
extern __m512 __cdecl _mm512_maskz_permute_ps(__mmask16, __m512, const int); 
#line 1273
extern __m512d __cdecl _mm512_permutevar_pd(__m512d, __m512i); 
#line 1274
extern __m512d __cdecl _mm512_mask_permutevar_pd(__m512d, __mmask8, __m512d, __m512i); 
#line 1275
extern __m512d __cdecl _mm512_maskz_permutevar_pd(__mmask8, __m512d, __m512i); 
#line 1276
extern __m512 __cdecl _mm512_permutevar_ps(__m512, __m512i); 
#line 1277
extern __m512 __cdecl _mm512_mask_permutevar_ps(__m512, __mmask16, __m512, __m512i); 
#line 1278
extern __m512 __cdecl _mm512_maskz_permutevar_ps(__mmask16, __m512, __m512i); 
#line 1279
extern __m512i __cdecl _mm512_permutevar_epi32(__m512i, __m512i); 
#line 1280
extern __m512i __cdecl _mm512_mask_permutevar_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 1282
extern __m512d __cdecl _mm512_permutex_pd(__m512d, const int); 
#line 1283
extern __m512d __cdecl _mm512_mask_permutex_pd(__m512d, __mmask8, __m512d, const int); 
#line 1284
extern __m512d __cdecl _mm512_maskz_permutex_pd(__mmask8, __m512d, const int); 
#line 1285
extern __m512i __cdecl _mm512_permutex_epi64(__m512i, const int); 
#line 1286
extern __m512i __cdecl _mm512_mask_permutex_epi64(__m512i, __mmask8, __m512i, const int); 
#line 1287
extern __m512i __cdecl _mm512_maskz_permutex_epi64(__mmask8, __m512i, const int); 
#line 1288
extern __m512d __cdecl _mm512_permutexvar_pd(__m512i, __m512d); 
#line 1289
extern __m512d __cdecl _mm512_mask_permutexvar_pd(__m512d, __mmask8, __m512i, __m512d); 
#line 1290
extern __m512d __cdecl _mm512_maskz_permutexvar_pd(__mmask8, __m512i, __m512d); 
#line 1291
extern __m512 __cdecl _mm512_permutexvar_ps(__m512i, __m512); 
#line 1292
extern __m512 __cdecl _mm512_mask_permutexvar_ps(__m512, __mmask16, __m512i, __m512); 
#line 1293
extern __m512 __cdecl _mm512_maskz_permutexvar_ps(__mmask16, __m512i, __m512); 
#line 1294
extern __m512i __cdecl _mm512_permutexvar_epi16(__m512i, __m512i); 
#line 1295
extern __m512i __cdecl _mm512_mask_permutexvar_epi16(__m512i, __mmask32, __m512i, __m512i); 
#line 1296
extern __m512i __cdecl _mm512_maskz_permutexvar_epi16(__mmask32, __m512i, __m512i); 
#line 1297
extern __m512i __cdecl _mm512_permutexvar_epi32(__m512i, __m512i); 
#line 1298
extern __m512i __cdecl _mm512_mask_permutexvar_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 1299
extern __m512i __cdecl _mm512_maskz_permutexvar_epi32(__mmask16, __m512i, __m512i); 
#line 1300
extern __m512i __cdecl _mm512_permutexvar_epi64(__m512i, __m512i); 
#line 1301
extern __m512i __cdecl _mm512_mask_permutexvar_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 1302
extern __m512i __cdecl _mm512_maskz_permutexvar_epi64(__mmask8, __m512i, __m512i); 
#line 1304
extern __m512d __cdecl _mm512_permutex2var_pd(__m512d, __m512i, __m512d); 
#line 1305
extern __m512d __cdecl _mm512_mask_permutex2var_pd(__m512d, __mmask8, __m512i, __m512d); 
#line 1306
extern __m512d __cdecl _mm512_mask2_permutex2var_pd(__m512d, __m512i, __mmask8, __m512d); 
#line 1307
extern __m512d __cdecl _mm512_maskz_permutex2var_pd(__mmask8, __m512d, __m512i, __m512d); 
#line 1308
extern __m512 __cdecl _mm512_permutex2var_ps(__m512, __m512i, __m512); 
#line 1309
extern __m512 __cdecl _mm512_mask_permutex2var_ps(__m512, __mmask16, __m512i, __m512); 
#line 1310
extern __m512 __cdecl _mm512_mask2_permutex2var_ps(__m512, __m512i, __mmask16, __m512); 
#line 1311
extern __m512 __cdecl _mm512_maskz_permutex2var_ps(__mmask16, __m512, __m512i, __m512); 
#line 1312
extern __m512i __cdecl _mm512_permutex2var_epi16(__m512i, __m512i, __m512i); 
#line 1313
extern __m512i __cdecl _mm512_mask_permutex2var_epi16(__m512i, __mmask32, __m512i, __m512i); 
#line 1314
extern __m512i __cdecl _mm512_mask2_permutex2var_epi16(__m512i, __m512i, __mmask32, __m512i); 
#line 1315
extern __m512i __cdecl _mm512_maskz_permutex2var_epi16(__mmask32, __m512i, __m512i, __m512i); 
#line 1316
extern __m512i __cdecl _mm512_permutex2var_epi32(__m512i, __m512i, __m512i); 
#line 1317
extern __m512i __cdecl _mm512_mask_permutex2var_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 1318
extern __m512i __cdecl _mm512_mask2_permutex2var_epi32(__m512i, __m512i, __mmask16, __m512i); 
#line 1319
extern __m512i __cdecl _mm512_maskz_permutex2var_epi32(__mmask16, __m512i, __m512i, __m512i); 
#line 1320
extern __m512i __cdecl _mm512_permutex2var_epi64(__m512i, __m512i, __m512i); 
#line 1321
extern __m512i __cdecl _mm512_mask_permutex2var_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 1322
extern __m512i __cdecl _mm512_mask2_permutex2var_epi64(__m512i, __m512i, __mmask8, __m512i); 
#line 1323
extern __m512i __cdecl _mm512_maskz_permutex2var_epi64(__mmask8, __m512i, __m512i, __m512i); 
#line 1325
extern __m512d __cdecl _mm512_mask_compress_pd(__m512d, __mmask8, __m512d); 
#line 1326
extern __m512d __cdecl _mm512_maskz_compress_pd(__mmask8, __m512d); 
#line 1327
extern __m512 __cdecl _mm512_mask_compress_ps(__m512, __mmask16, __m512); 
#line 1328
extern __m512 __cdecl _mm512_maskz_compress_ps(__mmask16, __m512); 
#line 1329
extern __m512i __cdecl _mm512_mask_compress_epi8(__m512i, __mmask64, __m512i); 
#line 1330
extern __m512i __cdecl _mm512_maskz_compress_epi8(__mmask64, __m512i); 
#line 1331
extern __m512i __cdecl _mm512_mask_compress_epi16(__m512i, __mmask32, __m512i); 
#line 1332
extern __m512i __cdecl _mm512_maskz_compress_epi16(__mmask32, __m512i); 
#line 1333
extern __m512i __cdecl _mm512_mask_compress_epi32(__m512i, __mmask16, __m512i); 
#line 1334
extern __m512i __cdecl _mm512_maskz_compress_epi32(__mmask16, __m512i); 
#line 1335
extern __m512i __cdecl _mm512_mask_compress_epi64(__m512i, __mmask8, __m512i); 
#line 1336
extern __m512i __cdecl _mm512_maskz_compress_epi64(__mmask8, __m512i); 
#line 1338
extern void __cdecl _mm512_mask_compressstoreu_pd(void *, __mmask8, __m512d); 
#line 1339
extern void __cdecl _mm512_mask_compressstoreu_ps(void *, __mmask16, __m512); 
#line 1340
extern void __cdecl _mm512_mask_compressstoreu_epi8(void *, __mmask64, __m512i); 
#line 1341
extern void __cdecl _mm512_mask_compressstoreu_epi16(void *, __mmask32, __m512i); 
#line 1342
extern void __cdecl _mm512_mask_compressstoreu_epi32(void *, __mmask16, __m512i); 
#line 1343
extern void __cdecl _mm512_mask_compressstoreu_epi64(void *, __mmask8, __m512i); 
#line 1345
extern __m512d __cdecl _mm512_mask_expand_pd(__m512d, __mmask8, __m512d); 
#line 1346
extern __m512d __cdecl _mm512_maskz_expand_pd(__mmask8, __m512d); 
#line 1347
extern __m512 __cdecl _mm512_mask_expand_ps(__m512, __mmask16, __m512); 
#line 1348
extern __m512 __cdecl _mm512_maskz_expand_ps(__mmask16, __m512); 
#line 1349
extern __m512i __cdecl _mm512_mask_expand_epi8(__m512i, __mmask64, __m512i); 
#line 1350
extern __m512i __cdecl _mm512_maskz_expand_epi8(__mmask64, __m512i); 
#line 1351
extern __m512i __cdecl _mm512_mask_expand_epi16(__m512i, __mmask32, __m512i); 
#line 1352
extern __m512i __cdecl _mm512_maskz_expand_epi16(__mmask32, __m512i); 
#line 1353
extern __m512i __cdecl _mm512_mask_expand_epi32(__m512i, __mmask16, __m512i); 
#line 1354
extern __m512i __cdecl _mm512_maskz_expand_epi32(__mmask16, __m512i); 
#line 1355
extern __m512i __cdecl _mm512_mask_expand_epi64(__m512i, __mmask8, __m512i); 
#line 1356
extern __m512i __cdecl _mm512_maskz_expand_epi64(__mmask8, __m512i); 
#line 1357
extern __m512d __cdecl _mm512_mask_expandloadu_pd(__m512d, __mmask8, const void *); 
#line 1358
extern __m512d __cdecl _mm512_maskz_expandloadu_pd(__mmask8, const void *); 
#line 1359
extern __m512 __cdecl _mm512_mask_expandloadu_ps(__m512, __mmask16, const void *); 
#line 1360
extern __m512 __cdecl _mm512_maskz_expandloadu_ps(__mmask16, const void *); 
#line 1361
extern __m512i __cdecl _mm512_mask_expandloadu_epi8(__m512i, __mmask64, const void *); 
#line 1362
extern __m512i __cdecl _mm512_maskz_expandloadu_epi8(__mmask64, const void *); 
#line 1363
extern __m512i __cdecl _mm512_mask_expandloadu_epi16(__m512i, __mmask32, const void *); 
#line 1364
extern __m512i __cdecl _mm512_maskz_expandloadu_epi16(__mmask32, const void *); 
#line 1365
extern __m512i __cdecl _mm512_mask_expandloadu_epi32(__m512i, __mmask16, const void *); 
#line 1366
extern __m512i __cdecl _mm512_maskz_expandloadu_epi32(__mmask16, const void *); 
#line 1367
extern __m512i __cdecl _mm512_mask_expandloadu_epi64(__m512i, __mmask8, const void *); 
#line 1368
extern __m512i __cdecl _mm512_maskz_expandloadu_epi64(__mmask8, const void *); 
#line 1370
extern __m512i __cdecl _mm512_ternarylogic_epi32(__m512i, __m512i, __m512i, int); 
#line 1371
extern __m512i __cdecl _mm512_mask_ternarylogic_epi32(__m512i, __mmask16, __m512i, __m512i, int); 
#line 1372
extern __m512i __cdecl _mm512_maskz_ternarylogic_epi32(__mmask16, __m512i, __m512i, __m512i, int); 
#line 1373
extern __m512i __cdecl _mm512_ternarylogic_epi64(__m512i, __m512i, __m512i, int); 
#line 1374
extern __m512i __cdecl _mm512_mask_ternarylogic_epi64(__m512i, __mmask8, __m512i, __m512i, int); 
#line 1375
extern __m512i __cdecl _mm512_maskz_ternarylogic_epi64(__mmask8, __m512i, __m512i, __m512i, int); 
#line 1377
extern __m512i __cdecl _mm512_conflict_epi32(__m512i); 
#line 1378
extern __m512i __cdecl _mm512_mask_conflict_epi32(__m512i, __mmask16, __m512i); 
#line 1379
extern __m512i __cdecl _mm512_maskz_conflict_epi32(__mmask16, __m512i); 
#line 1380
extern __m512i __cdecl _mm512_conflict_epi64(__m512i); 
#line 1381
extern __m512i __cdecl _mm512_mask_conflict_epi64(__m512i, __mmask8, __m512i); 
#line 1382
extern __m512i __cdecl _mm512_maskz_conflict_epi64(__mmask8, __m512i); 
#line 1384
extern __m512i __cdecl _mm512_lzcnt_epi8(__m512i); 
#line 1385
extern __m256i __cdecl _mm256_lzcnt_epi8(__m256i); 
#line 1386
extern __m128i __cdecl _mm_lzcnt_epi8(__m128i); 
#line 1388
extern __m512i __cdecl _mm512_lzcnt_epi16(__m512i); 
#line 1389
extern __m256i __cdecl _mm256_lzcnt_epi16(__m256i); 
#line 1390
extern __m128i __cdecl _mm_lzcnt_epi16(__m128i); 
#line 1392
extern __m512i __cdecl _mm512_lzcnt_epi32(__m512i); 
#line 1393
extern __m512i __cdecl _mm512_mask_lzcnt_epi32(__m512i, __mmask16, __m512i); 
#line 1394
extern __m512i __cdecl _mm512_maskz_lzcnt_epi32(__mmask16, __m512i); 
#line 1395
extern __m512i __cdecl _mm512_lzcnt_epi64(__m512i); 
#line 1396
extern __m512i __cdecl _mm512_mask_lzcnt_epi64(__m512i, __mmask8, __m512i); 
#line 1397
extern __m512i __cdecl _mm512_maskz_lzcnt_epi64(__mmask8, __m512i); 
#line 1399
extern __m512i __cdecl _mm512_avg_epu8(__m512i, __m512i); 
#line 1400
extern __m512i __cdecl _mm512_mask_avg_epu8(__m512i, __mmask64, __m512i, __m512i); 
#line 1401
extern __m512i __cdecl _mm512_maskz_avg_epu8(__mmask64, __m512i, __m512i); 
#line 1402
extern __m512i __cdecl _mm512_avg_epu16(__m512i, __m512i); 
#line 1403
extern __m512i __cdecl _mm512_mask_avg_epu16(__m512i, __mmask32, __m512i, __m512i); 
#line 1404
extern __m512i __cdecl _mm512_maskz_avg_epu16(__mmask32, __m512i, __m512i); 
#line 1406
extern __m512i __cdecl _mm512_sad_epu8(__m512i, __m512i); 
#line 1407
extern __m512i __cdecl _mm512_dbsad_epu8(__m512i, __m512i, int); 
#line 1408
extern __m512i __cdecl _mm512_mask_dbsad_epu8(__m512i, __mmask32, __m512i, __m512i, int); 
#line 1409
extern __m512i __cdecl _mm512_maskz_dbsad_epu8(__mmask32, __m512i, __m512i, int); 
#line 1411
extern float __cdecl _mm512_reduce_add_ps(__m512); 
#line 1412
extern float __cdecl _mm512_mask_reduce_add_ps(__mmask16, __m512); 
#line 1413
extern double __cdecl _mm512_reduce_add_pd(__m512d); 
#line 1414
extern double __cdecl _mm512_mask_reduce_add_pd(__mmask8, __m512d); 
#line 1415
extern int __cdecl _mm512_reduce_add_epi8(__m512i); 
#line 1416
extern int __cdecl _mm512_mask_reduce_add_epi8(__mmask64, __m512i); 
#line 1417
extern int __cdecl _mm512_reduce_add_epi16(__m512i); 
#line 1418
extern int __cdecl _mm512_mask_reduce_add_epi16(__mmask32, __m512i); 
#line 1419
extern int __cdecl _mm512_reduce_add_epi32(__m512i); 
#line 1420
extern int __cdecl _mm512_mask_reduce_add_epi32(__mmask16, __m512i); 
#line 1421
extern __int64 __cdecl _mm512_reduce_add_epi64(__m512i); 
#line 1422
extern __int64 __cdecl _mm512_mask_reduce_add_epi64(__mmask8, __m512i); 
#line 1423
extern int __cdecl _mm512_reduce_add_epu8(__m512i); 
#line 1424
extern int __cdecl _mm512_mask_reduce_add_epu8(__mmask64, __m512i); 
#line 1425
extern int __cdecl _mm512_reduce_add_epu16(__m512i); 
#line 1426
extern int __cdecl _mm512_mask_reduce_add_epu16(__mmask32, __m512i); 
#line 1428
extern float __cdecl _mm512_reduce_mul_ps(__m512); 
#line 1429
extern float __cdecl _mm512_mask_reduce_mul_ps(__mmask16, __m512); 
#line 1430
extern double __cdecl _mm512_reduce_mul_pd(__m512d); 
#line 1431
extern double __cdecl _mm512_mask_reduce_mul_pd(__mmask8, __m512d); 
#line 1432
extern int __cdecl _mm512_reduce_mul_epi32(__m512i); 
#line 1433
extern int __cdecl _mm512_mask_reduce_mul_epi32(__mmask16, __m512i); 
#line 1434
extern __int64 __cdecl _mm512_reduce_mul_epi64(__m512i); 
#line 1435
extern __int64 __cdecl _mm512_mask_reduce_mul_epi64(__mmask8, __m512i); 
#line 1437
extern float __cdecl _mm512_reduce_min_ps(__m512); 
#line 1438
extern float __cdecl _mm512_mask_reduce_min_ps(__mmask16, __m512); 
#line 1439
extern double __cdecl _mm512_reduce_min_pd(__m512d); 
#line 1440
extern double __cdecl _mm512_mask_reduce_min_pd(__mmask8, __m512d); 
#line 1441
extern int __cdecl _mm512_reduce_min_epi32(__m512i); 
#line 1442
extern int __cdecl _mm512_mask_reduce_min_epi32(__mmask16, __m512i); 
#line 1443
extern __int64 __cdecl _mm512_reduce_min_epi64(__m512i); 
#line 1444
extern __int64 __cdecl _mm512_mask_reduce_min_epi64(__mmask8, __m512i); 
#line 1445
extern unsigned __cdecl _mm512_reduce_min_epu32(__m512i); 
#line 1446
extern unsigned __cdecl _mm512_mask_reduce_min_epu32(__mmask16, __m512i); 
#line 1447
extern unsigned __int64 __cdecl _mm512_reduce_min_epu64(__m512i); 
#line 1448
extern unsigned __int64 __cdecl _mm512_mask_reduce_min_epu64(__mmask8, __m512i); 
#line 1450
extern float __cdecl _mm512_reduce_max_ps(__m512); 
#line 1451
extern float __cdecl _mm512_mask_reduce_max_ps(__mmask16, __m512); 
#line 1452
extern double __cdecl _mm512_reduce_max_pd(__m512d); 
#line 1453
extern double __cdecl _mm512_mask_reduce_max_pd(__mmask8, __m512d); 
#line 1454
extern int __cdecl _mm512_reduce_max_epi32(__m512i); 
#line 1455
extern int __cdecl _mm512_mask_reduce_max_epi32(__mmask16, __m512i); 
#line 1456
extern __int64 __cdecl _mm512_reduce_max_epi64(__m512i); 
#line 1457
extern __int64 __cdecl _mm512_mask_reduce_max_epi64(__mmask8, __m512i); 
#line 1458
extern unsigned __cdecl _mm512_reduce_max_epu32(__m512i); 
#line 1459
extern unsigned __cdecl _mm512_mask_reduce_max_epu32(__mmask16, __m512i); 
#line 1460
extern unsigned __int64 __cdecl _mm512_reduce_max_epu64(__m512i); 
#line 1461
extern unsigned __int64 __cdecl _mm512_mask_reduce_max_epu64(__mmask8, __m512i); 
#line 1463
extern int __cdecl _mm512_reduce_and_epi32(__m512i); 
#line 1464
extern int __cdecl _mm512_mask_reduce_and_epi32(__mmask16, __m512i); 
#line 1465
extern __int64 __cdecl _mm512_reduce_and_epi64(__m512i); 
#line 1466
extern __int64 __cdecl _mm512_mask_reduce_and_epi64(__mmask8, __m512i); 
#line 1468
extern int __cdecl _mm512_reduce_or_epi32(__m512i); 
#line 1469
extern int __cdecl _mm512_mask_reduce_or_epi32(__mmask16, __m512i); 
#line 1470
extern __int64 __cdecl _mm512_reduce_or_epi64(__m512i); 
#line 1471
extern __int64 __cdecl _mm512_mask_reduce_or_epi64(__mmask8, __m512i); 
#line 1473
extern int __cdecl _mm512_reduce_xor_epi32(__m512i); 
#line 1474
extern int __cdecl _mm512_mask_reduce_xor_epi32(__mmask16, __m512i); 
#line 1475
extern __int64 __cdecl _mm512_reduce_xor_epi64(__m512i); 
#line 1476
extern __int64 __cdecl _mm512_mask_reduce_xor_epi64(__mmask8, __m512i); 
#line 1478
extern __m512d __cdecl _mm512_reduce_pd(__m512d, int); 
#line 1479
extern __m512d __cdecl _mm512_mask_reduce_pd(__m512d, __mmask8, __m512d, int); 
#line 1480
extern __m512d __cdecl _mm512_maskz_reduce_pd(__mmask8, __m512d, int); 
#line 1481
extern __m512d __cdecl _mm512_reduce_round_pd(__m512d, int, int); 
#line 1482
extern __m512d __cdecl _mm512_mask_reduce_round_pd(__m512d, __mmask8, __m512d, int, int); 
#line 1483
extern __m512d __cdecl _mm512_maskz_reduce_round_pd(__mmask8, __m512d, int, int); 
#line 1484
extern __m512 __cdecl _mm512_reduce_ps(__m512, int); 
#line 1485
extern __m512 __cdecl _mm512_mask_reduce_ps(__m512, __mmask16, __m512, int); 
#line 1486
extern __m512 __cdecl _mm512_maskz_reduce_ps(__mmask16, __m512, int); 
#line 1487
extern __m512 __cdecl _mm512_reduce_round_ps(__m512, int, int); 
#line 1488
extern __m512 __cdecl _mm512_mask_reduce_round_ps(__m512, __mmask16, __m512, int, int); 
#line 1489
extern __m512 __cdecl _mm512_maskz_reduce_round_ps(__mmask16, __m512, int, int); 
#line 1491
extern __m512d __cdecl _mm512_roundscale_pd(__m512d, int); 
#line 1492
extern __m512d __cdecl _mm512_mask_roundscale_pd(__m512d, __mmask8, __m512d, int); 
#line 1493
extern __m512d __cdecl _mm512_maskz_roundscale_pd(__mmask8, __m512d, int); 
#line 1494
extern __m512d __cdecl _mm512_roundscale_round_pd(__m512d, int, int); 
#line 1495
extern __m512d __cdecl _mm512_mask_roundscale_round_pd(__m512d, __mmask8, __m512d, int, int); 
#line 1496
extern __m512d __cdecl _mm512_maskz_roundscale_round_pd(__mmask8, __m512d, int, int); 
#line 1497
extern __m512 __cdecl _mm512_roundscale_ps(__m512, int); 
#line 1498
extern __m512 __cdecl _mm512_mask_roundscale_ps(__m512, __mmask16, __m512, int); 
#line 1499
extern __m512 __cdecl _mm512_maskz_roundscale_ps(__mmask16, __m512, int); 
#line 1500
extern __m512 __cdecl _mm512_roundscale_round_ps(__m512, int, int); 
#line 1501
extern __m512 __cdecl _mm512_mask_roundscale_round_ps(__m512, __mmask16, __m512, int, int); 
#line 1502
extern __m512 __cdecl _mm512_maskz_roundscale_round_ps(__mmask16, __m512, int, int); 
#line 1504
extern __m512d __cdecl _mm512_scalef_pd(__m512d, __m512d); 
#line 1505
extern __m512d __cdecl _mm512_mask_scalef_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 1506
extern __m512d __cdecl _mm512_maskz_scalef_pd(__mmask8, __m512d, __m512d); 
#line 1507
extern __m512d __cdecl _mm512_scalef_round_pd(__m512d, __m512d, int); 
#line 1508
extern __m512d __cdecl _mm512_mask_scalef_round_pd(__m512d, __mmask8, __m512d, __m512d, int); 
#line 1509
extern __m512d __cdecl _mm512_maskz_scalef_round_pd(__mmask8, __m512d, __m512d, int); 
#line 1510
extern __m512 __cdecl _mm512_scalef_ps(__m512, __m512); 
#line 1511
extern __m512 __cdecl _mm512_mask_scalef_ps(__m512, __mmask16, __m512, __m512); 
#line 1512
extern __m512 __cdecl _mm512_maskz_scalef_ps(__mmask16, __m512, __m512); 
#line 1513
extern __m512 __cdecl _mm512_scalef_round_ps(__m512, __m512, int); 
#line 1514
extern __m512 __cdecl _mm512_mask_scalef_round_ps(__m512, __mmask16, __m512, __m512, int); 
#line 1515
extern __m512 __cdecl _mm512_maskz_scalef_round_ps(__mmask16, __m512, __m512, int); 
#line 1517
extern __m512d __cdecl _mm512_fixupimm_pd(__m512d, __m512d, __m512i, const int); 
#line 1518
extern __m512d __cdecl _mm512_mask_fixupimm_pd(__m512d, __mmask8, __m512d, __m512i, const int); 
#line 1519
extern __m512d __cdecl _mm512_maskz_fixupimm_pd(__mmask8, __m512d, __m512d, __m512i, const int); 
#line 1520
extern __m512d __cdecl _mm512_fixupimm_round_pd(__m512d, __m512d, __m512i, const int, const int); 
#line 1521
extern __m512d __cdecl _mm512_mask_fixupimm_round_pd(__m512d, __mmask8, __m512d, __m512i, const int, const int); 
#line 1522
extern __m512d __cdecl _mm512_maskz_fixupimm_round_pd(__mmask8, __m512d, __m512d, __m512i, const int, const int); 
#line 1523
extern __m512 __cdecl _mm512_fixupimm_ps(__m512, __m512, __m512i, const int); 
#line 1524
extern __m512 __cdecl _mm512_mask_fixupimm_ps(__m512, __mmask16, __m512, __m512i, const int); 
#line 1525
extern __m512 __cdecl _mm512_maskz_fixupimm_ps(__mmask16, __m512, __m512, __m512i, const int); 
#line 1526
extern __m512 __cdecl _mm512_fixupimm_round_ps(__m512, __m512, __m512i, const int, const int); 
#line 1527
extern __m512 __cdecl _mm512_mask_fixupimm_round_ps(__m512, __mmask16, __m512, __m512i, const int, const int); 
#line 1528
extern __m512 __cdecl _mm512_maskz_fixupimm_round_ps(__mmask16, __m512, __m512, __m512i, const int, const int); 
#line 1530
extern void __cdecl _mm512_stream_pd(void *, __m512d); 
#line 1531
extern void __cdecl _mm512_stream_ps(void *, __m512); 
#line 1532
extern void __cdecl _mm512_stream_si512(void *, __m512i); 
#line 1533
extern __m512i __cdecl _mm512_stream_load_si512(const void *); 
#line 1535
extern __m128d __cdecl _mm512_castpd512_pd128(__m512d); 
#line 1536
extern __m128 __cdecl _mm512_castps512_ps128(__m512); 
#line 1537
extern __m128i __cdecl _mm512_castsi512_si128(__m512i); 
#line 1538
extern __m512i __cdecl _mm512_castsi128_si512(__m128i); 
#line 1540
extern __mmask16 __cdecl _mm512_fpclass_ps_mask(__m512, int); 
#line 1541
extern __mmask16 __cdecl _mm512_mask_fpclass_ps_mask(__mmask16, __m512, int); 
#line 1542
extern __mmask8 __cdecl _mm512_fpclass_pd_mask(__m512d, int); 
#line 1543
extern __mmask8 __cdecl _mm512_mask_fpclass_pd_mask(__mmask8, __m512d, int); 
#line 1545
extern __m512d __cdecl _mm512_range_pd(__m512d, __m512d, int); 
#line 1546
extern __m512d __cdecl _mm512_mask_range_pd(__m512d, __mmask8, __m512d, __m512d, int); 
#line 1547
extern __m512d __cdecl _mm512_maskz_range_pd(__mmask8, __m512d, __m512d, int); 
#line 1548
extern __m512d __cdecl _mm512_range_round_pd(__m512d, __m512d, int, int); 
#line 1549
extern __m512d __cdecl _mm512_mask_range_round_pd(__m512d, __mmask8, __m512d, __m512d, int, int); 
#line 1550
extern __m512d __cdecl _mm512_maskz_range_round_pd(__mmask8, __m512d, __m512d, int, int); 
#line 1551
extern __m512 __cdecl _mm512_range_ps(__m512, __m512, int); 
#line 1552
extern __m512 __cdecl _mm512_mask_range_ps(__m512, __mmask16, __m512, __m512, int); 
#line 1553
extern __m512 __cdecl _mm512_maskz_range_ps(__mmask16, __m512, __m512, int); 
#line 1554
extern __m512 __cdecl _mm512_range_round_ps(__m512, __m512, int, int); 
#line 1555
extern __m512 __cdecl _mm512_mask_range_round_ps(__m512, __mmask16, __m512, __m512, int, int); 
#line 1556
extern __m512 __cdecl _mm512_maskz_range_round_ps(__mmask16, __m512, __m512, int, int); 
#line 1558
extern __m512i __cdecl _mm512_madd_epi16(__m512i, __m512i); 
#line 1559
extern __m512i __cdecl _mm512_mask_madd_epi16(__m512i, __mmask16, __m512i, __m512i); 
#line 1560
extern __m512i __cdecl _mm512_maskz_madd_epi16(__mmask16, __m512i, __m512i); 
#line 1561
extern __m512i __cdecl _mm512_maddubs_epi16(__m512i, __m512i); 
#line 1562
extern __m512i __cdecl _mm512_mask_maddubs_epi16(__m512i, __mmask32, __m512i, __m512i); 
#line 1563
extern __m512i __cdecl _mm512_maskz_maddubs_epi16(__mmask32, __m512i, __m512i); 
#line 1565
extern __m512i __cdecl _mm512_packs_epi16(__m512i, __m512i); 
#line 1566
extern __m512i __cdecl _mm512_mask_packs_epi16(__m512i, __mmask64, __m512i, __m512i); 
#line 1567
extern __m512i __cdecl _mm512_maskz_packs_epi16(__mmask64, __m512i, __m512i); 
#line 1568
extern __m512i __cdecl _mm512_packs_epi32(__m512i, __m512i); 
#line 1569
extern __m512i __cdecl _mm512_mask_packs_epi32(__m512i, __mmask32, __m512i, __m512i); 
#line 1570
extern __m512i __cdecl _mm512_maskz_packs_epi32(__mmask32, __m512i, __m512i); 
#line 1571
extern __m512i __cdecl _mm512_packus_epi16(__m512i, __m512i); 
#line 1572
extern __m512i __cdecl _mm512_mask_packus_epi16(__m512i, __mmask64, __m512i, __m512i); 
#line 1573
extern __m512i __cdecl _mm512_maskz_packus_epi16(__mmask64, __m512i, __m512i); 
#line 1574
extern __m512i __cdecl _mm512_packus_epi32(__m512i, __m512i); 
#line 1575
extern __m512i __cdecl _mm512_mask_packus_epi32(__m512i, __mmask32, __m512i, __m512i); 
#line 1576
extern __m512i __cdecl _mm512_maskz_packus_epi32(__mmask32, __m512i, __m512i); 
#line 1578
extern __mmask64 __cdecl _mm512_cmp_epi8_mask(__m512i, __m512i, const int); 
#line 1579
extern __mmask64 __cdecl _mm512_mask_cmp_epi8_mask(__mmask64, __m512i, __m512i, const int); 
#line 1580
extern __mmask32 __cdecl _mm512_cmp_epi16_mask(__m512i, __m512i, const int); 
#line 1581
extern __mmask32 __cdecl _mm512_mask_cmp_epi16_mask(__mmask32, __m512i, __m512i, const int); 
#line 1582
extern __mmask16 __cdecl _mm512_cmp_epi32_mask(__m512i, __m512i, const int); 
#line 1583
extern __mmask16 __cdecl _mm512_mask_cmp_epi32_mask(__mmask16, __m512i, __m512i, const int); 
#line 1584
extern __mmask8 __cdecl _mm512_cmp_epi64_mask(__m512i, __m512i, const int); 
#line 1585
extern __mmask8 __cdecl _mm512_mask_cmp_epi64_mask(__mmask8, __m512i, __m512i, const int); 
#line 1586
extern __mmask64 __cdecl _mm512_cmp_epu8_mask(__m512i, __m512i, const int); 
#line 1587
extern __mmask64 __cdecl _mm512_mask_cmp_epu8_mask(__mmask64, __m512i, __m512i, const int); 
#line 1588
extern __mmask32 __cdecl _mm512_cmp_epu16_mask(__m512i, __m512i, const int); 
#line 1589
extern __mmask32 __cdecl _mm512_mask_cmp_epu16_mask(__mmask32, __m512i, __m512i, const int); 
#line 1590
extern __mmask16 __cdecl _mm512_cmp_epu32_mask(__m512i, __m512i, const int); 
#line 1591
extern __mmask16 __cdecl _mm512_mask_cmp_epu32_mask(__mmask16, __m512i, __m512i, const int); 
#line 1592
extern __mmask8 __cdecl _mm512_cmp_epu64_mask(__m512i, __m512i, const int); 
#line 1593
extern __mmask8 __cdecl _mm512_mask_cmp_epu64_mask(__mmask8, __m512i, __m512i, const int); 
#line 1595
extern __mmask64 __cdecl _mm512_test_epi8_mask(__m512i, __m512i); 
#line 1596
extern __mmask64 __cdecl _mm512_mask_test_epi8_mask(__mmask64, __m512i, __m512i); 
#line 1597
extern __mmask32 __cdecl _mm512_test_epi16_mask(__m512i, __m512i); 
#line 1598
extern __mmask32 __cdecl _mm512_mask_test_epi16_mask(__mmask32, __m512i, __m512i); 
#line 1599
extern __mmask64 __cdecl _mm512_testn_epi8_mask(__m512i, __m512i); 
#line 1600
extern __mmask64 __cdecl _mm512_mask_testn_epi8_mask(__mmask64, __m512i, __m512i); 
#line 1601
extern __mmask32 __cdecl _mm512_testn_epi16_mask(__m512i, __m512i); 
#line 1602
extern __mmask32 __cdecl _mm512_mask_testn_epi16_mask(__mmask32, __m512i, __m512i); 
#line 1603
extern __mmask16 __cdecl _mm512_test_epi32_mask(__m512i, __m512i); 
#line 1604
extern __mmask16 __cdecl _mm512_mask_test_epi32_mask(__mmask16, __m512i, __m512i); 
#line 1605
extern __mmask8 __cdecl _mm512_test_epi64_mask(__m512i, __m512i); 
#line 1606
extern __mmask8 __cdecl _mm512_mask_test_epi64_mask(__mmask8, __m512i, __m512i); 
#line 1607
extern __mmask16 __cdecl _mm512_testn_epi32_mask(__m512i, __m512i); 
#line 1608
extern __mmask16 __cdecl _mm512_mask_testn_epi32_mask(__mmask16, __m512i, __m512i); 
#line 1609
extern __mmask8 __cdecl _mm512_testn_epi64_mask(__m512i, __m512i); 
#line 1610
extern __mmask8 __cdecl _mm512_mask_testn_epi64_mask(__mmask8, __m512i, __m512i); 
#line 1612
extern __mmask16 __cdecl _mm512_kunpackb(__mmask16, __mmask16); 
#line 1613
extern __mmask32 __cdecl _mm512_kunpackw(__mmask32, __mmask32); 
#line 1614
extern __mmask64 __cdecl _mm512_kunpackd(__mmask64, __mmask64); 
#line 1616
extern unsigned char __cdecl _mm512_testz_and_mask8(__mmask8, __mmask8); 
#line 1617
extern unsigned char __cdecl _mm512_testz_and_mask16(__mmask16, __mmask16); 
#line 1618
extern unsigned char __cdecl _mm512_testz_and_mask32(__mmask32, __mmask32); 
#line 1619
extern unsigned char __cdecl _mm512_testz_and_mask64(__mmask64, __mmask64); 
#line 1620
extern unsigned char __cdecl _mm512_testz_andn_mask8(__mmask8, __mmask8); 
#line 1621
extern unsigned char __cdecl _mm512_testz_andn_mask16(__mmask16, __mmask16); 
#line 1622
extern unsigned char __cdecl _mm512_testz_andn_mask32(__mmask32, __mmask32); 
#line 1623
extern unsigned char __cdecl _mm512_testz_andn_mask64(__mmask64, __mmask64); 
#line 1624
extern unsigned char __cdecl _mm512_testz_or_mask8(__mmask8, __mmask8); 
#line 1625
extern unsigned char __cdecl _mm512_testz_or_mask16(__mmask16, __mmask16); 
#line 1626
extern unsigned char __cdecl _mm512_testz_or_mask32(__mmask32, __mmask32); 
#line 1627
extern unsigned char __cdecl _mm512_testz_or_mask64(__mmask64, __mmask64); 
#line 1628
extern unsigned char __cdecl _mm512_testz_nor_mask8(__mmask8, __mmask8); 
#line 1629
extern unsigned char __cdecl _mm512_testz_nor_mask16(__mmask16, __mmask16); 
#line 1630
extern unsigned char __cdecl _mm512_testz_nor_mask32(__mmask32, __mmask32); 
#line 1631
extern unsigned char __cdecl _mm512_testz_nor_mask64(__mmask64, __mmask64); 
#line 1633
extern __m512 __cdecl _mm512_i32gather_ps(__m512i, const void *, int); 
#line 1634
extern __m512 __cdecl _mm512_mask_i32gather_ps(__m512, __mmask16, __m512i, const void *, int); 
#line 1635
extern void __cdecl _mm512_i32scatter_ps(void *, __m512i, __m512, int); 
#line 1636
extern void __cdecl _mm512_mask_i32scatter_ps(void *, __mmask16, __m512i, __m512, int); 
#line 1637
extern __m512d __cdecl _mm512_i64gather_pd(__m512i, const void *, int); 
#line 1638
extern __m512d __cdecl _mm512_mask_i64gather_pd(__m512d, __mmask8, __m512i, const void *, int); 
#line 1639
extern void __cdecl _mm512_i64scatter_pd(void *, __m512i, __m512d, int); 
#line 1640
extern void __cdecl _mm512_mask_i64scatter_pd(void *, __mmask8, __m512i, __m512d, int); 
#line 1641
extern __m512d __cdecl _mm512_i32gather_pd(__m256i, const void *, int); 
#line 1642
extern __m512d __cdecl _mm512_mask_i32gather_pd(__m512d, __mmask8, __m256i, const void *, int); 
#line 1643
extern void __cdecl _mm512_i32scatter_pd(void *, __m256i, __m512d, int); 
#line 1644
extern void __cdecl _mm512_mask_i32scatter_pd(void *, __mmask8, __m256i, __m512d, int); 
#line 1645
extern __m512i __cdecl _mm512_i32gather_epi32(__m512i, const void *, int); 
#line 1646
extern __m512i __cdecl _mm512_mask_i32gather_epi32(__m512i, __mmask16, __m512i, const void *, int); 
#line 1647
extern void __cdecl _mm512_i32scatter_epi32(void *, __m512i, __m512i, int); 
#line 1648
extern void __cdecl _mm512_mask_i32scatter_epi32(void *, __mmask16, __m512i, __m512i, int); 
#line 1649
extern __m512i __cdecl _mm512_i32gather_epi64(__m256i, const void *, int); 
#line 1650
extern __m512i __cdecl _mm512_mask_i32gather_epi64(__m512i, __mmask8, __m256i, const void *, int); 
#line 1651
extern __m512i __cdecl _mm512_i64gather_epi64(__m512i, const void *, int); 
#line 1652
extern __m512i __cdecl _mm512_mask_i64gather_epi64(__m512i, __mmask8, __m512i, const void *, int); 
#line 1653
extern void __cdecl _mm512_i32scatter_epi64(void *, __m256i, __m512i, int); 
#line 1654
extern void __cdecl _mm512_mask_i32scatter_epi64(void *, __mmask8, __m256i, __m512i, int); 
#line 1655
extern void __cdecl _mm512_i64scatter_epi64(void *, __m512i, __m512i, int); 
#line 1656
extern void __cdecl _mm512_mask_i64scatter_epi64(void *, __mmask8, __m512i, __m512i, int); 
#line 1657
extern __m256 __cdecl _mm512_i64gather_ps(__m512i, const void *, int); 
#line 1658
extern __m256 __cdecl _mm512_mask_i64gather_ps(__m256, __mmask8, __m512i, const void *, int); 
#line 1659
extern void __cdecl _mm512_i64scatter_ps(void *, __m512i, __m256, int); 
#line 1660
extern void __cdecl _mm512_mask_i64scatter_ps(void *, __mmask8, __m512i, __m256, int); 
#line 1661
extern __m256i __cdecl _mm512_i64gather_epi32(__m512i, const void *, int); 
#line 1662
extern __m256i __cdecl _mm512_mask_i64gather_epi32(__m256i, __mmask8, __m512i, const void *, int); 
#line 1663
extern void __cdecl _mm512_i64scatter_epi32(void *, __m512i, __m256i, int); 
#line 1664
extern void __cdecl _mm512_mask_i64scatter_epi32(void *, __mmask8, __m512i, __m256i, int); 
#line 1666
extern __m512d __cdecl _mm512_cvtpslo_pd(__m512); 
#line 1667
extern __m512d __cdecl _mm512_mask_cvtpslo_pd(__m512d, __mmask8, __m512); 
#line 1668
extern __m512d __cdecl _mm512_cvtepi32lo_pd(__m512i); 
#line 1669
extern __m512d __cdecl _mm512_mask_cvtepi32lo_pd(__m512d, __mmask8, __m512i); 
#line 1670
extern __m512d __cdecl _mm512_cvtepu32lo_pd(__m512i); 
#line 1671
extern __m512d __cdecl _mm512_mask_cvtepu32lo_pd(__m512d, __mmask8, __m512i); 
#line 1672
extern __m512d __cdecl _mm512_cvtepi32_pd(__m256i); 
#line 1673
extern __m512d __cdecl _mm512_mask_cvtepi32_pd(__m512d, __mmask8, __m256i); 
#line 1674
extern __m512d __cdecl _mm512_maskz_cvtepi32_pd(__mmask8, __m256i); 
#line 1675
extern __m512d __cdecl _mm512_cvtepu32_pd(__m256i); 
#line 1676
extern __m512d __cdecl _mm512_mask_cvtepu32_pd(__m512d, __mmask8, __m256i); 
#line 1677
extern __m512d __cdecl _mm512_maskz_cvtepu32_pd(__mmask8, __m256i); 
#line 1679
extern __m512 __cdecl _mm512_cvtepi32_ps(__m512i); 
#line 1680
extern __m512 __cdecl _mm512_mask_cvtepi32_ps(__m512, __mmask16, __m512i); 
#line 1681
extern __m512 __cdecl _mm512_maskz_cvtepi32_ps(__mmask16, __m512i); 
#line 1682
extern __m512 __cdecl _mm512_cvt_roundepi32_ps(__m512i, int); 
#line 1683
extern __m512 __cdecl _mm512_mask_cvt_roundepi32_ps(__m512, __mmask16, __m512i, int); 
#line 1684
extern __m512 __cdecl _mm512_maskz_cvt_roundepi32_ps(__mmask16, __m512i, int); 
#line 1685
extern __m512 __cdecl _mm512_cvtepu32_ps(__m512i); 
#line 1686
extern __m512 __cdecl _mm512_mask_cvtepu32_ps(__m512, __mmask16, __m512i); 
#line 1687
extern __m512 __cdecl _mm512_maskz_cvtepu32_ps(__mmask16, __m512i); 
#line 1688
extern __m512 __cdecl _mm512_cvt_roundepu32_ps(__m512i, int); 
#line 1689
extern __m512 __cdecl _mm512_mask_cvt_roundepu32_ps(__m512, __mmask16, __m512i, int); 
#line 1690
extern __m512 __cdecl _mm512_maskz_cvt_roundepu32_ps(__mmask16, __m512i, int); 
#line 1691
extern __m512 __cdecl _mm512_cvtph_ps(__m256i); 
#line 1692
extern __m512 __cdecl _mm512_mask_cvtph_ps(__m512, __mmask16, __m256i); 
#line 1693
extern __m512 __cdecl _mm512_maskz_cvtph_ps(__mmask16, __m256i); 
#line 1694
extern __m512 __cdecl _mm512_cvt_roundph_ps(__m256i, int); 
#line 1695
extern __m512 __cdecl _mm512_mask_cvt_roundph_ps(__m512, __mmask16, __m256i, int); 
#line 1696
extern __m512 __cdecl _mm512_maskz_cvt_roundph_ps(__mmask16, __m256i, int); 
#line 1697
extern __m256i __cdecl _mm512_cvtps_ph(__m512, int); 
#line 1698
extern __m256i __cdecl _mm512_mask_cvtps_ph(__m256i, __mmask16, __m512, int); 
#line 1699
extern __m256i __cdecl _mm512_maskz_cvtps_ph(__mmask16, __m512, int); 
#line 1700
extern __m256i __cdecl _mm512_cvt_roundps_ph(__m512, int); 
#line 1701
extern __m256i __cdecl _mm512_mask_cvt_roundps_ph(__m256i, __mmask16, __m512, int); 
#line 1702
extern __m256i __cdecl _mm512_maskz_cvt_roundps_ph(__mmask16, __m512, int); 
#line 1703
extern __m256 __cdecl _mm512_cvtepi64_ps(__m512i); 
#line 1704
extern __m256 __cdecl _mm512_mask_cvtepi64_ps(__m256, __mmask8, __m512i); 
#line 1705
extern __m256 __cdecl _mm512_maskz_cvtepi64_ps(__mmask8, __m512i); 
#line 1706
extern __m256 __cdecl _mm512_cvt_roundepi64_ps(__m512i, int); 
#line 1707
extern __m256 __cdecl _mm512_mask_cvt_roundepi64_ps(__m256, __mmask8, __m512i, int); 
#line 1708
extern __m256 __cdecl _mm512_maskz_cvt_roundepi64_ps(__mmask8, __m512i, int); 
#line 1709
extern __m256 __cdecl _mm512_cvtepu64_ps(__m512i); 
#line 1710
extern __m256 __cdecl _mm512_mask_cvtepu64_ps(__m256, __mmask8, __m512i); 
#line 1711
extern __m256 __cdecl _mm512_maskz_cvtepu64_ps(__mmask8, __m512i); 
#line 1712
extern __m256 __cdecl _mm512_cvt_roundepu64_ps(__m512i, int); 
#line 1713
extern __m256 __cdecl _mm512_mask_cvt_roundepu64_ps(__m256, __mmask8, __m512i, int); 
#line 1714
extern __m256 __cdecl _mm512_maskz_cvt_roundepu64_ps(__mmask8, __m512i, int); 
#line 1716
extern __m512i __cdecl _mm512_cvtepi8_epi32(__m128i); 
#line 1717
extern __m512i __cdecl _mm512_mask_cvtepi8_epi32(__m512i, __mmask16, __m128i); 
#line 1718
extern __m512i __cdecl _mm512_maskz_cvtepi8_epi32(__mmask16, __m128i); 
#line 1719
extern __m512i __cdecl _mm512_cvtepi8_epi64(__m128i); 
#line 1720
extern __m512i __cdecl _mm512_mask_cvtepi8_epi64(__m512i, __mmask8, __m128i); 
#line 1721
extern __m512i __cdecl _mm512_maskz_cvtepi8_epi64(__mmask8, __m128i); 
#line 1722
extern __m512i __cdecl _mm512_cvtepi16_epi32(__m256i); 
#line 1723
extern __m512i __cdecl _mm512_mask_cvtepi16_epi32(__m512i, __mmask16, __m256i); 
#line 1724
extern __m512i __cdecl _mm512_maskz_cvtepi16_epi32(__mmask16, __m256i); 
#line 1725
extern __m512i __cdecl _mm512_cvtepi16_epi64(__m128i); 
#line 1726
extern __m512i __cdecl _mm512_mask_cvtepi16_epi64(__m512i, __mmask8, __m128i); 
#line 1727
extern __m512i __cdecl _mm512_maskz_cvtepi16_epi64(__mmask8, __m128i); 
#line 1728
extern __m128i __cdecl _mm512_cvtepi32_epi8(__m512i); 
#line 1729
extern __m128i __cdecl _mm512_mask_cvtepi32_epi8(__m128i, __mmask16, __m512i); 
#line 1730
extern __m128i __cdecl _mm512_maskz_cvtepi32_epi8(__mmask16, __m512i); 
#line 1731
extern void __cdecl _mm512_mask_cvtepi32_storeu_epi8(void *, __mmask16, __m512i); 
#line 1732
extern __m128i __cdecl _mm512_cvtsepi32_epi8(__m512i); 
#line 1733
extern __m128i __cdecl _mm512_mask_cvtsepi32_epi8(__m128i, __mmask16, __m512i); 
#line 1734
extern __m128i __cdecl _mm512_maskz_cvtsepi32_epi8(__mmask16, __m512i); 
#line 1735
extern void __cdecl _mm512_mask_cvtsepi32_storeu_epi8(void *, __mmask16, __m512i); 
#line 1736
extern __m128i __cdecl _mm512_cvtusepi32_epi8(__m512i); 
#line 1737
extern __m128i __cdecl _mm512_mask_cvtusepi32_epi8(__m128i, __mmask16, __m512i); 
#line 1738
extern __m128i __cdecl _mm512_maskz_cvtusepi32_epi8(__mmask16, __m512i); 
#line 1739
extern void __cdecl _mm512_mask_cvtusepi32_storeu_epi8(void *, __mmask16, __m512i); 
#line 1740
extern __m256i __cdecl _mm512_cvtepi32_epi16(__m512i); 
#line 1741
extern __m256i __cdecl _mm512_mask_cvtepi32_epi16(__m256i, __mmask16, __m512i); 
#line 1742
extern __m256i __cdecl _mm512_maskz_cvtepi32_epi16(__mmask16, __m512i); 
#line 1743
extern void __cdecl _mm512_mask_cvtepi32_storeu_epi16(void *, __mmask16, __m512i); 
#line 1744
extern __m256i __cdecl _mm512_cvtsepi32_epi16(__m512i); 
#line 1745
extern __m256i __cdecl _mm512_mask_cvtsepi32_epi16(__m256i, __mmask16, __m512i); 
#line 1746
extern __m256i __cdecl _mm512_maskz_cvtsepi32_epi16(__mmask16, __m512i); 
#line 1747
extern void __cdecl _mm512_mask_cvtsepi32_storeu_epi16(void *, __mmask16, __m512i); 
#line 1748
extern __m256i __cdecl _mm512_cvtusepi32_epi16(__m512i); 
#line 1749
extern __m256i __cdecl _mm512_mask_cvtusepi32_epi16(__m256i, __mmask16, __m512i); 
#line 1750
extern __m256i __cdecl _mm512_maskz_cvtusepi32_epi16(__mmask16, __m512i); 
#line 1751
extern void __cdecl _mm512_mask_cvtusepi32_storeu_epi16(void *, __mmask16, __m512i); 
#line 1752
extern __m512i __cdecl _mm512_cvtepi32_epi64(__m256i); 
#line 1753
extern __m512i __cdecl _mm512_mask_cvtepi32_epi64(__m512i, __mmask8, __m256i); 
#line 1754
extern __m512i __cdecl _mm512_maskz_cvtepi32_epi64(__mmask8, __m256i); 
#line 1755
extern __m128i __cdecl _mm512_cvtepi64_epi8(__m512i); 
#line 1756
extern __m128i __cdecl _mm512_mask_cvtepi64_epi8(__m128i, __mmask8, __m512i); 
#line 1757
extern __m128i __cdecl _mm512_maskz_cvtepi64_epi8(__mmask8, __m512i); 
#line 1758
extern void __cdecl _mm512_mask_cvtepi64_storeu_epi8(void *, __mmask8, __m512i); 
#line 1759
extern __m128i __cdecl _mm512_cvtsepi64_epi8(__m512i); 
#line 1760
extern __m128i __cdecl _mm512_mask_cvtsepi64_epi8(__m128i, __mmask8, __m512i); 
#line 1761
extern __m128i __cdecl _mm512_maskz_cvtsepi64_epi8(__mmask8, __m512i); 
#line 1762
extern void __cdecl _mm512_mask_cvtsepi64_storeu_epi8(void *, __mmask8, __m512i); 
#line 1763
extern __m128i __cdecl _mm512_cvtusepi64_epi8(__m512i); 
#line 1764
extern __m128i __cdecl _mm512_mask_cvtusepi64_epi8(__m128i, __mmask8, __m512i); 
#line 1765
extern __m128i __cdecl _mm512_maskz_cvtusepi64_epi8(__mmask8, __m512i); 
#line 1766
extern void __cdecl _mm512_mask_cvtusepi64_storeu_epi8(void *, __mmask8, __m512i); 
#line 1767
extern __m128i __cdecl _mm512_cvtepi64_epi16(__m512i); 
#line 1768
extern __m128i __cdecl _mm512_mask_cvtepi64_epi16(__m128i, __mmask8, __m512i); 
#line 1769
extern __m128i __cdecl _mm512_maskz_cvtepi64_epi16(__mmask8, __m512i); 
#line 1770
extern void __cdecl _mm512_mask_cvtepi64_storeu_epi16(void *, __mmask8, __m512i); 
#line 1771
extern __m128i __cdecl _mm512_cvtsepi64_epi16(__m512i); 
#line 1772
extern __m128i __cdecl _mm512_mask_cvtsepi64_epi16(__m128i, __mmask8, __m512i); 
#line 1773
extern __m128i __cdecl _mm512_maskz_cvtsepi64_epi16(__mmask8, __m512i); 
#line 1774
extern void __cdecl _mm512_mask_cvtsepi64_storeu_epi16(void *, __mmask8, __m512i); 
#line 1775
extern __m128i __cdecl _mm512_cvtusepi64_epi16(__m512i); 
#line 1776
extern __m128i __cdecl _mm512_mask_cvtusepi64_epi16(__m128i, __mmask8, __m512i); 
#line 1777
extern __m128i __cdecl _mm512_maskz_cvtusepi64_epi16(__mmask8, __m512i); 
#line 1778
extern void __cdecl _mm512_mask_cvtusepi64_storeu_epi16(void *, __mmask8, __m512i); 
#line 1779
extern __m256i __cdecl _mm512_cvtepi64_epi32(__m512i); 
#line 1780
extern __m256i __cdecl _mm512_mask_cvtepi64_epi32(__m256i, __mmask8, __m512i); 
#line 1781
extern __m256i __cdecl _mm512_maskz_cvtepi64_epi32(__mmask8, __m512i); 
#line 1782
extern void __cdecl _mm512_mask_cvtepi64_storeu_epi32(void *, __mmask8, __m512i); 
#line 1783
extern __m256i __cdecl _mm512_cvtsepi64_epi32(__m512i); 
#line 1784
extern __m256i __cdecl _mm512_mask_cvtsepi64_epi32(__m256i, __mmask8, __m512i); 
#line 1785
extern __m256i __cdecl _mm512_maskz_cvtsepi64_epi32(__mmask8, __m512i); 
#line 1786
extern void __cdecl _mm512_mask_cvtsepi64_storeu_epi32(void *, __mmask8, __m512i); 
#line 1787
extern __m256i __cdecl _mm512_cvtusepi64_epi32(__m512i); 
#line 1788
extern __m256i __cdecl _mm512_mask_cvtusepi64_epi32(__m256i, __mmask8, __m512i); 
#line 1789
extern __m256i __cdecl _mm512_maskz_cvtusepi64_epi32(__mmask8, __m512i); 
#line 1790
extern void __cdecl _mm512_mask_cvtusepi64_storeu_epi32(void *, __mmask8, __m512i); 
#line 1791
extern __m512i __cdecl _mm512_cvtepu8_epi32(__m128i); 
#line 1792
extern __m512i __cdecl _mm512_mask_cvtepu8_epi32(__m512i, __mmask16, __m128i); 
#line 1793
extern __m512i __cdecl _mm512_maskz_cvtepu8_epi32(__mmask16, __m128i); 
#line 1794
extern __m512i __cdecl _mm512_cvtepu8_epi64(__m128i); 
#line 1795
extern __m512i __cdecl _mm512_mask_cvtepu8_epi64(__m512i, __mmask8, __m128i); 
#line 1796
extern __m512i __cdecl _mm512_maskz_cvtepu8_epi64(__mmask8, __m128i); 
#line 1797
extern __m512i __cdecl _mm512_cvtepu16_epi32(__m256i); 
#line 1798
extern __m512i __cdecl _mm512_mask_cvtepu16_epi32(__m512i, __mmask16, __m256i); 
#line 1799
extern __m512i __cdecl _mm512_maskz_cvtepu16_epi32(__mmask16, __m256i); 
#line 1800
extern __m512i __cdecl _mm512_cvtepu16_epi64(__m128i); 
#line 1801
extern __m512i __cdecl _mm512_mask_cvtepu16_epi64(__m512i, __mmask8, __m128i); 
#line 1802
extern __m512i __cdecl _mm512_maskz_cvtepu16_epi64(__mmask8, __m128i); 
#line 1803
extern __m512i __cdecl _mm512_cvtepu32_epi64(__m256i); 
#line 1804
extern __m512i __cdecl _mm512_mask_cvtepu32_epi64(__m512i, __mmask8, __m256i); 
#line 1805
extern __m512i __cdecl _mm512_maskz_cvtepu32_epi64(__mmask8, __m256i); 
#line 1807
extern __m512i __cdecl _mm512_cvtps_epi32(__m512); 
#line 1808
extern __m512i __cdecl _mm512_mask_cvtps_epi32(__m512i, __mmask16, __m512); 
#line 1809
extern __m512i __cdecl _mm512_maskz_cvtps_epi32(__mmask16, __m512); 
#line 1810
extern __m512i __cdecl _mm512_cvt_roundps_epi32(__m512, int); 
#line 1811
extern __m512i __cdecl _mm512_mask_cvt_roundps_epi32(__m512i, __mmask16, __m512, int); 
#line 1812
extern __m512i __cdecl _mm512_maskz_cvt_roundps_epi32(__mmask16, __m512, int); 
#line 1813
extern __m512i __cdecl _mm512_cvttps_epi32(__m512); 
#line 1814
extern __m512i __cdecl _mm512_mask_cvttps_epi32(__m512i, __mmask16, __m512); 
#line 1815
extern __m512i __cdecl _mm512_maskz_cvttps_epi32(__mmask16, __m512); 
#line 1816
extern __m512i __cdecl _mm512_cvtt_roundps_epi32(__m512, int); 
#line 1817
extern __m512i __cdecl _mm512_mask_cvtt_roundps_epi32(__m512i, __mmask16, __m512, int); 
#line 1818
extern __m512i __cdecl _mm512_maskz_cvtt_roundps_epi32(__mmask16, __m512, int); 
#line 1819
extern __m512i __cdecl _mm512_cvtps_epu32(__m512); 
#line 1820
extern __m512i __cdecl _mm512_mask_cvtps_epu32(__m512i, __mmask16, __m512); 
#line 1821
extern __m512i __cdecl _mm512_maskz_cvtps_epu32(__mmask16, __m512); 
#line 1822
extern __m512i __cdecl _mm512_cvt_roundps_epu32(__m512, int); 
#line 1823
extern __m512i __cdecl _mm512_mask_cvt_roundps_epu32(__m512i, __mmask16, __m512, int); 
#line 1824
extern __m512i __cdecl _mm512_maskz_cvt_roundps_epu32(__mmask16, __m512, int); 
#line 1825
extern __m512i __cdecl _mm512_cvttps_epu32(__m512); 
#line 1826
extern __m512i __cdecl _mm512_mask_cvttps_epu32(__m512i, __mmask16, __m512); 
#line 1827
extern __m512i __cdecl _mm512_maskz_cvttps_epu32(__mmask16, __m512); 
#line 1828
extern __m512i __cdecl _mm512_cvtt_roundps_epu32(__m512, int); 
#line 1829
extern __m512i __cdecl _mm512_mask_cvtt_roundps_epu32(__m512i, __mmask16, __m512, int); 
#line 1830
extern __m512i __cdecl _mm512_maskz_cvtt_roundps_epu32(__mmask16, __m512, int); 
#line 1831
extern __m256i __cdecl _mm512_cvtpd_epi32(__m512d); 
#line 1832
extern __m256i __cdecl _mm512_mask_cvtpd_epi32(__m256i, __mmask8, __m512d); 
#line 1833
extern __m256i __cdecl _mm512_maskz_cvtpd_epi32(__mmask8, __m512d); 
#line 1834
extern __m256i __cdecl _mm512_cvt_roundpd_epi32(__m512d, int); 
#line 1835
extern __m256i __cdecl _mm512_mask_cvt_roundpd_epi32(__m256i, __mmask8, __m512d, int); 
#line 1836
extern __m256i __cdecl _mm512_maskz_cvt_roundpd_epi32(__mmask8, __m512d, int); 
#line 1837
extern __m256i __cdecl _mm512_cvttpd_epi32(__m512d); 
#line 1838
extern __m256i __cdecl _mm512_mask_cvttpd_epi32(__m256i, __mmask8, __m512d); 
#line 1839
extern __m256i __cdecl _mm512_maskz_cvttpd_epi32(__mmask8, __m512d); 
#line 1840
extern __m256i __cdecl _mm512_cvtt_roundpd_epi32(__m512d, int); 
#line 1841
extern __m256i __cdecl _mm512_mask_cvtt_roundpd_epi32(__m256i, __mmask8, __m512d, int); 
#line 1842
extern __m256i __cdecl _mm512_maskz_cvtt_roundpd_epi32(__mmask8, __m512d, int); 
#line 1843
extern __m256i __cdecl _mm512_cvtpd_epu32(__m512d); 
#line 1844
extern __m256i __cdecl _mm512_mask_cvtpd_epu32(__m256i, __mmask8, __m512d); 
#line 1845
extern __m256i __cdecl _mm512_maskz_cvtpd_epu32(__mmask8, __m512d); 
#line 1846
extern __m256i __cdecl _mm512_cvt_roundpd_epu32(__m512d, int); 
#line 1847
extern __m256i __cdecl _mm512_mask_cvt_roundpd_epu32(__m256i, __mmask8, __m512d, int); 
#line 1848
extern __m256i __cdecl _mm512_maskz_cvt_roundpd_epu32(__mmask8, __m512d, int); 
#line 1849
extern __m256i __cdecl _mm512_cvttpd_epu32(__m512d); 
#line 1850
extern __m256i __cdecl _mm512_mask_cvttpd_epu32(__m256i, __mmask8, __m512d); 
#line 1851
extern __m256i __cdecl _mm512_maskz_cvttpd_epu32(__mmask8, __m512d); 
#line 1852
extern __m256i __cdecl _mm512_cvtt_roundpd_epu32(__m512d, int); 
#line 1853
extern __m256i __cdecl _mm512_mask_cvtt_roundpd_epu32(__m256i, __mmask8, __m512d, int); 
#line 1854
extern __m256i __cdecl _mm512_maskz_cvtt_roundpd_epu32(__mmask8, __m512d, int); 
#line 1856
extern __m512i __cdecl _mm512_cvtepi8_epi16(__m256i); 
#line 1857
extern __m512i __cdecl _mm512_mask_cvtepi8_epi16(__m512i, __mmask32, __m256i); 
#line 1858
extern __m512i __cdecl _mm512_maskz_cvtepi8_epi16(__mmask32, __m256i); 
#line 1859
extern __m512i __cdecl _mm512_cvtepu8_epi16(__m256i); 
#line 1860
extern __m512i __cdecl _mm512_mask_cvtepu8_epi16(__m512i, __mmask32, __m256i); 
#line 1861
extern __m512i __cdecl _mm512_maskz_cvtepu8_epi16(__mmask32, __m256i); 
#line 1862
extern __m256i __cdecl _mm512_cvtepi16_epi8(__m512i); 
#line 1863
extern __m256i __cdecl _mm512_mask_cvtepi16_epi8(__m256i, __mmask32, __m512i); 
#line 1864
extern __m256i __cdecl _mm512_maskz_cvtepi16_epi8(__mmask32, __m512i); 
#line 1865
extern void __cdecl _mm512_mask_cvtepi16_storeu_epi8(void *, __mmask32, __m512i); 
#line 1866
extern __m256i __cdecl _mm512_cvtsepi16_epi8(__m512i); 
#line 1867
extern __m256i __cdecl _mm512_mask_cvtsepi16_epi8(__m256i, __mmask32, __m512i); 
#line 1868
extern __m256i __cdecl _mm512_maskz_cvtsepi16_epi8(__mmask32, __m512i); 
#line 1869
extern void __cdecl _mm512_mask_cvtsepi16_storeu_epi8(void *, __mmask32, __m512i); 
#line 1870
extern __m256i __cdecl _mm512_cvtusepi16_epi8(__m512i); 
#line 1871
extern __m256i __cdecl _mm512_mask_cvtusepi16_epi8(__m256i, __mmask32, __m512i); 
#line 1872
extern __m256i __cdecl _mm512_maskz_cvtusepi16_epi8(__mmask32, __m512i); 
#line 1873
extern void __cdecl _mm512_mask_cvtusepi16_storeu_epi8(void *, __mmask32, __m512i); 
#line 1875
extern __m512d __cdecl _mm512_cvtepi64_pd(__m512i); 
#line 1876
extern __m512d __cdecl _mm512_mask_cvtepi64_pd(__m512d, __mmask8, __m512i); 
#line 1877
extern __m512d __cdecl _mm512_maskz_cvtepi64_pd(__mmask8, __m512i); 
#line 1878
extern __m512d __cdecl _mm512_cvt_roundepi64_pd(__m512i, int); 
#line 1879
extern __m512d __cdecl _mm512_mask_cvt_roundepi64_pd(__m512d, __mmask8, __m512i, int); 
#line 1880
extern __m512d __cdecl _mm512_maskz_cvt_roundepi64_pd(__mmask8, __m512i, int); 
#line 1881
extern __m512d __cdecl _mm512_cvtepu64_pd(__m512i); 
#line 1882
extern __m512d __cdecl _mm512_mask_cvtepu64_pd(__m512d, __mmask8, __m512i); 
#line 1883
extern __m512d __cdecl _mm512_maskz_cvtepu64_pd(__mmask8, __m512i); 
#line 1884
extern __m512d __cdecl _mm512_cvt_roundepu64_pd(__m512i, int); 
#line 1885
extern __m512d __cdecl _mm512_mask_cvt_roundepu64_pd(__m512d, __mmask8, __m512i, int); 
#line 1886
extern __m512d __cdecl _mm512_maskz_cvt_roundepu64_pd(__mmask8, __m512i, int); 
#line 1887
extern __m512i __cdecl _mm512_cvtpd_epi64(__m512d); 
#line 1888
extern __m512i __cdecl _mm512_mask_cvtpd_epi64(__m512i, __mmask8, __m512d); 
#line 1889
extern __m512i __cdecl _mm512_maskz_cvtpd_epi64(__mmask8, __m512d); 
#line 1890
extern __m512i __cdecl _mm512_cvt_roundpd_epi64(__m512d, int); 
#line 1891
extern __m512i __cdecl _mm512_mask_cvt_roundpd_epi64(__m512i, __mmask8, __m512d, int); 
#line 1892
extern __m512i __cdecl _mm512_maskz_cvt_roundpd_epi64(__mmask8, __m512d, int); 
#line 1893
extern __m512i __cdecl _mm512_cvtpd_epu64(__m512d); 
#line 1894
extern __m512i __cdecl _mm512_mask_cvtpd_epu64(__m512i, __mmask8, __m512d); 
#line 1895
extern __m512i __cdecl _mm512_maskz_cvtpd_epu64(__mmask8, __m512d); 
#line 1896
extern __m512i __cdecl _mm512_cvt_roundpd_epu64(__m512d, int); 
#line 1897
extern __m512i __cdecl _mm512_mask_cvt_roundpd_epu64(__m512i, __mmask8, __m512d, int); 
#line 1898
extern __m512i __cdecl _mm512_maskz_cvt_roundpd_epu64(__mmask8, __m512d, int); 
#line 1899
extern __m512i __cdecl _mm512_cvttpd_epi64(__m512d); 
#line 1900
extern __m512i __cdecl _mm512_mask_cvttpd_epi64(__m512i, __mmask8, __m512d); 
#line 1901
extern __m512i __cdecl _mm512_maskz_cvttpd_epi64(__mmask8, __m512d); 
#line 1902
extern __m512i __cdecl _mm512_cvtt_roundpd_epi64(__m512d, int); 
#line 1903
extern __m512i __cdecl _mm512_mask_cvtt_roundpd_epi64(__m512i, __mmask8, __m512d, int); 
#line 1904
extern __m512i __cdecl _mm512_maskz_cvtt_roundpd_epi64(__mmask8, __m512d, int); 
#line 1905
extern __m512i __cdecl _mm512_cvttpd_epu64(__m512d); 
#line 1906
extern __m512i __cdecl _mm512_mask_cvttpd_epu64(__m512i, __mmask8, __m512d); 
#line 1907
extern __m512i __cdecl _mm512_maskz_cvttpd_epu64(__mmask8, __m512d); 
#line 1908
extern __m512i __cdecl _mm512_cvtt_roundpd_epu64(__m512d, int); 
#line 1909
extern __m512i __cdecl _mm512_mask_cvtt_roundpd_epu64(__m512i, __mmask8, __m512d, int); 
#line 1910
extern __m512i __cdecl _mm512_maskz_cvtt_roundpd_epu64(__mmask8, __m512d, int); 
#line 1911
extern __m512i __cdecl _mm512_cvtps_epi64(__m256); 
#line 1912
extern __m512i __cdecl _mm512_mask_cvtps_epi64(__m512i, __mmask8, __m256); 
#line 1913
extern __m512i __cdecl _mm512_maskz_cvtps_epi64(__mmask8, __m256); 
#line 1914
extern __m512i __cdecl _mm512_cvt_roundps_epi64(__m256, int); 
#line 1915
extern __m512i __cdecl _mm512_mask_cvt_roundps_epi64(__m512i, __mmask8, __m256, int); 
#line 1916
extern __m512i __cdecl _mm512_maskz_cvt_roundps_epi64(__mmask8, __m256, int); 
#line 1917
extern __m512i __cdecl _mm512_cvtps_epu64(__m256); 
#line 1918
extern __m512i __cdecl _mm512_mask_cvtps_epu64(__m512i, __mmask8, __m256); 
#line 1919
extern __m512i __cdecl _mm512_maskz_cvtps_epu64(__mmask8, __m256); 
#line 1920
extern __m512i __cdecl _mm512_cvt_roundps_epu64(__m256, int); 
#line 1921
extern __m512i __cdecl _mm512_mask_cvt_roundps_epu64(__m512i, __mmask8, __m256, int); 
#line 1922
extern __m512i __cdecl _mm512_maskz_cvt_roundps_epu64(__mmask8, __m256, int); 
#line 1923
extern __m512i __cdecl _mm512_cvttps_epi64(__m256); 
#line 1924
extern __m512i __cdecl _mm512_mask_cvttps_epi64(__m512i, __mmask8, __m256); 
#line 1925
extern __m512i __cdecl _mm512_maskz_cvttps_epi64(__mmask8, __m256); 
#line 1926
extern __m512i __cdecl _mm512_cvtt_roundps_epi64(__m256, int); 
#line 1927
extern __m512i __cdecl _mm512_mask_cvtt_roundps_epi64(__m512i, __mmask8, __m256, int); 
#line 1928
extern __m512i __cdecl _mm512_maskz_cvtt_roundps_epi64(__mmask8, __m256, int); 
#line 1929
extern __m512i __cdecl _mm512_cvttps_epu64(__m256); 
#line 1930
extern __m512i __cdecl _mm512_mask_cvttps_epu64(__m512i, __mmask8, __m256); 
#line 1931
extern __m512i __cdecl _mm512_maskz_cvttps_epu64(__mmask8, __m256); 
#line 1932
extern __m512i __cdecl _mm512_cvtt_roundps_epu64(__m256, int); 
#line 1933
extern __m512i __cdecl _mm512_mask_cvtt_roundps_epu64(__m512i, __mmask8, __m256, int); 
#line 1934
extern __m512i __cdecl _mm512_maskz_cvtt_roundps_epu64(__mmask8, __m256, int); 
#line 1936
extern __mmask64 __cdecl _mm512_cmpeq_epi8_mask(__m512i, __m512i); 
#line 1937
extern __mmask64 __cdecl _mm512_cmpge_epi8_mask(__m512i, __m512i); 
#line 1938
extern __mmask64 __cdecl _mm512_cmpgt_epi8_mask(__m512i, __m512i); 
#line 1939
extern __mmask64 __cdecl _mm512_cmple_epi8_mask(__m512i, __m512i); 
#line 1940
extern __mmask64 __cdecl _mm512_cmplt_epi8_mask(__m512i, __m512i); 
#line 1941
extern __mmask64 __cdecl _mm512_cmpneq_epi8_mask(__m512i, __m512i); 
#line 1942
extern __mmask64 __cdecl _mm512_cmpeq_epu8_mask(__m512i, __m512i); 
#line 1943
extern __mmask64 __cdecl _mm512_cmpge_epu8_mask(__m512i, __m512i); 
#line 1944
extern __mmask64 __cdecl _mm512_cmpgt_epu8_mask(__m512i, __m512i); 
#line 1945
extern __mmask64 __cdecl _mm512_cmple_epu8_mask(__m512i, __m512i); 
#line 1946
extern __mmask64 __cdecl _mm512_cmplt_epu8_mask(__m512i, __m512i); 
#line 1947
extern __mmask64 __cdecl _mm512_cmpneq_epu8_mask(__m512i, __m512i); 
#line 1949
extern __mmask64 __cdecl _mm512_mask_cmpeq_epi8_mask(__mmask64, __m512i, __m512i); 
#line 1950
extern __mmask64 __cdecl _mm512_mask_cmpge_epi8_mask(__mmask64, __m512i, __m512i); 
#line 1951
extern __mmask64 __cdecl _mm512_mask_cmpgt_epi8_mask(__mmask64, __m512i, __m512i); 
#line 1952
extern __mmask64 __cdecl _mm512_mask_cmple_epi8_mask(__mmask64, __m512i, __m512i); 
#line 1953
extern __mmask64 __cdecl _mm512_mask_cmplt_epi8_mask(__mmask64, __m512i, __m512i); 
#line 1954
extern __mmask64 __cdecl _mm512_mask_cmpneq_epi8_mask(__mmask64, __m512i, __m512i); 
#line 1955
extern __mmask64 __cdecl _mm512_mask_cmpeq_epu8_mask(__mmask64, __m512i, __m512i); 
#line 1956
extern __mmask64 __cdecl _mm512_mask_cmpge_epu8_mask(__mmask64, __m512i, __m512i); 
#line 1957
extern __mmask64 __cdecl _mm512_mask_cmpgt_epu8_mask(__mmask64, __m512i, __m512i); 
#line 1958
extern __mmask64 __cdecl _mm512_mask_cmple_epu8_mask(__mmask64, __m512i, __m512i); 
#line 1959
extern __mmask64 __cdecl _mm512_mask_cmplt_epu8_mask(__mmask64, __m512i, __m512i); 
#line 1960
extern __mmask64 __cdecl _mm512_mask_cmpneq_epu8_mask(__mmask64, __m512i, __m512i); 
#line 1962
extern __mmask32 __cdecl _mm512_cmpeq_epi16_mask(__m512i, __m512i); 
#line 1963
extern __mmask32 __cdecl _mm512_cmpge_epi16_mask(__m512i, __m512i); 
#line 1964
extern __mmask32 __cdecl _mm512_cmpgt_epi16_mask(__m512i, __m512i); 
#line 1965
extern __mmask32 __cdecl _mm512_cmple_epi16_mask(__m512i, __m512i); 
#line 1966
extern __mmask32 __cdecl _mm512_cmplt_epi16_mask(__m512i, __m512i); 
#line 1967
extern __mmask32 __cdecl _mm512_cmpneq_epi16_mask(__m512i, __m512i); 
#line 1968
extern __mmask32 __cdecl _mm512_cmpeq_epu16_mask(__m512i, __m512i); 
#line 1969
extern __mmask32 __cdecl _mm512_cmpge_epu16_mask(__m512i, __m512i); 
#line 1970
extern __mmask32 __cdecl _mm512_cmpgt_epu16_mask(__m512i, __m512i); 
#line 1971
extern __mmask32 __cdecl _mm512_cmple_epu16_mask(__m512i, __m512i); 
#line 1972
extern __mmask32 __cdecl _mm512_cmplt_epu16_mask(__m512i, __m512i); 
#line 1973
extern __mmask32 __cdecl _mm512_cmpneq_epu16_mask(__m512i, __m512i); 
#line 1975
extern __mmask32 __cdecl _mm512_mask_cmpeq_epi16_mask(__mmask32, __m512i, __m512i); 
#line 1976
extern __mmask32 __cdecl _mm512_mask_cmpge_epi16_mask(__mmask32, __m512i, __m512i); 
#line 1977
extern __mmask32 __cdecl _mm512_mask_cmpgt_epi16_mask(__mmask32, __m512i, __m512i); 
#line 1978
extern __mmask32 __cdecl _mm512_mask_cmple_epi16_mask(__mmask32, __m512i, __m512i); 
#line 1979
extern __mmask32 __cdecl _mm512_mask_cmplt_epi16_mask(__mmask32, __m512i, __m512i); 
#line 1980
extern __mmask32 __cdecl _mm512_mask_cmpneq_epi16_mask(__mmask32, __m512i, __m512i); 
#line 1981
extern __mmask32 __cdecl _mm512_mask_cmpeq_epu16_mask(__mmask32, __m512i, __m512i); 
#line 1982
extern __mmask32 __cdecl _mm512_mask_cmpge_epu16_mask(__mmask32, __m512i, __m512i); 
#line 1983
extern __mmask32 __cdecl _mm512_mask_cmpgt_epu16_mask(__mmask32, __m512i, __m512i); 
#line 1984
extern __mmask32 __cdecl _mm512_mask_cmple_epu16_mask(__mmask32, __m512i, __m512i); 
#line 1985
extern __mmask32 __cdecl _mm512_mask_cmplt_epu16_mask(__mmask32, __m512i, __m512i); 
#line 1986
extern __mmask32 __cdecl _mm512_mask_cmpneq_epu16_mask(__mmask32, __m512i, __m512i); 
#line 1988
extern __mmask16 __cdecl _mm512_cmpeq_epi32_mask(__m512i, __m512i); 
#line 1989
extern __mmask16 __cdecl _mm512_cmpge_epi32_mask(__m512i, __m512i); 
#line 1990
extern __mmask16 __cdecl _mm512_cmpgt_epi32_mask(__m512i, __m512i); 
#line 1991
extern __mmask16 __cdecl _mm512_cmple_epi32_mask(__m512i, __m512i); 
#line 1992
extern __mmask16 __cdecl _mm512_cmplt_epi32_mask(__m512i, __m512i); 
#line 1993
extern __mmask16 __cdecl _mm512_cmpneq_epi32_mask(__m512i, __m512i); 
#line 1994
extern __mmask16 __cdecl _mm512_cmpeq_epu32_mask(__m512i, __m512i); 
#line 1995
extern __mmask16 __cdecl _mm512_cmpge_epu32_mask(__m512i, __m512i); 
#line 1996
extern __mmask16 __cdecl _mm512_cmpgt_epu32_mask(__m512i, __m512i); 
#line 1997
extern __mmask16 __cdecl _mm512_cmple_epu32_mask(__m512i, __m512i); 
#line 1998
extern __mmask16 __cdecl _mm512_cmplt_epu32_mask(__m512i, __m512i); 
#line 1999
extern __mmask16 __cdecl _mm512_cmpneq_epu32_mask(__m512i, __m512i); 
#line 2001
extern __mmask16 __cdecl _mm512_mask_cmpeq_epi32_mask(__mmask16, __m512i, __m512i); 
#line 2002
extern __mmask16 __cdecl _mm512_mask_cmpge_epi32_mask(__mmask16, __m512i, __m512i); 
#line 2003
extern __mmask16 __cdecl _mm512_mask_cmpgt_epi32_mask(__mmask16, __m512i, __m512i); 
#line 2004
extern __mmask16 __cdecl _mm512_mask_cmple_epi32_mask(__mmask16, __m512i, __m512i); 
#line 2005
extern __mmask16 __cdecl _mm512_mask_cmplt_epi32_mask(__mmask16, __m512i, __m512i); 
#line 2006
extern __mmask16 __cdecl _mm512_mask_cmpneq_epi32_mask(__mmask16, __m512i, __m512i); 
#line 2007
extern __mmask16 __cdecl _mm512_mask_cmpeq_epu32_mask(__mmask16, __m512i, __m512i); 
#line 2008
extern __mmask16 __cdecl _mm512_mask_cmpge_epu32_mask(__mmask16, __m512i, __m512i); 
#line 2009
extern __mmask16 __cdecl _mm512_mask_cmpgt_epu32_mask(__mmask16, __m512i, __m512i); 
#line 2010
extern __mmask16 __cdecl _mm512_mask_cmple_epu32_mask(__mmask16, __m512i, __m512i); 
#line 2011
extern __mmask16 __cdecl _mm512_mask_cmplt_epu32_mask(__mmask16, __m512i, __m512i); 
#line 2012
extern __mmask16 __cdecl _mm512_mask_cmpneq_epu32_mask(__mmask16, __m512i, __m512i); 
#line 2014
extern __mmask8 __cdecl _mm512_cmpeq_epi64_mask(__m512i, __m512i); 
#line 2015
extern __mmask8 __cdecl _mm512_cmpge_epi64_mask(__m512i, __m512i); 
#line 2016
extern __mmask8 __cdecl _mm512_cmpgt_epi64_mask(__m512i, __m512i); 
#line 2017
extern __mmask8 __cdecl _mm512_cmple_epi64_mask(__m512i, __m512i); 
#line 2018
extern __mmask8 __cdecl _mm512_cmplt_epi64_mask(__m512i, __m512i); 
#line 2019
extern __mmask8 __cdecl _mm512_cmpneq_epi64_mask(__m512i, __m512i); 
#line 2020
extern __mmask8 __cdecl _mm512_cmpeq_epu64_mask(__m512i, __m512i); 
#line 2021
extern __mmask8 __cdecl _mm512_cmpge_epu64_mask(__m512i, __m512i); 
#line 2022
extern __mmask8 __cdecl _mm512_cmpgt_epu64_mask(__m512i, __m512i); 
#line 2023
extern __mmask8 __cdecl _mm512_cmple_epu64_mask(__m512i, __m512i); 
#line 2024
extern __mmask8 __cdecl _mm512_cmplt_epu64_mask(__m512i, __m512i); 
#line 2025
extern __mmask8 __cdecl _mm512_cmpneq_epu64_mask(__m512i, __m512i); 
#line 2027
extern __mmask8 __cdecl _mm512_mask_cmpeq_epi64_mask(__mmask8, __m512i, __m512i); 
#line 2028
extern __mmask8 __cdecl _mm512_mask_cmpge_epi64_mask(__mmask8, __m512i, __m512i); 
#line 2029
extern __mmask8 __cdecl _mm512_mask_cmpgt_epi64_mask(__mmask8, __m512i, __m512i); 
#line 2030
extern __mmask8 __cdecl _mm512_mask_cmple_epi64_mask(__mmask8, __m512i, __m512i); 
#line 2031
extern __mmask8 __cdecl _mm512_mask_cmplt_epi64_mask(__mmask8, __m512i, __m512i); 
#line 2032
extern __mmask8 __cdecl _mm512_mask_cmpneq_epi64_mask(__mmask8, __m512i, __m512i); 
#line 2033
extern __mmask8 __cdecl _mm512_mask_cmpeq_epu64_mask(__mmask8, __m512i, __m512i); 
#line 2034
extern __mmask8 __cdecl _mm512_mask_cmpge_epu64_mask(__mmask8, __m512i, __m512i); 
#line 2035
extern __mmask8 __cdecl _mm512_mask_cmpgt_epu64_mask(__mmask8, __m512i, __m512i); 
#line 2036
extern __mmask8 __cdecl _mm512_mask_cmple_epu64_mask(__mmask8, __m512i, __m512i); 
#line 2037
extern __mmask8 __cdecl _mm512_mask_cmplt_epu64_mask(__mmask8, __m512i, __m512i); 
#line 2038
extern __mmask8 __cdecl _mm512_mask_cmpneq_epu64_mask(__mmask8, __m512i, __m512i); 
#line 2102
extern __m128i __cdecl _mm_mask_abs_epi16(__m128i, __mmask8, __m128i); 
#line 2103
extern __m128i __cdecl _mm_maskz_abs_epi16(__mmask8, __m128i); 
#line 2104
extern __m256i __cdecl _mm256_mask_abs_epi16(__m256i, __mmask16, __m256i); 
#line 2105
extern __m256i __cdecl _mm256_maskz_abs_epi16(__mmask16, __m256i); 
#line 2106
extern __m128i __cdecl _mm_mask_abs_epi32(__m128i, __mmask8, __m128i); 
#line 2107
extern __m128i __cdecl _mm_maskz_abs_epi32(__mmask8, __m128i); 
#line 2108
extern __m256i __cdecl _mm256_mask_abs_epi32(__m256i, __mmask8, __m256i); 
#line 2109
extern __m256i __cdecl _mm256_maskz_abs_epi32(__mmask8, __m256i); 
#line 2110
extern __m128i __cdecl _mm_abs_epi64(__m128i); 
#line 2111
extern __m128i __cdecl _mm_mask_abs_epi64(__m128i, __mmask8, __m128i); 
#line 2112
extern __m128i __cdecl _mm_maskz_abs_epi64(__mmask8, __m128i); 
#line 2113
extern __m256i __cdecl _mm256_abs_epi64(__m256i); 
#line 2114
extern __m256i __cdecl _mm256_mask_abs_epi64(__m256i, __mmask8, __m256i); 
#line 2115
extern __m256i __cdecl _mm256_maskz_abs_epi64(__mmask8, __m256i); 
#line 2116
extern __m128i __cdecl _mm_mask_abs_epi8(__m128i, __mmask16, __m128i); 
#line 2117
extern __m128i __cdecl _mm_maskz_abs_epi8(__mmask16, __m128i); 
#line 2118
extern __m256i __cdecl _mm256_mask_abs_epi8(__m256i, __mmask32, __m256i); 
#line 2119
extern __m256i __cdecl _mm256_maskz_abs_epi8(__mmask32, __m256i); 
#line 2120
extern __m128i __cdecl _mm_mask_add_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 2121
extern __m128i __cdecl _mm_maskz_add_epi16(__mmask8, __m128i, __m128i); 
#line 2122
extern __m256i __cdecl _mm256_mask_add_epi16(__m256i, __mmask16, __m256i, __m256i); 
#line 2123
extern __m256i __cdecl _mm256_maskz_add_epi16(__mmask16, __m256i, __m256i); 
#line 2124
extern __m128i __cdecl _mm_mask_add_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 2125
extern __m128i __cdecl _mm_maskz_add_epi32(__mmask8, __m128i, __m128i); 
#line 2126
extern __m256i __cdecl _mm256_mask_add_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 2127
extern __m256i __cdecl _mm256_maskz_add_epi32(__mmask8, __m256i, __m256i); 
#line 2128
extern __m128i __cdecl _mm_mask_add_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 2129
extern __m128i __cdecl _mm_maskz_add_epi64(__mmask8, __m128i, __m128i); 
#line 2130
extern __m256i __cdecl _mm256_mask_add_epi64(__m256i, __mmask8, __m256i, __m256i); 
#line 2131
extern __m256i __cdecl _mm256_maskz_add_epi64(__mmask8, __m256i, __m256i); 
#line 2132
extern __m128i __cdecl _mm_mask_add_epi8(__m128i, __mmask16, __m128i, __m128i); 
#line 2133
extern __m128i __cdecl _mm_maskz_add_epi8(__mmask16, __m128i, __m128i); 
#line 2134
extern __m256i __cdecl _mm256_mask_add_epi8(__m256i, __mmask32, __m256i, __m256i); 
#line 2135
extern __m256i __cdecl _mm256_maskz_add_epi8(__mmask32, __m256i, __m256i); 
#line 2136
extern __m128d __cdecl _mm_mask_add_pd(__m128d, __mmask8, __m128d, __m128d); 
#line 2137
extern __m128d __cdecl _mm_maskz_add_pd(__mmask8, __m128d, __m128d); 
#line 2138
extern __m256d __cdecl _mm256_mask_add_pd(__m256d, __mmask8, __m256d, __m256d); 
#line 2139
extern __m256d __cdecl _mm256_maskz_add_pd(__mmask8, __m256d, __m256d); 
#line 2140
extern __m128 __cdecl _mm_mask_add_ps(__m128, __mmask8, __m128, __m128); 
#line 2141
extern __m128 __cdecl _mm_maskz_add_ps(__mmask8, __m128, __m128); 
#line 2142
extern __m256 __cdecl _mm256_mask_add_ps(__m256, __mmask8, __m256, __m256); 
#line 2143
extern __m256 __cdecl _mm256_maskz_add_ps(__mmask8, __m256, __m256); 
#line 2144
extern __m128i __cdecl _mm_mask_adds_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 2145
extern __m128i __cdecl _mm_maskz_adds_epi16(__mmask8, __m128i, __m128i); 
#line 2146
extern __m256i __cdecl _mm256_mask_adds_epi16(__m256i, __mmask16, __m256i, __m256i); 
#line 2147
extern __m256i __cdecl _mm256_maskz_adds_epi16(__mmask16, __m256i, __m256i); 
#line 2148
extern __m128i __cdecl _mm_mask_adds_epi8(__m128i, __mmask16, __m128i, __m128i); 
#line 2149
extern __m128i __cdecl _mm_maskz_adds_epi8(__mmask16, __m128i, __m128i); 
#line 2150
extern __m256i __cdecl _mm256_mask_adds_epi8(__m256i, __mmask32, __m256i, __m256i); 
#line 2151
extern __m256i __cdecl _mm256_maskz_adds_epi8(__mmask32, __m256i, __m256i); 
#line 2152
extern __m128i __cdecl _mm_mask_adds_epu16(__m128i, __mmask8, __m128i, __m128i); 
#line 2153
extern __m128i __cdecl _mm_maskz_adds_epu16(__mmask8, __m128i, __m128i); 
#line 2154
extern __m256i __cdecl _mm256_mask_adds_epu16(__m256i, __mmask16, __m256i, __m256i); 
#line 2155
extern __m256i __cdecl _mm256_maskz_adds_epu16(__mmask16, __m256i, __m256i); 
#line 2156
extern __m128i __cdecl _mm_mask_adds_epu8(__m128i, __mmask16, __m128i, __m128i); 
#line 2157
extern __m128i __cdecl _mm_maskz_adds_epu8(__mmask16, __m128i, __m128i); 
#line 2158
extern __m256i __cdecl _mm256_mask_adds_epu8(__m256i, __mmask32, __m256i, __m256i); 
#line 2159
extern __m256i __cdecl _mm256_maskz_adds_epu8(__mmask32, __m256i, __m256i); 
#line 2160
extern __m128i __cdecl _mm_alignr_epi32(__m128i, __m128i, const int); 
#line 2161
extern __m128i __cdecl _mm_mask_alignr_epi32(__m128i, __mmask8, __m128i, __m128i, const int); 
#line 2162
extern __m128i __cdecl _mm_maskz_alignr_epi32(__mmask8, __m128i, __m128i, const int); 
#line 2163
extern __m256i __cdecl _mm256_alignr_epi32(__m256i, __m256i, const int); 
#line 2164
extern __m256i __cdecl _mm256_mask_alignr_epi32(__m256i, __mmask8, __m256i, __m256i, const int); 
#line 2165
extern __m256i __cdecl _mm256_maskz_alignr_epi32(__mmask8, __m256i, __m256i, const int); 
#line 2166
extern __m128i __cdecl _mm_alignr_epi64(__m128i, __m128i, const int); 
#line 2167
extern __m128i __cdecl _mm_mask_alignr_epi64(__m128i, __mmask8, __m128i, __m128i, const int); 
#line 2168
extern __m128i __cdecl _mm_maskz_alignr_epi64(__mmask8, __m128i, __m128i, const int); 
#line 2169
extern __m256i __cdecl _mm256_alignr_epi64(__m256i, __m256i, const int); 
#line 2170
extern __m256i __cdecl _mm256_mask_alignr_epi64(__m256i, __mmask8, __m256i, __m256i, const int); 
#line 2171
extern __m256i __cdecl _mm256_maskz_alignr_epi64(__mmask8, __m256i, __m256i, const int); 
#line 2172
extern __m128i __cdecl _mm_mask_alignr_epi8(__m128i, __mmask16, __m128i, __m128i, const int); 
#line 2173
extern __m128i __cdecl _mm_maskz_alignr_epi8(__mmask16, __m128i, __m128i, const int); 
#line 2174
extern __m256i __cdecl _mm256_mask_alignr_epi8(__m256i, __mmask32, __m256i, __m256i, const int); 
#line 2175
extern __m256i __cdecl _mm256_maskz_alignr_epi8(__mmask32, __m256i, __m256i, const int); 
#line 2176
extern __m128i __cdecl _mm_and_epi32(__m128i, __m128i); 
#line 2177
extern __m128i __cdecl _mm_mask_and_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 2178
extern __m128i __cdecl _mm_maskz_and_epi32(__mmask8, __m128i, __m128i); 
#line 2179
extern __m256i __cdecl _mm256_and_epi32(__m256i, __m256i); 
#line 2180
extern __m256i __cdecl _mm256_mask_and_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 2181
extern __m256i __cdecl _mm256_maskz_and_epi32(__mmask8, __m256i, __m256i); 
#line 2182
extern __m128i __cdecl _mm_and_epi64(__m128i, __m128i); 
#line 2183
extern __m128i __cdecl _mm_mask_and_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 2184
extern __m128i __cdecl _mm_maskz_and_epi64(__mmask8, __m128i, __m128i); 
#line 2185
extern __m256i __cdecl _mm256_and_epi64(__m256i, __m256i); 
#line 2186
extern __m256i __cdecl _mm256_mask_and_epi64(__m256i, __mmask8, __m256i, __m256i); 
#line 2187
extern __m256i __cdecl _mm256_maskz_and_epi64(__mmask8, __m256i, __m256i); 
#line 2188
extern __m128d __cdecl _mm_mask_and_pd(__m128d, __mmask8, __m128d, __m128d); 
#line 2189
extern __m128d __cdecl _mm_maskz_and_pd(__mmask8, __m128d, __m128d); 
#line 2190
extern __m256d __cdecl _mm256_mask_and_pd(__m256d, __mmask8, __m256d, __m256d); 
#line 2191
extern __m256d __cdecl _mm256_maskz_and_pd(__mmask8, __m256d, __m256d); 
#line 2192
extern __m128 __cdecl _mm_mask_and_ps(__m128, __mmask8, __m128, __m128); 
#line 2193
extern __m128 __cdecl _mm_maskz_and_ps(__mmask8, __m128, __m128); 
#line 2194
extern __m256 __cdecl _mm256_mask_and_ps(__m256, __mmask8, __m256, __m256); 
#line 2195
extern __m256 __cdecl _mm256_maskz_and_ps(__mmask8, __m256, __m256); 
#line 2196
extern __m128i __cdecl _mm_andnot_epi32(__m128i, __m128i); 
#line 2197
extern __m128i __cdecl _mm_mask_andnot_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 2198
extern __m128i __cdecl _mm_maskz_andnot_epi32(__mmask8, __m128i, __m128i); 
#line 2199
extern __m256i __cdecl _mm256_andnot_epi32(__m256i, __m256i); 
#line 2200
extern __m256i __cdecl _mm256_mask_andnot_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 2201
extern __m256i __cdecl _mm256_maskz_andnot_epi32(__mmask8, __m256i, __m256i); 
#line 2202
extern __m128i __cdecl _mm_andnot_epi64(__m128i, __m128i); 
#line 2203
extern __m128i __cdecl _mm_mask_andnot_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 2204
extern __m128i __cdecl _mm_maskz_andnot_epi64(__mmask8, __m128i, __m128i); 
#line 2205
extern __m256i __cdecl _mm256_andnot_epi64(__m256i, __m256i); 
#line 2206
extern __m256i __cdecl _mm256_mask_andnot_epi64(__m256i, __mmask8, __m256i, __m256i); 
#line 2207
extern __m256i __cdecl _mm256_maskz_andnot_epi64(__mmask8, __m256i, __m256i); 
#line 2208
extern __m128d __cdecl _mm_mask_andnot_pd(__m128d, __mmask8, __m128d, __m128d); 
#line 2209
extern __m128d __cdecl _mm_maskz_andnot_pd(__mmask8, __m128d, __m128d); 
#line 2210
extern __m256d __cdecl _mm256_mask_andnot_pd(__m256d, __mmask8, __m256d, __m256d); 
#line 2211
extern __m256d __cdecl _mm256_maskz_andnot_pd(__mmask8, __m256d, __m256d); 
#line 2212
extern __m128 __cdecl _mm_mask_andnot_ps(__m128, __mmask8, __m128, __m128); 
#line 2213
extern __m128 __cdecl _mm_maskz_andnot_ps(__mmask8, __m128, __m128); 
#line 2214
extern __m256 __cdecl _mm256_mask_andnot_ps(__m256, __mmask8, __m256, __m256); 
#line 2215
extern __m256 __cdecl _mm256_maskz_andnot_ps(__mmask8, __m256, __m256); 
#line 2216
extern __m128i __cdecl _mm_mask_avg_epu16(__m128i, __mmask8, __m128i, __m128i); 
#line 2217
extern __m128i __cdecl _mm_maskz_avg_epu16(__mmask8, __m128i, __m128i); 
#line 2218
extern __m256i __cdecl _mm256_mask_avg_epu16(__m256i, __mmask16, __m256i, __m256i); 
#line 2219
extern __m256i __cdecl _mm256_maskz_avg_epu16(__mmask16, __m256i, __m256i); 
#line 2220
extern __m128i __cdecl _mm_mask_avg_epu8(__m128i, __mmask16, __m128i, __m128i); 
#line 2221
extern __m128i __cdecl _mm_maskz_avg_epu8(__mmask16, __m128i, __m128i); 
#line 2222
extern __m256i __cdecl _mm256_mask_avg_epu8(__m256i, __mmask32, __m256i, __m256i); 
#line 2223
extern __m256i __cdecl _mm256_maskz_avg_epu8(__mmask32, __m256i, __m256i); 
#line 2224
extern __m128i __cdecl _mm_mask_blend_epi16(__mmask8, __m128i, __m128i); 
#line 2225
extern __m256i __cdecl _mm256_mask_blend_epi16(__mmask16, __m256i, __m256i); 
#line 2226
extern __m128i __cdecl _mm_mask_blend_epi32(__mmask8, __m128i, __m128i); 
#line 2227
extern __m256i __cdecl _mm256_mask_blend_epi32(__mmask8, __m256i, __m256i); 
#line 2228
extern __m128i __cdecl _mm_mask_blend_epi64(__mmask8, __m128i, __m128i); 
#line 2229
extern __m256i __cdecl _mm256_mask_blend_epi64(__mmask8, __m256i, __m256i); 
#line 2230
extern __m128i __cdecl _mm_mask_blend_epi8(__mmask16, __m128i, __m128i); 
#line 2231
extern __m256i __cdecl _mm256_mask_blend_epi8(__mmask32, __m256i, __m256i); 
#line 2232
extern __m128d __cdecl _mm_mask_blend_pd(__mmask8, __m128d, __m128d); 
#line 2233
extern __m256d __cdecl _mm256_mask_blend_pd(__mmask8, __m256d, __m256d); 
#line 2234
extern __m128 __cdecl _mm_mask_blend_ps(__mmask8, __m128, __m128); 
#line 2235
extern __m256 __cdecl _mm256_mask_blend_ps(__mmask8, __m256, __m256); 
#line 2236
extern __m256 __cdecl _mm256_broadcast_f32x2(__m128); 
#line 2237
extern __m256 __cdecl _mm256_mask_broadcast_f32x2(__m256, __mmask8, __m128); 
#line 2238
extern __m256 __cdecl _mm256_maskz_broadcast_f32x2(__mmask8, __m128); 
#line 2239
extern __m256 __cdecl _mm256_broadcast_f32x4(__m128); 
#line 2240
extern __m256 __cdecl _mm256_mask_broadcast_f32x4(__m256, __mmask8, __m128); 
#line 2241
extern __m256 __cdecl _mm256_maskz_broadcast_f32x4(__mmask8, __m128); 
#line 2242
extern __m256d __cdecl _mm256_broadcast_f64x2(__m128d); 
#line 2243
extern __m256d __cdecl _mm256_mask_broadcast_f64x2(__m256d, __mmask8, __m128d); 
#line 2244
extern __m256d __cdecl _mm256_maskz_broadcast_f64x2(__mmask8, __m128d); 
#line 2245
extern __m128i __cdecl _mm_broadcast_i32x2(__m128i); 
#line 2246
extern __m128i __cdecl _mm_mask_broadcast_i32x2(__m128i, __mmask8, __m128i); 
#line 2247
extern __m128i __cdecl _mm_maskz_broadcast_i32x2(__mmask8, __m128i); 
#line 2248
extern __m256i __cdecl _mm256_broadcast_i32x2(__m128i); 
#line 2249
extern __m256i __cdecl _mm256_mask_broadcast_i32x2(__m256i, __mmask8, __m128i); 
#line 2250
extern __m256i __cdecl _mm256_maskz_broadcast_i32x2(__mmask8, __m128i); 
#line 2251
extern __m256i __cdecl _mm256_broadcast_i32x4(__m128i); 
#line 2252
extern __m256i __cdecl _mm256_mask_broadcast_i32x4(__m256i, __mmask8, __m128i); 
#line 2253
extern __m256i __cdecl _mm256_maskz_broadcast_i32x4(__mmask8, __m128i); 
#line 2254
extern __m256i __cdecl _mm256_broadcast_i64x2(__m128i); 
#line 2255
extern __m256i __cdecl _mm256_mask_broadcast_i64x2(__m256i, __mmask8, __m128i); 
#line 2256
extern __m256i __cdecl _mm256_maskz_broadcast_i64x2(__mmask8, __m128i); 
#line 2257
extern __m128i __cdecl _mm_mask_broadcastb_epi8(__m128i, __mmask16, __m128i); 
#line 2258
extern __m128i __cdecl _mm_maskz_broadcastb_epi8(__mmask16, __m128i); 
#line 2259
extern __m256i __cdecl _mm256_mask_broadcastb_epi8(__m256i, __mmask32, __m128i); 
#line 2260
extern __m256i __cdecl _mm256_maskz_broadcastb_epi8(__mmask32, __m128i); 
#line 2261
extern __m128i __cdecl _mm_mask_broadcastd_epi32(__m128i, __mmask8, __m128i); 
#line 2262
extern __m128i __cdecl _mm_maskz_broadcastd_epi32(__mmask8, __m128i); 
#line 2263
extern __m256i __cdecl _mm256_mask_broadcastd_epi32(__m256i, __mmask8, __m128i); 
#line 2264
extern __m256i __cdecl _mm256_maskz_broadcastd_epi32(__mmask8, __m128i); 
#line 2265
extern __m128i __cdecl _mm_broadcastmb_epi64(__mmask8); 
#line 2266
extern __m256i __cdecl _mm256_broadcastmb_epi64(__mmask8); 
#line 2267
extern __m128i __cdecl _mm_broadcastmw_epi32(__mmask16); 
#line 2268
extern __m256i __cdecl _mm256_broadcastmw_epi32(__mmask16); 
#line 2269
extern __m128i __cdecl _mm_mask_broadcastq_epi64(__m128i, __mmask8, __m128i); 
#line 2270
extern __m128i __cdecl _mm_maskz_broadcastq_epi64(__mmask8, __m128i); 
#line 2271
extern __m256i __cdecl _mm256_mask_broadcastq_epi64(__m256i, __mmask8, __m128i); 
#line 2272
extern __m256i __cdecl _mm256_maskz_broadcastq_epi64(__mmask8, __m128i); 
#line 2273
extern __m256d __cdecl _mm256_mask_broadcastsd_pd(__m256d, __mmask8, __m128d); 
#line 2274
extern __m256d __cdecl _mm256_maskz_broadcastsd_pd(__mmask8, __m128d); 
#line 2275
extern __m128 __cdecl _mm_mask_broadcastss_ps(__m128, __mmask8, __m128); 
#line 2276
extern __m128 __cdecl _mm_maskz_broadcastss_ps(__mmask8, __m128); 
#line 2277
extern __m256 __cdecl _mm256_mask_broadcastss_ps(__m256, __mmask8, __m128); 
#line 2278
extern __m256 __cdecl _mm256_maskz_broadcastss_ps(__mmask8, __m128); 
#line 2279
extern __m128i __cdecl _mm_mask_broadcastw_epi16(__m128i, __mmask8, __m128i); 
#line 2280
extern __m128i __cdecl _mm_maskz_broadcastw_epi16(__mmask8, __m128i); 
#line 2281
extern __m256i __cdecl _mm256_mask_broadcastw_epi16(__m256i, __mmask16, __m128i); 
#line 2282
extern __m256i __cdecl _mm256_maskz_broadcastw_epi16(__mmask16, __m128i); 
#line 2283
extern __mmask8 __cdecl _mm_cmp_epi16_mask(__m128i, __m128i, const int); 
#line 2284
extern __mmask8 __cdecl _mm_mask_cmp_epi16_mask(__mmask8, __m128i, __m128i, const int); 
#line 2285
extern __mmask16 __cdecl _mm256_cmp_epi16_mask(__m256i, __m256i, const int); 
#line 2286
extern __mmask16 __cdecl _mm256_mask_cmp_epi16_mask(__mmask16, __m256i, __m256i, const int); 
#line 2287
extern __mmask8 __cdecl _mm_cmp_epi32_mask(__m128i, __m128i, int); 
#line 2288
extern __mmask8 __cdecl _mm_mask_cmp_epi32_mask(__mmask8, __m128i, __m128i, int); 
#line 2289
extern __mmask8 __cdecl _mm256_cmp_epi32_mask(__m256i, __m256i, int); 
#line 2290
extern __mmask8 __cdecl _mm256_mask_cmp_epi32_mask(__mmask8, __m256i, __m256i, int); 
#line 2291
extern __mmask8 __cdecl _mm_cmp_epi64_mask(__m128i, __m128i, int); 
#line 2292
extern __mmask8 __cdecl _mm_mask_cmp_epi64_mask(__mmask8, __m128i, __m128i, int); 
#line 2293
extern __mmask8 __cdecl _mm256_cmp_epi64_mask(__m256i, __m256i, int); 
#line 2294
extern __mmask8 __cdecl _mm256_mask_cmp_epi64_mask(__mmask8, __m256i, __m256i, int); 
#line 2295
extern __mmask16 __cdecl _mm_cmp_epi8_mask(__m128i, __m128i, const int); 
#line 2296
extern __mmask16 __cdecl _mm_mask_cmp_epi8_mask(__mmask16, __m128i, __m128i, const int); 
#line 2297
extern __mmask32 __cdecl _mm256_cmp_epi8_mask(__m256i, __m256i, const int); 
#line 2298
extern __mmask32 __cdecl _mm256_mask_cmp_epi8_mask(__mmask32, __m256i, __m256i, const int); 
#line 2299
extern __mmask8 __cdecl _mm_cmp_epu16_mask(__m128i, __m128i, const int); 
#line 2300
extern __mmask8 __cdecl _mm_mask_cmp_epu16_mask(__mmask8, __m128i, __m128i, const int); 
#line 2301
extern __mmask16 __cdecl _mm256_cmp_epu16_mask(__m256i, __m256i, const int); 
#line 2302
extern __mmask16 __cdecl _mm256_mask_cmp_epu16_mask(__mmask16, __m256i, __m256i, const int); 
#line 2303
extern __mmask8 __cdecl _mm_cmp_epu32_mask(__m128i, __m128i, int); 
#line 2304
extern __mmask8 __cdecl _mm_mask_cmp_epu32_mask(__mmask8, __m128i, __m128i, int); 
#line 2305
extern __mmask8 __cdecl _mm256_cmp_epu32_mask(__m256i, __m256i, int); 
#line 2306
extern __mmask8 __cdecl _mm256_mask_cmp_epu32_mask(__mmask8, __m256i, __m256i, int); 
#line 2307
extern __mmask8 __cdecl _mm_cmp_epu64_mask(__m128i, __m128i, int); 
#line 2308
extern __mmask8 __cdecl _mm_mask_cmp_epu64_mask(__mmask8, __m128i, __m128i, int); 
#line 2309
extern __mmask8 __cdecl _mm256_cmp_epu64_mask(__m256i, __m256i, int); 
#line 2310
extern __mmask8 __cdecl _mm256_mask_cmp_epu64_mask(__mmask8, __m256i, __m256i, int); 
#line 2311
extern __mmask16 __cdecl _mm_cmp_epu8_mask(__m128i, __m128i, const int); 
#line 2312
extern __mmask16 __cdecl _mm_mask_cmp_epu8_mask(__mmask16, __m128i, __m128i, const int); 
#line 2313
extern __mmask32 __cdecl _mm256_cmp_epu8_mask(__m256i, __m256i, const int); 
#line 2314
extern __mmask32 __cdecl _mm256_mask_cmp_epu8_mask(__mmask32, __m256i, __m256i, const int); 
#line 2315
extern __mmask8 __cdecl _mm_cmp_pd_mask(__m128d, __m128d, const int); 
#line 2316
extern __mmask8 __cdecl _mm_mask_cmp_pd_mask(__mmask8, __m128d, __m128d, const int); 
#line 2317
extern __mmask8 __cdecl _mm256_cmp_pd_mask(__m256d, __m256d, const int); 
#line 2318
extern __mmask8 __cdecl _mm256_mask_cmp_pd_mask(__mmask8, __m256d, __m256d, const int); 
#line 2319
extern __mmask8 __cdecl _mm_cmp_ps_mask(__m128, __m128, const int); 
#line 2320
extern __mmask8 __cdecl _mm_mask_cmp_ps_mask(__mmask8, __m128, __m128, const int); 
#line 2321
extern __mmask8 __cdecl _mm256_cmp_ps_mask(__m256, __m256, const int); 
#line 2322
extern __mmask8 __cdecl _mm256_mask_cmp_ps_mask(__mmask8, __m256, __m256, const int); 
#line 2323
extern __m128i __cdecl _mm_mask_compress_epi8(__m128i, __mmask16, __m128i); 
#line 2324
extern __m128i __cdecl _mm_maskz_compress_epi8(__mmask16, __m128i); 
#line 2325
extern __m256i __cdecl _mm256_mask_compress_epi8(__m256i, __mmask32, __m256i); 
#line 2326
extern __m256i __cdecl _mm256_maskz_compress_epi8(__mmask32, __m256i); 
#line 2327
extern __m128i __cdecl _mm_mask_compress_epi16(__m128i, __mmask8, __m128i); 
#line 2328
extern __m128i __cdecl _mm_maskz_compress_epi16(__mmask8, __m128i); 
#line 2329
extern __m256i __cdecl _mm256_mask_compress_epi16(__m256i, __mmask16, __m256i); 
#line 2330
extern __m256i __cdecl _mm256_maskz_compress_epi16(__mmask16, __m256i); 
#line 2331
extern __m128i __cdecl _mm_mask_compress_epi32(__m128i, __mmask8, __m128i); 
#line 2332
extern __m128i __cdecl _mm_maskz_compress_epi32(__mmask8, __m128i); 
#line 2333
extern __m256i __cdecl _mm256_mask_compress_epi32(__m256i, __mmask8, __m256i); 
#line 2334
extern __m256i __cdecl _mm256_maskz_compress_epi32(__mmask8, __m256i); 
#line 2335
extern __m128i __cdecl _mm_mask_compress_epi64(__m128i, __mmask8, __m128i); 
#line 2336
extern __m128i __cdecl _mm_maskz_compress_epi64(__mmask8, __m128i); 
#line 2337
extern __m256i __cdecl _mm256_mask_compress_epi64(__m256i, __mmask8, __m256i); 
#line 2338
extern __m256i __cdecl _mm256_maskz_compress_epi64(__mmask8, __m256i); 
#line 2339
extern __m128d __cdecl _mm_mask_compress_pd(__m128d, __mmask8, __m128d); 
#line 2340
extern __m128d __cdecl _mm_maskz_compress_pd(__mmask8, __m128d); 
#line 2341
extern __m256d __cdecl _mm256_mask_compress_pd(__m256d, __mmask8, __m256d); 
#line 2342
extern __m256d __cdecl _mm256_maskz_compress_pd(__mmask8, __m256d); 
#line 2343
extern __m128 __cdecl _mm_mask_compress_ps(__m128, __mmask8, __m128); 
#line 2344
extern __m128 __cdecl _mm_maskz_compress_ps(__mmask8, __m128); 
#line 2345
extern __m256 __cdecl _mm256_mask_compress_ps(__m256, __mmask8, __m256); 
#line 2346
extern __m256 __cdecl _mm256_maskz_compress_ps(__mmask8, __m256); 
#line 2347
extern void __cdecl _mm_mask_compressstoreu_epi8(void *, __mmask16, __m128i); 
#line 2348
extern void __cdecl _mm256_mask_compressstoreu_epi8(void *, __mmask32, __m256i); 
#line 2349
extern void __cdecl _mm_mask_compressstoreu_epi16(void *, __mmask8, __m128i); 
#line 2350
extern void __cdecl _mm256_mask_compressstoreu_epi16(void *, __mmask16, __m256i); 
#line 2351
extern void __cdecl _mm_mask_compressstoreu_epi32(void *, __mmask8, __m128i); 
#line 2352
extern void __cdecl _mm256_mask_compressstoreu_epi32(void *, __mmask8, __m256i); 
#line 2353
extern void __cdecl _mm_mask_compressstoreu_epi64(void *, __mmask8, __m128i); 
#line 2354
extern void __cdecl _mm256_mask_compressstoreu_epi64(void *, __mmask8, __m256i); 
#line 2355
extern void __cdecl _mm_mask_compressstoreu_pd(void *, __mmask8, __m128d); 
#line 2356
extern void __cdecl _mm256_mask_compressstoreu_pd(void *, __mmask8, __m256d); 
#line 2357
extern void __cdecl _mm_mask_compressstoreu_ps(void *, __mmask8, __m128); 
#line 2358
extern void __cdecl _mm256_mask_compressstoreu_ps(void *, __mmask8, __m256); 
#line 2359
extern __m128i __cdecl _mm_conflict_epi32(__m128i); 
#line 2360
extern __m128i __cdecl _mm_mask_conflict_epi32(__m128i, __mmask8, __m128i); 
#line 2361
extern __m128i __cdecl _mm_maskz_conflict_epi32(__mmask8, __m128i); 
#line 2362
extern __m256i __cdecl _mm256_conflict_epi32(__m256i); 
#line 2363
extern __m256i __cdecl _mm256_mask_conflict_epi32(__m256i, __mmask8, __m256i); 
#line 2364
extern __m256i __cdecl _mm256_maskz_conflict_epi32(__mmask8, __m256i); 
#line 2365
extern __m128i __cdecl _mm_conflict_epi64(__m128i); 
#line 2366
extern __m128i __cdecl _mm_mask_conflict_epi64(__m128i, __mmask8, __m128i); 
#line 2367
extern __m128i __cdecl _mm_maskz_conflict_epi64(__mmask8, __m128i); 
#line 2368
extern __m256i __cdecl _mm256_conflict_epi64(__m256i); 
#line 2369
extern __m256i __cdecl _mm256_mask_conflict_epi64(__m256i, __mmask8, __m256i); 
#line 2370
extern __m256i __cdecl _mm256_maskz_conflict_epi64(__mmask8, __m256i); 
#line 2371
extern __m128i __cdecl _mm_mask_cvtps_ph(__m128i, __mmask8, __m128, int); 
#line 2372
extern __m128i __cdecl _mm_maskz_cvtps_ph(__mmask8, __m128, int); 
#line 2373
extern __m128i __cdecl _mm_mask_cvt_roundps_ph(__m128i, __mmask8, __m128, int); 
#line 2374
extern __m128i __cdecl _mm_maskz_cvt_roundps_ph(__mmask8, __m128, int); 
#line 2375
extern __m128i __cdecl _mm256_mask_cvtps_ph(__m128i, __mmask8, __m256, int); 
#line 2376
extern __m128i __cdecl _mm256_maskz_cvtps_ph(__mmask8, __m256, int); 
#line 2377
extern __m128i __cdecl _mm256_mask_cvt_roundps_ph(__m128i, __mmask8, __m256, int); 
#line 2378
extern __m128i __cdecl _mm256_maskz_cvt_roundps_ph(__mmask8, __m256, int); 
#line 2379
extern __m128i __cdecl _mm_mask_cvtepi16_epi32(__m128i, __mmask8, __m128i); 
#line 2380
extern __m128i __cdecl _mm_maskz_cvtepi16_epi32(__mmask8, __m128i); 
#line 2381
extern __m256i __cdecl _mm256_mask_cvtepi16_epi32(__m256i, __mmask8, __m128i); 
#line 2382
extern __m256i __cdecl _mm256_maskz_cvtepi16_epi32(__mmask8, __m128i); 
#line 2383
extern __m128i __cdecl _mm_mask_cvtepi16_epi64(__m128i, __mmask8, __m128i); 
#line 2384
extern __m128i __cdecl _mm_maskz_cvtepi16_epi64(__mmask8, __m128i); 
#line 2385
extern __m256i __cdecl _mm256_mask_cvtepi16_epi64(__m256i, __mmask8, __m128i); 
#line 2386
extern __m256i __cdecl _mm256_maskz_cvtepi16_epi64(__mmask8, __m128i); 
#line 2387
extern __m128i __cdecl _mm_cvtepi16_epi8(__m128i); 
#line 2388
extern __m128i __cdecl _mm_mask_cvtepi16_epi8(__m128i, __mmask8, __m128i); 
#line 2389
extern __m128i __cdecl _mm_maskz_cvtepi16_epi8(__mmask8, __m128i); 
#line 2390
extern __m128i __cdecl _mm256_cvtepi16_epi8(__m256i); 
#line 2391
extern __m128i __cdecl _mm256_mask_cvtepi16_epi8(__m128i, __mmask16, __m256i); 
#line 2392
extern __m128i __cdecl _mm256_maskz_cvtepi16_epi8(__mmask16, __m256i); 
#line 2393
extern void __cdecl _mm_mask_cvtepi16_storeu_epi8(void *, __mmask8, __m128i); 
#line 2394
extern void __cdecl _mm256_mask_cvtepi16_storeu_epi8(void *, __mmask16, __m256i); 
#line 2395
extern __m128i __cdecl _mm_cvtepi32_epi16(__m128i); 
#line 2396
extern __m128i __cdecl _mm_mask_cvtepi32_epi16(__m128i, __mmask8, __m128i); 
#line 2397
extern __m128i __cdecl _mm_maskz_cvtepi32_epi16(__mmask8, __m128i); 
#line 2398
extern __m128i __cdecl _mm256_cvtepi32_epi16(__m256i); 
#line 2399
extern __m128i __cdecl _mm256_mask_cvtepi32_epi16(__m128i, __mmask8, __m256i); 
#line 2400
extern __m128i __cdecl _mm256_maskz_cvtepi32_epi16(__mmask8, __m256i); 
#line 2401
extern __m128i __cdecl _mm_mask_cvtepi32_epi64(__m128i, __mmask8, __m128i); 
#line 2402
extern __m128i __cdecl _mm_maskz_cvtepi32_epi64(__mmask8, __m128i); 
#line 2403
extern __m256i __cdecl _mm256_mask_cvtepi32_epi64(__m256i, __mmask8, __m128i); 
#line 2404
extern __m256i __cdecl _mm256_maskz_cvtepi32_epi64(__mmask8, __m128i); 
#line 2405
extern __m128i __cdecl _mm_cvtepi32_epi8(__m128i); 
#line 2406
extern __m128i __cdecl _mm_mask_cvtepi32_epi8(__m128i, __mmask8, __m128i); 
#line 2407
extern __m128i __cdecl _mm_maskz_cvtepi32_epi8(__mmask8, __m128i); 
#line 2408
extern __m128i __cdecl _mm256_cvtepi32_epi8(__m256i); 
#line 2409
extern __m128i __cdecl _mm256_mask_cvtepi32_epi8(__m128i, __mmask8, __m256i); 
#line 2410
extern __m128i __cdecl _mm256_maskz_cvtepi32_epi8(__mmask8, __m256i); 
#line 2411
extern __m128d __cdecl _mm_mask_cvtepi32_pd(__m128d, __mmask8, __m128i); 
#line 2412
extern __m128d __cdecl _mm_maskz_cvtepi32_pd(__mmask8, __m128i); 
#line 2413
extern __m256d __cdecl _mm256_mask_cvtepi32_pd(__m256d, __mmask8, __m128i); 
#line 2414
extern __m256d __cdecl _mm256_maskz_cvtepi32_pd(__mmask8, __m128i); 
#line 2415
extern __m128 __cdecl _mm_mask_cvtepi32_ps(__m128, __mmask8, __m128i); 
#line 2416
extern __m128 __cdecl _mm_maskz_cvtepi32_ps(__mmask8, __m128i); 
#line 2417
extern __m256 __cdecl _mm256_mask_cvtepi32_ps(__m256, __mmask8, __m256i); 
#line 2418
extern __m256 __cdecl _mm256_maskz_cvtepi32_ps(__mmask8, __m256i); 
#line 2419
extern void __cdecl _mm_mask_cvtepi32_storeu_epi16(void *, __mmask8, __m128i); 
#line 2420
extern void __cdecl _mm256_mask_cvtepi32_storeu_epi16(void *, __mmask8, __m256i); 
#line 2421
extern void __cdecl _mm_mask_cvtepi32_storeu_epi8(void *, __mmask8, __m128i); 
#line 2422
extern void __cdecl _mm256_mask_cvtepi32_storeu_epi8(void *, __mmask8, __m256i); 
#line 2423
extern __m128i __cdecl _mm_cvtepi64_epi16(__m128i); 
#line 2424
extern __m128i __cdecl _mm_mask_cvtepi64_epi16(__m128i, __mmask8, __m128i); 
#line 2425
extern __m128i __cdecl _mm_maskz_cvtepi64_epi16(__mmask8, __m128i); 
#line 2426
extern __m128i __cdecl _mm256_cvtepi64_epi16(__m256i); 
#line 2427
extern __m128i __cdecl _mm256_mask_cvtepi64_epi16(__m128i, __mmask8, __m256i); 
#line 2428
extern __m128i __cdecl _mm256_maskz_cvtepi64_epi16(__mmask8, __m256i); 
#line 2429
extern __m128i __cdecl _mm_cvtepi64_epi32(__m128i); 
#line 2430
extern __m128i __cdecl _mm_mask_cvtepi64_epi32(__m128i, __mmask8, __m128i); 
#line 2431
extern __m128i __cdecl _mm_maskz_cvtepi64_epi32(__mmask8, __m128i); 
#line 2432
extern __m128i __cdecl _mm256_cvtepi64_epi32(__m256i); 
#line 2433
extern __m128i __cdecl _mm256_mask_cvtepi64_epi32(__m128i, __mmask8, __m256i); 
#line 2434
extern __m128i __cdecl _mm256_maskz_cvtepi64_epi32(__mmask8, __m256i); 
#line 2435
extern __m128i __cdecl _mm_cvtepi64_epi8(__m128i); 
#line 2436
extern __m128i __cdecl _mm_mask_cvtepi64_epi8(__m128i, __mmask8, __m128i); 
#line 2437
extern __m128i __cdecl _mm_maskz_cvtepi64_epi8(__mmask8, __m128i); 
#line 2438
extern __m128i __cdecl _mm256_cvtepi64_epi8(__m256i); 
#line 2439
extern __m128i __cdecl _mm256_mask_cvtepi64_epi8(__m128i, __mmask8, __m256i); 
#line 2440
extern __m128i __cdecl _mm256_maskz_cvtepi64_epi8(__mmask8, __m256i); 
#line 2441
extern __m128d __cdecl _mm_cvtepi64_pd(__m128i); 
#line 2442
extern __m128d __cdecl _mm_mask_cvtepi64_pd(__m128d, __mmask8, __m128i); 
#line 2443
extern __m128d __cdecl _mm_maskz_cvtepi64_pd(__mmask8, __m128i); 
#line 2444
extern __m256d __cdecl _mm256_cvtepi64_pd(__m256i); 
#line 2445
extern __m256d __cdecl _mm256_mask_cvtepi64_pd(__m256d, __mmask8, __m256i); 
#line 2446
extern __m256d __cdecl _mm256_maskz_cvtepi64_pd(__mmask8, __m256i); 
#line 2447
extern __m128 __cdecl _mm_cvtepi64_ps(__m128i); 
#line 2448
extern __m128 __cdecl _mm_mask_cvtepi64_ps(__m128, __mmask8, __m128i); 
#line 2449
extern __m128 __cdecl _mm_maskz_cvtepi64_ps(__mmask8, __m128i); 
#line 2450
extern __m128 __cdecl _mm256_cvtepi64_ps(__m256i); 
#line 2451
extern __m128 __cdecl _mm256_mask_cvtepi64_ps(__m128, __mmask8, __m256i); 
#line 2452
extern __m128 __cdecl _mm256_maskz_cvtepi64_ps(__mmask8, __m256i); 
#line 2453
extern void __cdecl _mm_mask_cvtepi64_storeu_epi16(void *, __mmask8, __m128i); 
#line 2454
extern void __cdecl _mm256_mask_cvtepi64_storeu_epi16(void *, __mmask8, __m256i); 
#line 2455
extern void __cdecl _mm_mask_cvtepi64_storeu_epi32(void *, __mmask8, __m128i); 
#line 2456
extern void __cdecl _mm256_mask_cvtepi64_storeu_epi32(void *, __mmask8, __m256i); 
#line 2457
extern void __cdecl _mm_mask_cvtepi64_storeu_epi8(void *, __mmask8, __m128i); 
#line 2458
extern void __cdecl _mm256_mask_cvtepi64_storeu_epi8(void *, __mmask8, __m256i); 
#line 2459
extern __m128i __cdecl _mm_mask_cvtepi8_epi16(__m128i, __mmask8, __m128i); 
#line 2460
extern __m128i __cdecl _mm_maskz_cvtepi8_epi16(__mmask8, __m128i); 
#line 2461
extern __m256i __cdecl _mm256_mask_cvtepi8_epi16(__m256i, __mmask16, __m128i); 
#line 2462
extern __m256i __cdecl _mm256_maskz_cvtepi8_epi16(__mmask16, __m128i); 
#line 2463
extern __m128i __cdecl _mm_mask_cvtepi8_epi32(__m128i, __mmask8, __m128i); 
#line 2464
extern __m128i __cdecl _mm_maskz_cvtepi8_epi32(__mmask8, __m128i); 
#line 2465
extern __m256i __cdecl _mm256_mask_cvtepi8_epi32(__m256i, __mmask8, __m128i); 
#line 2466
extern __m256i __cdecl _mm256_maskz_cvtepi8_epi32(__mmask8, __m128i); 
#line 2467
extern __m128i __cdecl _mm_mask_cvtepi8_epi64(__m128i, __mmask8, __m128i); 
#line 2468
extern __m128i __cdecl _mm_maskz_cvtepi8_epi64(__mmask8, __m128i); 
#line 2469
extern __m256i __cdecl _mm256_mask_cvtepi8_epi64(__m256i, __mmask8, __m128i); 
#line 2470
extern __m256i __cdecl _mm256_maskz_cvtepi8_epi64(__mmask8, __m128i); 
#line 2471
extern __m128i __cdecl _mm_mask_cvtepu16_epi32(__m128i, __mmask8, __m128i); 
#line 2472
extern __m128i __cdecl _mm_maskz_cvtepu16_epi32(__mmask8, __m128i); 
#line 2473
extern __m256i __cdecl _mm256_mask_cvtepu16_epi32(__m256i, __mmask8, __m128i); 
#line 2474
extern __m256i __cdecl _mm256_maskz_cvtepu16_epi32(__mmask8, __m128i); 
#line 2475
extern __m128i __cdecl _mm_mask_cvtepu16_epi64(__m128i, __mmask8, __m128i); 
#line 2476
extern __m128i __cdecl _mm_maskz_cvtepu16_epi64(__mmask8, __m128i); 
#line 2477
extern __m256i __cdecl _mm256_mask_cvtepu16_epi64(__m256i, __mmask8, __m128i); 
#line 2478
extern __m256i __cdecl _mm256_maskz_cvtepu16_epi64(__mmask8, __m128i); 
#line 2479
extern __m128i __cdecl _mm_mask_cvtepu32_epi64(__m128i, __mmask8, __m128i); 
#line 2480
extern __m128i __cdecl _mm_maskz_cvtepu32_epi64(__mmask8, __m128i); 
#line 2481
extern __m256i __cdecl _mm256_mask_cvtepu32_epi64(__m256i, __mmask8, __m128i); 
#line 2482
extern __m256i __cdecl _mm256_maskz_cvtepu32_epi64(__mmask8, __m128i); 
#line 2483
extern __m128 __cdecl _mm_cvtepu32_ps(__m128i); 
#line 2484
extern __m128 __cdecl _mm_mask_cvtepu32_ps(__m128, __mmask8, __m128i); 
#line 2485
extern __m128 __cdecl _mm_maskz_cvtepu32_ps(__mmask8, __m128i); 
#line 2486
extern __m256 __cdecl _mm256_cvtepu32_ps(__m256i); 
#line 2487
extern __m256 __cdecl _mm256_mask_cvtepu32_ps(__m256, __mmask8, __m256i); 
#line 2488
extern __m256 __cdecl _mm256_maskz_cvtepu32_ps(__mmask8, __m256i); 
#line 2489
extern __m128d __cdecl _mm_cvtepu32_pd(__m128i); 
#line 2490
extern __m128d __cdecl _mm_mask_cvtepu32_pd(__m128d, __mmask8, __m128i); 
#line 2491
extern __m128d __cdecl _mm_maskz_cvtepu32_pd(__mmask8, __m128i); 
#line 2492
extern __m256d __cdecl _mm256_cvtepu32_pd(__m128i); 
#line 2493
extern __m256d __cdecl _mm256_mask_cvtepu32_pd(__m256d, __mmask8, __m128i); 
#line 2494
extern __m256d __cdecl _mm256_maskz_cvtepu32_pd(__mmask8, __m128i); 
#line 2495
extern __m128d __cdecl _mm_cvtepu64_pd(__m128i); 
#line 2496
extern __m128d __cdecl _mm_mask_cvtepu64_pd(__m128d, __mmask8, __m128i); 
#line 2497
extern __m128d __cdecl _mm_maskz_cvtepu64_pd(__mmask8, __m128i); 
#line 2498
extern __m256d __cdecl _mm256_cvtepu64_pd(__m256i); 
#line 2499
extern __m256d __cdecl _mm256_mask_cvtepu64_pd(__m256d, __mmask8, __m256i); 
#line 2500
extern __m256d __cdecl _mm256_maskz_cvtepu64_pd(__mmask8, __m256i); 
#line 2501
extern __m128 __cdecl _mm_cvtepu64_ps(__m128i); 
#line 2502
extern __m128 __cdecl _mm_mask_cvtepu64_ps(__m128, __mmask8, __m128i); 
#line 2503
extern __m128 __cdecl _mm_maskz_cvtepu64_ps(__mmask8, __m128i); 
#line 2504
extern __m128 __cdecl _mm256_cvtepu64_ps(__m256i); 
#line 2505
extern __m128 __cdecl _mm256_mask_cvtepu64_ps(__m128, __mmask8, __m256i); 
#line 2506
extern __m128 __cdecl _mm256_maskz_cvtepu64_ps(__mmask8, __m256i); 
#line 2507
extern __m128i __cdecl _mm_mask_cvtepu8_epi16(__m128i, __mmask8, __m128i); 
#line 2508
extern __m128i __cdecl _mm_maskz_cvtepu8_epi16(__mmask8, __m128i); 
#line 2509
extern __m256i __cdecl _mm256_mask_cvtepu8_epi16(__m256i, __mmask16, __m128i); 
#line 2510
extern __m256i __cdecl _mm256_maskz_cvtepu8_epi16(__mmask16, __m128i); 
#line 2511
extern __m128i __cdecl _mm_mask_cvtepu8_epi32(__m128i, __mmask8, __m128i); 
#line 2512
extern __m128i __cdecl _mm_maskz_cvtepu8_epi32(__mmask8, __m128i); 
#line 2513
extern __m256i __cdecl _mm256_mask_cvtepu8_epi32(__m256i, __mmask8, __m128i); 
#line 2514
extern __m256i __cdecl _mm256_maskz_cvtepu8_epi32(__mmask8, __m128i); 
#line 2515
extern __m128i __cdecl _mm_mask_cvtepu8_epi64(__m128i, __mmask8, __m128i); 
#line 2516
extern __m128i __cdecl _mm_maskz_cvtepu8_epi64(__mmask8, __m128i); 
#line 2517
extern __m256i __cdecl _mm256_mask_cvtepu8_epi64(__m256i, __mmask8, __m128i); 
#line 2518
extern __m256i __cdecl _mm256_maskz_cvtepu8_epi64(__mmask8, __m128i); 
#line 2519
extern __m128i __cdecl _mm_mask_cvtpd_epi32(__m128i, __mmask8, __m128d); 
#line 2520
extern __m128i __cdecl _mm_maskz_cvtpd_epi32(__mmask8, __m128d); 
#line 2521
extern __m128i __cdecl _mm256_mask_cvtpd_epi32(__m128i, __mmask8, __m256d); 
#line 2522
extern __m128i __cdecl _mm256_maskz_cvtpd_epi32(__mmask8, __m256d); 
#line 2523
extern __m128i __cdecl _mm_cvtpd_epi64(__m128d); 
#line 2524
extern __m128i __cdecl _mm_mask_cvtpd_epi64(__m128i, __mmask8, __m128d); 
#line 2525
extern __m128i __cdecl _mm_maskz_cvtpd_epi64(__mmask8, __m128d); 
#line 2526
extern __m256i __cdecl _mm256_cvtpd_epi64(__m256d); 
#line 2527
extern __m256i __cdecl _mm256_mask_cvtpd_epi64(__m256i, __mmask8, __m256d); 
#line 2528
extern __m256i __cdecl _mm256_maskz_cvtpd_epi64(__mmask8, __m256d); 
#line 2529
extern __m128i __cdecl _mm_cvtpd_epu32(__m128d); 
#line 2530
extern __m128i __cdecl _mm_mask_cvtpd_epu32(__m128i, __mmask8, __m128d); 
#line 2531
extern __m128i __cdecl _mm_maskz_cvtpd_epu32(__mmask8, __m128d); 
#line 2532
extern __m128i __cdecl _mm256_cvtpd_epu32(__m256d); 
#line 2533
extern __m128i __cdecl _mm256_mask_cvtpd_epu32(__m128i, __mmask8, __m256d); 
#line 2534
extern __m128i __cdecl _mm256_maskz_cvtpd_epu32(__mmask8, __m256d); 
#line 2535
extern __m128i __cdecl _mm_cvtpd_epu64(__m128d); 
#line 2536
extern __m128i __cdecl _mm_mask_cvtpd_epu64(__m128i, __mmask8, __m128d); 
#line 2537
extern __m128i __cdecl _mm_maskz_cvtpd_epu64(__mmask8, __m128d); 
#line 2538
extern __m256i __cdecl _mm256_cvtpd_epu64(__m256d); 
#line 2539
extern __m256i __cdecl _mm256_mask_cvtpd_epu64(__m256i, __mmask8, __m256d); 
#line 2540
extern __m256i __cdecl _mm256_maskz_cvtpd_epu64(__mmask8, __m256d); 
#line 2541
extern __m128 __cdecl _mm_mask_cvtpd_ps(__m128, __mmask8, __m128d); 
#line 2542
extern __m128 __cdecl _mm_maskz_cvtpd_ps(__mmask8, __m128d); 
#line 2543
extern __m128 __cdecl _mm256_mask_cvtpd_ps(__m128, __mmask8, __m256d); 
#line 2544
extern __m128 __cdecl _mm256_maskz_cvtpd_ps(__mmask8, __m256d); 
#line 2545
extern __m128 __cdecl _mm_mask_cvtph_ps(__m128, __mmask8, __m128i); 
#line 2546
extern __m128 __cdecl _mm_maskz_cvtph_ps(__mmask8, __m128i); 
#line 2547
extern __m256 __cdecl _mm256_mask_cvtph_ps(__m256, __mmask8, __m128i); 
#line 2548
extern __m256 __cdecl _mm256_maskz_cvtph_ps(__mmask8, __m128i); 
#line 2549
extern __m128i __cdecl _mm_mask_cvtps_epi32(__m128i, __mmask8, __m128); 
#line 2550
extern __m128i __cdecl _mm_maskz_cvtps_epi32(__mmask8, __m128); 
#line 2551
extern __m256i __cdecl _mm256_mask_cvtps_epi32(__m256i, __mmask8, __m256); 
#line 2552
extern __m256i __cdecl _mm256_maskz_cvtps_epi32(__mmask8, __m256); 
#line 2553
extern __m128i __cdecl _mm_cvtps_epi64(__m128); 
#line 2554
extern __m128i __cdecl _mm_mask_cvtps_epi64(__m128i, __mmask8, __m128); 
#line 2555
extern __m128i __cdecl _mm_maskz_cvtps_epi64(__mmask8, __m128); 
#line 2556
extern __m256i __cdecl _mm256_cvtps_epi64(__m128); 
#line 2557
extern __m256i __cdecl _mm256_mask_cvtps_epi64(__m256i, __mmask8, __m128); 
#line 2558
extern __m256i __cdecl _mm256_maskz_cvtps_epi64(__mmask8, __m128); 
#line 2559
extern __m128i __cdecl _mm_cvtps_epu32(__m128); 
#line 2560
extern __m128i __cdecl _mm_mask_cvtps_epu32(__m128i, __mmask8, __m128); 
#line 2561
extern __m128i __cdecl _mm_maskz_cvtps_epu32(__mmask8, __m128); 
#line 2562
extern __m256i __cdecl _mm256_cvtps_epu32(__m256); 
#line 2563
extern __m256i __cdecl _mm256_mask_cvtps_epu32(__m256i, __mmask8, __m256); 
#line 2564
extern __m256i __cdecl _mm256_maskz_cvtps_epu32(__mmask8, __m256); 
#line 2565
extern __m128i __cdecl _mm_cvtps_epu64(__m128); 
#line 2566
extern __m128i __cdecl _mm_mask_cvtps_epu64(__m128i, __mmask8, __m128); 
#line 2567
extern __m128i __cdecl _mm_maskz_cvtps_epu64(__mmask8, __m128); 
#line 2568
extern __m256i __cdecl _mm256_cvtps_epu64(__m128); 
#line 2569
extern __m256i __cdecl _mm256_mask_cvtps_epu64(__m256i, __mmask8, __m128); 
#line 2570
extern __m256i __cdecl _mm256_maskz_cvtps_epu64(__mmask8, __m128); 
#line 2571
extern __m128d __cdecl _mm_mask_cvtps_pd(__m128d, __mmask8, __m128); 
#line 2572
extern __m128d __cdecl _mm_maskz_cvtps_pd(__mmask8, __m128); 
#line 2573
extern __m256d __cdecl _mm256_mask_cvtps_pd(__m256d, __mmask8, __m128); 
#line 2574
extern __m256d __cdecl _mm256_maskz_cvtps_pd(__mmask8, __m128); 
#line 2575
extern __m128i __cdecl _mm_cvtsepi16_epi8(__m128i); 
#line 2576
extern __m128i __cdecl _mm_mask_cvtsepi16_epi8(__m128i, __mmask8, __m128i); 
#line 2577
extern __m128i __cdecl _mm_maskz_cvtsepi16_epi8(__mmask8, __m128i); 
#line 2578
extern __m128i __cdecl _mm256_cvtsepi16_epi8(__m256i); 
#line 2579
extern __m128i __cdecl _mm256_mask_cvtsepi16_epi8(__m128i, __mmask16, __m256i); 
#line 2580
extern __m128i __cdecl _mm256_maskz_cvtsepi16_epi8(__mmask16, __m256i); 
#line 2581
extern void __cdecl _mm_mask_cvtsepi16_storeu_epi8(void *, __mmask8, __m128i); 
#line 2582
extern void __cdecl _mm256_mask_cvtsepi16_storeu_epi8(void *, __mmask16, __m256i); 
#line 2583
extern __m128i __cdecl _mm_cvtsepi32_epi16(__m128i); 
#line 2584
extern __m128i __cdecl _mm_mask_cvtsepi32_epi16(__m128i, __mmask8, __m128i); 
#line 2585
extern __m128i __cdecl _mm_maskz_cvtsepi32_epi16(__mmask8, __m128i); 
#line 2586
extern __m128i __cdecl _mm256_cvtsepi32_epi16(__m256i); 
#line 2587
extern __m128i __cdecl _mm256_mask_cvtsepi32_epi16(__m128i, __mmask8, __m256i); 
#line 2588
extern __m128i __cdecl _mm256_maskz_cvtsepi32_epi16(__mmask8, __m256i); 
#line 2589
extern __m128i __cdecl _mm_cvtsepi32_epi8(__m128i); 
#line 2590
extern __m128i __cdecl _mm_mask_cvtsepi32_epi8(__m128i, __mmask8, __m128i); 
#line 2591
extern __m128i __cdecl _mm_maskz_cvtsepi32_epi8(__mmask8, __m128i); 
#line 2592
extern __m128i __cdecl _mm256_cvtsepi32_epi8(__m256i); 
#line 2593
extern __m128i __cdecl _mm256_mask_cvtsepi32_epi8(__m128i, __mmask8, __m256i); 
#line 2594
extern __m128i __cdecl _mm256_maskz_cvtsepi32_epi8(__mmask8, __m256i); 
#line 2595
extern void __cdecl _mm_mask_cvtsepi32_storeu_epi16(void *, __mmask8, __m128i); 
#line 2596
extern void __cdecl _mm256_mask_cvtsepi32_storeu_epi16(void *, __mmask8, __m256i); 
#line 2597
extern void __cdecl _mm_mask_cvtsepi32_storeu_epi8(void *, __mmask8, __m128i); 
#line 2598
extern void __cdecl _mm256_mask_cvtsepi32_storeu_epi8(void *, __mmask8, __m256i); 
#line 2599
extern __m128i __cdecl _mm_cvtsepi64_epi16(__m128i); 
#line 2600
extern __m128i __cdecl _mm_mask_cvtsepi64_epi16(__m128i, __mmask8, __m128i); 
#line 2601
extern __m128i __cdecl _mm_maskz_cvtsepi64_epi16(__mmask8, __m128i); 
#line 2602
extern __m128i __cdecl _mm256_cvtsepi64_epi16(__m256i); 
#line 2603
extern __m128i __cdecl _mm256_mask_cvtsepi64_epi16(__m128i, __mmask8, __m256i); 
#line 2604
extern __m128i __cdecl _mm256_maskz_cvtsepi64_epi16(__mmask8, __m256i); 
#line 2605
extern __m128i __cdecl _mm_cvtsepi64_epi32(__m128i); 
#line 2606
extern __m128i __cdecl _mm_mask_cvtsepi64_epi32(__m128i, __mmask8, __m128i); 
#line 2607
extern __m128i __cdecl _mm_maskz_cvtsepi64_epi32(__mmask8, __m128i); 
#line 2608
extern __m128i __cdecl _mm256_cvtsepi64_epi32(__m256i); 
#line 2609
extern __m128i __cdecl _mm256_mask_cvtsepi64_epi32(__m128i, __mmask8, __m256i); 
#line 2610
extern __m128i __cdecl _mm256_maskz_cvtsepi64_epi32(__mmask8, __m256i); 
#line 2611
extern __m128i __cdecl _mm_cvtsepi64_epi8(__m128i); 
#line 2612
extern __m128i __cdecl _mm_mask_cvtsepi64_epi8(__m128i, __mmask8, __m128i); 
#line 2613
extern __m128i __cdecl _mm_maskz_cvtsepi64_epi8(__mmask8, __m128i); 
#line 2614
extern __m128i __cdecl _mm256_cvtsepi64_epi8(__m256i); 
#line 2615
extern __m128i __cdecl _mm256_mask_cvtsepi64_epi8(__m128i, __mmask8, __m256i); 
#line 2616
extern __m128i __cdecl _mm256_maskz_cvtsepi64_epi8(__mmask8, __m256i); 
#line 2617
extern void __cdecl _mm_mask_cvtsepi64_storeu_epi16(void *, __mmask8, __m128i); 
#line 2618
extern void __cdecl _mm256_mask_cvtsepi64_storeu_epi16(void *, __mmask8, __m256i); 
#line 2619
extern void __cdecl _mm_mask_cvtsepi64_storeu_epi32(void *, __mmask8, __m128i); 
#line 2620
extern void __cdecl _mm256_mask_cvtsepi64_storeu_epi32(void *, __mmask8, __m256i); 
#line 2621
extern void __cdecl _mm_mask_cvtsepi64_storeu_epi8(void *, __mmask8, __m128i); 
#line 2622
extern void __cdecl _mm256_mask_cvtsepi64_storeu_epi8(void *, __mmask8, __m256i); 
#line 2623
extern __m128i __cdecl _mm_mask_cvttpd_epi32(__m128i, __mmask8, __m128d); 
#line 2624
extern __m128i __cdecl _mm_maskz_cvttpd_epi32(__mmask8, __m128d); 
#line 2625
extern __m128i __cdecl _mm256_mask_cvttpd_epi32(__m128i, __mmask8, __m256d); 
#line 2626
extern __m128i __cdecl _mm256_maskz_cvttpd_epi32(__mmask8, __m256d); 
#line 2627
extern __m128i __cdecl _mm_cvttpd_epi64(__m128d); 
#line 2628
extern __m128i __cdecl _mm_mask_cvttpd_epi64(__m128i, __mmask8, __m128d); 
#line 2629
extern __m128i __cdecl _mm_maskz_cvttpd_epi64(__mmask8, __m128d); 
#line 2630
extern __m256i __cdecl _mm256_cvttpd_epi64(__m256d); 
#line 2631
extern __m256i __cdecl _mm256_mask_cvttpd_epi64(__m256i, __mmask8, __m256d); 
#line 2632
extern __m256i __cdecl _mm256_maskz_cvttpd_epi64(__mmask8, __m256d); 
#line 2633
extern __m128i __cdecl _mm_cvttpd_epu32(__m128d); 
#line 2634
extern __m128i __cdecl _mm_mask_cvttpd_epu32(__m128i, __mmask8, __m128d); 
#line 2635
extern __m128i __cdecl _mm_maskz_cvttpd_epu32(__mmask8, __m128d); 
#line 2636
extern __m128i __cdecl _mm256_cvttpd_epu32(__m256d); 
#line 2637
extern __m128i __cdecl _mm256_mask_cvttpd_epu32(__m128i, __mmask8, __m256d); 
#line 2638
extern __m128i __cdecl _mm256_maskz_cvttpd_epu32(__mmask8, __m256d); 
#line 2639
extern __m128i __cdecl _mm_cvttpd_epu64(__m128d); 
#line 2640
extern __m128i __cdecl _mm_mask_cvttpd_epu64(__m128i, __mmask8, __m128d); 
#line 2641
extern __m128i __cdecl _mm_maskz_cvttpd_epu64(__mmask8, __m128d); 
#line 2642
extern __m256i __cdecl _mm256_cvttpd_epu64(__m256d); 
#line 2643
extern __m256i __cdecl _mm256_mask_cvttpd_epu64(__m256i, __mmask8, __m256d); 
#line 2644
extern __m256i __cdecl _mm256_maskz_cvttpd_epu64(__mmask8, __m256d); 
#line 2645
extern __m128i __cdecl _mm_mask_cvttps_epi32(__m128i, __mmask8, __m128); 
#line 2646
extern __m128i __cdecl _mm_maskz_cvttps_epi32(__mmask8, __m128); 
#line 2647
extern __m256i __cdecl _mm256_mask_cvttps_epi32(__m256i, __mmask8, __m256); 
#line 2648
extern __m256i __cdecl _mm256_maskz_cvttps_epi32(__mmask8, __m256); 
#line 2649
extern __m128i __cdecl _mm_cvttps_epi64(__m128); 
#line 2650
extern __m128i __cdecl _mm_mask_cvttps_epi64(__m128i, __mmask8, __m128); 
#line 2651
extern __m128i __cdecl _mm_maskz_cvttps_epi64(__mmask8, __m128); 
#line 2652
extern __m256i __cdecl _mm256_cvttps_epi64(__m128); 
#line 2653
extern __m256i __cdecl _mm256_mask_cvttps_epi64(__m256i, __mmask8, __m128); 
#line 2654
extern __m256i __cdecl _mm256_maskz_cvttps_epi64(__mmask8, __m128); 
#line 2655
extern __m128i __cdecl _mm_cvttps_epu32(__m128); 
#line 2656
extern __m128i __cdecl _mm_mask_cvttps_epu32(__m128i, __mmask8, __m128); 
#line 2657
extern __m128i __cdecl _mm_maskz_cvttps_epu32(__mmask8, __m128); 
#line 2658
extern __m256i __cdecl _mm256_cvttps_epu32(__m256); 
#line 2659
extern __m256i __cdecl _mm256_mask_cvttps_epu32(__m256i, __mmask8, __m256); 
#line 2660
extern __m256i __cdecl _mm256_maskz_cvttps_epu32(__mmask8, __m256); 
#line 2661
extern __m128i __cdecl _mm_cvttps_epu64(__m128); 
#line 2662
extern __m128i __cdecl _mm_mask_cvttps_epu64(__m128i, __mmask8, __m128); 
#line 2663
extern __m128i __cdecl _mm_maskz_cvttps_epu64(__mmask8, __m128); 
#line 2664
extern __m256i __cdecl _mm256_cvttps_epu64(__m128); 
#line 2665
extern __m256i __cdecl _mm256_mask_cvttps_epu64(__m256i, __mmask8, __m128); 
#line 2666
extern __m256i __cdecl _mm256_maskz_cvttps_epu64(__mmask8, __m128); 
#line 2667
extern __m128i __cdecl _mm_cvtusepi16_epi8(__m128i); 
#line 2668
extern __m128i __cdecl _mm_mask_cvtusepi16_epi8(__m128i, __mmask8, __m128i); 
#line 2669
extern __m128i __cdecl _mm_maskz_cvtusepi16_epi8(__mmask8, __m128i); 
#line 2670
extern __m128i __cdecl _mm256_cvtusepi16_epi8(__m256i); 
#line 2671
extern __m128i __cdecl _mm256_mask_cvtusepi16_epi8(__m128i, __mmask16, __m256i); 
#line 2672
extern __m128i __cdecl _mm256_maskz_cvtusepi16_epi8(__mmask16, __m256i); 
#line 2673
extern void __cdecl _mm_mask_cvtusepi16_storeu_epi8(void *, __mmask8, __m128i); 
#line 2674
extern void __cdecl _mm256_mask_cvtusepi16_storeu_epi8(void *, __mmask16, __m256i); 
#line 2675
extern __m128i __cdecl _mm_cvtusepi32_epi16(__m128i); 
#line 2676
extern __m128i __cdecl _mm_mask_cvtusepi32_epi16(__m128i, __mmask8, __m128i); 
#line 2677
extern __m128i __cdecl _mm_maskz_cvtusepi32_epi16(__mmask8, __m128i); 
#line 2678
extern __m128i __cdecl _mm256_cvtusepi32_epi16(__m256i); 
#line 2679
extern __m128i __cdecl _mm256_mask_cvtusepi32_epi16(__m128i, __mmask8, __m256i); 
#line 2680
extern __m128i __cdecl _mm256_maskz_cvtusepi32_epi16(__mmask8, __m256i); 
#line 2681
extern __m128i __cdecl _mm_cvtusepi32_epi8(__m128i); 
#line 2682
extern __m128i __cdecl _mm_mask_cvtusepi32_epi8(__m128i, __mmask8, __m128i); 
#line 2683
extern __m128i __cdecl _mm_maskz_cvtusepi32_epi8(__mmask8, __m128i); 
#line 2684
extern __m128i __cdecl _mm256_cvtusepi32_epi8(__m256i); 
#line 2685
extern __m128i __cdecl _mm256_mask_cvtusepi32_epi8(__m128i, __mmask8, __m256i); 
#line 2686
extern __m128i __cdecl _mm256_maskz_cvtusepi32_epi8(__mmask8, __m256i); 
#line 2687
extern void __cdecl _mm_mask_cvtusepi32_storeu_epi16(void *, __mmask8, __m128i); 
#line 2688
extern void __cdecl _mm256_mask_cvtusepi32_storeu_epi16(void *, __mmask8, __m256i); 
#line 2689
extern void __cdecl _mm_mask_cvtusepi32_storeu_epi8(void *, __mmask8, __m128i); 
#line 2690
extern void __cdecl _mm256_mask_cvtusepi32_storeu_epi8(void *, __mmask8, __m256i); 
#line 2691
extern __m128i __cdecl _mm_cvtusepi64_epi16(__m128i); 
#line 2692
extern __m128i __cdecl _mm_mask_cvtusepi64_epi16(__m128i, __mmask8, __m128i); 
#line 2693
extern __m128i __cdecl _mm_maskz_cvtusepi64_epi16(__mmask8, __m128i); 
#line 2694
extern __m128i __cdecl _mm256_cvtusepi64_epi16(__m256i); 
#line 2695
extern __m128i __cdecl _mm256_mask_cvtusepi64_epi16(__m128i, __mmask8, __m256i); 
#line 2696
extern __m128i __cdecl _mm256_maskz_cvtusepi64_epi16(__mmask8, __m256i); 
#line 2697
extern __m128i __cdecl _mm_cvtusepi64_epi32(__m128i); 
#line 2698
extern __m128i __cdecl _mm_mask_cvtusepi64_epi32(__m128i, __mmask8, __m128i); 
#line 2699
extern __m128i __cdecl _mm_maskz_cvtusepi64_epi32(__mmask8, __m128i); 
#line 2700
extern __m128i __cdecl _mm256_cvtusepi64_epi32(__m256i); 
#line 2701
extern __m128i __cdecl _mm256_mask_cvtusepi64_epi32(__m128i, __mmask8, __m256i); 
#line 2702
extern __m128i __cdecl _mm256_maskz_cvtusepi64_epi32(__mmask8, __m256i); 
#line 2703
extern __m128i __cdecl _mm_cvtusepi64_epi8(__m128i); 
#line 2704
extern __m128i __cdecl _mm_mask_cvtusepi64_epi8(__m128i, __mmask8, __m128i); 
#line 2705
extern __m128i __cdecl _mm_maskz_cvtusepi64_epi8(__mmask8, __m128i); 
#line 2706
extern __m128i __cdecl _mm256_cvtusepi64_epi8(__m256i); 
#line 2707
extern __m128i __cdecl _mm256_mask_cvtusepi64_epi8(__m128i, __mmask8, __m256i); 
#line 2708
extern __m128i __cdecl _mm256_maskz_cvtusepi64_epi8(__mmask8, __m256i); 
#line 2709
extern void __cdecl _mm_mask_cvtusepi64_storeu_epi16(void *, __mmask8, __m128i); 
#line 2710
extern void __cdecl _mm256_mask_cvtusepi64_storeu_epi16(void *, __mmask8, __m256i); 
#line 2711
extern void __cdecl _mm_mask_cvtusepi64_storeu_epi32(void *, __mmask8, __m128i); 
#line 2712
extern void __cdecl _mm256_mask_cvtusepi64_storeu_epi32(void *, __mmask8, __m256i); 
#line 2713
extern void __cdecl _mm_mask_cvtusepi64_storeu_epi8(void *, __mmask8, __m128i); 
#line 2714
extern void __cdecl _mm256_mask_cvtusepi64_storeu_epi8(void *, __mmask8, __m256i); 
#line 2715
extern __m128i __cdecl _mm_dbsad_epu8(__m128i, __m128i, int); 
#line 2716
extern __m128i __cdecl _mm_mask_dbsad_epu8(__m128i, __mmask8, __m128i, __m128i, int); 
#line 2717
extern __m128i __cdecl _mm_maskz_dbsad_epu8(__mmask8, __m128i, __m128i, int); 
#line 2718
extern __m256i __cdecl _mm256_dbsad_epu8(__m256i, __m256i, int); 
#line 2719
extern __m256i __cdecl _mm256_mask_dbsad_epu8(__m256i, __mmask16, __m256i, __m256i, int); 
#line 2720
extern __m256i __cdecl _mm256_maskz_dbsad_epu8(__mmask16, __m256i, __m256i, int); 
#line 2721
extern __m128d __cdecl _mm_mask_div_pd(__m128d, __mmask8, __m128d, __m128d); 
#line 2722
extern __m128d __cdecl _mm_maskz_div_pd(__mmask8, __m128d, __m128d); 
#line 2723
extern __m256d __cdecl _mm256_mask_div_pd(__m256d, __mmask8, __m256d, __m256d); 
#line 2724
extern __m256d __cdecl _mm256_maskz_div_pd(__mmask8, __m256d, __m256d); 
#line 2725
extern __m128 __cdecl _mm_mask_div_ps(__m128, __mmask8, __m128, __m128); 
#line 2726
extern __m128 __cdecl _mm_maskz_div_ps(__mmask8, __m128, __m128); 
#line 2727
extern __m256 __cdecl _mm256_mask_div_ps(__m256, __mmask8, __m256, __m256); 
#line 2728
extern __m256 __cdecl _mm256_maskz_div_ps(__mmask8, __m256, __m256); 
#line 2729
extern __m128i __cdecl _mm_mask_expand_epi8(__m128i, __mmask16, __m128i); 
#line 2730
extern __m128i __cdecl _mm_maskz_expand_epi8(__mmask16, __m128i); 
#line 2731
extern __m256i __cdecl _mm256_mask_expand_epi8(__m256i, __mmask32, __m256i); 
#line 2732
extern __m256i __cdecl _mm256_maskz_expand_epi8(__mmask32, __m256i); 
#line 2733
extern __m128i __cdecl _mm_mask_expand_epi16(__m128i, __mmask8, __m128i); 
#line 2734
extern __m128i __cdecl _mm_maskz_expand_epi16(__mmask8, __m128i); 
#line 2735
extern __m256i __cdecl _mm256_mask_expand_epi16(__m256i, __mmask16, __m256i); 
#line 2736
extern __m256i __cdecl _mm256_maskz_expand_epi16(__mmask16, __m256i); 
#line 2737
extern __m128i __cdecl _mm_mask_expand_epi32(__m128i, __mmask8, __m128i); 
#line 2738
extern __m128i __cdecl _mm_maskz_expand_epi32(__mmask8, __m128i); 
#line 2739
extern __m256i __cdecl _mm256_mask_expand_epi32(__m256i, __mmask8, __m256i); 
#line 2740
extern __m256i __cdecl _mm256_maskz_expand_epi32(__mmask8, __m256i); 
#line 2741
extern __m128i __cdecl _mm_mask_expand_epi64(__m128i, __mmask8, __m128i); 
#line 2742
extern __m128i __cdecl _mm_maskz_expand_epi64(__mmask8, __m128i); 
#line 2743
extern __m256i __cdecl _mm256_mask_expand_epi64(__m256i, __mmask8, __m256i); 
#line 2744
extern __m256i __cdecl _mm256_maskz_expand_epi64(__mmask8, __m256i); 
#line 2745
extern __m128d __cdecl _mm_mask_expand_pd(__m128d, __mmask8, __m128d); 
#line 2746
extern __m128d __cdecl _mm_maskz_expand_pd(__mmask8, __m128d); 
#line 2747
extern __m256d __cdecl _mm256_mask_expand_pd(__m256d, __mmask8, __m256d); 
#line 2748
extern __m256d __cdecl _mm256_maskz_expand_pd(__mmask8, __m256d); 
#line 2749
extern __m128 __cdecl _mm_mask_expand_ps(__m128, __mmask8, __m128); 
#line 2750
extern __m128 __cdecl _mm_maskz_expand_ps(__mmask8, __m128); 
#line 2751
extern __m256 __cdecl _mm256_mask_expand_ps(__m256, __mmask8, __m256); 
#line 2752
extern __m256 __cdecl _mm256_maskz_expand_ps(__mmask8, __m256); 
#line 2753
extern __m128i __cdecl _mm_mask_expandloadu_epi8(__m128i, __mmask16, const void *); 
#line 2754
extern __m128i __cdecl _mm_maskz_expandloadu_epi8(__mmask16, const void *); 
#line 2755
extern __m256i __cdecl _mm256_mask_expandloadu_epi8(__m256i, __mmask32, const void *); 
#line 2756
extern __m256i __cdecl _mm256_maskz_expandloadu_epi8(__mmask32, const void *); 
#line 2757
extern __m128i __cdecl _mm_mask_expandloadu_epi16(__m128i, __mmask8, const void *); 
#line 2758
extern __m128i __cdecl _mm_maskz_expandloadu_epi16(__mmask8, const void *); 
#line 2759
extern __m256i __cdecl _mm256_mask_expandloadu_epi16(__m256i, __mmask16, const void *); 
#line 2760
extern __m256i __cdecl _mm256_maskz_expandloadu_epi16(__mmask16, const void *); 
#line 2761
extern __m128i __cdecl _mm_mask_expandloadu_epi32(__m128i, __mmask8, const void *); 
#line 2762
extern __m128i __cdecl _mm_maskz_expandloadu_epi32(__mmask8, const void *); 
#line 2763
extern __m256i __cdecl _mm256_mask_expandloadu_epi32(__m256i, __mmask8, const void *); 
#line 2764
extern __m256i __cdecl _mm256_maskz_expandloadu_epi32(__mmask8, const void *); 
#line 2765
extern __m128i __cdecl _mm_mask_expandloadu_epi64(__m128i, __mmask8, const void *); 
#line 2766
extern __m128i __cdecl _mm_maskz_expandloadu_epi64(__mmask8, const void *); 
#line 2767
extern __m256i __cdecl _mm256_mask_expandloadu_epi64(__m256i, __mmask8, const void *); 
#line 2768
extern __m256i __cdecl _mm256_maskz_expandloadu_epi64(__mmask8, const void *); 
#line 2769
extern __m128d __cdecl _mm_mask_expandloadu_pd(__m128d, __mmask8, const void *); 
#line 2770
extern __m128d __cdecl _mm_maskz_expandloadu_pd(__mmask8, const void *); 
#line 2771
extern __m256d __cdecl _mm256_mask_expandloadu_pd(__m256d, __mmask8, const void *); 
#line 2772
extern __m256d __cdecl _mm256_maskz_expandloadu_pd(__mmask8, const void *); 
#line 2773
extern __m128 __cdecl _mm_mask_expandloadu_ps(__m128, __mmask8, const void *); 
#line 2774
extern __m128 __cdecl _mm_maskz_expandloadu_ps(__mmask8, const void *); 
#line 2775
extern __m256 __cdecl _mm256_mask_expandloadu_ps(__m256, __mmask8, const void *); 
#line 2776
extern __m256 __cdecl _mm256_maskz_expandloadu_ps(__mmask8, const void *); 
#line 2777
extern __m128 __cdecl _mm256_extractf32x4_ps(__m256, int); 
#line 2778
extern __m128 __cdecl _mm256_mask_extractf32x4_ps(__m128, __mmask8, __m256, int); 
#line 2779
extern __m128 __cdecl _mm256_maskz_extractf32x4_ps(__mmask8, __m256, int); 
#line 2780
extern __m128d __cdecl _mm256_extractf64x2_pd(__m256d, int); 
#line 2781
extern __m128d __cdecl _mm256_mask_extractf64x2_pd(__m128d, __mmask8, __m256d, int); 
#line 2782
extern __m128d __cdecl _mm256_maskz_extractf64x2_pd(__mmask8, __m256d, int); 
#line 2783
extern __m128i __cdecl _mm256_extracti32x4_epi32(__m256i, int); 
#line 2784
extern __m128i __cdecl _mm256_mask_extracti32x4_epi32(__m128i, __mmask8, __m256i, int); 
#line 2785
extern __m128i __cdecl _mm256_maskz_extracti32x4_epi32(__mmask8, __m256i, int); 
#line 2786
extern __m128i __cdecl _mm256_extracti64x2_epi64(__m256i, int); 
#line 2787
extern __m128i __cdecl _mm256_mask_extracti64x2_epi64(__m128i, __mmask8, __m256i, int); 
#line 2788
extern __m128i __cdecl _mm256_maskz_extracti64x2_epi64(__mmask8, __m256i, int); 
#line 2789
extern __m128d __cdecl _mm_fixupimm_pd(__m128d, __m128d, __m128i, const int); 
#line 2790
extern __m128d __cdecl _mm_mask_fixupimm_pd(__m128d, __mmask8, __m128d, __m128i, const int); 
#line 2791
extern __m128d __cdecl _mm_maskz_fixupimm_pd(__mmask8, __m128d, __m128d, __m128i, const int); 
#line 2792
extern __m256d __cdecl _mm256_fixupimm_pd(__m256d, __m256d, __m256i, const int); 
#line 2793
extern __m256d __cdecl _mm256_mask_fixupimm_pd(__m256d, __mmask8, __m256d, __m256i, const int); 
#line 2794
extern __m256d __cdecl _mm256_maskz_fixupimm_pd(__mmask8, __m256d, __m256d, __m256i, const int); 
#line 2795
extern __m128 __cdecl _mm_fixupimm_ps(__m128, __m128, __m128i, const int); 
#line 2796
extern __m128 __cdecl _mm_mask_fixupimm_ps(__m128, __mmask8, __m128, __m128i, const int); 
#line 2797
extern __m128 __cdecl _mm_maskz_fixupimm_ps(__mmask8, __m128, __m128, __m128i, const int); 
#line 2798
extern __m256 __cdecl _mm256_fixupimm_ps(__m256, __m256, __m256i, const int); 
#line 2799
extern __m256 __cdecl _mm256_mask_fixupimm_ps(__m256, __mmask8, __m256, __m256i, const int); 
#line 2800
extern __m256 __cdecl _mm256_maskz_fixupimm_ps(__mmask8, __m256, __m256, __m256i, const int); 
#line 2801
extern __m128d __cdecl _mm_mask_fmadd_pd(__m128d, __mmask8, __m128d, __m128d); 
#line 2802
extern __m128d __cdecl _mm_mask3_fmadd_pd(__m128d, __m128d, __m128d, __mmask8); 
#line 2803
extern __m128d __cdecl _mm_maskz_fmadd_pd(__mmask8, __m128d, __m128d, __m128d); 
#line 2804
extern __m256d __cdecl _mm256_mask_fmadd_pd(__m256d, __mmask8, __m256d, __m256d); 
#line 2805
extern __m256d __cdecl _mm256_mask3_fmadd_pd(__m256d, __m256d, __m256d, __mmask8); 
#line 2806
extern __m256d __cdecl _mm256_maskz_fmadd_pd(__mmask8, __m256d, __m256d, __m256d); 
#line 2807
extern __m128 __cdecl _mm_mask_fmadd_ps(__m128, __mmask8, __m128, __m128); 
#line 2808
extern __m128 __cdecl _mm_mask3_fmadd_ps(__m128, __m128, __m128, __mmask8); 
#line 2809
extern __m128 __cdecl _mm_maskz_fmadd_ps(__mmask8, __m128, __m128, __m128); 
#line 2810
extern __m256 __cdecl _mm256_mask_fmadd_ps(__m256, __mmask8, __m256, __m256); 
#line 2811
extern __m256 __cdecl _mm256_mask3_fmadd_ps(__m256, __m256, __m256, __mmask8); 
#line 2812
extern __m256 __cdecl _mm256_maskz_fmadd_ps(__mmask8, __m256, __m256, __m256); 
#line 2813
extern __m128d __cdecl _mm_mask_fmaddsub_pd(__m128d, __mmask8, __m128d, __m128d); 
#line 2814
extern __m128d __cdecl _mm_mask3_fmaddsub_pd(__m128d, __m128d, __m128d, __mmask8); 
#line 2815
extern __m128d __cdecl _mm_maskz_fmaddsub_pd(__mmask8, __m128d, __m128d, __m128d); 
#line 2816
extern __m256d __cdecl _mm256_mask_fmaddsub_pd(__m256d, __mmask8, __m256d, __m256d); 
#line 2817
extern __m256d __cdecl _mm256_mask3_fmaddsub_pd(__m256d, __m256d, __m256d, __mmask8); 
#line 2818
extern __m256d __cdecl _mm256_maskz_fmaddsub_pd(__mmask8, __m256d, __m256d, __m256d); 
#line 2819
extern __m128 __cdecl _mm_mask_fmaddsub_ps(__m128, __mmask8, __m128, __m128); 
#line 2820
extern __m128 __cdecl _mm_mask3_fmaddsub_ps(__m128, __m128, __m128, __mmask8); 
#line 2821
extern __m128 __cdecl _mm_maskz_fmaddsub_ps(__mmask8, __m128, __m128, __m128); 
#line 2822
extern __m256 __cdecl _mm256_mask_fmaddsub_ps(__m256, __mmask8, __m256, __m256); 
#line 2823
extern __m256 __cdecl _mm256_mask3_fmaddsub_ps(__m256, __m256, __m256, __mmask8); 
#line 2824
extern __m256 __cdecl _mm256_maskz_fmaddsub_ps(__mmask8, __m256, __m256, __m256); 
#line 2825
extern __m128d __cdecl _mm_mask_fmsub_pd(__m128d, __mmask8, __m128d, __m128d); 
#line 2826
extern __m128d __cdecl _mm_mask3_fmsub_pd(__m128d, __m128d, __m128d, __mmask8); 
#line 2827
extern __m128d __cdecl _mm_maskz_fmsub_pd(__mmask8, __m128d, __m128d, __m128d); 
#line 2828
extern __m256d __cdecl _mm256_mask_fmsub_pd(__m256d, __mmask8, __m256d, __m256d); 
#line 2829
extern __m256d __cdecl _mm256_mask3_fmsub_pd(__m256d, __m256d, __m256d, __mmask8); 
#line 2830
extern __m256d __cdecl _mm256_maskz_fmsub_pd(__mmask8, __m256d, __m256d, __m256d); 
#line 2831
extern __m128 __cdecl _mm_mask_fmsub_ps(__m128, __mmask8, __m128, __m128); 
#line 2832
extern __m128 __cdecl _mm_mask3_fmsub_ps(__m128, __m128, __m128, __mmask8); 
#line 2833
extern __m128 __cdecl _mm_maskz_fmsub_ps(__mmask8, __m128, __m128, __m128); 
#line 2834
extern __m256 __cdecl _mm256_mask_fmsub_ps(__m256, __mmask8, __m256, __m256); 
#line 2835
extern __m256 __cdecl _mm256_mask3_fmsub_ps(__m256, __m256, __m256, __mmask8); 
#line 2836
extern __m256 __cdecl _mm256_maskz_fmsub_ps(__mmask8, __m256, __m256, __m256); 
#line 2837
extern __m128d __cdecl _mm_mask_fmsubadd_pd(__m128d, __mmask8, __m128d, __m128d); 
#line 2838
extern __m128d __cdecl _mm_mask3_fmsubadd_pd(__m128d, __m128d, __m128d, __mmask8); 
#line 2839
extern __m128d __cdecl _mm_maskz_fmsubadd_pd(__mmask8, __m128d, __m128d, __m128d); 
#line 2840
extern __m256d __cdecl _mm256_mask_fmsubadd_pd(__m256d, __mmask8, __m256d, __m256d); 
#line 2841
extern __m256d __cdecl _mm256_mask3_fmsubadd_pd(__m256d, __m256d, __m256d, __mmask8); 
#line 2842
extern __m256d __cdecl _mm256_maskz_fmsubadd_pd(__mmask8, __m256d, __m256d, __m256d); 
#line 2843
extern __m128 __cdecl _mm_mask_fmsubadd_ps(__m128, __mmask8, __m128, __m128); 
#line 2844
extern __m128 __cdecl _mm_mask3_fmsubadd_ps(__m128, __m128, __m128, __mmask8); 
#line 2845
extern __m128 __cdecl _mm_maskz_fmsubadd_ps(__mmask8, __m128, __m128, __m128); 
#line 2846
extern __m256 __cdecl _mm256_mask_fmsubadd_ps(__m256, __mmask8, __m256, __m256); 
#line 2847
extern __m256 __cdecl _mm256_mask3_fmsubadd_ps(__m256, __m256, __m256, __mmask8); 
#line 2848
extern __m256 __cdecl _mm256_maskz_fmsubadd_ps(__mmask8, __m256, __m256, __m256); 
#line 2849
extern __m128d __cdecl _mm_mask_fnmadd_pd(__m128d, __mmask8, __m128d, __m128d); 
#line 2850
extern __m128d __cdecl _mm_mask3_fnmadd_pd(__m128d, __m128d, __m128d, __mmask8); 
#line 2851
extern __m128d __cdecl _mm_maskz_fnmadd_pd(__mmask8, __m128d, __m128d, __m128d); 
#line 2852
extern __m256d __cdecl _mm256_mask_fnmadd_pd(__m256d, __mmask8, __m256d, __m256d); 
#line 2853
extern __m256d __cdecl _mm256_mask3_fnmadd_pd(__m256d, __m256d, __m256d, __mmask8); 
#line 2854
extern __m256d __cdecl _mm256_maskz_fnmadd_pd(__mmask8, __m256d, __m256d, __m256d); 
#line 2855
extern __m128 __cdecl _mm_mask_fnmadd_ps(__m128, __mmask8, __m128, __m128); 
#line 2856
extern __m128 __cdecl _mm_mask3_fnmadd_ps(__m128, __m128, __m128, __mmask8); 
#line 2857
extern __m128 __cdecl _mm_maskz_fnmadd_ps(__mmask8, __m128, __m128, __m128); 
#line 2858
extern __m256 __cdecl _mm256_mask_fnmadd_ps(__m256, __mmask8, __m256, __m256); 
#line 2859
extern __m256 __cdecl _mm256_mask3_fnmadd_ps(__m256, __m256, __m256, __mmask8); 
#line 2860
extern __m256 __cdecl _mm256_maskz_fnmadd_ps(__mmask8, __m256, __m256, __m256); 
#line 2861
extern __m128d __cdecl _mm_mask_fnmsub_pd(__m128d, __mmask8, __m128d, __m128d); 
#line 2862
extern __m128d __cdecl _mm_mask3_fnmsub_pd(__m128d, __m128d, __m128d, __mmask8); 
#line 2863
extern __m128d __cdecl _mm_maskz_fnmsub_pd(__mmask8, __m128d, __m128d, __m128d); 
#line 2864
extern __m256d __cdecl _mm256_mask_fnmsub_pd(__m256d, __mmask8, __m256d, __m256d); 
#line 2865
extern __m256d __cdecl _mm256_mask3_fnmsub_pd(__m256d, __m256d, __m256d, __mmask8); 
#line 2866
extern __m256d __cdecl _mm256_maskz_fnmsub_pd(__mmask8, __m256d, __m256d, __m256d); 
#line 2867
extern __m128 __cdecl _mm_mask_fnmsub_ps(__m128, __mmask8, __m128, __m128); 
#line 2868
extern __m128 __cdecl _mm_mask3_fnmsub_ps(__m128, __m128, __m128, __mmask8); 
#line 2869
extern __m128 __cdecl _mm_maskz_fnmsub_ps(__mmask8, __m128, __m128, __m128); 
#line 2870
extern __m256 __cdecl _mm256_mask_fnmsub_ps(__m256, __mmask8, __m256, __m256); 
#line 2871
extern __m256 __cdecl _mm256_mask3_fnmsub_ps(__m256, __m256, __m256, __mmask8); 
#line 2872
extern __m256 __cdecl _mm256_maskz_fnmsub_ps(__mmask8, __m256, __m256, __m256); 
#line 2873
extern __mmask8 __cdecl _mm_fpclass_pd_mask(__m128d, int); 
#line 2874
extern __mmask8 __cdecl _mm_mask_fpclass_pd_mask(__mmask8, __m128d, int); 
#line 2875
extern __mmask8 __cdecl _mm256_fpclass_pd_mask(__m256d, int); 
#line 2876
extern __mmask8 __cdecl _mm256_mask_fpclass_pd_mask(__mmask8, __m256d, int); 
#line 2877
extern __mmask8 __cdecl _mm_fpclass_ps_mask(__m128, int); 
#line 2878
extern __mmask8 __cdecl _mm_mask_fpclass_ps_mask(__mmask8, __m128, int); 
#line 2879
extern __mmask8 __cdecl _mm256_fpclass_ps_mask(__m256, int); 
#line 2880
extern __mmask8 __cdecl _mm256_mask_fpclass_ps_mask(__mmask8, __m256, int); 
#line 2881
extern __m128d __cdecl _mm_getexp_pd(__m128d); 
#line 2882
extern __m128d __cdecl _mm_mask_getexp_pd(__m128d, __mmask8, __m128d); 
#line 2883
extern __m128d __cdecl _mm_maskz_getexp_pd(__mmask8, __m128d); 
#line 2884
extern __m256d __cdecl _mm256_getexp_pd(__m256d); 
#line 2885
extern __m256d __cdecl _mm256_mask_getexp_pd(__m256d, __mmask8, __m256d); 
#line 2886
extern __m256d __cdecl _mm256_maskz_getexp_pd(__mmask8, __m256d); 
#line 2887
extern __m128 __cdecl _mm_getexp_ps(__m128); 
#line 2888
extern __m128 __cdecl _mm_mask_getexp_ps(__m128, __mmask8, __m128); 
#line 2889
extern __m128 __cdecl _mm_maskz_getexp_ps(__mmask8, __m128); 
#line 2890
extern __m256 __cdecl _mm256_getexp_ps(__m256); 
#line 2891
extern __m256 __cdecl _mm256_mask_getexp_ps(__m256, __mmask8, __m256); 
#line 2892
extern __m256 __cdecl _mm256_maskz_getexp_ps(__mmask8, __m256); 
#line 2893
extern __m128d __cdecl _mm_getmant_pd(__m128d, int, int); 
#line 2894
extern __m128d __cdecl _mm_mask_getmant_pd(__m128d, __mmask8, __m128d, int, int); 
#line 2895
extern __m128d __cdecl _mm_maskz_getmant_pd(__mmask8, __m128d, int, int); 
#line 2896
extern __m256d __cdecl _mm256_getmant_pd(__m256d, int, int); 
#line 2897
extern __m256d __cdecl _mm256_mask_getmant_pd(__m256d, __mmask8, __m256d, int, int); 
#line 2898
extern __m256d __cdecl _mm256_maskz_getmant_pd(__mmask8, __m256d, int, int); 
#line 2899
extern __m128 __cdecl _mm_getmant_ps(__m128, int, int); 
#line 2900
extern __m128 __cdecl _mm_mask_getmant_ps(__m128, __mmask8, __m128, int, int); 
#line 2901
extern __m128 __cdecl _mm_maskz_getmant_ps(__mmask8, __m128, int, int); 
#line 2902
extern __m256 __cdecl _mm256_getmant_ps(__m256, int, int); 
#line 2903
extern __m256 __cdecl _mm256_mask_getmant_ps(__m256, __mmask8, __m256, int, int); 
#line 2904
extern __m256 __cdecl _mm256_maskz_getmant_ps(__mmask8, __m256, int, int); 
#line 2905
extern __m128i __cdecl _mm_mmask_i32gather_epi32(__m128i, __mmask8, __m128i, const void *, const int); 
#line 2906
extern __m256i __cdecl _mm256_mmask_i32gather_epi32(__m256i, __mmask8, __m256i, const void *, const int); 
#line 2907
extern __m128i __cdecl _mm_mmask_i32gather_epi64(__m128i, __mmask8, __m128i, const void *, const int); 
#line 2908
extern __m256i __cdecl _mm256_mmask_i32gather_epi64(__m256i, __mmask8, __m128i, const void *, const int); 
#line 2909
extern __m128d __cdecl _mm_mmask_i32gather_pd(__m128d, __mmask8, __m128i, const void *, const int); 
#line 2910
extern __m256d __cdecl _mm256_mmask_i32gather_pd(__m256d, __mmask8, __m128i, const void *, const int); 
#line 2911
extern __m128 __cdecl _mm_mmask_i32gather_ps(__m128, __mmask8, __m128i, const void *, const int); 
#line 2912
extern __m256 __cdecl _mm256_mmask_i32gather_ps(__m256, __mmask8, __m256i, const void *, const int); 
#line 2913
extern void __cdecl _mm_i32scatter_epi32(void *, __m128i, __m128i, const int); 
#line 2914
extern void __cdecl _mm_mask_i32scatter_epi32(void *, __mmask8, __m128i, __m128i, const int); 
#line 2915
extern void __cdecl _mm256_i32scatter_epi32(void *, __m256i, __m256i, const int); 
#line 2916
extern void __cdecl _mm256_mask_i32scatter_epi32(void *, __mmask8, __m256i, __m256i, const int); 
#line 2917
extern void __cdecl _mm_i32scatter_epi64(void *, __m128i, __m128i, const int); 
#line 2918
extern void __cdecl _mm_mask_i32scatter_epi64(void *, __mmask8, __m128i, __m128i, const int); 
#line 2919
extern void __cdecl _mm256_i32scatter_epi64(void *, __m128i, __m256i, const int); 
#line 2920
extern void __cdecl _mm256_mask_i32scatter_epi64(void *, __mmask8, __m128i, __m256i, const int); 
#line 2921
extern void __cdecl _mm_i32scatter_pd(void *, __m128i, __m128d, const int); 
#line 2922
extern void __cdecl _mm_mask_i32scatter_pd(void *, __mmask8, __m128i, __m128d, const int); 
#line 2923
extern void __cdecl _mm256_i32scatter_pd(void *, __m128i, __m256d, const int); 
#line 2924
extern void __cdecl _mm256_mask_i32scatter_pd(void *, __mmask8, __m128i, __m256d, const int); 
#line 2925
extern void __cdecl _mm_i32scatter_ps(void *, __m128i, __m128, const int); 
#line 2926
extern void __cdecl _mm_mask_i32scatter_ps(void *, __mmask8, __m128i, __m128, const int); 
#line 2927
extern void __cdecl _mm256_i32scatter_ps(void *, __m256i, __m256, const int); 
#line 2928
extern void __cdecl _mm256_mask_i32scatter_ps(void *, __mmask8, __m256i, __m256, const int); 
#line 2929
extern __m128i __cdecl _mm_mmask_i64gather_epi32(__m128i, __mmask8, __m128i, const void *, const int); 
#line 2930
extern __m128i __cdecl _mm256_mmask_i64gather_epi32(__m128i, __mmask8, __m256i, const void *, const int); 
#line 2931
extern __m128i __cdecl _mm_mmask_i64gather_epi64(__m128i, __mmask8, __m128i, const void *, const int); 
#line 2932
extern __m256i __cdecl _mm256_mmask_i64gather_epi64(__m256i, __mmask8, __m256i, const void *, const int); 
#line 2933
extern __m128d __cdecl _mm_mmask_i64gather_pd(__m128d, __mmask8, __m128i, const void *, const int); 
#line 2934
extern __m256d __cdecl _mm256_mmask_i64gather_pd(__m256d, __mmask8, __m256i, const void *, const int); 
#line 2935
extern __m128 __cdecl _mm_mmask_i64gather_ps(__m128, __mmask8, __m128i, const void *, const int); 
#line 2936
extern __m128 __cdecl _mm256_mmask_i64gather_ps(__m128, __mmask8, __m256i, const void *, const int); 
#line 2937
extern void __cdecl _mm_i64scatter_epi32(void *, __m128i, __m128i, const int); 
#line 2938
extern void __cdecl _mm_mask_i64scatter_epi32(void *, __mmask8, __m128i, __m128i, const int); 
#line 2939
extern void __cdecl _mm256_i64scatter_epi32(void *, __m256i, __m128i, const int); 
#line 2940
extern void __cdecl _mm256_mask_i64scatter_epi32(void *, __mmask8, __m256i, __m128i, const int); 
#line 2941
extern void __cdecl _mm_i64scatter_epi64(void *, __m128i, __m128i, const int); 
#line 2942
extern void __cdecl _mm_mask_i64scatter_epi64(void *, __mmask8, __m128i, __m128i, const int); 
#line 2943
extern void __cdecl _mm256_i64scatter_epi64(void *, __m256i, __m256i, const int); 
#line 2944
extern void __cdecl _mm256_mask_i64scatter_epi64(void *, __mmask8, __m256i, __m256i, const int); 
#line 2945
extern void __cdecl _mm_i64scatter_pd(void *, __m128i, __m128d, const int); 
#line 2946
extern void __cdecl _mm_mask_i64scatter_pd(void *, __mmask8, __m128i, __m128d, const int); 
#line 2947
extern void __cdecl _mm256_i64scatter_pd(void *, __m256i, __m256d, const int); 
#line 2948
extern void __cdecl _mm256_mask_i64scatter_pd(void *, __mmask8, __m256i, __m256d, const int); 
#line 2949
extern void __cdecl _mm_i64scatter_ps(void *, __m128i, __m128, const int); 
#line 2950
extern void __cdecl _mm_mask_i64scatter_ps(void *, __mmask8, __m128i, __m128, const int); 
#line 2951
extern void __cdecl _mm256_i64scatter_ps(void *, __m256i, __m128, const int); 
#line 2952
extern void __cdecl _mm256_mask_i64scatter_ps(void *, __mmask8, __m256i, __m128, const int); 
#line 2953
extern __m256 __cdecl _mm256_insertf32x4(__m256, __m128, int); 
#line 2954
extern __m256 __cdecl _mm256_mask_insertf32x4(__m256, __mmask8, __m256, __m128, int); 
#line 2955
extern __m256 __cdecl _mm256_maskz_insertf32x4(__mmask8, __m256, __m128, int); 
#line 2956
extern __m256d __cdecl _mm256_insertf64x2(__m256d, __m128d, int); 
#line 2957
extern __m256d __cdecl _mm256_mask_insertf64x2(__m256d, __mmask8, __m256d, __m128d, int); 
#line 2958
extern __m256d __cdecl _mm256_maskz_insertf64x2(__mmask8, __m256d, __m128d, int); 
#line 2959
extern __m256i __cdecl _mm256_inserti32x4(__m256i, __m128i, int); 
#line 2960
extern __m256i __cdecl _mm256_mask_inserti32x4(__m256i, __mmask8, __m256i, __m128i, int); 
#line 2961
extern __m256i __cdecl _mm256_maskz_inserti32x4(__mmask8, __m256i, __m128i, int); 
#line 2962
extern __m256i __cdecl _mm256_inserti64x2(__m256i, __m128i, int); 
#line 2963
extern __m256i __cdecl _mm256_mask_inserti64x2(__m256i, __mmask8, __m256i, __m128i, int); 
#line 2964
extern __m256i __cdecl _mm256_maskz_inserti64x2(__mmask8, __m256i, __m128i, int); 
#line 2965
extern __m128i __cdecl _mm_mask_load_epi32(__m128i, __mmask8, const void *); 
#line 2966
extern __m128i __cdecl _mm_maskz_load_epi32(__mmask8, const void *); 
#line 2967
extern __m256i __cdecl _mm256_mask_load_epi32(__m256i, __mmask8, const void *); 
#line 2968
extern __m256i __cdecl _mm256_maskz_load_epi32(__mmask8, const void *); 
#line 2969
extern __m128i __cdecl _mm_mask_load_epi64(__m128i, __mmask8, const void *); 
#line 2970
extern __m128i __cdecl _mm_maskz_load_epi64(__mmask8, const void *); 
#line 2971
extern __m256i __cdecl _mm256_mask_load_epi64(__m256i, __mmask8, const void *); 
#line 2972
extern __m256i __cdecl _mm256_maskz_load_epi64(__mmask8, const void *); 
#line 2973
extern __m128d __cdecl _mm_mask_load_pd(__m128d, __mmask8, const void *); 
#line 2974
extern __m128d __cdecl _mm_maskz_load_pd(__mmask8, const void *); 
#line 2975
extern __m256d __cdecl _mm256_mask_load_pd(__m256d, __mmask8, const void *); 
#line 2976
extern __m256d __cdecl _mm256_maskz_load_pd(__mmask8, const void *); 
#line 2977
extern __m128 __cdecl _mm_mask_load_ps(__m128, __mmask8, const void *); 
#line 2978
extern __m128 __cdecl _mm_maskz_load_ps(__mmask8, const void *); 
#line 2979
extern __m256 __cdecl _mm256_mask_load_ps(__m256, __mmask8, const void *); 
#line 2980
extern __m256 __cdecl _mm256_maskz_load_ps(__mmask8, const void *); 
#line 2981
extern __m128i __cdecl _mm_loadu_epi16(const void *); 
#line 2982
extern __m128i __cdecl _mm_mask_loadu_epi16(__m128i, __mmask8, const void *); 
#line 2983
extern __m128i __cdecl _mm_maskz_loadu_epi16(__mmask8, const void *); 
#line 2984
extern __m256i __cdecl _mm256_loadu_epi16(const void *); 
#line 2985
extern __m256i __cdecl _mm256_mask_loadu_epi16(__m256i, __mmask16, const void *); 
#line 2986
extern __m256i __cdecl _mm256_maskz_loadu_epi16(__mmask16, const void *); 
#line 2987
extern __m128i __cdecl _mm_loadu_epi32(const void *); 
#line 2988
extern __m128i __cdecl _mm_mask_loadu_epi32(__m128i, __mmask8, const void *); 
#line 2989
extern __m128i __cdecl _mm_maskz_loadu_epi32(__mmask8, const void *); 
#line 2990
extern __m256i __cdecl _mm256_loadu_epi32(const void *); 
#line 2991
extern __m256i __cdecl _mm256_mask_loadu_epi32(__m256i, __mmask8, const void *); 
#line 2992
extern __m256i __cdecl _mm256_maskz_loadu_epi32(__mmask8, const void *); 
#line 2993
extern __m128i __cdecl _mm_loadu_epi64(const void *); 
#line 2994
extern __m128i __cdecl _mm_mask_loadu_epi64(__m128i, __mmask8, const void *); 
#line 2995
extern __m128i __cdecl _mm_maskz_loadu_epi64(__mmask8, const void *); 
#line 2996
extern __m256i __cdecl _mm256_loadu_epi64(const void *); 
#line 2997
extern __m256i __cdecl _mm256_mask_loadu_epi64(__m256i, __mmask8, const void *); 
#line 2998
extern __m256i __cdecl _mm256_maskz_loadu_epi64(__mmask8, const void *); 
#line 2999
extern __m128i __cdecl _mm_loadu_epi8(const void *); 
#line 3000
extern __m128i __cdecl _mm_mask_loadu_epi8(__m128i, __mmask16, const void *); 
#line 3001
extern __m128i __cdecl _mm_maskz_loadu_epi8(__mmask16, const void *); 
#line 3002
extern __m256i __cdecl _mm256_loadu_epi8(const void *); 
#line 3003
extern __m256i __cdecl _mm256_mask_loadu_epi8(__m256i, __mmask32, const void *); 
#line 3004
extern __m256i __cdecl _mm256_maskz_loadu_epi8(__mmask32, const void *); 
#line 3005
extern __m128d __cdecl _mm_mask_loadu_pd(__m128d, __mmask8, const void *); 
#line 3006
extern __m128d __cdecl _mm_maskz_loadu_pd(__mmask8, const void *); 
#line 3007
extern __m256d __cdecl _mm256_mask_loadu_pd(__m256d, __mmask8, const void *); 
#line 3008
extern __m256d __cdecl _mm256_maskz_loadu_pd(__mmask8, const void *); 
#line 3009
extern __m128 __cdecl _mm_mask_loadu_ps(__m128, __mmask8, const void *); 
#line 3010
extern __m128 __cdecl _mm_maskz_loadu_ps(__mmask8, const void *); 
#line 3011
extern __m256 __cdecl _mm256_mask_loadu_ps(__m256, __mmask8, const void *); 
#line 3012
extern __m256 __cdecl _mm256_maskz_loadu_ps(__mmask8, const void *); 
#line 3013
extern __m128i __cdecl _mm_lzcnt_epi32(__m128i); 
#line 3014
extern __m128i __cdecl _mm_mask_lzcnt_epi32(__m128i, __mmask8, __m128i); 
#line 3015
extern __m128i __cdecl _mm_maskz_lzcnt_epi32(__mmask8, __m128i); 
#line 3016
extern __m256i __cdecl _mm256_lzcnt_epi32(__m256i); 
#line 3017
extern __m256i __cdecl _mm256_mask_lzcnt_epi32(__m256i, __mmask8, __m256i); 
#line 3018
extern __m256i __cdecl _mm256_maskz_lzcnt_epi32(__mmask8, __m256i); 
#line 3019
extern __m128i __cdecl _mm_lzcnt_epi64(__m128i); 
#line 3020
extern __m128i __cdecl _mm_mask_lzcnt_epi64(__m128i, __mmask8, __m128i); 
#line 3021
extern __m128i __cdecl _mm_maskz_lzcnt_epi64(__mmask8, __m128i); 
#line 3022
extern __m256i __cdecl _mm256_lzcnt_epi64(__m256i); 
#line 3023
extern __m256i __cdecl _mm256_mask_lzcnt_epi64(__m256i, __mmask8, __m256i); 
#line 3024
extern __m256i __cdecl _mm256_maskz_lzcnt_epi64(__mmask8, __m256i); 
#line 3025
extern __m128i __cdecl _mm_mask_madd_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 3026
extern __m128i __cdecl _mm_maskz_madd_epi16(__mmask8, __m128i, __m128i); 
#line 3027
extern __m256i __cdecl _mm256_mask_madd_epi16(__m256i, __mmask8, __m256i, __m256i); 
#line 3028
extern __m256i __cdecl _mm256_maskz_madd_epi16(__mmask8, __m256i, __m256i); 
#line 3029
extern __m128i __cdecl _mm_mask_maddubs_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 3030
extern __m128i __cdecl _mm_maskz_maddubs_epi16(__mmask8, __m128i, __m128i); 
#line 3031
extern __m256i __cdecl _mm256_mask_maddubs_epi16(__m256i, __mmask16, __m256i, __m256i); 
#line 3032
extern __m256i __cdecl _mm256_maskz_maddubs_epi16(__mmask16, __m256i, __m256i); 
#line 3033
extern __m128i __cdecl _mm_mask_max_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 3034
extern __m128i __cdecl _mm_maskz_max_epi16(__mmask8, __m128i, __m128i); 
#line 3035
extern __m256i __cdecl _mm256_mask_max_epi16(__m256i, __mmask16, __m256i, __m256i); 
#line 3036
extern __m256i __cdecl _mm256_maskz_max_epi16(__mmask16, __m256i, __m256i); 
#line 3037
extern __m128i __cdecl _mm_mask_max_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 3038
extern __m128i __cdecl _mm_maskz_max_epi32(__mmask8, __m128i, __m128i); 
#line 3039
extern __m256i __cdecl _mm256_mask_max_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 3040
extern __m256i __cdecl _mm256_maskz_max_epi32(__mmask8, __m256i, __m256i); 
#line 3041
extern __m128i __cdecl _mm_mask_max_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 3042
extern __m128i __cdecl _mm_maskz_max_epi64(__mmask8, __m128i, __m128i); 
#line 3043
extern __m128i __cdecl _mm_max_epi64(__m128i, __m128i); 
#line 3044
extern __m256i __cdecl _mm256_mask_max_epi64(__m256i, __mmask8, __m256i, __m256i); 
#line 3045
extern __m256i __cdecl _mm256_maskz_max_epi64(__mmask8, __m256i, __m256i); 
#line 3046
extern __m256i __cdecl _mm256_max_epi64(__m256i, __m256i); 
#line 3047
extern __m128i __cdecl _mm_mask_max_epi8(__m128i, __mmask16, __m128i, __m128i); 
#line 3048
extern __m128i __cdecl _mm_maskz_max_epi8(__mmask16, __m128i, __m128i); 
#line 3049
extern __m256i __cdecl _mm256_mask_max_epi8(__m256i, __mmask32, __m256i, __m256i); 
#line 3050
extern __m256i __cdecl _mm256_maskz_max_epi8(__mmask32, __m256i, __m256i); 
#line 3051
extern __m128i __cdecl _mm_mask_max_epu16(__m128i, __mmask8, __m128i, __m128i); 
#line 3052
extern __m128i __cdecl _mm_maskz_max_epu16(__mmask8, __m128i, __m128i); 
#line 3053
extern __m256i __cdecl _mm256_mask_max_epu16(__m256i, __mmask16, __m256i, __m256i); 
#line 3054
extern __m256i __cdecl _mm256_maskz_max_epu16(__mmask16, __m256i, __m256i); 
#line 3055
extern __m128i __cdecl _mm_mask_max_epu32(__m128i, __mmask8, __m128i, __m128i); 
#line 3056
extern __m128i __cdecl _mm_maskz_max_epu32(__mmask8, __m128i, __m128i); 
#line 3057
extern __m256i __cdecl _mm256_mask_max_epu32(__m256i, __mmask8, __m256i, __m256i); 
#line 3058
extern __m256i __cdecl _mm256_maskz_max_epu32(__mmask8, __m256i, __m256i); 
#line 3059
extern __m128i __cdecl _mm_mask_max_epu64(__m128i, __mmask8, __m128i, __m128i); 
#line 3060
extern __m128i __cdecl _mm_maskz_max_epu64(__mmask8, __m128i, __m128i); 
#line 3061
extern __m128i __cdecl _mm_max_epu64(__m128i, __m128i); 
#line 3062
extern __m256i __cdecl _mm256_mask_max_epu64(__m256i, __mmask8, __m256i, __m256i); 
#line 3063
extern __m256i __cdecl _mm256_maskz_max_epu64(__mmask8, __m256i, __m256i); 
#line 3064
extern __m256i __cdecl _mm256_max_epu64(__m256i, __m256i); 
#line 3065
extern __m128i __cdecl _mm_mask_max_epu8(__m128i, __mmask16, __m128i, __m128i); 
#line 3066
extern __m128i __cdecl _mm_maskz_max_epu8(__mmask16, __m128i, __m128i); 
#line 3067
extern __m256i __cdecl _mm256_mask_max_epu8(__m256i, __mmask32, __m256i, __m256i); 
#line 3068
extern __m256i __cdecl _mm256_maskz_max_epu8(__mmask32, __m256i, __m256i); 
#line 3069
extern __m128d __cdecl _mm_mask_max_pd(__m128d, __mmask8, __m128d, __m128d); 
#line 3070
extern __m128d __cdecl _mm_maskz_max_pd(__mmask8, __m128d, __m128d); 
#line 3071
extern __m256d __cdecl _mm256_mask_max_pd(__m256d, __mmask8, __m256d, __m256d); 
#line 3072
extern __m256d __cdecl _mm256_maskz_max_pd(__mmask8, __m256d, __m256d); 
#line 3073
extern __m128 __cdecl _mm_mask_max_ps(__m128, __mmask8, __m128, __m128); 
#line 3074
extern __m128 __cdecl _mm_maskz_max_ps(__mmask8, __m128, __m128); 
#line 3075
extern __m256 __cdecl _mm256_mask_max_ps(__m256, __mmask8, __m256, __m256); 
#line 3076
extern __m256 __cdecl _mm256_maskz_max_ps(__mmask8, __m256, __m256); 
#line 3077
extern __m128i __cdecl _mm_mask_min_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 3078
extern __m128i __cdecl _mm_maskz_min_epi16(__mmask8, __m128i, __m128i); 
#line 3079
extern __m256i __cdecl _mm256_mask_min_epi16(__m256i, __mmask16, __m256i, __m256i); 
#line 3080
extern __m256i __cdecl _mm256_maskz_min_epi16(__mmask16, __m256i, __m256i); 
#line 3081
extern __m128i __cdecl _mm_mask_min_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 3082
extern __m128i __cdecl _mm_maskz_min_epi32(__mmask8, __m128i, __m128i); 
#line 3083
extern __m256i __cdecl _mm256_mask_min_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 3084
extern __m256i __cdecl _mm256_maskz_min_epi32(__mmask8, __m256i, __m256i); 
#line 3085
extern __m128i __cdecl _mm_mask_min_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 3086
extern __m128i __cdecl _mm_maskz_min_epi64(__mmask8, __m128i, __m128i); 
#line 3087
extern __m128i __cdecl _mm_min_epi64(__m128i, __m128i); 
#line 3088
extern __m256i __cdecl _mm256_mask_min_epi64(__m256i, __mmask8, __m256i, __m256i); 
#line 3089
extern __m256i __cdecl _mm256_maskz_min_epi64(__mmask8, __m256i, __m256i); 
#line 3090
extern __m256i __cdecl _mm256_min_epi64(__m256i, __m256i); 
#line 3091
extern __m128i __cdecl _mm_mask_min_epi8(__m128i, __mmask16, __m128i, __m128i); 
#line 3092
extern __m128i __cdecl _mm_maskz_min_epi8(__mmask16, __m128i, __m128i); 
#line 3093
extern __m256i __cdecl _mm256_mask_min_epi8(__m256i, __mmask32, __m256i, __m256i); 
#line 3094
extern __m256i __cdecl _mm256_maskz_min_epi8(__mmask32, __m256i, __m256i); 
#line 3095
extern __m128i __cdecl _mm_mask_min_epu16(__m128i, __mmask8, __m128i, __m128i); 
#line 3096
extern __m128i __cdecl _mm_maskz_min_epu16(__mmask8, __m128i, __m128i); 
#line 3097
extern __m256i __cdecl _mm256_mask_min_epu16(__m256i, __mmask16, __m256i, __m256i); 
#line 3098
extern __m256i __cdecl _mm256_maskz_min_epu16(__mmask16, __m256i, __m256i); 
#line 3099
extern __m128i __cdecl _mm_mask_min_epu32(__m128i, __mmask8, __m128i, __m128i); 
#line 3100
extern __m128i __cdecl _mm_maskz_min_epu32(__mmask8, __m128i, __m128i); 
#line 3101
extern __m256i __cdecl _mm256_mask_min_epu32(__m256i, __mmask8, __m256i, __m256i); 
#line 3102
extern __m256i __cdecl _mm256_maskz_min_epu32(__mmask8, __m256i, __m256i); 
#line 3103
extern __m128i __cdecl _mm_mask_min_epu64(__m128i, __mmask8, __m128i, __m128i); 
#line 3104
extern __m128i __cdecl _mm_maskz_min_epu64(__mmask8, __m128i, __m128i); 
#line 3105
extern __m128i __cdecl _mm_min_epu64(__m128i, __m128i); 
#line 3106
extern __m256i __cdecl _mm256_mask_min_epu64(__m256i, __mmask8, __m256i, __m256i); 
#line 3107
extern __m256i __cdecl _mm256_maskz_min_epu64(__mmask8, __m256i, __m256i); 
#line 3108
extern __m256i __cdecl _mm256_min_epu64(__m256i, __m256i); 
#line 3109
extern __m128i __cdecl _mm_mask_min_epu8(__m128i, __mmask16, __m128i, __m128i); 
#line 3110
extern __m128i __cdecl _mm_maskz_min_epu8(__mmask16, __m128i, __m128i); 
#line 3111
extern __m256i __cdecl _mm256_mask_min_epu8(__m256i, __mmask32, __m256i, __m256i); 
#line 3112
extern __m256i __cdecl _mm256_maskz_min_epu8(__mmask32, __m256i, __m256i); 
#line 3113
extern __m128d __cdecl _mm_mask_min_pd(__m128d, __mmask8, __m128d, __m128d); 
#line 3114
extern __m128d __cdecl _mm_maskz_min_pd(__mmask8, __m128d, __m128d); 
#line 3115
extern __m256d __cdecl _mm256_mask_min_pd(__m256d, __mmask8, __m256d, __m256d); 
#line 3116
extern __m256d __cdecl _mm256_maskz_min_pd(__mmask8, __m256d, __m256d); 
#line 3117
extern __m128 __cdecl _mm_mask_min_ps(__m128, __mmask8, __m128, __m128); 
#line 3118
extern __m128 __cdecl _mm_maskz_min_ps(__mmask8, __m128, __m128); 
#line 3119
extern __m256 __cdecl _mm256_mask_min_ps(__m256, __mmask8, __m256, __m256); 
#line 3120
extern __m256 __cdecl _mm256_maskz_min_ps(__mmask8, __m256, __m256); 
#line 3121
extern __m128i __cdecl _mm_mask_mov_epi16(__m128i, __mmask8, __m128i); 
#line 3122
extern __m128i __cdecl _mm_maskz_mov_epi16(__mmask8, __m128i); 
#line 3123
extern __m256i __cdecl _mm256_mask_mov_epi16(__m256i, __mmask16, __m256i); 
#line 3124
extern __m256i __cdecl _mm256_maskz_mov_epi16(__mmask16, __m256i); 
#line 3125
extern __m128i __cdecl _mm_mask_mov_epi32(__m128i, __mmask8, __m128i); 
#line 3126
extern __m128i __cdecl _mm_maskz_mov_epi32(__mmask8, __m128i); 
#line 3127
extern __m256i __cdecl _mm256_mask_mov_epi32(__m256i, __mmask8, __m256i); 
#line 3128
extern __m256i __cdecl _mm256_maskz_mov_epi32(__mmask8, __m256i); 
#line 3129
extern __m128i __cdecl _mm_mask_mov_epi64(__m128i, __mmask8, __m128i); 
#line 3130
extern __m128i __cdecl _mm_maskz_mov_epi64(__mmask8, __m128i); 
#line 3131
extern __m256i __cdecl _mm256_mask_mov_epi64(__m256i, __mmask8, __m256i); 
#line 3132
extern __m256i __cdecl _mm256_maskz_mov_epi64(__mmask8, __m256i); 
#line 3133
extern __m128i __cdecl _mm_mask_mov_epi8(__m128i, __mmask16, __m128i); 
#line 3134
extern __m128i __cdecl _mm_maskz_mov_epi8(__mmask16, __m128i); 
#line 3135
extern __m256i __cdecl _mm256_mask_mov_epi8(__m256i, __mmask32, __m256i); 
#line 3136
extern __m256i __cdecl _mm256_maskz_mov_epi8(__mmask32, __m256i); 
#line 3137
extern __m128d __cdecl _mm_mask_mov_pd(__m128d, __mmask8, __m128d); 
#line 3138
extern __m128d __cdecl _mm_maskz_mov_pd(__mmask8, __m128d); 
#line 3139
extern __m256d __cdecl _mm256_mask_mov_pd(__m256d, __mmask8, __m256d); 
#line 3140
extern __m256d __cdecl _mm256_maskz_mov_pd(__mmask8, __m256d); 
#line 3141
extern __m128 __cdecl _mm_mask_mov_ps(__m128, __mmask8, __m128); 
#line 3142
extern __m128 __cdecl _mm_maskz_mov_ps(__mmask8, __m128); 
#line 3143
extern __m256 __cdecl _mm256_mask_mov_ps(__m256, __mmask8, __m256); 
#line 3144
extern __m256 __cdecl _mm256_maskz_mov_ps(__mmask8, __m256); 
#line 3145
extern __m128d __cdecl _mm_mask_movedup_pd(__m128d, __mmask8, __m128d); 
#line 3146
extern __m128d __cdecl _mm_maskz_movedup_pd(__mmask8, __m128d); 
#line 3147
extern __m256d __cdecl _mm256_mask_movedup_pd(__m256d, __mmask8, __m256d); 
#line 3148
extern __m256d __cdecl _mm256_maskz_movedup_pd(__mmask8, __m256d); 
#line 3149
extern __m128 __cdecl _mm_mask_movehdup_ps(__m128, __mmask8, __m128); 
#line 3150
extern __m128 __cdecl _mm_maskz_movehdup_ps(__mmask8, __m128); 
#line 3151
extern __m256 __cdecl _mm256_mask_movehdup_ps(__m256, __mmask8, __m256); 
#line 3152
extern __m256 __cdecl _mm256_maskz_movehdup_ps(__mmask8, __m256); 
#line 3153
extern __m128 __cdecl _mm_mask_moveldup_ps(__m128, __mmask8, __m128); 
#line 3154
extern __m128 __cdecl _mm_maskz_moveldup_ps(__mmask8, __m128); 
#line 3155
extern __m256 __cdecl _mm256_mask_moveldup_ps(__m256, __mmask8, __m256); 
#line 3156
extern __m256 __cdecl _mm256_maskz_moveldup_ps(__mmask8, __m256); 
#line 3157
extern __mmask8 __cdecl _mm_movepi16_mask(__m128i); 
#line 3158
extern __mmask16 __cdecl _mm256_movepi16_mask(__m256i); 
#line 3159
extern __mmask8 __cdecl _mm_movepi32_mask(__m128i); 
#line 3160
extern __mmask8 __cdecl _mm256_movepi32_mask(__m256i); 
#line 3161
extern __mmask8 __cdecl _mm_movepi64_mask(__m128i); 
#line 3162
extern __mmask8 __cdecl _mm256_movepi64_mask(__m256i); 
#line 3163
extern __mmask16 __cdecl _mm_movepi8_mask(__m128i); 
#line 3164
extern __mmask32 __cdecl _mm256_movepi8_mask(__m256i); 
#line 3165
extern __m128i __cdecl _mm_movm_epi16(__mmask8); 
#line 3166
extern __m256i __cdecl _mm256_movm_epi16(__mmask16); 
#line 3167
extern __m128i __cdecl _mm_movm_epi32(__mmask8); 
#line 3168
extern __m256i __cdecl _mm256_movm_epi32(__mmask8); 
#line 3169
extern __m128i __cdecl _mm_movm_epi64(__mmask8); 
#line 3170
extern __m256i __cdecl _mm256_movm_epi64(__mmask8); 
#line 3171
extern __m128i __cdecl _mm_movm_epi8(__mmask16); 
#line 3172
extern __m256i __cdecl _mm256_movm_epi8(__mmask32); 
#line 3173
extern __m128i __cdecl _mm_mask_mul_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 3174
extern __m128i __cdecl _mm_maskz_mul_epi32(__mmask8, __m128i, __m128i); 
#line 3175
extern __m256i __cdecl _mm256_mask_mul_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 3176
extern __m256i __cdecl _mm256_maskz_mul_epi32(__mmask8, __m256i, __m256i); 
#line 3177
extern __m128i __cdecl _mm_mask_mul_epu32(__m128i, __mmask8, __m128i, __m128i); 
#line 3178
extern __m128i __cdecl _mm_maskz_mul_epu32(__mmask8, __m128i, __m128i); 
#line 3179
extern __m256i __cdecl _mm256_mask_mul_epu32(__m256i, __mmask8, __m256i, __m256i); 
#line 3180
extern __m256i __cdecl _mm256_maskz_mul_epu32(__mmask8, __m256i, __m256i); 
#line 3181
extern __m128d __cdecl _mm_mask_mul_pd(__m128d, __mmask8, __m128d, __m128d); 
#line 3182
extern __m128d __cdecl _mm_maskz_mul_pd(__mmask8, __m128d, __m128d); 
#line 3183
extern __m256d __cdecl _mm256_mask_mul_pd(__m256d, __mmask8, __m256d, __m256d); 
#line 3184
extern __m256d __cdecl _mm256_maskz_mul_pd(__mmask8, __m256d, __m256d); 
#line 3185
extern __m128 __cdecl _mm_mask_mul_ps(__m128, __mmask8, __m128, __m128); 
#line 3186
extern __m128 __cdecl _mm_maskz_mul_ps(__mmask8, __m128, __m128); 
#line 3187
extern __m256 __cdecl _mm256_mask_mul_ps(__m256, __mmask8, __m256, __m256); 
#line 3188
extern __m256 __cdecl _mm256_maskz_mul_ps(__mmask8, __m256, __m256); 
#line 3189
extern __m128i __cdecl _mm_mask_mulhi_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 3190
extern __m128i __cdecl _mm_maskz_mulhi_epi16(__mmask8, __m128i, __m128i); 
#line 3191
extern __m256i __cdecl _mm256_mask_mulhi_epi16(__m256i, __mmask16, __m256i, __m256i); 
#line 3192
extern __m256i __cdecl _mm256_maskz_mulhi_epi16(__mmask16, __m256i, __m256i); 
#line 3193
extern __m128i __cdecl _mm_mask_mulhi_epu16(__m128i, __mmask8, __m128i, __m128i); 
#line 3194
extern __m128i __cdecl _mm_maskz_mulhi_epu16(__mmask8, __m128i, __m128i); 
#line 3195
extern __m256i __cdecl _mm256_mask_mulhi_epu16(__m256i, __mmask16, __m256i, __m256i); 
#line 3196
extern __m256i __cdecl _mm256_maskz_mulhi_epu16(__mmask16, __m256i, __m256i); 
#line 3197
extern __m128i __cdecl _mm_mask_mulhrs_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 3198
extern __m128i __cdecl _mm_maskz_mulhrs_epi16(__mmask8, __m128i, __m128i); 
#line 3199
extern __m256i __cdecl _mm256_mask_mulhrs_epi16(__m256i, __mmask16, __m256i, __m256i); 
#line 3200
extern __m256i __cdecl _mm256_maskz_mulhrs_epi16(__mmask16, __m256i, __m256i); 
#line 3201
extern __m128i __cdecl _mm_mask_mullo_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 3202
extern __m128i __cdecl _mm_maskz_mullo_epi16(__mmask8, __m128i, __m128i); 
#line 3203
extern __m256i __cdecl _mm256_mask_mullo_epi16(__m256i, __mmask16, __m256i, __m256i); 
#line 3204
extern __m256i __cdecl _mm256_maskz_mullo_epi16(__mmask16, __m256i, __m256i); 
#line 3205
extern __m128i __cdecl _mm_mask_mullo_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 3206
extern __m128i __cdecl _mm_maskz_mullo_epi32(__mmask8, __m128i, __m128i); 
#line 3207
extern __m256i __cdecl _mm256_mask_mullo_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 3208
extern __m256i __cdecl _mm256_maskz_mullo_epi32(__mmask8, __m256i, __m256i); 
#line 3209
extern __m128i __cdecl _mm_mask_mullo_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 3210
extern __m128i __cdecl _mm_maskz_mullo_epi64(__mmask8, __m128i, __m128i); 
#line 3211
extern __m128i __cdecl _mm_mullo_epi64(__m128i, __m128i); 
#line 3212
extern __m256i __cdecl _mm256_mask_mullo_epi64(__m256i, __mmask8, __m256i, __m256i); 
#line 3213
extern __m256i __cdecl _mm256_maskz_mullo_epi64(__mmask8, __m256i, __m256i); 
#line 3214
extern __m256i __cdecl _mm256_mullo_epi64(__m256i, __m256i); 
#line 3215
extern __m128i __cdecl _mm_or_epi32(__m128i, __m128i); 
#line 3216
extern __m128i __cdecl _mm_mask_or_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 3217
extern __m128i __cdecl _mm_maskz_or_epi32(__mmask8, __m128i, __m128i); 
#line 3218
extern __m256i __cdecl _mm256_or_epi32(__m256i, __m256i); 
#line 3219
extern __m256i __cdecl _mm256_mask_or_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 3220
extern __m256i __cdecl _mm256_maskz_or_epi32(__mmask8, __m256i, __m256i); 
#line 3221
extern __m128i __cdecl _mm_or_epi64(__m128i, __m128i); 
#line 3222
extern __m128i __cdecl _mm_mask_or_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 3223
extern __m128i __cdecl _mm_maskz_or_epi64(__mmask8, __m128i, __m128i); 
#line 3224
extern __m256i __cdecl _mm256_or_epi64(__m256i, __m256i); 
#line 3225
extern __m256i __cdecl _mm256_mask_or_epi64(__m256i, __mmask8, __m256i, __m256i); 
#line 3226
extern __m256i __cdecl _mm256_maskz_or_epi64(__mmask8, __m256i, __m256i); 
#line 3227
extern __m128d __cdecl _mm_mask_or_pd(__m128d, __mmask8, __m128d, __m128d); 
#line 3228
extern __m128d __cdecl _mm_maskz_or_pd(__mmask8, __m128d, __m128d); 
#line 3229
extern __m256d __cdecl _mm256_mask_or_pd(__m256d, __mmask8, __m256d, __m256d); 
#line 3230
extern __m256d __cdecl _mm256_maskz_or_pd(__mmask8, __m256d, __m256d); 
#line 3231
extern __m128 __cdecl _mm_mask_or_ps(__m128, __mmask8, __m128, __m128); 
#line 3232
extern __m128 __cdecl _mm_maskz_or_ps(__mmask8, __m128, __m128); 
#line 3233
extern __m256 __cdecl _mm256_mask_or_ps(__m256, __mmask8, __m256, __m256); 
#line 3234
extern __m256 __cdecl _mm256_maskz_or_ps(__mmask8, __m256, __m256); 
#line 3235
extern __m128i __cdecl _mm_mask_packs_epi16(__m128i, __mmask16, __m128i, __m128i); 
#line 3236
extern __m128i __cdecl _mm_maskz_packs_epi16(__mmask16, __m128i, __m128i); 
#line 3237
extern __m256i __cdecl _mm256_mask_packs_epi16(__m256i, __mmask32, __m256i, __m256i); 
#line 3238
extern __m256i __cdecl _mm256_maskz_packs_epi16(__mmask32, __m256i, __m256i); 
#line 3239
extern __m128i __cdecl _mm_mask_packs_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 3240
extern __m128i __cdecl _mm_maskz_packs_epi32(__mmask8, __m128i, __m128i); 
#line 3241
extern __m256i __cdecl _mm256_mask_packs_epi32(__m256i, __mmask16, __m256i, __m256i); 
#line 3242
extern __m256i __cdecl _mm256_maskz_packs_epi32(__mmask16, __m256i, __m256i); 
#line 3243
extern __m128i __cdecl _mm_mask_packus_epi16(__m128i, __mmask16, __m128i, __m128i); 
#line 3244
extern __m128i __cdecl _mm_maskz_packus_epi16(__mmask16, __m128i, __m128i); 
#line 3245
extern __m256i __cdecl _mm256_mask_packus_epi16(__m256i, __mmask32, __m256i, __m256i); 
#line 3246
extern __m256i __cdecl _mm256_maskz_packus_epi16(__mmask32, __m256i, __m256i); 
#line 3247
extern __m128i __cdecl _mm_mask_packus_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 3248
extern __m128i __cdecl _mm_maskz_packus_epi32(__mmask8, __m128i, __m128i); 
#line 3249
extern __m256i __cdecl _mm256_mask_packus_epi32(__m256i, __mmask16, __m256i, __m256i); 
#line 3250
extern __m256i __cdecl _mm256_maskz_packus_epi32(__mmask16, __m256i, __m256i); 
#line 3251
extern __m128d __cdecl _mm_mask_permute_pd(__m128d, __mmask8, __m128d, const int); 
#line 3252
extern __m128d __cdecl _mm_maskz_permute_pd(__mmask8, __m128d, const int); 
#line 3253
extern __m256d __cdecl _mm256_mask_permute_pd(__m256d, __mmask8, __m256d, const int); 
#line 3254
extern __m256d __cdecl _mm256_maskz_permute_pd(__mmask8, __m256d, const int); 
#line 3255
extern __m128 __cdecl _mm_mask_permute_ps(__m128, __mmask8, __m128, const int); 
#line 3256
extern __m128 __cdecl _mm_maskz_permute_ps(__mmask8, __m128, const int); 
#line 3257
extern __m256 __cdecl _mm256_mask_permute_ps(__m256, __mmask8, __m256, const int); 
#line 3258
extern __m256 __cdecl _mm256_maskz_permute_ps(__mmask8, __m256, const int); 
#line 3259
extern __m128d __cdecl _mm_mask_permutevar_pd(__m128d, __mmask8, __m128d, __m128i); 
#line 3260
extern __m128d __cdecl _mm_maskz_permutevar_pd(__mmask8, __m128d, __m128i); 
#line 3261
extern __m256d __cdecl _mm256_mask_permutevar_pd(__m256d, __mmask8, __m256d, __m256i); 
#line 3262
extern __m256d __cdecl _mm256_maskz_permutevar_pd(__mmask8, __m256d, __m256i); 
#line 3263
extern __m128 __cdecl _mm_mask_permutevar_ps(__m128, __mmask8, __m128, __m128i); 
#line 3264
extern __m128 __cdecl _mm_maskz_permutevar_ps(__mmask8, __m128, __m128i); 
#line 3265
extern __m256 __cdecl _mm256_mask_permutevar_ps(__m256, __mmask8, __m256, __m256i); 
#line 3266
extern __m256 __cdecl _mm256_maskz_permutevar_ps(__mmask8, __m256, __m256i); 
#line 3267
extern __m256i __cdecl _mm256_mask_permutex_epi64(__m256i, __mmask8, __m256i, const int); 
#line 3268
extern __m256i __cdecl _mm256_maskz_permutex_epi64(__mmask8, __m256i, const int); 
#line 3269
extern __m256i __cdecl _mm256_permutex_epi64(__m256i, const int); 
#line 3270
extern __m256d __cdecl _mm256_mask_permutex_pd(__m256d, __mmask8, __m256d, const int); 
#line 3271
extern __m256d __cdecl _mm256_maskz_permutex_pd(__mmask8, __m256d, const int); 
#line 3272
extern __m256d __cdecl _mm256_permutex_pd(__m256d, const int); 
#line 3273
extern __m128i __cdecl _mm_mask_permutex2var_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 3274
extern __m128i __cdecl _mm_mask2_permutex2var_epi16(__m128i, __m128i, __mmask8, __m128i); 
#line 3275
extern __m128i __cdecl _mm_maskz_permutex2var_epi16(__mmask8, __m128i, __m128i, __m128i); 
#line 3276
extern __m128i __cdecl _mm_permutex2var_epi16(__m128i, __m128i, __m128i); 
#line 3277
extern __m256i __cdecl _mm256_mask_permutex2var_epi16(__m256i, __mmask16, __m256i, __m256i); 
#line 3278
extern __m256i __cdecl _mm256_mask2_permutex2var_epi16(__m256i, __m256i, __mmask16, __m256i); 
#line 3279
extern __m256i __cdecl _mm256_maskz_permutex2var_epi16(__mmask16, __m256i, __m256i, __m256i); 
#line 3280
extern __m256i __cdecl _mm256_permutex2var_epi16(__m256i, __m256i, __m256i); 
#line 3281
extern __m128i __cdecl _mm_mask_permutex2var_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 3282
extern __m128i __cdecl _mm_mask2_permutex2var_epi32(__m128i, __m128i, __mmask8, __m128i); 
#line 3283
extern __m128i __cdecl _mm_maskz_permutex2var_epi32(__mmask8, __m128i, __m128i, __m128i); 
#line 3284
extern __m128i __cdecl _mm_permutex2var_epi32(__m128i, __m128i, __m128i); 
#line 3285
extern __m256i __cdecl _mm256_mask_permutex2var_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 3286
extern __m256i __cdecl _mm256_mask2_permutex2var_epi32(__m256i, __m256i, __mmask8, __m256i); 
#line 3287
extern __m256i __cdecl _mm256_maskz_permutex2var_epi32(__mmask8, __m256i, __m256i, __m256i); 
#line 3288
extern __m256i __cdecl _mm256_permutex2var_epi32(__m256i, __m256i, __m256i); 
#line 3289
extern __m128i __cdecl _mm_mask_permutex2var_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 3290
extern __m128i __cdecl _mm_mask2_permutex2var_epi64(__m128i, __m128i, __mmask8, __m128i); 
#line 3291
extern __m128i __cdecl _mm_maskz_permutex2var_epi64(__mmask8, __m128i, __m128i, __m128i); 
#line 3292
extern __m128i __cdecl _mm_permutex2var_epi64(__m128i, __m128i, __m128i); 
#line 3293
extern __m256i __cdecl _mm256_mask_permutex2var_epi64(__m256i, __mmask8, __m256i, __m256i); 
#line 3294
extern __m256i __cdecl _mm256_mask2_permutex2var_epi64(__m256i, __m256i, __mmask8, __m256i); 
#line 3295
extern __m256i __cdecl _mm256_maskz_permutex2var_epi64(__mmask8, __m256i, __m256i, __m256i); 
#line 3296
extern __m256i __cdecl _mm256_permutex2var_epi64(__m256i, __m256i, __m256i); 
#line 3297
extern __m128d __cdecl _mm_mask_permutex2var_pd(__m128d, __mmask8, __m128i, __m128d); 
#line 3298
extern __m128d __cdecl _mm_mask2_permutex2var_pd(__m128d, __m128i, __mmask8, __m128d); 
#line 3299
extern __m128d __cdecl _mm_maskz_permutex2var_pd(__mmask8, __m128d, __m128i, __m128d); 
#line 3300
extern __m128d __cdecl _mm_permutex2var_pd(__m128d, __m128i, __m128d); 
#line 3301
extern __m256d __cdecl _mm256_mask_permutex2var_pd(__m256d, __mmask8, __m256i, __m256d); 
#line 3302
extern __m256d __cdecl _mm256_mask2_permutex2var_pd(__m256d, __m256i, __mmask8, __m256d); 
#line 3303
extern __m256d __cdecl _mm256_maskz_permutex2var_pd(__mmask8, __m256d, __m256i, __m256d); 
#line 3304
extern __m256d __cdecl _mm256_permutex2var_pd(__m256d, __m256i, __m256d); 
#line 3305
extern __m128 __cdecl _mm_mask_permutex2var_ps(__m128, __mmask8, __m128i, __m128); 
#line 3306
extern __m128 __cdecl _mm_mask2_permutex2var_ps(__m128, __m128i, __mmask8, __m128); 
#line 3307
extern __m128 __cdecl _mm_maskz_permutex2var_ps(__mmask8, __m128, __m128i, __m128); 
#line 3308
extern __m128 __cdecl _mm_permutex2var_ps(__m128, __m128i, __m128); 
#line 3309
extern __m256 __cdecl _mm256_mask_permutex2var_ps(__m256, __mmask8, __m256i, __m256); 
#line 3310
extern __m256 __cdecl _mm256_mask2_permutex2var_ps(__m256, __m256i, __mmask8, __m256); 
#line 3311
extern __m256 __cdecl _mm256_maskz_permutex2var_ps(__mmask8, __m256, __m256i, __m256); 
#line 3312
extern __m256 __cdecl _mm256_permutex2var_ps(__m256, __m256i, __m256); 
#line 3313
extern __m128i __cdecl _mm_mask_permutexvar_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 3314
extern __m128i __cdecl _mm_maskz_permutexvar_epi16(__mmask8, __m128i, __m128i); 
#line 3315
extern __m128i __cdecl _mm_permutexvar_epi16(__m128i, __m128i); 
#line 3316
extern __m256i __cdecl _mm256_mask_permutexvar_epi16(__m256i, __mmask16, __m256i, __m256i); 
#line 3317
extern __m256i __cdecl _mm256_maskz_permutexvar_epi16(__mmask16, __m256i, __m256i); 
#line 3318
extern __m256i __cdecl _mm256_permutexvar_epi16(__m256i, __m256i); 
#line 3319
extern __m256i __cdecl _mm256_mask_permutexvar_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 3320
extern __m256i __cdecl _mm256_maskz_permutexvar_epi32(__mmask8, __m256i, __m256i); 
#line 3321
extern __m256i __cdecl _mm256_permutexvar_epi32(__m256i, __m256i); 
#line 3322
extern __m256i __cdecl _mm256_mask_permutexvar_epi64(__m256i, __mmask8, __m256i, __m256i); 
#line 3323
extern __m256i __cdecl _mm256_maskz_permutexvar_epi64(__mmask8, __m256i, __m256i); 
#line 3324
extern __m256i __cdecl _mm256_permutexvar_epi64(__m256i, __m256i); 
#line 3325
extern __m256d __cdecl _mm256_mask_permutexvar_pd(__m256d, __mmask8, __m256i, __m256d); 
#line 3326
extern __m256d __cdecl _mm256_maskz_permutexvar_pd(__mmask8, __m256i, __m256d); 
#line 3327
extern __m256d __cdecl _mm256_permutexvar_pd(__m256i, __m256d); 
#line 3328
extern __m256 __cdecl _mm256_mask_permutexvar_ps(__m256, __mmask8, __m256i, __m256); 
#line 3329
extern __m256 __cdecl _mm256_maskz_permutexvar_ps(__mmask8, __m256i, __m256); 
#line 3330
extern __m256 __cdecl _mm256_permutexvar_ps(__m256i, __m256); 
#line 3331
extern __m128d __cdecl _mm_mask_range_pd(__m128d, __mmask8, __m128d, __m128d, int); 
#line 3332
extern __m128d __cdecl _mm_maskz_range_pd(__mmask8, __m128d, __m128d, int); 
#line 3333
extern __m128d __cdecl _mm_range_pd(__m128d, __m128d, int); 
#line 3334
extern __m256d __cdecl _mm256_mask_range_pd(__m256d, __mmask8, __m256d, __m256d, int); 
#line 3335
extern __m256d __cdecl _mm256_maskz_range_pd(__mmask8, __m256d, __m256d, int); 
#line 3336
extern __m256d __cdecl _mm256_range_pd(__m256d, __m256d, int); 
#line 3337
extern __m128 __cdecl _mm_mask_range_ps(__m128, __mmask8, __m128, __m128, int); 
#line 3338
extern __m128 __cdecl _mm_maskz_range_ps(__mmask8, __m128, __m128, int); 
#line 3339
extern __m128 __cdecl _mm_range_ps(__m128, __m128, int); 
#line 3340
extern __m256 __cdecl _mm256_mask_range_ps(__m256, __mmask8, __m256, __m256, int); 
#line 3341
extern __m256 __cdecl _mm256_maskz_range_ps(__mmask8, __m256, __m256, int); 
#line 3342
extern __m256 __cdecl _mm256_range_ps(__m256, __m256, int); 
#line 3343
extern __m128d __cdecl _mm_mask_rcp14_pd(__m128d, __mmask8, __m128d); 
#line 3344
extern __m128d __cdecl _mm_maskz_rcp14_pd(__mmask8, __m128d); 
#line 3345
extern __m128d __cdecl _mm_rcp14_pd(__m128d); 
#line 3346
extern __m256d __cdecl _mm256_mask_rcp14_pd(__m256d, __mmask8, __m256d); 
#line 3347
extern __m256d __cdecl _mm256_maskz_rcp14_pd(__mmask8, __m256d); 
#line 3348
extern __m256d __cdecl _mm256_rcp14_pd(__m256d); 
#line 3349
extern __m128 __cdecl _mm_mask_rcp14_ps(__m128, __mmask8, __m128); 
#line 3350
extern __m128 __cdecl _mm_maskz_rcp14_ps(__mmask8, __m128); 
#line 3351
extern __m128 __cdecl _mm_rcp14_ps(__m128); 
#line 3352
extern __m256 __cdecl _mm256_mask_rcp14_ps(__m256, __mmask8, __m256); 
#line 3353
extern __m256 __cdecl _mm256_maskz_rcp14_ps(__mmask8, __m256); 
#line 3354
extern __m256 __cdecl _mm256_rcp14_ps(__m256); 
#line 3355
extern __m128d __cdecl _mm_mask_reduce_pd(__m128d, __mmask8, __m128d, int); 
#line 3356
extern __m128d __cdecl _mm_maskz_reduce_pd(__mmask8, __m128d, int); 
#line 3357
extern __m128d __cdecl _mm_reduce_pd(__m128d, int); 
#line 3358
extern __m256d __cdecl _mm256_mask_reduce_pd(__m256d, __mmask8, __m256d, int); 
#line 3359
extern __m256d __cdecl _mm256_maskz_reduce_pd(__mmask8, __m256d, int); 
#line 3360
extern __m256d __cdecl _mm256_reduce_pd(__m256d, int); 
#line 3361
extern __m128 __cdecl _mm_mask_reduce_ps(__m128, __mmask8, __m128, int); 
#line 3362
extern __m128 __cdecl _mm_maskz_reduce_ps(__mmask8, __m128, int); 
#line 3363
extern __m128 __cdecl _mm_reduce_ps(__m128, int); 
#line 3364
extern __m256 __cdecl _mm256_mask_reduce_ps(__m256, __mmask8, __m256, int); 
#line 3365
extern __m256 __cdecl _mm256_maskz_reduce_ps(__mmask8, __m256, int); 
#line 3366
extern __m256 __cdecl _mm256_reduce_ps(__m256, int); 
#line 3367
extern __m128i __cdecl _mm_mask_rol_epi32(__m128i, __mmask8, __m128i, const int); 
#line 3368
extern __m128i __cdecl _mm_maskz_rol_epi32(__mmask8, __m128i, const int); 
#line 3369
extern __m128i __cdecl _mm_rol_epi32(__m128i, int); 
#line 3370
extern __m256i __cdecl _mm256_mask_rol_epi32(__m256i, __mmask8, __m256i, const int); 
#line 3371
extern __m256i __cdecl _mm256_maskz_rol_epi32(__mmask8, __m256i, const int); 
#line 3372
extern __m256i __cdecl _mm256_rol_epi32(__m256i, const int); 
#line 3373
extern __m128i __cdecl _mm_mask_rol_epi64(__m128i, __mmask8, __m128i, const int); 
#line 3374
extern __m128i __cdecl _mm_maskz_rol_epi64(__mmask8, __m128i, const int); 
#line 3375
extern __m128i __cdecl _mm_rol_epi64(__m128i, const int); 
#line 3376
extern __m256i __cdecl _mm256_mask_rol_epi64(__m256i, __mmask8, __m256i, const int); 
#line 3377
extern __m256i __cdecl _mm256_maskz_rol_epi64(__mmask8, __m256i, const int); 
#line 3378
extern __m256i __cdecl _mm256_rol_epi64(__m256i, const int); 
#line 3379
extern __m128i __cdecl _mm_mask_rolv_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 3380
extern __m128i __cdecl _mm_maskz_rolv_epi32(__mmask8, __m128i, __m128i); 
#line 3381
extern __m128i __cdecl _mm_rolv_epi32(__m128i, __m128i); 
#line 3382
extern __m256i __cdecl _mm256_mask_rolv_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 3383
extern __m256i __cdecl _mm256_maskz_rolv_epi32(__mmask8, __m256i, __m256i); 
#line 3384
extern __m256i __cdecl _mm256_rolv_epi32(__m256i, __m256i); 
#line 3385
extern __m128i __cdecl _mm_mask_rolv_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 3386
extern __m128i __cdecl _mm_maskz_rolv_epi64(__mmask8, __m128i, __m128i); 
#line 3387
extern __m128i __cdecl _mm_rolv_epi64(__m128i, __m128i); 
#line 3388
extern __m256i __cdecl _mm256_mask_rolv_epi64(__m256i, __mmask8, __m256i, __m256i); 
#line 3389
extern __m256i __cdecl _mm256_maskz_rolv_epi64(__mmask8, __m256i, __m256i); 
#line 3390
extern __m256i __cdecl _mm256_rolv_epi64(__m256i, __m256i); 
#line 3391
extern __m128i __cdecl _mm_mask_ror_epi32(__m128i, __mmask8, __m128i, const int); 
#line 3392
extern __m128i __cdecl _mm_maskz_ror_epi32(__mmask8, __m128i, const int); 
#line 3393
extern __m128i __cdecl _mm_ror_epi32(__m128i, const int); 
#line 3394
extern __m256i __cdecl _mm256_mask_ror_epi32(__m256i, __mmask8, __m256i, const int); 
#line 3395
extern __m256i __cdecl _mm256_maskz_ror_epi32(__mmask8, __m256i, const int); 
#line 3396
extern __m256i __cdecl _mm256_ror_epi32(__m256i, const int); 
#line 3397
extern __m128i __cdecl _mm_mask_ror_epi64(__m128i, __mmask8, __m128i, const int); 
#line 3398
extern __m128i __cdecl _mm_maskz_ror_epi64(__mmask8, __m128i, const int); 
#line 3399
extern __m128i __cdecl _mm_ror_epi64(__m128i, const int); 
#line 3400
extern __m256i __cdecl _mm256_mask_ror_epi64(__m256i, __mmask8, __m256i, const int); 
#line 3401
extern __m256i __cdecl _mm256_maskz_ror_epi64(__mmask8, __m256i, const int); 
#line 3402
extern __m256i __cdecl _mm256_ror_epi64(__m256i, const int); 
#line 3403
extern __m128i __cdecl _mm_mask_rorv_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 3404
extern __m128i __cdecl _mm_maskz_rorv_epi32(__mmask8, __m128i, __m128i); 
#line 3405
extern __m128i __cdecl _mm_rorv_epi32(__m128i, __m128i); 
#line 3406
extern __m256i __cdecl _mm256_mask_rorv_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 3407
extern __m256i __cdecl _mm256_maskz_rorv_epi32(__mmask8, __m256i, __m256i); 
#line 3408
extern __m256i __cdecl _mm256_rorv_epi32(__m256i, __m256i); 
#line 3409
extern __m128i __cdecl _mm_mask_rorv_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 3410
extern __m128i __cdecl _mm_maskz_rorv_epi64(__mmask8, __m128i, __m128i); 
#line 3411
extern __m128i __cdecl _mm_rorv_epi64(__m128i, __m128i); 
#line 3412
extern __m256i __cdecl _mm256_mask_rorv_epi64(__m256i, __mmask8, __m256i, __m256i); 
#line 3413
extern __m256i __cdecl _mm256_maskz_rorv_epi64(__mmask8, __m256i, __m256i); 
#line 3414
extern __m256i __cdecl _mm256_rorv_epi64(__m256i, __m256i); 
#line 3415
extern __m128d __cdecl _mm_mask_roundscale_pd(__m128d, __mmask8, __m128d, int); 
#line 3416
extern __m128d __cdecl _mm_maskz_roundscale_pd(__mmask8, __m128d, int); 
#line 3417
extern __m128d __cdecl _mm_roundscale_pd(__m128d, int); 
#line 3418
extern __m256d __cdecl _mm256_mask_roundscale_pd(__m256d, __mmask8, __m256d, int); 
#line 3419
extern __m256d __cdecl _mm256_maskz_roundscale_pd(__mmask8, __m256d, int); 
#line 3420
extern __m256d __cdecl _mm256_roundscale_pd(__m256d, int); 
#line 3421
extern __m128 __cdecl _mm_mask_roundscale_ps(__m128, __mmask8, __m128, int); 
#line 3422
extern __m128 __cdecl _mm_maskz_roundscale_ps(__mmask8, __m128, int); 
#line 3423
extern __m128 __cdecl _mm_roundscale_ps(__m128, int); 
#line 3424
extern __m256 __cdecl _mm256_mask_roundscale_ps(__m256, __mmask8, __m256, int); 
#line 3425
extern __m256 __cdecl _mm256_maskz_roundscale_ps(__mmask8, __m256, int); 
#line 3426
extern __m256 __cdecl _mm256_roundscale_ps(__m256, int); 
#line 3427
extern __m128d __cdecl _mm_mask_rsqrt14_pd(__m128d, __mmask8, __m128d); 
#line 3428
extern __m128d __cdecl _mm_maskz_rsqrt14_pd(__mmask8, __m128d); 
#line 3429
extern __m256d __cdecl _mm256_mask_rsqrt14_pd(__m256d, __mmask8, __m256d); 
#line 3430
extern __m256d __cdecl _mm256_maskz_rsqrt14_pd(__mmask8, __m256d); 
#line 3431
extern __m128 __cdecl _mm_mask_rsqrt14_ps(__m128, __mmask8, __m128); 
#line 3432
extern __m128 __cdecl _mm_maskz_rsqrt14_ps(__mmask8, __m128); 
#line 3433
extern __m256 __cdecl _mm256_mask_rsqrt14_ps(__m256, __mmask8, __m256); 
#line 3434
extern __m256 __cdecl _mm256_maskz_rsqrt14_ps(__mmask8, __m256); 
#line 3435
extern __m128d __cdecl _mm_mask_scalef_pd(__m128d, __mmask8, __m128d, __m128d); 
#line 3436
extern __m128d __cdecl _mm_maskz_scalef_pd(__mmask8, __m128d, __m128d); 
#line 3437
extern __m128d __cdecl _mm_scalef_pd(__m128d, __m128d); 
#line 3438
extern __m256d __cdecl _mm256_mask_scalef_pd(__m256d, __mmask8, __m256d, __m256d); 
#line 3439
extern __m256d __cdecl _mm256_maskz_scalef_pd(__mmask8, __m256d, __m256d); 
#line 3440
extern __m256d __cdecl _mm256_scalef_pd(__m256d, __m256d); 
#line 3441
extern __m128 __cdecl _mm_mask_scalef_ps(__m128, __mmask8, __m128, __m128); 
#line 3442
extern __m128 __cdecl _mm_maskz_scalef_ps(__mmask8, __m128, __m128); 
#line 3443
extern __m128 __cdecl _mm_scalef_ps(__m128, __m128); 
#line 3444
extern __m256 __cdecl _mm256_mask_scalef_ps(__m256, __mmask8, __m256, __m256); 
#line 3445
extern __m256 __cdecl _mm256_maskz_scalef_ps(__mmask8, __m256, __m256); 
#line 3446
extern __m256 __cdecl _mm256_scalef_ps(__m256, __m256); 
#line 3447
extern __m128i __cdecl _mm_mask_set1_epi16(__m128i, __mmask8, short); 
#line 3448
extern __m128i __cdecl _mm_maskz_set1_epi16(__mmask8, short); 
#line 3449
extern __m256i __cdecl _mm256_mask_set1_epi16(__m256i, __mmask16, short); 
#line 3450
extern __m256i __cdecl _mm256_maskz_set1_epi16(__mmask16, short); 
#line 3451
extern __m128i __cdecl _mm_mask_set1_epi32(__m128i, __mmask8, int); 
#line 3452
extern __m128i __cdecl _mm_maskz_set1_epi32(__mmask8, int); 
#line 3453
extern __m256i __cdecl _mm256_mask_set1_epi32(__m256i, __mmask8, int); 
#line 3454
extern __m256i __cdecl _mm256_maskz_set1_epi32(__mmask8, int); 
#line 3455
extern __m128i __cdecl _mm_mask_set1_epi64(__m128i, __mmask8, __int64); 
#line 3456
extern __m128i __cdecl _mm_maskz_set1_epi64(__mmask8, __int64); 
#line 3457
extern __m256i __cdecl _mm256_mask_set1_epi64(__m256i, __mmask8, __int64); 
#line 3458
extern __m256i __cdecl _mm256_maskz_set1_epi64(__mmask8, __int64); 
#line 3459
extern __m128i __cdecl _mm_mask_set1_epi8(__m128i, __mmask16, char); 
#line 3460
extern __m128i __cdecl _mm_maskz_set1_epi8(__mmask16, char); 
#line 3461
extern __m256i __cdecl _mm256_mask_set1_epi8(__m256i, __mmask32, char); 
#line 3462
extern __m256i __cdecl _mm256_maskz_set1_epi8(__mmask32, char); 
#line 3463
extern __m128i __cdecl _mm_mask_shuffle_epi32(__m128i, __mmask8, __m128i, int); 
#line 3464
extern __m128i __cdecl _mm_maskz_shuffle_epi32(__mmask8, __m128i, int); 
#line 3465
extern __m256i __cdecl _mm256_mask_shuffle_epi32(__m256i, __mmask8, __m256i, int); 
#line 3466
extern __m256i __cdecl _mm256_maskz_shuffle_epi32(__mmask8, __m256i, int); 
#line 3467
extern __m128i __cdecl _mm_mask_shuffle_epi8(__m128i, __mmask16, __m128i, __m128i); 
#line 3468
extern __m128i __cdecl _mm_maskz_shuffle_epi8(__mmask16, __m128i, __m128i); 
#line 3469
extern __m256i __cdecl _mm256_mask_shuffle_epi8(__m256i, __mmask32, __m256i, __m256i); 
#line 3470
extern __m256i __cdecl _mm256_maskz_shuffle_epi8(__mmask32, __m256i, __m256i); 
#line 3471
extern __m256 __cdecl _mm256_mask_shuffle_f32x4(__m256, __mmask8, __m256, __m256, const int); 
#line 3472
extern __m256 __cdecl _mm256_maskz_shuffle_f32x4(__mmask8, __m256, __m256, const int); 
#line 3473
extern __m256 __cdecl _mm256_shuffle_f32x4(__m256, __m256, const int); 
#line 3474
extern __m256d __cdecl _mm256_mask_shuffle_f64x2(__m256d, __mmask8, __m256d, __m256d, const int); 
#line 3475
extern __m256d __cdecl _mm256_maskz_shuffle_f64x2(__mmask8, __m256d, __m256d, const int); 
#line 3476
extern __m256d __cdecl _mm256_shuffle_f64x2(__m256d, __m256d, const int); 
#line 3477
extern __m256i __cdecl _mm256_mask_shuffle_i32x4(__m256i, __mmask8, __m256i, __m256i, const int); 
#line 3478
extern __m256i __cdecl _mm256_maskz_shuffle_i32x4(__mmask8, __m256i, __m256i, const int); 
#line 3479
extern __m256i __cdecl _mm256_shuffle_i32x4(__m256i, __m256i, const int); 
#line 3480
extern __m256i __cdecl _mm256_mask_shuffle_i64x2(__m256i, __mmask8, __m256i, __m256i, const int); 
#line 3481
extern __m256i __cdecl _mm256_maskz_shuffle_i64x2(__mmask8, __m256i, __m256i, const int); 
#line 3482
extern __m256i __cdecl _mm256_shuffle_i64x2(__m256i, __m256i, const int); 
#line 3483
extern __m128d __cdecl _mm_mask_shuffle_pd(__m128d, __mmask8, __m128d, __m128d, const int); 
#line 3484
extern __m128d __cdecl _mm_maskz_shuffle_pd(__mmask8, __m128d, __m128d, const int); 
#line 3485
extern __m256d __cdecl _mm256_mask_shuffle_pd(__m256d, __mmask8, __m256d, __m256d, const int); 
#line 3486
extern __m256d __cdecl _mm256_maskz_shuffle_pd(__mmask8, __m256d, __m256d, const int); 
#line 3487
extern __m128 __cdecl _mm_mask_shuffle_ps(__m128, __mmask8, __m128, __m128, const int); 
#line 3488
extern __m128 __cdecl _mm_maskz_shuffle_ps(__mmask8, __m128, __m128, const int); 
#line 3489
extern __m256 __cdecl _mm256_mask_shuffle_ps(__m256, __mmask8, __m256, __m256, const int); 
#line 3490
extern __m256 __cdecl _mm256_maskz_shuffle_ps(__mmask8, __m256, __m256, const int); 
#line 3491
extern __m128i __cdecl _mm_mask_shufflehi_epi16(__m128i, __mmask8, __m128i, int); 
#line 3492
extern __m128i __cdecl _mm_maskz_shufflehi_epi16(__mmask8, __m128i, int); 
#line 3493
extern __m256i __cdecl _mm256_mask_shufflehi_epi16(__m256i, __mmask16, __m256i, int); 
#line 3494
extern __m256i __cdecl _mm256_maskz_shufflehi_epi16(__mmask16, __m256i, int); 
#line 3495
extern __m128i __cdecl _mm_mask_shufflelo_epi16(__m128i, __mmask8, __m128i, int); 
#line 3496
extern __m128i __cdecl _mm_maskz_shufflelo_epi16(__mmask8, __m128i, int); 
#line 3497
extern __m256i __cdecl _mm256_mask_shufflelo_epi16(__m256i, __mmask16, __m256i, int); 
#line 3498
extern __m256i __cdecl _mm256_maskz_shufflelo_epi16(__mmask16, __m256i, int); 
#line 3499
extern __m128i __cdecl _mm_mask_sll_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 3500
extern __m128i __cdecl _mm_maskz_sll_epi16(__mmask8, __m128i, __m128i); 
#line 3501
extern __m256i __cdecl _mm256_mask_sll_epi16(__m256i, __mmask16, __m256i, __m128i); 
#line 3502
extern __m256i __cdecl _mm256_maskz_sll_epi16(__mmask16, __m256i, __m128i); 
#line 3503
extern __m128i __cdecl _mm_mask_sll_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 3504
extern __m128i __cdecl _mm_maskz_sll_epi32(__mmask8, __m128i, __m128i); 
#line 3505
extern __m256i __cdecl _mm256_mask_sll_epi32(__m256i, __mmask8, __m256i, __m128i); 
#line 3506
extern __m256i __cdecl _mm256_maskz_sll_epi32(__mmask8, __m256i, __m128i); 
#line 3507
extern __m128i __cdecl _mm_mask_sll_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 3508
extern __m128i __cdecl _mm_maskz_sll_epi64(__mmask8, __m128i, __m128i); 
#line 3509
extern __m256i __cdecl _mm256_mask_sll_epi64(__m256i, __mmask8, __m256i, __m128i); 
#line 3510
extern __m256i __cdecl _mm256_maskz_sll_epi64(__mmask8, __m256i, __m128i); 
#line 3511
extern __m128i __cdecl _mm_mask_slli_epi16(__m128i, __mmask8, __m128i, unsigned); 
#line 3512
extern __m128i __cdecl _mm_maskz_slli_epi16(__mmask8, __m128i, unsigned); 
#line 3513
extern __m256i __cdecl _mm256_mask_slli_epi16(__m256i, __mmask16, __m256i, unsigned); 
#line 3514
extern __m256i __cdecl _mm256_maskz_slli_epi16(__mmask16, __m256i, unsigned); 
#line 3515
extern __m128i __cdecl _mm_mask_slli_epi32(__m128i, __mmask8, __m128i, unsigned); 
#line 3516
extern __m128i __cdecl _mm_maskz_slli_epi32(__mmask8, __m128i, unsigned); 
#line 3517
extern __m256i __cdecl _mm256_mask_slli_epi32(__m256i, __mmask8, __m256i, unsigned); 
#line 3518
extern __m256i __cdecl _mm256_maskz_slli_epi32(__mmask8, __m256i, unsigned); 
#line 3519
extern __m128i __cdecl _mm_mask_slli_epi64(__m128i, __mmask8, __m128i, unsigned); 
#line 3520
extern __m128i __cdecl _mm_maskz_slli_epi64(__mmask8, __m128i, unsigned); 
#line 3521
extern __m256i __cdecl _mm256_mask_slli_epi64(__m256i, __mmask8, __m256i, unsigned); 
#line 3522
extern __m256i __cdecl _mm256_maskz_slli_epi64(__mmask8, __m256i, unsigned); 
#line 3523
extern __m128i __cdecl _mm_mask_sllv_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 3524
extern __m128i __cdecl _mm_maskz_sllv_epi16(__mmask8, __m128i, __m128i); 
#line 3525
extern __m128i __cdecl _mm_sllv_epi16(__m128i, __m128i); 
#line 3526
extern __m256i __cdecl _mm256_mask_sllv_epi16(__m256i, __mmask16, __m256i, __m256i); 
#line 3527
extern __m256i __cdecl _mm256_maskz_sllv_epi16(__mmask16, __m256i, __m256i); 
#line 3528
extern __m256i __cdecl _mm256_sllv_epi16(__m256i, __m256i); 
#line 3529
extern __m128i __cdecl _mm_mask_sllv_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 3530
extern __m128i __cdecl _mm_maskz_sllv_epi32(__mmask8, __m128i, __m128i); 
#line 3531
extern __m256i __cdecl _mm256_mask_sllv_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 3532
extern __m256i __cdecl _mm256_maskz_sllv_epi32(__mmask8, __m256i, __m256i); 
#line 3533
extern __m128i __cdecl _mm_mask_sllv_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 3534
extern __m128i __cdecl _mm_maskz_sllv_epi64(__mmask8, __m128i, __m128i); 
#line 3535
extern __m256i __cdecl _mm256_mask_sllv_epi64(__m256i, __mmask8, __m256i, __m256i); 
#line 3536
extern __m256i __cdecl _mm256_maskz_sllv_epi64(__mmask8, __m256i, __m256i); 
#line 3537
extern __m128d __cdecl _mm_mask_sqrt_pd(__m128d, __mmask8, __m128d); 
#line 3538
extern __m128d __cdecl _mm_maskz_sqrt_pd(__mmask8, __m128d); 
#line 3539
extern __m256d __cdecl _mm256_mask_sqrt_pd(__m256d, __mmask8, __m256d); 
#line 3540
extern __m256d __cdecl _mm256_maskz_sqrt_pd(__mmask8, __m256d); 
#line 3541
extern __m128 __cdecl _mm_mask_sqrt_ps(__m128, __mmask8, __m128); 
#line 3542
extern __m128 __cdecl _mm_maskz_sqrt_ps(__mmask8, __m128); 
#line 3543
extern __m256 __cdecl _mm256_mask_sqrt_ps(__m256, __mmask8, __m256); 
#line 3544
extern __m256 __cdecl _mm256_maskz_sqrt_ps(__mmask8, __m256); 
#line 3545
extern __m128i __cdecl _mm_mask_sra_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 3546
extern __m128i __cdecl _mm_maskz_sra_epi16(__mmask8, __m128i, __m128i); 
#line 3547
extern __m256i __cdecl _mm256_mask_sra_epi16(__m256i, __mmask16, __m256i, __m128i); 
#line 3548
extern __m256i __cdecl _mm256_maskz_sra_epi16(__mmask16, __m256i, __m128i); 
#line 3549
extern __m128i __cdecl _mm_mask_sra_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 3550
extern __m128i __cdecl _mm_maskz_sra_epi32(__mmask8, __m128i, __m128i); 
#line 3551
extern __m256i __cdecl _mm256_mask_sra_epi32(__m256i, __mmask8, __m256i, __m128i); 
#line 3552
extern __m256i __cdecl _mm256_maskz_sra_epi32(__mmask8, __m256i, __m128i); 
#line 3553
extern __m128i __cdecl _mm_mask_sra_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 3554
extern __m128i __cdecl _mm_maskz_sra_epi64(__mmask8, __m128i, __m128i); 
#line 3555
extern __m128i __cdecl _mm_sra_epi64(__m128i, __m128i); 
#line 3556
extern __m256i __cdecl _mm256_mask_sra_epi64(__m256i, __mmask8, __m256i, __m128i); 
#line 3557
extern __m256i __cdecl _mm256_maskz_sra_epi64(__mmask8, __m256i, __m128i); 
#line 3558
extern __m256i __cdecl _mm256_sra_epi64(__m256i, __m128i); 
#line 3559
extern __m128i __cdecl _mm_mask_srai_epi16(__m128i, __mmask8, __m128i, unsigned); 
#line 3560
extern __m128i __cdecl _mm_maskz_srai_epi16(__mmask8, __m128i, unsigned); 
#line 3561
extern __m256i __cdecl _mm256_mask_srai_epi16(__m256i, __mmask16, __m256i, unsigned); 
#line 3562
extern __m256i __cdecl _mm256_maskz_srai_epi16(__mmask16, __m256i, unsigned); 
#line 3563
extern __m128i __cdecl _mm_mask_srai_epi32(__m128i, __mmask8, __m128i, unsigned); 
#line 3564
extern __m128i __cdecl _mm_maskz_srai_epi32(__mmask8, __m128i, unsigned); 
#line 3565
extern __m256i __cdecl _mm256_mask_srai_epi32(__m256i, __mmask8, __m256i, unsigned); 
#line 3566
extern __m256i __cdecl _mm256_maskz_srai_epi32(__mmask8, __m256i, unsigned); 
#line 3567
extern __m128i __cdecl _mm_mask_srai_epi64(__m128i, __mmask8, __m128i, unsigned); 
#line 3568
extern __m128i __cdecl _mm_maskz_srai_epi64(__mmask8, __m128i, unsigned); 
#line 3569
extern __m128i __cdecl _mm_srai_epi64(__m128i, unsigned); 
#line 3570
extern __m256i __cdecl _mm256_mask_srai_epi64(__m256i, __mmask8, __m256i, unsigned); 
#line 3571
extern __m256i __cdecl _mm256_maskz_srai_epi64(__mmask8, __m256i, unsigned); 
#line 3572
extern __m256i __cdecl _mm256_srai_epi64(__m256i, unsigned); 
#line 3573
extern __m128i __cdecl _mm_mask_srav_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 3574
extern __m128i __cdecl _mm_maskz_srav_epi16(__mmask8, __m128i, __m128i); 
#line 3575
extern __m128i __cdecl _mm_srav_epi16(__m128i, __m128i); 
#line 3576
extern __m256i __cdecl _mm256_mask_srav_epi16(__m256i, __mmask16, __m256i, __m256i); 
#line 3577
extern __m256i __cdecl _mm256_maskz_srav_epi16(__mmask16, __m256i, __m256i); 
#line 3578
extern __m256i __cdecl _mm256_srav_epi16(__m256i, __m256i); 
#line 3579
extern __m128i __cdecl _mm_mask_srav_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 3580
extern __m128i __cdecl _mm_maskz_srav_epi32(__mmask8, __m128i, __m128i); 
#line 3581
extern __m256i __cdecl _mm256_mask_srav_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 3582
extern __m256i __cdecl _mm256_maskz_srav_epi32(__mmask8, __m256i, __m256i); 
#line 3583
extern __m128i __cdecl _mm_mask_srav_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 3584
extern __m128i __cdecl _mm_maskz_srav_epi64(__mmask8, __m128i, __m128i); 
#line 3585
extern __m128i __cdecl _mm_srav_epi64(__m128i, __m128i); 
#line 3586
extern __m256i __cdecl _mm256_mask_srav_epi64(__m256i, __mmask8, __m256i, __m256i); 
#line 3587
extern __m256i __cdecl _mm256_maskz_srav_epi64(__mmask8, __m256i, __m256i); 
#line 3588
extern __m256i __cdecl _mm256_srav_epi64(__m256i, __m256i); 
#line 3589
extern __m128i __cdecl _mm_mask_srl_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 3590
extern __m128i __cdecl _mm_maskz_srl_epi16(__mmask8, __m128i, __m128i); 
#line 3591
extern __m256i __cdecl _mm256_mask_srl_epi16(__m256i, __mmask16, __m256i, __m128i); 
#line 3592
extern __m256i __cdecl _mm256_maskz_srl_epi16(__mmask16, __m256i, __m128i); 
#line 3593
extern __m128i __cdecl _mm_mask_srl_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 3594
extern __m128i __cdecl _mm_maskz_srl_epi32(__mmask8, __m128i, __m128i); 
#line 3595
extern __m256i __cdecl _mm256_mask_srl_epi32(__m256i, __mmask8, __m256i, __m128i); 
#line 3596
extern __m256i __cdecl _mm256_maskz_srl_epi32(__mmask8, __m256i, __m128i); 
#line 3597
extern __m128i __cdecl _mm_mask_srl_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 3598
extern __m128i __cdecl _mm_maskz_srl_epi64(__mmask8, __m128i, __m128i); 
#line 3599
extern __m256i __cdecl _mm256_mask_srl_epi64(__m256i, __mmask8, __m256i, __m128i); 
#line 3600
extern __m256i __cdecl _mm256_maskz_srl_epi64(__mmask8, __m256i, __m128i); 
#line 3601
extern __m128i __cdecl _mm_mask_srli_epi16(__m128i, __mmask8, __m128i, int); 
#line 3602
extern __m128i __cdecl _mm_maskz_srli_epi16(__mmask8, __m128i, int); 
#line 3603
extern __m256i __cdecl _mm256_mask_srli_epi16(__m256i, __mmask16, __m256i, int); 
#line 3604
extern __m256i __cdecl _mm256_maskz_srli_epi16(__mmask16, __m256i, int); 
#line 3605
extern __m128i __cdecl _mm_mask_srli_epi32(__m128i, __mmask8, __m128i, unsigned); 
#line 3606
extern __m128i __cdecl _mm_maskz_srli_epi32(__mmask8, __m128i, unsigned); 
#line 3607
extern __m256i __cdecl _mm256_mask_srli_epi32(__m256i, __mmask8, __m256i, unsigned); 
#line 3608
extern __m256i __cdecl _mm256_maskz_srli_epi32(__mmask8, __m256i, unsigned); 
#line 3609
extern __m128i __cdecl _mm_mask_srli_epi64(__m128i, __mmask8, __m128i, unsigned); 
#line 3610
extern __m128i __cdecl _mm_maskz_srli_epi64(__mmask8, __m128i, unsigned); 
#line 3611
extern __m256i __cdecl _mm256_mask_srli_epi64(__m256i, __mmask8, __m256i, unsigned); 
#line 3612
extern __m256i __cdecl _mm256_maskz_srli_epi64(__mmask8, __m256i, unsigned); 
#line 3613
extern __m128i __cdecl _mm_mask_srlv_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 3614
extern __m128i __cdecl _mm_maskz_srlv_epi16(__mmask8, __m128i, __m128i); 
#line 3615
extern __m128i __cdecl _mm_srlv_epi16(__m128i, __m128i); 
#line 3616
extern __m256i __cdecl _mm256_mask_srlv_epi16(__m256i, __mmask16, __m256i, __m256i); 
#line 3617
extern __m256i __cdecl _mm256_maskz_srlv_epi16(__mmask16, __m256i, __m256i); 
#line 3618
extern __m256i __cdecl _mm256_srlv_epi16(__m256i, __m256i); 
#line 3619
extern __m128i __cdecl _mm_mask_srlv_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 3620
extern __m128i __cdecl _mm_maskz_srlv_epi32(__mmask8, __m128i, __m128i); 
#line 3621
extern __m256i __cdecl _mm256_mask_srlv_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 3622
extern __m256i __cdecl _mm256_maskz_srlv_epi32(__mmask8, __m256i, __m256i); 
#line 3623
extern __m128i __cdecl _mm_mask_srlv_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 3624
extern __m128i __cdecl _mm_maskz_srlv_epi64(__mmask8, __m128i, __m128i); 
#line 3625
extern __m256i __cdecl _mm256_mask_srlv_epi64(__m256i, __mmask8, __m256i, __m256i); 
#line 3626
extern __m256i __cdecl _mm256_maskz_srlv_epi64(__mmask8, __m256i, __m256i); 
#line 3627
extern void __cdecl _mm_mask_store_epi32(void *, __mmask8, __m128i); 
#line 3628
extern void __cdecl _mm256_mask_store_epi32(void *, __mmask8, __m256i); 
#line 3629
extern void __cdecl _mm_mask_store_epi64(void *, __mmask8, __m128i); 
#line 3630
extern void __cdecl _mm256_mask_store_epi64(void *, __mmask8, __m256i); 
#line 3631
extern void __cdecl _mm_mask_store_pd(void *, __mmask8, __m128d); 
#line 3632
extern void __cdecl _mm256_mask_store_pd(void *, __mmask8, __m256d); 
#line 3633
extern void __cdecl _mm_mask_store_ps(void *, __mmask8, __m128); 
#line 3634
extern void __cdecl _mm256_mask_store_ps(void *, __mmask8, __m256); 
#line 3635
extern void __cdecl _mm_storeu_epi16(void *, __m128i); 
#line 3636
extern void __cdecl _mm256_storeu_epi16(void *, __m256i); 
#line 3637
extern void __cdecl _mm_mask_storeu_epi16(void *, __mmask8, __m128i); 
#line 3638
extern void __cdecl _mm256_mask_storeu_epi16(void *, __mmask16, __m256i); 
#line 3639
extern void __cdecl _mm_storeu_epi32(void *, __m128i); 
#line 3640
extern void __cdecl _mm256_storeu_epi32(void *, __m256i); 
#line 3641
extern void __cdecl _mm_mask_storeu_epi32(void *, __mmask8, __m128i); 
#line 3642
extern void __cdecl _mm256_mask_storeu_epi32(void *, __mmask8, __m256i); 
#line 3643
extern void __cdecl _mm_storeu_epi64(void *, __m128i); 
#line 3644
extern void __cdecl _mm256_storeu_epi64(void *, __m256i); 
#line 3645
extern void __cdecl _mm_mask_storeu_epi64(void *, __mmask8, __m128i); 
#line 3646
extern void __cdecl _mm256_mask_storeu_epi64(void *, __mmask8, __m256i); 
#line 3647
extern void __cdecl _mm_storeu_epi8(void *, __m128i); 
#line 3648
extern void __cdecl _mm256_storeu_epi8(void *, __m256i); 
#line 3649
extern void __cdecl _mm_mask_storeu_epi8(void *, __mmask16, __m128i); 
#line 3650
extern void __cdecl _mm256_mask_storeu_epi8(void *, __mmask32, __m256i); 
#line 3651
extern void __cdecl _mm_mask_storeu_pd(void *, __mmask8, __m128d); 
#line 3652
extern void __cdecl _mm256_mask_storeu_pd(void *, __mmask8, __m256d); 
#line 3653
extern void __cdecl _mm_mask_storeu_ps(void *, __mmask8, __m128); 
#line 3654
extern void __cdecl _mm256_mask_storeu_ps(void *, __mmask8, __m256); 
#line 3655
extern __m128i __cdecl _mm_mask_sub_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 3656
extern __m128i __cdecl _mm_maskz_sub_epi16(__mmask8, __m128i, __m128i); 
#line 3657
extern __m256i __cdecl _mm256_mask_sub_epi16(__m256i, __mmask16, __m256i, __m256i); 
#line 3658
extern __m256i __cdecl _mm256_maskz_sub_epi16(__mmask16, __m256i, __m256i); 
#line 3659
extern __m128i __cdecl _mm_mask_sub_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 3660
extern __m128i __cdecl _mm_maskz_sub_epi32(__mmask8, __m128i, __m128i); 
#line 3661
extern __m256i __cdecl _mm256_mask_sub_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 3662
extern __m256i __cdecl _mm256_maskz_sub_epi32(__mmask8, __m256i, __m256i); 
#line 3663
extern __m128i __cdecl _mm_mask_sub_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 3664
extern __m128i __cdecl _mm_maskz_sub_epi64(__mmask8, __m128i, __m128i); 
#line 3665
extern __m256i __cdecl _mm256_mask_sub_epi64(__m256i, __mmask8, __m256i, __m256i); 
#line 3666
extern __m256i __cdecl _mm256_maskz_sub_epi64(__mmask8, __m256i, __m256i); 
#line 3667
extern __m128i __cdecl _mm_mask_sub_epi8(__m128i, __mmask16, __m128i, __m128i); 
#line 3668
extern __m128i __cdecl _mm_maskz_sub_epi8(__mmask16, __m128i, __m128i); 
#line 3669
extern __m256i __cdecl _mm256_mask_sub_epi8(__m256i, __mmask32, __m256i, __m256i); 
#line 3670
extern __m256i __cdecl _mm256_maskz_sub_epi8(__mmask32, __m256i, __m256i); 
#line 3671
extern __m128d __cdecl _mm_mask_sub_pd(__m128d, __mmask8, __m128d, __m128d); 
#line 3672
extern __m128d __cdecl _mm_maskz_sub_pd(__mmask8, __m128d, __m128d); 
#line 3673
extern __m256d __cdecl _mm256_mask_sub_pd(__m256d, __mmask8, __m256d, __m256d); 
#line 3674
extern __m256d __cdecl _mm256_maskz_sub_pd(__mmask8, __m256d, __m256d); 
#line 3675
extern __m128 __cdecl _mm_mask_sub_ps(__m128, __mmask8, __m128, __m128); 
#line 3676
extern __m128 __cdecl _mm_maskz_sub_ps(__mmask8, __m128, __m128); 
#line 3677
extern __m256 __cdecl _mm256_mask_sub_ps(__m256, __mmask8, __m256, __m256); 
#line 3678
extern __m256 __cdecl _mm256_maskz_sub_ps(__mmask8, __m256, __m256); 
#line 3679
extern __m128i __cdecl _mm_mask_subs_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 3680
extern __m128i __cdecl _mm_maskz_subs_epi16(__mmask8, __m128i, __m128i); 
#line 3681
extern __m256i __cdecl _mm256_mask_subs_epi16(__m256i, __mmask16, __m256i, __m256i); 
#line 3682
extern __m256i __cdecl _mm256_maskz_subs_epi16(__mmask16, __m256i, __m256i); 
#line 3683
extern __m128i __cdecl _mm_mask_subs_epi8(__m128i, __mmask16, __m128i, __m128i); 
#line 3684
extern __m128i __cdecl _mm_maskz_subs_epi8(__mmask16, __m128i, __m128i); 
#line 3685
extern __m256i __cdecl _mm256_mask_subs_epi8(__m256i, __mmask32, __m256i, __m256i); 
#line 3686
extern __m256i __cdecl _mm256_maskz_subs_epi8(__mmask32, __m256i, __m256i); 
#line 3687
extern __m128i __cdecl _mm_mask_subs_epu16(__m128i, __mmask8, __m128i, __m128i); 
#line 3688
extern __m128i __cdecl _mm_maskz_subs_epu16(__mmask8, __m128i, __m128i); 
#line 3689
extern __m256i __cdecl _mm256_mask_subs_epu16(__m256i, __mmask16, __m256i, __m256i); 
#line 3690
extern __m256i __cdecl _mm256_maskz_subs_epu16(__mmask16, __m256i, __m256i); 
#line 3691
extern __m128i __cdecl _mm_mask_subs_epu8(__m128i, __mmask16, __m128i, __m128i); 
#line 3692
extern __m128i __cdecl _mm_maskz_subs_epu8(__mmask16, __m128i, __m128i); 
#line 3693
extern __m256i __cdecl _mm256_mask_subs_epu8(__m256i, __mmask32, __m256i, __m256i); 
#line 3694
extern __m256i __cdecl _mm256_maskz_subs_epu8(__mmask32, __m256i, __m256i); 
#line 3695
extern __m128i __cdecl _mm_mask_ternarylogic_epi32(__m128i, __mmask8, __m128i, __m128i, int); 
#line 3696
extern __m128i __cdecl _mm_maskz_ternarylogic_epi32(__mmask8, __m128i, __m128i, __m128i, int); 
#line 3697
extern __m128i __cdecl _mm_ternarylogic_epi32(__m128i, __m128i, __m128i, int); 
#line 3698
extern __m256i __cdecl _mm256_mask_ternarylogic_epi32(__m256i, __mmask8, __m256i, __m256i, int); 
#line 3699
extern __m256i __cdecl _mm256_maskz_ternarylogic_epi32(__mmask8, __m256i, __m256i, __m256i, int); 
#line 3700
extern __m256i __cdecl _mm256_ternarylogic_epi32(__m256i, __m256i, __m256i, int); 
#line 3701
extern __m128i __cdecl _mm_mask_ternarylogic_epi64(__m128i, __mmask8, __m128i, __m128i, int); 
#line 3702
extern __m128i __cdecl _mm_maskz_ternarylogic_epi64(__mmask8, __m128i, __m128i, __m128i, int); 
#line 3703
extern __m128i __cdecl _mm_ternarylogic_epi64(__m128i, __m128i, __m128i, int); 
#line 3704
extern __m256i __cdecl _mm256_mask_ternarylogic_epi64(__m256i, __mmask8, __m256i, __m256i, int); 
#line 3705
extern __m256i __cdecl _mm256_maskz_ternarylogic_epi64(__mmask8, __m256i, __m256i, __m256i, int); 
#line 3706
extern __m256i __cdecl _mm256_ternarylogic_epi64(__m256i, __m256i, __m256i, int); 
#line 3707
extern __mmask8 __cdecl _mm_mask_test_epi16_mask(__mmask8, __m128i, __m128i); 
#line 3708
extern __mmask8 __cdecl _mm_test_epi16_mask(__m128i, __m128i); 
#line 3709
extern __mmask16 __cdecl _mm256_mask_test_epi16_mask(__mmask16, __m256i, __m256i); 
#line 3710
extern __mmask16 __cdecl _mm256_test_epi16_mask(__m256i, __m256i); 
#line 3711
extern __mmask8 __cdecl _mm_mask_test_epi32_mask(__mmask8, __m128i, __m128i); 
#line 3712
extern __mmask8 __cdecl _mm_test_epi32_mask(__m128i, __m128i); 
#line 3713
extern __mmask8 __cdecl _mm256_mask_test_epi32_mask(__mmask8, __m256i, __m256i); 
#line 3714
extern __mmask8 __cdecl _mm256_test_epi32_mask(__m256i, __m256i); 
#line 3715
extern __mmask8 __cdecl _mm_mask_test_epi64_mask(__mmask8, __m128i, __m128i); 
#line 3716
extern __mmask8 __cdecl _mm_test_epi64_mask(__m128i, __m128i); 
#line 3717
extern __mmask8 __cdecl _mm256_mask_test_epi64_mask(__mmask8, __m256i, __m256i); 
#line 3718
extern __mmask8 __cdecl _mm256_test_epi64_mask(__m256i, __m256i); 
#line 3719
extern __mmask16 __cdecl _mm_mask_test_epi8_mask(__mmask16, __m128i, __m128i); 
#line 3720
extern __mmask16 __cdecl _mm_test_epi8_mask(__m128i, __m128i); 
#line 3721
extern __mmask32 __cdecl _mm256_mask_test_epi8_mask(__mmask32, __m256i, __m256i); 
#line 3722
extern __mmask32 __cdecl _mm256_test_epi8_mask(__m256i, __m256i); 
#line 3723
extern __mmask8 __cdecl _mm_mask_testn_epi16_mask(__mmask8, __m128i, __m128i); 
#line 3724
extern __mmask8 __cdecl _mm_testn_epi16_mask(__m128i, __m128i); 
#line 3725
extern __mmask16 __cdecl _mm256_mask_testn_epi16_mask(__mmask16, __m256i, __m256i); 
#line 3726
extern __mmask16 __cdecl _mm256_testn_epi16_mask(__m256i, __m256i); 
#line 3727
extern __mmask8 __cdecl _mm_mask_testn_epi32_mask(__mmask8, __m128i, __m128i); 
#line 3728
extern __mmask8 __cdecl _mm_testn_epi32_mask(__m128i, __m128i); 
#line 3729
extern __mmask8 __cdecl _mm256_mask_testn_epi32_mask(__mmask8, __m256i, __m256i); 
#line 3730
extern __mmask8 __cdecl _mm256_testn_epi32_mask(__m256i, __m256i); 
#line 3731
extern __mmask8 __cdecl _mm_mask_testn_epi64_mask(__mmask8, __m128i, __m128i); 
#line 3732
extern __mmask8 __cdecl _mm_testn_epi64_mask(__m128i, __m128i); 
#line 3733
extern __mmask8 __cdecl _mm256_mask_testn_epi64_mask(__mmask8, __m256i, __m256i); 
#line 3734
extern __mmask8 __cdecl _mm256_testn_epi64_mask(__m256i, __m256i); 
#line 3735
extern __mmask16 __cdecl _mm_mask_testn_epi8_mask(__mmask16, __m128i, __m128i); 
#line 3736
extern __mmask16 __cdecl _mm_testn_epi8_mask(__m128i, __m128i); 
#line 3737
extern __mmask32 __cdecl _mm256_mask_testn_epi8_mask(__mmask32, __m256i, __m256i); 
#line 3738
extern __mmask32 __cdecl _mm256_testn_epi8_mask(__m256i, __m256i); 
#line 3739
extern __m128i __cdecl _mm_mask_unpackhi_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 3740
extern __m128i __cdecl _mm_maskz_unpackhi_epi16(__mmask8, __m128i, __m128i); 
#line 3741
extern __m256i __cdecl _mm256_mask_unpackhi_epi16(__m256i, __mmask16, __m256i, __m256i); 
#line 3742
extern __m256i __cdecl _mm256_maskz_unpackhi_epi16(__mmask16, __m256i, __m256i); 
#line 3743
extern __m128i __cdecl _mm_mask_unpackhi_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 3744
extern __m128i __cdecl _mm_maskz_unpackhi_epi32(__mmask8, __m128i, __m128i); 
#line 3745
extern __m256i __cdecl _mm256_mask_unpackhi_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 3746
extern __m256i __cdecl _mm256_maskz_unpackhi_epi32(__mmask8, __m256i, __m256i); 
#line 3747
extern __m128i __cdecl _mm_mask_unpackhi_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 3748
extern __m128i __cdecl _mm_maskz_unpackhi_epi64(__mmask8, __m128i, __m128i); 
#line 3749
extern __m256i __cdecl _mm256_mask_unpackhi_epi64(__m256i, __mmask8, __m256i, __m256i); 
#line 3750
extern __m256i __cdecl _mm256_maskz_unpackhi_epi64(__mmask8, __m256i, __m256i); 
#line 3751
extern __m128i __cdecl _mm_mask_unpackhi_epi8(__m128i, __mmask16, __m128i, __m128i); 
#line 3752
extern __m128i __cdecl _mm_maskz_unpackhi_epi8(__mmask16, __m128i, __m128i); 
#line 3753
extern __m256i __cdecl _mm256_mask_unpackhi_epi8(__m256i, __mmask32, __m256i, __m256i); 
#line 3754
extern __m256i __cdecl _mm256_maskz_unpackhi_epi8(__mmask32, __m256i, __m256i); 
#line 3755
extern __m128d __cdecl _mm_mask_unpackhi_pd(__m128d, __mmask8, __m128d, __m128d); 
#line 3756
extern __m128d __cdecl _mm_maskz_unpackhi_pd(__mmask8, __m128d, __m128d); 
#line 3757
extern __m256d __cdecl _mm256_mask_unpackhi_pd(__m256d, __mmask8, __m256d, __m256d); 
#line 3758
extern __m256d __cdecl _mm256_maskz_unpackhi_pd(__mmask8, __m256d, __m256d); 
#line 3759
extern __m128 __cdecl _mm_mask_unpackhi_ps(__m128, __mmask8, __m128, __m128); 
#line 3760
extern __m128 __cdecl _mm_maskz_unpackhi_ps(__mmask8, __m128, __m128); 
#line 3761
extern __m256 __cdecl _mm256_mask_unpackhi_ps(__m256, __mmask8, __m256, __m256); 
#line 3762
extern __m256 __cdecl _mm256_maskz_unpackhi_ps(__mmask8, __m256, __m256); 
#line 3763
extern __m128i __cdecl _mm_mask_unpacklo_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 3764
extern __m128i __cdecl _mm_maskz_unpacklo_epi16(__mmask8, __m128i, __m128i); 
#line 3765
extern __m256i __cdecl _mm256_mask_unpacklo_epi16(__m256i, __mmask16, __m256i, __m256i); 
#line 3766
extern __m256i __cdecl _mm256_maskz_unpacklo_epi16(__mmask16, __m256i, __m256i); 
#line 3767
extern __m128i __cdecl _mm_mask_unpacklo_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 3768
extern __m128i __cdecl _mm_maskz_unpacklo_epi32(__mmask8, __m128i, __m128i); 
#line 3769
extern __m256i __cdecl _mm256_mask_unpacklo_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 3770
extern __m256i __cdecl _mm256_maskz_unpacklo_epi32(__mmask8, __m256i, __m256i); 
#line 3771
extern __m128i __cdecl _mm_mask_unpacklo_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 3772
extern __m128i __cdecl _mm_maskz_unpacklo_epi64(__mmask8, __m128i, __m128i); 
#line 3773
extern __m256i __cdecl _mm256_mask_unpacklo_epi64(__m256i, __mmask8, __m256i, __m256i); 
#line 3774
extern __m256i __cdecl _mm256_maskz_unpacklo_epi64(__mmask8, __m256i, __m256i); 
#line 3775
extern __m128i __cdecl _mm_mask_unpacklo_epi8(__m128i, __mmask16, __m128i, __m128i); 
#line 3776
extern __m128i __cdecl _mm_maskz_unpacklo_epi8(__mmask16, __m128i, __m128i); 
#line 3777
extern __m256i __cdecl _mm256_mask_unpacklo_epi8(__m256i, __mmask32, __m256i, __m256i); 
#line 3778
extern __m256i __cdecl _mm256_maskz_unpacklo_epi8(__mmask32, __m256i, __m256i); 
#line 3779
extern __m128d __cdecl _mm_mask_unpacklo_pd(__m128d, __mmask8, __m128d, __m128d); 
#line 3780
extern __m128d __cdecl _mm_maskz_unpacklo_pd(__mmask8, __m128d, __m128d); 
#line 3781
extern __m256d __cdecl _mm256_mask_unpacklo_pd(__m256d, __mmask8, __m256d, __m256d); 
#line 3782
extern __m256d __cdecl _mm256_maskz_unpacklo_pd(__mmask8, __m256d, __m256d); 
#line 3783
extern __m128 __cdecl _mm_mask_unpacklo_ps(__m128, __mmask8, __m128, __m128); 
#line 3784
extern __m128 __cdecl _mm_maskz_unpacklo_ps(__mmask8, __m128, __m128); 
#line 3785
extern __m256 __cdecl _mm256_mask_unpacklo_ps(__m256, __mmask8, __m256, __m256); 
#line 3786
extern __m256 __cdecl _mm256_maskz_unpacklo_ps(__mmask8, __m256, __m256); 
#line 3787
extern __m128i __cdecl _mm_xor_epi32(__m128i, __m128i); 
#line 3788
extern __m128i __cdecl _mm_mask_xor_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 3789
extern __m128i __cdecl _mm_maskz_xor_epi32(__mmask8, __m128i, __m128i); 
#line 3790
extern __m256i __cdecl _mm256_xor_epi32(__m256i, __m256i); 
#line 3791
extern __m256i __cdecl _mm256_mask_xor_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 3792
extern __m256i __cdecl _mm256_maskz_xor_epi32(__mmask8, __m256i, __m256i); 
#line 3793
extern __m128i __cdecl _mm_xor_epi64(__m128i, __m128i); 
#line 3794
extern __m128i __cdecl _mm_mask_xor_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 3795
extern __m128i __cdecl _mm_maskz_xor_epi64(__mmask8, __m128i, __m128i); 
#line 3796
extern __m256i __cdecl _mm256_xor_epi64(__m256i, __m256i); 
#line 3797
extern __m256i __cdecl _mm256_mask_xor_epi64(__m256i, __mmask8, __m256i, __m256i); 
#line 3798
extern __m256i __cdecl _mm256_maskz_xor_epi64(__mmask8, __m256i, __m256i); 
#line 3799
extern __m128d __cdecl _mm_mask_xor_pd(__m128d, __mmask8, __m128d, __m128d); 
#line 3800
extern __m128d __cdecl _mm_maskz_xor_pd(__mmask8, __m128d, __m128d); 
#line 3801
extern __m256d __cdecl _mm256_mask_xor_pd(__m256d, __mmask8, __m256d, __m256d); 
#line 3802
extern __m256d __cdecl _mm256_maskz_xor_pd(__mmask8, __m256d, __m256d); 
#line 3803
extern __m128 __cdecl _mm_mask_xor_ps(__m128, __mmask8, __m128, __m128); 
#line 3804
extern __m128 __cdecl _mm_maskz_xor_ps(__mmask8, __m128, __m128); 
#line 3805
extern __m256 __cdecl _mm256_mask_xor_ps(__m256, __mmask8, __m256, __m256); 
#line 3806
extern __m256 __cdecl _mm256_maskz_xor_ps(__mmask8, __m256, __m256); 
#line 3808
extern __mmask16 __cdecl _mm_cmpeq_epi8_mask(__m128i, __m128i); 
#line 3809
extern __mmask16 __cdecl _mm_cmpge_epi8_mask(__m128i, __m128i); 
#line 3810
extern __mmask16 __cdecl _mm_cmpgt_epi8_mask(__m128i, __m128i); 
#line 3811
extern __mmask16 __cdecl _mm_cmple_epi8_mask(__m128i, __m128i); 
#line 3812
extern __mmask16 __cdecl _mm_cmplt_epi8_mask(__m128i, __m128i); 
#line 3813
extern __mmask16 __cdecl _mm_cmpneq_epi8_mask(__m128i, __m128i); 
#line 3814
extern __mmask16 __cdecl _mm_cmpeq_epu8_mask(__m128i, __m128i); 
#line 3815
extern __mmask16 __cdecl _mm_cmpge_epu8_mask(__m128i, __m128i); 
#line 3816
extern __mmask16 __cdecl _mm_cmpgt_epu8_mask(__m128i, __m128i); 
#line 3817
extern __mmask16 __cdecl _mm_cmple_epu8_mask(__m128i, __m128i); 
#line 3818
extern __mmask16 __cdecl _mm_cmplt_epu8_mask(__m128i, __m128i); 
#line 3819
extern __mmask16 __cdecl _mm_cmpneq_epu8_mask(__m128i, __m128i); 
#line 3821
extern __mmask16 __cdecl _mm_mask_cmpeq_epi8_mask(__mmask16, __m128i, __m128i); 
#line 3822
extern __mmask16 __cdecl _mm_mask_cmpge_epi8_mask(__mmask16, __m128i, __m128i); 
#line 3823
extern __mmask16 __cdecl _mm_mask_cmpgt_epi8_mask(__mmask16, __m128i, __m128i); 
#line 3824
extern __mmask16 __cdecl _mm_mask_cmple_epi8_mask(__mmask16, __m128i, __m128i); 
#line 3825
extern __mmask16 __cdecl _mm_mask_cmplt_epi8_mask(__mmask16, __m128i, __m128i); 
#line 3826
extern __mmask16 __cdecl _mm_mask_cmpneq_epi8_mask(__mmask16, __m128i, __m128i); 
#line 3827
extern __mmask16 __cdecl _mm_mask_cmpeq_epu8_mask(__mmask16, __m128i, __m128i); 
#line 3828
extern __mmask16 __cdecl _mm_mask_cmpge_epu8_mask(__mmask16, __m128i, __m128i); 
#line 3829
extern __mmask16 __cdecl _mm_mask_cmpgt_epu8_mask(__mmask16, __m128i, __m128i); 
#line 3830
extern __mmask16 __cdecl _mm_mask_cmple_epu8_mask(__mmask16, __m128i, __m128i); 
#line 3831
extern __mmask16 __cdecl _mm_mask_cmplt_epu8_mask(__mmask16, __m128i, __m128i); 
#line 3832
extern __mmask16 __cdecl _mm_mask_cmpneq_epu8_mask(__mmask16, __m128i, __m128i); 
#line 3834
extern __mmask8 __cdecl _mm_cmpeq_epi16_mask(__m128i, __m128i); 
#line 3835
extern __mmask8 __cdecl _mm_cmpge_epi16_mask(__m128i, __m128i); 
#line 3836
extern __mmask8 __cdecl _mm_cmpgt_epi16_mask(__m128i, __m128i); 
#line 3837
extern __mmask8 __cdecl _mm_cmple_epi16_mask(__m128i, __m128i); 
#line 3838
extern __mmask8 __cdecl _mm_cmplt_epi16_mask(__m128i, __m128i); 
#line 3839
extern __mmask8 __cdecl _mm_cmpneq_epi16_mask(__m128i, __m128i); 
#line 3840
extern __mmask8 __cdecl _mm_cmpeq_epu16_mask(__m128i, __m128i); 
#line 3841
extern __mmask8 __cdecl _mm_cmpge_epu16_mask(__m128i, __m128i); 
#line 3842
extern __mmask8 __cdecl _mm_cmpgt_epu16_mask(__m128i, __m128i); 
#line 3843
extern __mmask8 __cdecl _mm_cmple_epu16_mask(__m128i, __m128i); 
#line 3844
extern __mmask8 __cdecl _mm_cmplt_epu16_mask(__m128i, __m128i); 
#line 3845
extern __mmask8 __cdecl _mm_cmpneq_epu16_mask(__m128i, __m128i); 
#line 3847
extern __mmask8 __cdecl _mm_mask_cmpeq_epi16_mask(__mmask8, __m128i, __m128i); 
#line 3848
extern __mmask8 __cdecl _mm_mask_cmpge_epi16_mask(__mmask8, __m128i, __m128i); 
#line 3849
extern __mmask8 __cdecl _mm_mask_cmpgt_epi16_mask(__mmask8, __m128i, __m128i); 
#line 3850
extern __mmask8 __cdecl _mm_mask_cmple_epi16_mask(__mmask8, __m128i, __m128i); 
#line 3851
extern __mmask8 __cdecl _mm_mask_cmplt_epi16_mask(__mmask8, __m128i, __m128i); 
#line 3852
extern __mmask8 __cdecl _mm_mask_cmpneq_epi16_mask(__mmask8, __m128i, __m128i); 
#line 3853
extern __mmask8 __cdecl _mm_mask_cmpeq_epu16_mask(__mmask8, __m128i, __m128i); 
#line 3854
extern __mmask8 __cdecl _mm_mask_cmpge_epu16_mask(__mmask8, __m128i, __m128i); 
#line 3855
extern __mmask8 __cdecl _mm_mask_cmpgt_epu16_mask(__mmask8, __m128i, __m128i); 
#line 3856
extern __mmask8 __cdecl _mm_mask_cmple_epu16_mask(__mmask8, __m128i, __m128i); 
#line 3857
extern __mmask8 __cdecl _mm_mask_cmplt_epu16_mask(__mmask8, __m128i, __m128i); 
#line 3858
extern __mmask8 __cdecl _mm_mask_cmpneq_epu16_mask(__mmask8, __m128i, __m128i); 
#line 3860
extern __mmask8 __cdecl _mm_cmpeq_epi32_mask(__m128i, __m128i); 
#line 3861
extern __mmask8 __cdecl _mm_cmpge_epi32_mask(__m128i, __m128i); 
#line 3862
extern __mmask8 __cdecl _mm_cmpgt_epi32_mask(__m128i, __m128i); 
#line 3863
extern __mmask8 __cdecl _mm_cmple_epi32_mask(__m128i, __m128i); 
#line 3864
extern __mmask8 __cdecl _mm_cmplt_epi32_mask(__m128i, __m128i); 
#line 3865
extern __mmask8 __cdecl _mm_cmpneq_epi32_mask(__m128i, __m128i); 
#line 3866
extern __mmask8 __cdecl _mm_cmpeq_epu32_mask(__m128i, __m128i); 
#line 3867
extern __mmask8 __cdecl _mm_cmpge_epu32_mask(__m128i, __m128i); 
#line 3868
extern __mmask8 __cdecl _mm_cmpgt_epu32_mask(__m128i, __m128i); 
#line 3869
extern __mmask8 __cdecl _mm_cmple_epu32_mask(__m128i, __m128i); 
#line 3870
extern __mmask8 __cdecl _mm_cmplt_epu32_mask(__m128i, __m128i); 
#line 3871
extern __mmask8 __cdecl _mm_cmpneq_epu32_mask(__m128i, __m128i); 
#line 3873
extern __mmask8 __cdecl _mm_mask_cmpeq_epi32_mask(__mmask8, __m128i, __m128i); 
#line 3874
extern __mmask8 __cdecl _mm_mask_cmpge_epi32_mask(__mmask8, __m128i, __m128i); 
#line 3875
extern __mmask8 __cdecl _mm_mask_cmpgt_epi32_mask(__mmask8, __m128i, __m128i); 
#line 3876
extern __mmask8 __cdecl _mm_mask_cmple_epi32_mask(__mmask8, __m128i, __m128i); 
#line 3877
extern __mmask8 __cdecl _mm_mask_cmplt_epi32_mask(__mmask8, __m128i, __m128i); 
#line 3878
extern __mmask8 __cdecl _mm_mask_cmpneq_epi32_mask(__mmask8, __m128i, __m128i); 
#line 3879
extern __mmask8 __cdecl _mm_mask_cmpeq_epu32_mask(__mmask8, __m128i, __m128i); 
#line 3880
extern __mmask8 __cdecl _mm_mask_cmpge_epu32_mask(__mmask8, __m128i, __m128i); 
#line 3881
extern __mmask8 __cdecl _mm_mask_cmpgt_epu32_mask(__mmask8, __m128i, __m128i); 
#line 3882
extern __mmask8 __cdecl _mm_mask_cmple_epu32_mask(__mmask8, __m128i, __m128i); 
#line 3883
extern __mmask8 __cdecl _mm_mask_cmplt_epu32_mask(__mmask8, __m128i, __m128i); 
#line 3884
extern __mmask8 __cdecl _mm_mask_cmpneq_epu32_mask(__mmask8, __m128i, __m128i); 
#line 3886
extern __mmask8 __cdecl _mm_cmpeq_epi64_mask(__m128i, __m128i); 
#line 3887
extern __mmask8 __cdecl _mm_cmpge_epi64_mask(__m128i, __m128i); 
#line 3888
extern __mmask8 __cdecl _mm_cmpgt_epi64_mask(__m128i, __m128i); 
#line 3889
extern __mmask8 __cdecl _mm_cmple_epi64_mask(__m128i, __m128i); 
#line 3890
extern __mmask8 __cdecl _mm_cmplt_epi64_mask(__m128i, __m128i); 
#line 3891
extern __mmask8 __cdecl _mm_cmpneq_epi64_mask(__m128i, __m128i); 
#line 3892
extern __mmask8 __cdecl _mm_cmpeq_epu64_mask(__m128i, __m128i); 
#line 3893
extern __mmask8 __cdecl _mm_cmpge_epu64_mask(__m128i, __m128i); 
#line 3894
extern __mmask8 __cdecl _mm_cmpgt_epu64_mask(__m128i, __m128i); 
#line 3895
extern __mmask8 __cdecl _mm_cmple_epu64_mask(__m128i, __m128i); 
#line 3896
extern __mmask8 __cdecl _mm_cmplt_epu64_mask(__m128i, __m128i); 
#line 3897
extern __mmask8 __cdecl _mm_cmpneq_epu64_mask(__m128i, __m128i); 
#line 3899
extern __mmask8 __cdecl _mm_mask_cmpeq_epi64_mask(__mmask8, __m128i, __m128i); 
#line 3900
extern __mmask8 __cdecl _mm_mask_cmpge_epi64_mask(__mmask8, __m128i, __m128i); 
#line 3901
extern __mmask8 __cdecl _mm_mask_cmpgt_epi64_mask(__mmask8, __m128i, __m128i); 
#line 3902
extern __mmask8 __cdecl _mm_mask_cmple_epi64_mask(__mmask8, __m128i, __m128i); 
#line 3903
extern __mmask8 __cdecl _mm_mask_cmplt_epi64_mask(__mmask8, __m128i, __m128i); 
#line 3904
extern __mmask8 __cdecl _mm_mask_cmpneq_epi64_mask(__mmask8, __m128i, __m128i); 
#line 3905
extern __mmask8 __cdecl _mm_mask_cmpeq_epu64_mask(__mmask8, __m128i, __m128i); 
#line 3906
extern __mmask8 __cdecl _mm_mask_cmpge_epu64_mask(__mmask8, __m128i, __m128i); 
#line 3907
extern __mmask8 __cdecl _mm_mask_cmpgt_epu64_mask(__mmask8, __m128i, __m128i); 
#line 3908
extern __mmask8 __cdecl _mm_mask_cmple_epu64_mask(__mmask8, __m128i, __m128i); 
#line 3909
extern __mmask8 __cdecl _mm_mask_cmplt_epu64_mask(__mmask8, __m128i, __m128i); 
#line 3910
extern __mmask8 __cdecl _mm_mask_cmpneq_epu64_mask(__mmask8, __m128i, __m128i); 
#line 3912
extern __mmask32 __cdecl _mm256_cmpeq_epi8_mask(__m256i, __m256i); 
#line 3913
extern __mmask32 __cdecl _mm256_cmpge_epi8_mask(__m256i, __m256i); 
#line 3914
extern __mmask32 __cdecl _mm256_cmpgt_epi8_mask(__m256i, __m256i); 
#line 3915
extern __mmask32 __cdecl _mm256_cmple_epi8_mask(__m256i, __m256i); 
#line 3916
extern __mmask32 __cdecl _mm256_cmplt_epi8_mask(__m256i, __m256i); 
#line 3917
extern __mmask32 __cdecl _mm256_cmpneq_epi8_mask(__m256i, __m256i); 
#line 3918
extern __mmask32 __cdecl _mm256_cmpeq_epu8_mask(__m256i, __m256i); 
#line 3919
extern __mmask32 __cdecl _mm256_cmpge_epu8_mask(__m256i, __m256i); 
#line 3920
extern __mmask32 __cdecl _mm256_cmpgt_epu8_mask(__m256i, __m256i); 
#line 3921
extern __mmask32 __cdecl _mm256_cmple_epu8_mask(__m256i, __m256i); 
#line 3922
extern __mmask32 __cdecl _mm256_cmplt_epu8_mask(__m256i, __m256i); 
#line 3923
extern __mmask32 __cdecl _mm256_cmpneq_epu8_mask(__m256i, __m256i); 
#line 3925
extern __mmask32 __cdecl _mm256_mask_cmpeq_epi8_mask(__mmask32, __m256i, __m256i); 
#line 3926
extern __mmask32 __cdecl _mm256_mask_cmpge_epi8_mask(__mmask32, __m256i, __m256i); 
#line 3927
extern __mmask32 __cdecl _mm256_mask_cmpgt_epi8_mask(__mmask32, __m256i, __m256i); 
#line 3928
extern __mmask32 __cdecl _mm256_mask_cmple_epi8_mask(__mmask32, __m256i, __m256i); 
#line 3929
extern __mmask32 __cdecl _mm256_mask_cmplt_epi8_mask(__mmask32, __m256i, __m256i); 
#line 3930
extern __mmask32 __cdecl _mm256_mask_cmpneq_epi8_mask(__mmask32, __m256i, __m256i); 
#line 3931
extern __mmask32 __cdecl _mm256_mask_cmpeq_epu8_mask(__mmask32, __m256i, __m256i); 
#line 3932
extern __mmask32 __cdecl _mm256_mask_cmpge_epu8_mask(__mmask32, __m256i, __m256i); 
#line 3933
extern __mmask32 __cdecl _mm256_mask_cmpgt_epu8_mask(__mmask32, __m256i, __m256i); 
#line 3934
extern __mmask32 __cdecl _mm256_mask_cmple_epu8_mask(__mmask32, __m256i, __m256i); 
#line 3935
extern __mmask32 __cdecl _mm256_mask_cmplt_epu8_mask(__mmask32, __m256i, __m256i); 
#line 3936
extern __mmask32 __cdecl _mm256_mask_cmpneq_epu8_mask(__mmask32, __m256i, __m256i); 
#line 3938
extern __mmask16 __cdecl _mm256_cmpeq_epi16_mask(__m256i, __m256i); 
#line 3939
extern __mmask16 __cdecl _mm256_cmpge_epi16_mask(__m256i, __m256i); 
#line 3940
extern __mmask16 __cdecl _mm256_cmpgt_epi16_mask(__m256i, __m256i); 
#line 3941
extern __mmask16 __cdecl _mm256_cmple_epi16_mask(__m256i, __m256i); 
#line 3942
extern __mmask16 __cdecl _mm256_cmplt_epi16_mask(__m256i, __m256i); 
#line 3943
extern __mmask16 __cdecl _mm256_cmpneq_epi16_mask(__m256i, __m256i); 
#line 3944
extern __mmask16 __cdecl _mm256_cmpeq_epu16_mask(__m256i, __m256i); 
#line 3945
extern __mmask16 __cdecl _mm256_cmpge_epu16_mask(__m256i, __m256i); 
#line 3946
extern __mmask16 __cdecl _mm256_cmpgt_epu16_mask(__m256i, __m256i); 
#line 3947
extern __mmask16 __cdecl _mm256_cmple_epu16_mask(__m256i, __m256i); 
#line 3948
extern __mmask16 __cdecl _mm256_cmplt_epu16_mask(__m256i, __m256i); 
#line 3949
extern __mmask16 __cdecl _mm256_cmpneq_epu16_mask(__m256i, __m256i); 
#line 3951
extern __mmask16 __cdecl _mm256_mask_cmpeq_epi16_mask(__mmask16, __m256i, __m256i); 
#line 3952
extern __mmask16 __cdecl _mm256_mask_cmpge_epi16_mask(__mmask16, __m256i, __m256i); 
#line 3953
extern __mmask16 __cdecl _mm256_mask_cmpgt_epi16_mask(__mmask16, __m256i, __m256i); 
#line 3954
extern __mmask16 __cdecl _mm256_mask_cmple_epi16_mask(__mmask16, __m256i, __m256i); 
#line 3955
extern __mmask16 __cdecl _mm256_mask_cmplt_epi16_mask(__mmask16, __m256i, __m256i); 
#line 3956
extern __mmask16 __cdecl _mm256_mask_cmpneq_epi16_mask(__mmask16, __m256i, __m256i); 
#line 3957
extern __mmask16 __cdecl _mm256_mask_cmpeq_epu16_mask(__mmask16, __m256i, __m256i); 
#line 3958
extern __mmask16 __cdecl _mm256_mask_cmpge_epu16_mask(__mmask16, __m256i, __m256i); 
#line 3959
extern __mmask16 __cdecl _mm256_mask_cmpgt_epu16_mask(__mmask16, __m256i, __m256i); 
#line 3960
extern __mmask16 __cdecl _mm256_mask_cmple_epu16_mask(__mmask16, __m256i, __m256i); 
#line 3961
extern __mmask16 __cdecl _mm256_mask_cmplt_epu16_mask(__mmask16, __m256i, __m256i); 
#line 3962
extern __mmask16 __cdecl _mm256_mask_cmpneq_epu16_mask(__mmask16, __m256i, __m256i); 
#line 3964
extern __mmask8 __cdecl _mm256_cmpeq_epi32_mask(__m256i, __m256i); 
#line 3965
extern __mmask8 __cdecl _mm256_cmpge_epi32_mask(__m256i, __m256i); 
#line 3966
extern __mmask8 __cdecl _mm256_cmpgt_epi32_mask(__m256i, __m256i); 
#line 3967
extern __mmask8 __cdecl _mm256_cmple_epi32_mask(__m256i, __m256i); 
#line 3968
extern __mmask8 __cdecl _mm256_cmplt_epi32_mask(__m256i, __m256i); 
#line 3969
extern __mmask8 __cdecl _mm256_cmpneq_epi32_mask(__m256i, __m256i); 
#line 3970
extern __mmask8 __cdecl _mm256_cmpeq_epu32_mask(__m256i, __m256i); 
#line 3971
extern __mmask8 __cdecl _mm256_cmpge_epu32_mask(__m256i, __m256i); 
#line 3972
extern __mmask8 __cdecl _mm256_cmpgt_epu32_mask(__m256i, __m256i); 
#line 3973
extern __mmask8 __cdecl _mm256_cmple_epu32_mask(__m256i, __m256i); 
#line 3974
extern __mmask8 __cdecl _mm256_cmplt_epu32_mask(__m256i, __m256i); 
#line 3975
extern __mmask8 __cdecl _mm256_cmpneq_epu32_mask(__m256i, __m256i); 
#line 3977
extern __mmask8 __cdecl _mm256_mask_cmpeq_epi32_mask(__mmask8, __m256i, __m256i); 
#line 3978
extern __mmask8 __cdecl _mm256_mask_cmpge_epi32_mask(__mmask8, __m256i, __m256i); 
#line 3979
extern __mmask8 __cdecl _mm256_mask_cmpgt_epi32_mask(__mmask8, __m256i, __m256i); 
#line 3980
extern __mmask8 __cdecl _mm256_mask_cmple_epi32_mask(__mmask8, __m256i, __m256i); 
#line 3981
extern __mmask8 __cdecl _mm256_mask_cmplt_epi32_mask(__mmask8, __m256i, __m256i); 
#line 3982
extern __mmask8 __cdecl _mm256_mask_cmpneq_epi32_mask(__mmask8, __m256i, __m256i); 
#line 3983
extern __mmask8 __cdecl _mm256_mask_cmpeq_epu32_mask(__mmask8, __m256i, __m256i); 
#line 3984
extern __mmask8 __cdecl _mm256_mask_cmpge_epu32_mask(__mmask8, __m256i, __m256i); 
#line 3985
extern __mmask8 __cdecl _mm256_mask_cmpgt_epu32_mask(__mmask8, __m256i, __m256i); 
#line 3986
extern __mmask8 __cdecl _mm256_mask_cmple_epu32_mask(__mmask8, __m256i, __m256i); 
#line 3987
extern __mmask8 __cdecl _mm256_mask_cmplt_epu32_mask(__mmask8, __m256i, __m256i); 
#line 3988
extern __mmask8 __cdecl _mm256_mask_cmpneq_epu32_mask(__mmask8, __m256i, __m256i); 
#line 3990
extern __mmask8 __cdecl _mm256_cmpeq_epi64_mask(__m256i, __m256i); 
#line 3991
extern __mmask8 __cdecl _mm256_cmpge_epi64_mask(__m256i, __m256i); 
#line 3992
extern __mmask8 __cdecl _mm256_cmpgt_epi64_mask(__m256i, __m256i); 
#line 3993
extern __mmask8 __cdecl _mm256_cmple_epi64_mask(__m256i, __m256i); 
#line 3994
extern __mmask8 __cdecl _mm256_cmplt_epi64_mask(__m256i, __m256i); 
#line 3995
extern __mmask8 __cdecl _mm256_cmpneq_epi64_mask(__m256i, __m256i); 
#line 3996
extern __mmask8 __cdecl _mm256_cmpeq_epu64_mask(__m256i, __m256i); 
#line 3997
extern __mmask8 __cdecl _mm256_cmpge_epu64_mask(__m256i, __m256i); 
#line 3998
extern __mmask8 __cdecl _mm256_cmpgt_epu64_mask(__m256i, __m256i); 
#line 3999
extern __mmask8 __cdecl _mm256_cmple_epu64_mask(__m256i, __m256i); 
#line 4000
extern __mmask8 __cdecl _mm256_cmplt_epu64_mask(__m256i, __m256i); 
#line 4001
extern __mmask8 __cdecl _mm256_cmpneq_epu64_mask(__m256i, __m256i); 
#line 4003
extern __mmask8 __cdecl _mm256_mask_cmpeq_epi64_mask(__mmask8, __m256i, __m256i); 
#line 4004
extern __mmask8 __cdecl _mm256_mask_cmpge_epi64_mask(__mmask8, __m256i, __m256i); 
#line 4005
extern __mmask8 __cdecl _mm256_mask_cmpgt_epi64_mask(__mmask8, __m256i, __m256i); 
#line 4006
extern __mmask8 __cdecl _mm256_mask_cmple_epi64_mask(__mmask8, __m256i, __m256i); 
#line 4007
extern __mmask8 __cdecl _mm256_mask_cmplt_epi64_mask(__mmask8, __m256i, __m256i); 
#line 4008
extern __mmask8 __cdecl _mm256_mask_cmpneq_epi64_mask(__mmask8, __m256i, __m256i); 
#line 4009
extern __mmask8 __cdecl _mm256_mask_cmpeq_epu64_mask(__mmask8, __m256i, __m256i); 
#line 4010
extern __mmask8 __cdecl _mm256_mask_cmpge_epu64_mask(__mmask8, __m256i, __m256i); 
#line 4011
extern __mmask8 __cdecl _mm256_mask_cmpgt_epu64_mask(__mmask8, __m256i, __m256i); 
#line 4012
extern __mmask8 __cdecl _mm256_mask_cmple_epu64_mask(__mmask8, __m256i, __m256i); 
#line 4013
extern __mmask8 __cdecl _mm256_mask_cmplt_epu64_mask(__mmask8, __m256i, __m256i); 
#line 4014
extern __mmask8 __cdecl _mm256_mask_cmpneq_epu64_mask(__mmask8, __m256i, __m256i); 
#line 4017
extern __m128d __cdecl _mm_add_round_sd(__m128d, __m128d, int); 
#line 4018
extern __m128d __cdecl _mm_mask_add_round_sd(__m128d, __mmask8, __m128d, __m128d, int); 
#line 4019
extern __m128d __cdecl _mm_maskz_add_round_sd(__mmask8, __m128d, __m128d, int); 
#line 4020
extern __m128 __cdecl _mm_add_round_ss(__m128, __m128, int); 
#line 4021
extern __m128 __cdecl _mm_mask_add_round_ss(__m128, __mmask8, __m128, __m128, int); 
#line 4022
extern __m128 __cdecl _mm_maskz_add_round_ss(__mmask8, __m128, __m128, int); 
#line 4023
extern __m128d __cdecl _mm_mask_add_sd(__m128d, __mmask8, __m128d, __m128d); 
#line 4024
extern __m128d __cdecl _mm_maskz_add_sd(__mmask8, __m128d, __m128d); 
#line 4025
extern __m128 __cdecl _mm_mask_add_ss(__m128, __mmask8, __m128, __m128); 
#line 4026
extern __m128 __cdecl _mm_maskz_add_ss(__mmask8, __m128, __m128); 
#line 4027
extern __mmask8 __cdecl _mm_cmp_round_sd_mask(__m128d, __m128d, const int, const int); 
#line 4028
extern __mmask8 __cdecl _mm_mask_cmp_round_sd_mask(__mmask8, __m128d, __m128d, const int, const int); 
#line 4029
extern __mmask8 __cdecl _mm_cmp_round_ss_mask(__m128, __m128, const int, const int); 
#line 4030
extern __mmask8 __cdecl _mm_mask_cmp_round_ss_mask(__mmask8, __m128, __m128, const int, const int); 
#line 4031
extern __mmask8 __cdecl _mm_cmp_sd_mask(__m128d, __m128d, const int); 
#line 4032
extern __mmask8 __cdecl _mm_mask_cmp_sd_mask(__mmask8, __m128d, __m128d, const int); 
#line 4033
extern __mmask8 __cdecl _mm_cmp_ss_mask(__m128, __m128, const int); 
#line 4034
extern __mmask8 __cdecl _mm_mask_cmp_ss_mask(__mmask8, __m128, __m128, const int); 
#line 4035
extern int __cdecl _mm_comi_round_sd(__m128d, __m128d, const int, const int); 
#line 4036
extern int __cdecl _mm_comi_round_ss(__m128, __m128, const int, const int); 
#line 4037
extern __m128 __cdecl _mm_cvt_roundi32_ss(__m128, int, int); 
#line 4038
extern int __cdecl _mm_cvt_roundsd_i32(__m128d, int); 
#line 4039
extern int __cdecl _mm_cvt_roundsd_si32(__m128d, int); 
#line 4040
extern __m128 __cdecl _mm_cvt_roundsd_ss(__m128, __m128d, int); 
#line 4041
extern __m128 __cdecl _mm_mask_cvt_roundsd_ss(__m128, __mmask8, __m128, __m128d, int); 
#line 4042
extern __m128 __cdecl _mm_maskz_cvt_roundsd_ss(__mmask8, __m128, __m128d, int); 
#line 4043
extern unsigned __cdecl _mm_cvt_roundsd_u32(__m128d, int); 
#line 4044
extern __m128 __cdecl _mm_cvt_roundsi32_ss(__m128, int, int); 
#line 4045
extern int __cdecl _mm_cvt_roundss_i32(__m128, int); 
#line 4046
extern __m128d __cdecl _mm_cvt_roundss_sd(__m128d, __m128, int); 
#line 4047
extern __m128d __cdecl _mm_mask_cvt_roundss_sd(__m128d, __mmask8, __m128d, __m128, int); 
#line 4048
extern __m128d __cdecl _mm_maskz_cvt_roundss_sd(__mmask8, __m128d, __m128, int); 
#line 4049
extern int __cdecl _mm_cvt_roundss_si32(__m128, int); 
#line 4050
extern unsigned __cdecl _mm_cvt_roundss_u32(__m128, int); 
#line 4051
extern __m128 __cdecl _mm_cvt_roundu32_ss(__m128, unsigned, int); 
#line 4052
extern __m128d __cdecl _mm_cvti32_sd(__m128d, int); 
#line 4053
extern __m128 __cdecl _mm_cvti32_ss(__m128, int); 
#line 4054
extern int __cdecl _mm_cvtsd_i32(__m128d); 
#line 4055
extern __m128 __cdecl _mm_mask_cvtsd_ss(__m128, __mmask8, __m128, __m128d); 
#line 4056
extern __m128 __cdecl _mm_maskz_cvtsd_ss(__mmask8, __m128, __m128d); 
#line 4057
extern unsigned __cdecl _mm_cvtsd_u32(__m128d); 
#line 4058
extern int __cdecl _mm_cvtss_i32(__m128); 
#line 4059
extern __m128d __cdecl _mm_mask_cvtss_sd(__m128d, __mmask8, __m128d, __m128); 
#line 4060
extern __m128d __cdecl _mm_maskz_cvtss_sd(__mmask8, __m128d, __m128); 
#line 4061
extern unsigned __cdecl _mm_cvtss_u32(__m128); 
#line 4062
extern int __cdecl _mm_cvtt_roundsd_i32(__m128d, int); 
#line 4063
extern int __cdecl _mm_cvtt_roundsd_si32(__m128d, int); 
#line 4064
extern unsigned __cdecl _mm_cvtt_roundsd_u32(__m128d, int); 
#line 4065
extern int __cdecl _mm_cvtt_roundss_i32(__m128, int); 
#line 4066
extern int __cdecl _mm_cvtt_roundss_si32(__m128, int); 
#line 4067
extern unsigned __cdecl _mm_cvtt_roundss_u32(__m128, int); 
#line 4068
extern int __cdecl _mm_cvttsd_i32(__m128d); 
#line 4069
extern unsigned __cdecl _mm_cvttsd_u32(__m128d); 
#line 4070
extern int __cdecl _mm_cvttss_i32(__m128); 
#line 4071
extern unsigned __cdecl _mm_cvttss_u32(__m128); 
#line 4072
extern __m128d __cdecl _mm_cvtu32_sd(__m128d, unsigned); 
#line 4073
extern __m128 __cdecl _mm_cvtu32_ss(__m128, unsigned); 
#line 4074
extern __m128d __cdecl _mm_div_round_sd(__m128d, __m128d, int); 
#line 4075
extern __m128d __cdecl _mm_mask_div_round_sd(__m128d, __mmask8, __m128d, __m128d, int); 
#line 4076
extern __m128d __cdecl _mm_maskz_div_round_sd(__mmask8, __m128d, __m128d, int); 
#line 4077
extern __m128 __cdecl _mm_div_round_ss(__m128, __m128, int); 
#line 4078
extern __m128 __cdecl _mm_mask_div_round_ss(__m128, __mmask8, __m128, __m128, int); 
#line 4079
extern __m128 __cdecl _mm_maskz_div_round_ss(__mmask8, __m128, __m128, int); 
#line 4080
extern __m128d __cdecl _mm_mask_div_sd(__m128d, __mmask8, __m128d, __m128d); 
#line 4081
extern __m128d __cdecl _mm_maskz_div_sd(__mmask8, __m128d, __m128d); 
#line 4082
extern __m128 __cdecl _mm_mask_div_ss(__m128, __mmask8, __m128, __m128); 
#line 4083
extern __m128 __cdecl _mm_maskz_div_ss(__mmask8, __m128, __m128); 
#line 4084
extern __m128d __cdecl _mm_fixupimm_round_sd(__m128d, __m128d, __m128i, const int, int); 
#line 4085
extern __m128d __cdecl _mm_mask_fixupimm_round_sd(__m128d, __mmask8, __m128d, __m128i, const int, const int); 
#line 4086
extern __m128d __cdecl _mm_maskz_fixupimm_round_sd(__mmask8, __m128d, __m128d, __m128i, const int, const int); 
#line 4087
extern __m128 __cdecl _mm_fixupimm_round_ss(__m128, __m128, __m128i, const int, const int); 
#line 4088
extern __m128 __cdecl _mm_mask_fixupimm_round_ss(__m128, __mmask8, __m128, __m128i, const int, const int); 
#line 4089
extern __m128 __cdecl _mm_maskz_fixupimm_round_ss(__mmask8, __m128, __m128, __m128i, const int, const int); 
#line 4090
extern __m128d __cdecl _mm_fixupimm_sd(__m128d, __m128d, __m128i, const int); 
#line 4091
extern __m128d __cdecl _mm_mask_fixupimm_sd(__m128d, __mmask8, __m128d, __m128i, const int); 
#line 4092
extern __m128d __cdecl _mm_maskz_fixupimm_sd(__mmask8, __m128d, __m128d, __m128i, const int); 
#line 4093
extern __m128 __cdecl _mm_fixupimm_ss(__m128, __m128, __m128i, const int); 
#line 4094
extern __m128 __cdecl _mm_mask_fixupimm_ss(__m128, __mmask8, __m128, __m128i, const int); 
#line 4095
extern __m128 __cdecl _mm_maskz_fixupimm_ss(__mmask8, __m128, __m128, __m128i, const int); 
#line 4096
extern __m128d __cdecl _mm_fmadd_round_sd(__m128d, __m128d, __m128d, int); 
#line 4097
extern __m128d __cdecl _mm_mask_fmadd_round_sd(__m128d, __mmask8, __m128d, __m128d, int); 
#line 4098
extern __m128d __cdecl _mm_mask3_fmadd_round_sd(__m128d, __m128d, __m128d, __mmask8, int); 
#line 4099
extern __m128d __cdecl _mm_maskz_fmadd_round_sd(__mmask8, __m128d, __m128d, __m128d, int); 
#line 4100
extern __m128 __cdecl _mm_fmadd_round_ss(__m128, __m128, __m128, int); 
#line 4101
extern __m128 __cdecl _mm_mask_fmadd_round_ss(__m128, __mmask8, __m128, __m128, int); 
#line 4102
extern __m128 __cdecl _mm_mask3_fmadd_round_ss(__m128, __m128, __m128, __mmask8, int); 
#line 4103
extern __m128 __cdecl _mm_maskz_fmadd_round_ss(__mmask8, __m128, __m128, __m128, int); 
#line 4104
extern __m128d __cdecl _mm_mask_fmadd_sd(__m128d, __mmask8, __m128d, __m128d); 
#line 4105
extern __m128d __cdecl _mm_mask3_fmadd_sd(__m128d, __m128d, __m128d, __mmask8); 
#line 4106
extern __m128d __cdecl _mm_maskz_fmadd_sd(__mmask8, __m128d, __m128d, __m128d); 
#line 4107
extern __m128 __cdecl _mm_mask_fmadd_ss(__m128, __mmask8, __m128, __m128); 
#line 4108
extern __m128 __cdecl _mm_mask3_fmadd_ss(__m128, __m128, __m128, __mmask8); 
#line 4109
extern __m128 __cdecl _mm_maskz_fmadd_ss(__mmask8, __m128, __m128, __m128); 
#line 4110
extern __m128d __cdecl _mm_fmsub_round_sd(__m128d, __m128d, __m128d, int); 
#line 4111
extern __m128d __cdecl _mm_mask_fmsub_round_sd(__m128d, __mmask8, __m128d, __m128d, int); 
#line 4112
extern __m128d __cdecl _mm_mask3_fmsub_round_sd(__m128d, __m128d, __m128d, __mmask8, int); 
#line 4113
extern __m128d __cdecl _mm_maskz_fmsub_round_sd(__mmask8, __m128d, __m128d, __m128d, int); 
#line 4114
extern __m128 __cdecl _mm_fmsub_round_ss(__m128, __m128, __m128, int); 
#line 4115
extern __m128 __cdecl _mm_mask_fmsub_round_ss(__m128, __mmask8, __m128, __m128, int); 
#line 4116
extern __m128 __cdecl _mm_mask3_fmsub_round_ss(__m128, __m128, __m128, __mmask8, int); 
#line 4117
extern __m128 __cdecl _mm_maskz_fmsub_round_ss(__mmask8, __m128, __m128, __m128, int); 
#line 4118
extern __m128d __cdecl _mm_mask_fmsub_sd(__m128d, __mmask8, __m128d, __m128d); 
#line 4119
extern __m128d __cdecl _mm_mask3_fmsub_sd(__m128d, __m128d, __m128d, __mmask8); 
#line 4120
extern __m128d __cdecl _mm_maskz_fmsub_sd(__mmask8, __m128d, __m128d, __m128d); 
#line 4121
extern __m128 __cdecl _mm_mask_fmsub_ss(__m128, __mmask8, __m128, __m128); 
#line 4122
extern __m128 __cdecl _mm_mask3_fmsub_ss(__m128, __m128, __m128, __mmask8); 
#line 4123
extern __m128 __cdecl _mm_maskz_fmsub_ss(__mmask8, __m128, __m128, __m128); 
#line 4124
extern __m128d __cdecl _mm_fnmadd_round_sd(__m128d, __m128d, __m128d, int); 
#line 4125
extern __m128d __cdecl _mm_mask_fnmadd_round_sd(__m128d, __mmask8, __m128d, __m128d, int); 
#line 4126
extern __m128d __cdecl _mm_mask3_fnmadd_round_sd(__m128d, __m128d, __m128d, __mmask8, int); 
#line 4127
extern __m128d __cdecl _mm_maskz_fnmadd_round_sd(__mmask8, __m128d, __m128d, __m128d, int); 
#line 4128
extern __m128 __cdecl _mm_fnmadd_round_ss(__m128, __m128, __m128, int); 
#line 4129
extern __m128 __cdecl _mm_mask_fnmadd_round_ss(__m128, __mmask8, __m128, __m128, int); 
#line 4130
extern __m128 __cdecl _mm_mask3_fnmadd_round_ss(__m128, __m128, __m128, __mmask8, int); 
#line 4131
extern __m128 __cdecl _mm_maskz_fnmadd_round_ss(__mmask8, __m128, __m128, __m128, int); 
#line 4132
extern __m128d __cdecl _mm_mask_fnmadd_sd(__m128d, __mmask8, __m128d, __m128d); 
#line 4133
extern __m128d __cdecl _mm_mask3_fnmadd_sd(__m128d, __m128d, __m128d, __mmask8); 
#line 4134
extern __m128d __cdecl _mm_maskz_fnmadd_sd(__mmask8, __m128d, __m128d, __m128d); 
#line 4135
extern __m128 __cdecl _mm_mask_fnmadd_ss(__m128, __mmask8, __m128, __m128); 
#line 4136
extern __m128 __cdecl _mm_mask3_fnmadd_ss(__m128, __m128, __m128, __mmask8); 
#line 4137
extern __m128 __cdecl _mm_maskz_fnmadd_ss(__mmask8, __m128, __m128, __m128); 
#line 4138
extern __m128d __cdecl _mm_fnmsub_round_sd(__m128d, __m128d, __m128d, int); 
#line 4139
extern __m128d __cdecl _mm_mask_fnmsub_round_sd(__m128d, __mmask8, __m128d, __m128d, int); 
#line 4140
extern __m128d __cdecl _mm_mask3_fnmsub_round_sd(__m128d, __m128d, __m128d, __mmask8, int); 
#line 4141
extern __m128d __cdecl _mm_maskz_fnmsub_round_sd(__mmask8, __m128d, __m128d, __m128d, int); 
#line 4142
extern __m128 __cdecl _mm_fnmsub_round_ss(__m128, __m128, __m128, int); 
#line 4143
extern __m128 __cdecl _mm_mask_fnmsub_round_ss(__m128, __mmask8, __m128, __m128, int); 
#line 4144
extern __m128 __cdecl _mm_mask3_fnmsub_round_ss(__m128, __m128, __m128, __mmask8, int); 
#line 4145
extern __m128 __cdecl _mm_maskz_fnmsub_round_ss(__mmask8, __m128, __m128, __m128, int); 
#line 4146
extern __m128d __cdecl _mm_mask_fnmsub_sd(__m128d, __mmask8, __m128d, __m128d); 
#line 4147
extern __m128d __cdecl _mm_mask3_fnmsub_sd(__m128d, __m128d, __m128d, __mmask8); 
#line 4148
extern __m128d __cdecl _mm_maskz_fnmsub_sd(__mmask8, __m128d, __m128d, __m128d); 
#line 4149
extern __m128 __cdecl _mm_mask_fnmsub_ss(__m128, __mmask8, __m128, __m128); 
#line 4150
extern __m128 __cdecl _mm_mask3_fnmsub_ss(__m128, __m128, __m128, __mmask8); 
#line 4151
extern __m128 __cdecl _mm_maskz_fnmsub_ss(__mmask8, __m128, __m128, __m128); 
#line 4152
extern __mmask8 __cdecl _mm_fpclass_sd_mask(__m128d, int); 
#line 4153
extern __mmask8 __cdecl _mm_mask_fpclass_sd_mask(__mmask8, __m128d, int); 
#line 4154
extern __mmask8 __cdecl _mm_fpclass_ss_mask(__m128, int); 
#line 4155
extern __mmask8 __cdecl _mm_mask_fpclass_ss_mask(__mmask8, __m128, int); 
#line 4156
extern __m128d __cdecl _mm_getexp_round_sd(__m128d, __m128d, const int); 
#line 4157
extern __m128d __cdecl _mm_mask_getexp_round_sd(__m128d, __mmask8, __m128d, __m128d, const int); 
#line 4158
extern __m128d __cdecl _mm_maskz_getexp_round_sd(__mmask8, __m128d, __m128d, const int); 
#line 4159
extern __m128 __cdecl _mm_getexp_round_ss(__m128, __m128, const int); 
#line 4160
extern __m128 __cdecl _mm_mask_getexp_round_ss(__m128, __mmask8, __m128, __m128, const int); 
#line 4161
extern __m128 __cdecl _mm_maskz_getexp_round_ss(__mmask8, __m128, __m128, const int); 
#line 4162
extern __m128d __cdecl _mm_getexp_sd(__m128d, __m128d); 
#line 4163
extern __m128d __cdecl _mm_mask_getexp_sd(__m128d, __mmask8, __m128d, __m128d); 
#line 4164
extern __m128d __cdecl _mm_maskz_getexp_sd(__mmask8, __m128d, __m128d); 
#line 4165
extern __m128 __cdecl _mm_getexp_ss(__m128, __m128); 
#line 4166
extern __m128 __cdecl _mm_mask_getexp_ss(__m128, __mmask8, __m128, __m128); 
#line 4167
extern __m128 __cdecl _mm_maskz_getexp_ss(__mmask8, __m128, __m128); 
#line 4168
extern __m128d __cdecl _mm_getmant_round_sd(__m128d, __m128d, int, int, int); 
#line 4169
extern __m128d __cdecl _mm_mask_getmant_round_sd(__m128d, __mmask8, __m128d, __m128d, int, int, int); 
#line 4170
extern __m128d __cdecl _mm_maskz_getmant_round_sd(__mmask8, __m128d, __m128d, int, int, int); 
#line 4171
extern __m128 __cdecl _mm_getmant_round_ss(__m128, __m128, int, int, int); 
#line 4172
extern __m128 __cdecl _mm_mask_getmant_round_ss(__m128, __mmask8, __m128, __m128, int, int, int); 
#line 4173
extern __m128 __cdecl _mm_maskz_getmant_round_ss(__mmask8, __m128, __m128, int, int, int); 
#line 4174
extern __m128d __cdecl _mm_getmant_sd(__m128d, __m128d, int, int); 
#line 4175
extern __m128d __cdecl _mm_mask_getmant_sd(__m128d, __mmask8, __m128d, __m128d, int, int); 
#line 4176
extern __m128d __cdecl _mm_maskz_getmant_sd(__mmask8, __m128d, __m128d, int, int); 
#line 4177
extern __m128 __cdecl _mm_getmant_ss(__m128, __m128, int, int); 
#line 4178
extern __m128 __cdecl _mm_mask_getmant_ss(__m128, __mmask8, __m128, __m128, int, int); 
#line 4179
extern __m128 __cdecl _mm_maskz_getmant_ss(__mmask8, __m128, __m128, int, int); 
#line 4180
extern __m128d __cdecl _mm_mask_load_sd(__m128d, __mmask8, const double *); 
#line 4181
extern __m128d __cdecl _mm_maskz_load_sd(__mmask8, const double *); 
#line 4182
extern __m128 __cdecl _mm_mask_load_ss(__m128, __mmask8, const float *); 
#line 4183
extern __m128 __cdecl _mm_maskz_load_ss(__mmask8, const float *); 
#line 4184
extern __m128d __cdecl _mm_mask_max_round_sd(__m128d, __mmask8, __m128d, __m128d, int); 
#line 4185
extern __m128d __cdecl _mm_maskz_max_round_sd(__mmask8, __m128d, __m128d, int); 
#line 4186
extern __m128d __cdecl _mm_max_round_sd(__m128d, __m128d, int); 
#line 4187
extern __m128 __cdecl _mm_mask_max_round_ss(__m128, __mmask8, __m128, __m128, int); 
#line 4188
extern __m128 __cdecl _mm_maskz_max_round_ss(__mmask8, __m128, __m128, int); 
#line 4189
extern __m128 __cdecl _mm_max_round_ss(__m128, __m128, int); 
#line 4190
extern __m128d __cdecl _mm_mask_max_sd(__m128d, __mmask8, __m128d, __m128d); 
#line 4191
extern __m128d __cdecl _mm_maskz_max_sd(__mmask8, __m128d, __m128d); 
#line 4192
extern __m128 __cdecl _mm_mask_max_ss(__m128, __mmask8, __m128, __m128); 
#line 4193
extern __m128 __cdecl _mm_maskz_max_ss(__mmask8, __m128, __m128); 
#line 4194
extern __m128d __cdecl _mm_mask_min_round_sd(__m128d, __mmask8, __m128d, __m128d, int); 
#line 4195
extern __m128d __cdecl _mm_maskz_min_round_sd(__mmask8, __m128d, __m128d, int); 
#line 4196
extern __m128d __cdecl _mm_min_round_sd(__m128d, __m128d, int); 
#line 4197
extern __m128 __cdecl _mm_mask_min_round_ss(__m128, __mmask8, __m128, __m128, int); 
#line 4198
extern __m128 __cdecl _mm_maskz_min_round_ss(__mmask8, __m128, __m128, int); 
#line 4199
extern __m128 __cdecl _mm_min_round_ss(__m128, __m128, int); 
#line 4200
extern __m128d __cdecl _mm_mask_min_sd(__m128d, __mmask8, __m128d, __m128d); 
#line 4201
extern __m128d __cdecl _mm_maskz_min_sd(__mmask8, __m128d, __m128d); 
#line 4202
extern __m128 __cdecl _mm_mask_min_ss(__m128, __mmask8, __m128, __m128); 
#line 4203
extern __m128 __cdecl _mm_maskz_min_ss(__mmask8, __m128, __m128); 
#line 4204
extern __m128d __cdecl _mm_mask_move_sd(__m128d, __mmask8, __m128d, __m128d); 
#line 4205
extern __m128d __cdecl _mm_maskz_move_sd(__mmask8, __m128d, __m128d); 
#line 4206
extern __m128 __cdecl _mm_mask_move_ss(__m128, __mmask8, __m128, __m128); 
#line 4207
extern __m128 __cdecl _mm_maskz_move_ss(__mmask8, __m128, __m128); 
#line 4208
extern __m128d __cdecl _mm_mask_mul_round_sd(__m128d, __mmask8, __m128d, __m128d, int); 
#line 4209
extern __m128d __cdecl _mm_maskz_mul_round_sd(__mmask8, __m128d, __m128d, int); 
#line 4210
extern __m128d __cdecl _mm_mul_round_sd(__m128d, __m128d, int); 
#line 4211
extern __m128 __cdecl _mm_mask_mul_round_ss(__m128, __mmask8, __m128, __m128, int); 
#line 4212
extern __m128 __cdecl _mm_maskz_mul_round_ss(__mmask8, __m128, __m128, int); 
#line 4213
extern __m128 __cdecl _mm_mul_round_ss(__m128, __m128, int); 
#line 4214
extern __m128d __cdecl _mm_mask_mul_sd(__m128d, __mmask8, __m128d, __m128d); 
#line 4215
extern __m128d __cdecl _mm_maskz_mul_sd(__mmask8, __m128d, __m128d); 
#line 4216
extern __m128 __cdecl _mm_mask_mul_ss(__m128, __mmask8, __m128, __m128); 
#line 4217
extern __m128 __cdecl _mm_maskz_mul_ss(__mmask8, __m128, __m128); 
#line 4218
extern __m128d __cdecl _mm_range_sd(__m128d, __m128d, const int); 
#line 4219
extern __m128d __cdecl _mm_mask_range_sd(__m128d, __mmask8, __m128d, __m128d, const int); 
#line 4220
extern __m128d __cdecl _mm_maskz_range_sd(__mmask8, __m128d, __m128d, const int); 
#line 4221
extern __m128d __cdecl _mm_range_round_sd(__m128d, __m128d, const int, int); 
#line 4222
extern __m128d __cdecl _mm_mask_range_round_sd(__m128d, __mmask8, __m128d, __m128d, const int, int); 
#line 4223
extern __m128d __cdecl _mm_maskz_range_round_sd(__mmask8, __m128d, __m128d, const int, int); 
#line 4224
extern __m128 __cdecl _mm_range_ss(__m128, __m128, const int); 
#line 4225
extern __m128 __cdecl _mm_mask_range_ss(__m128, __mmask8, __m128, __m128, const int); 
#line 4226
extern __m128 __cdecl _mm_maskz_range_ss(__mmask8, __m128, __m128, const int); 
#line 4227
extern __m128 __cdecl _mm_range_round_ss(__m128, __m128, const int, int); 
#line 4228
extern __m128 __cdecl _mm_mask_range_round_ss(__m128, __mmask8, __m128, __m128, const int, int); 
#line 4229
extern __m128 __cdecl _mm_maskz_range_round_ss(__mmask8, __m128, __m128, const int, int); 
#line 4230
extern __m128d __cdecl _mm_mask_rcp14_sd(__m128d, __mmask8, __m128d, __m128d); 
#line 4231
extern __m128d __cdecl _mm_maskz_rcp14_sd(__mmask8, __m128d, __m128d); 
#line 4232
extern __m128d __cdecl _mm_rcp14_sd(__m128d, __m128d); 
#line 4233
extern __m128 __cdecl _mm_mask_rcp14_ss(__m128, __mmask8, __m128, __m128); 
#line 4234
extern __m128 __cdecl _mm_maskz_rcp14_ss(__mmask8, __m128, __m128); 
#line 4235
extern __m128 __cdecl _mm_rcp14_ss(__m128, __m128); 
#line 4236
extern __m128d __cdecl _mm_mask_rcp28_round_sd(__m128d, __mmask8, __m128d, __m128d, int); 
#line 4237
extern __m128d __cdecl _mm_maskz_rcp28_round_sd(__mmask8, __m128d, __m128d, int); 
#line 4238
extern __m128d __cdecl _mm_rcp28_round_sd(__m128d, __m128d, int); 
#line 4239
extern __m128 __cdecl _mm_mask_rcp28_round_ss(__m128, __mmask8, __m128, __m128, int); 
#line 4240
extern __m128 __cdecl _mm_maskz_rcp28_round_ss(__mmask8, __m128, __m128, int); 
#line 4241
extern __m128 __cdecl _mm_rcp28_round_ss(__m128, __m128, int); 
#line 4242
extern __m128d __cdecl _mm_mask_rcp28_sd(__m128d, __mmask8, __m128d, __m128d); 
#line 4243
extern __m128d __cdecl _mm_maskz_rcp28_sd(__mmask8, __m128d, __m128d); 
#line 4244
extern __m128d __cdecl _mm_rcp28_sd(__m128d, __m128d); 
#line 4245
extern __m128 __cdecl _mm_mask_rcp28_ss(__m128, __mmask8, __m128, __m128); 
#line 4246
extern __m128 __cdecl _mm_maskz_rcp28_ss(__mmask8, __m128, __m128); 
#line 4247
extern __m128 __cdecl _mm_rcp28_ss(__m128, __m128); 
#line 4248
extern __m128d __cdecl _mm_mask_reduce_round_sd(__m128d, __mmask8, __m128d, __m128d, const int, int); 
#line 4249
extern __m128d __cdecl _mm_maskz_reduce_round_sd(__mmask8, __m128d, __m128d, const int, int); 
#line 4250
extern __m128d __cdecl _mm_reduce_round_sd(__m128d, __m128d, const int, int); 
#line 4251
extern __m128 __cdecl _mm_mask_reduce_round_ss(__m128, __mmask8, __m128, __m128, const int, int); 
#line 4252
extern __m128 __cdecl _mm_maskz_reduce_round_ss(__mmask8, __m128, __m128, const int, int); 
#line 4253
extern __m128 __cdecl _mm_reduce_round_ss(__m128, __m128, const int, int); 
#line 4254
extern __m128d __cdecl _mm_mask_reduce_sd(__m128d, __mmask8, __m128d, __m128d, const int); 
#line 4255
extern __m128d __cdecl _mm_maskz_reduce_sd(__mmask8, __m128d, __m128d, const int); 
#line 4256
extern __m128d __cdecl _mm_reduce_sd(__m128d, __m128d, const int); 
#line 4257
extern __m128 __cdecl _mm_mask_reduce_ss(__m128, __mmask8, __m128, __m128, const int); 
#line 4258
extern __m128 __cdecl _mm_maskz_reduce_ss(__mmask8, __m128, __m128, const int); 
#line 4259
extern __m128 __cdecl _mm_reduce_ss(__m128, __m128, const int); 
#line 4260
extern __m128d __cdecl _mm_mask_roundscale_round_sd(__m128d, __mmask8, __m128d, __m128d, const int, const int); 
#line 4261
extern __m128d __cdecl _mm_maskz_roundscale_round_sd(__mmask8, __m128d, __m128d, const int, const int); 
#line 4262
extern __m128d __cdecl _mm_roundscale_round_sd(__m128d, __m128d, const int, const int); 
#line 4263
extern __m128 __cdecl _mm_mask_roundscale_round_ss(__m128, __mmask8, __m128, __m128, const int, const int); 
#line 4264
extern __m128 __cdecl _mm_maskz_roundscale_round_ss(__mmask8, __m128, __m128, const int, const int); 
#line 4265
extern __m128 __cdecl _mm_roundscale_round_ss(__m128, __m128, const int, const int); 
#line 4266
extern __m128d __cdecl _mm_mask_roundscale_sd(__m128d, __mmask8, __m128d, __m128d, const int); 
#line 4267
extern __m128d __cdecl _mm_maskz_roundscale_sd(__mmask8, __m128d, __m128d, const int); 
#line 4268
extern __m128d __cdecl _mm_roundscale_sd(__m128d, __m128d, const int); 
#line 4269
extern __m128 __cdecl _mm_mask_roundscale_ss(__m128, __mmask8, __m128, __m128, const int); 
#line 4270
extern __m128 __cdecl _mm_maskz_roundscale_ss(__mmask8, __m128, __m128, const int); 
#line 4271
extern __m128 __cdecl _mm_roundscale_ss(__m128, __m128, const int); 
#line 4272
extern __m128d __cdecl _mm_mask_rsqrt14_sd(__m128d, __mmask8, __m128d, __m128d); 
#line 4273
extern __m128d __cdecl _mm_maskz_rsqrt14_sd(__mmask8, __m128d, __m128d); 
#line 4274
extern __m128d __cdecl _mm_rsqrt14_sd(__m128d, __m128d); 
#line 4275
extern __m128 __cdecl _mm_mask_rsqrt14_ss(__m128, __mmask8, __m128, __m128); 
#line 4276
extern __m128 __cdecl _mm_maskz_rsqrt14_ss(__mmask8, __m128, __m128); 
#line 4277
extern __m128 __cdecl _mm_rsqrt14_ss(__m128, __m128); 
#line 4278
extern __m128d __cdecl _mm_mask_rsqrt28_round_sd(__m128d, __mmask8, __m128d, __m128d, int); 
#line 4279
extern __m128d __cdecl _mm_maskz_rsqrt28_round_sd(__mmask8, __m128d, __m128d, int); 
#line 4280
extern __m128d __cdecl _mm_rsqrt28_round_sd(__m128d, __m128d, int); 
#line 4281
extern __m128 __cdecl _mm_mask_rsqrt28_round_ss(__m128, __mmask8, __m128, __m128, int); 
#line 4282
extern __m128 __cdecl _mm_maskz_rsqrt28_round_ss(__mmask8, __m128, __m128, int); 
#line 4283
extern __m128 __cdecl _mm_rsqrt28_round_ss(__m128, __m128, int); 
#line 4284
extern __m128d __cdecl _mm_mask_rsqrt28_sd(__m128d, __mmask8, __m128d, __m128d); 
#line 4285
extern __m128d __cdecl _mm_maskz_rsqrt28_sd(__mmask8, __m128d, __m128d); 
#line 4286
extern __m128d __cdecl _mm_rsqrt28_sd(__m128d, __m128d); 
#line 4287
extern __m128 __cdecl _mm_mask_rsqrt28_ss(__m128, __mmask8, __m128, __m128); 
#line 4288
extern __m128 __cdecl _mm_maskz_rsqrt28_ss(__mmask8, __m128, __m128); 
#line 4289
extern __m128 __cdecl _mm_rsqrt28_ss(__m128, __m128); 
#line 4290
extern __m128d __cdecl _mm_mask_scalef_round_sd(__m128d, __mmask8, __m128d, __m128d, int); 
#line 4291
extern __m128d __cdecl _mm_maskz_scalef_round_sd(__mmask8, __m128d, __m128d, int); 
#line 4292
extern __m128d __cdecl _mm_scalef_round_sd(__m128d, __m128d, int); 
#line 4293
extern __m128 __cdecl _mm_mask_scalef_round_ss(__m128, __mmask8, __m128, __m128, int); 
#line 4294
extern __m128 __cdecl _mm_maskz_scalef_round_ss(__mmask8, __m128, __m128, int); 
#line 4295
extern __m128 __cdecl _mm_scalef_round_ss(__m128, __m128, int); 
#line 4296
extern __m128d __cdecl _mm_mask_scalef_sd(__m128d, __mmask8, __m128d, __m128d); 
#line 4297
extern __m128d __cdecl _mm_maskz_scalef_sd(__mmask8, __m128d, __m128d); 
#line 4298
extern __m128d __cdecl _mm_scalef_sd(__m128d, __m128d); 
#line 4299
extern __m128 __cdecl _mm_mask_scalef_ss(__m128, __mmask8, __m128, __m128); 
#line 4300
extern __m128 __cdecl _mm_maskz_scalef_ss(__mmask8, __m128, __m128); 
#line 4301
extern __m128 __cdecl _mm_scalef_ss(__m128, __m128); 
#line 4302
extern __m128d __cdecl _mm_mask_sqrt_round_sd(__m128d, __mmask8, __m128d, __m128d, int); 
#line 4303
extern __m128d __cdecl _mm_maskz_sqrt_round_sd(__mmask8, __m128d, __m128d, int); 
#line 4304
extern __m128d __cdecl _mm_sqrt_round_sd(__m128d, __m128d, int); 
#line 4305
extern __m128 __cdecl _mm_mask_sqrt_round_ss(__m128, __mmask8, __m128, __m128, int); 
#line 4306
extern __m128 __cdecl _mm_maskz_sqrt_round_ss(__mmask8, __m128, __m128, int); 
#line 4307
extern __m128 __cdecl _mm_sqrt_round_ss(__m128, __m128, int); 
#line 4308
extern __m128d __cdecl _mm_mask_sqrt_sd(__m128d, __mmask8, __m128d, __m128d); 
#line 4309
extern __m128d __cdecl _mm_maskz_sqrt_sd(__mmask8, __m128d, __m128d); 
#line 4310
extern __m128 __cdecl _mm_mask_sqrt_ss(__m128, __mmask8, __m128, __m128); 
#line 4311
extern __m128 __cdecl _mm_maskz_sqrt_ss(__mmask8, __m128, __m128); 
#line 4312
extern void __cdecl _mm_mask_store_sd(double *, __mmask8, __m128d); 
#line 4313
extern void __cdecl _mm_mask_store_ss(float *, __mmask8, __m128); 
#line 4314
extern __m128d __cdecl _mm_mask_sub_round_sd(__m128d, __mmask8, __m128d, __m128d, int); 
#line 4315
extern __m128d __cdecl _mm_maskz_sub_round_sd(__mmask8, __m128d, __m128d, int); 
#line 4316
extern __m128d __cdecl _mm_sub_round_sd(__m128d, __m128d, int); 
#line 4317
extern __m128 __cdecl _mm_mask_sub_round_ss(__m128, __mmask8, __m128, __m128, int); 
#line 4318
extern __m128 __cdecl _mm_maskz_sub_round_ss(__mmask8, __m128, __m128, int); 
#line 4319
extern __m128 __cdecl _mm_sub_round_ss(__m128, __m128, int); 
#line 4320
extern __m128d __cdecl _mm_mask_sub_sd(__m128d, __mmask8, __m128d, __m128d); 
#line 4321
extern __m128d __cdecl _mm_maskz_sub_sd(__mmask8, __m128d, __m128d); 
#line 4322
extern __m128 __cdecl _mm_mask_sub_ss(__m128, __mmask8, __m128, __m128); 
#line 4323
extern __m128 __cdecl _mm_maskz_sub_ss(__mmask8, __m128, __m128); 
#line 4327
extern unsigned __int64 __cdecl _mm_cvtsd_u64(__m128d); 
#line 4328
extern unsigned __int64 __cdecl _mm_cvtss_u64(__m128); 
#line 4329
extern unsigned __int64 __cdecl _mm_cvttsd_u64(__m128d); 
#line 4330
extern unsigned __int64 __cdecl _mm_cvttss_u64(__m128); 
#line 4331
extern unsigned __int64 __cdecl _mm_cvt_roundsd_u64(__m128d, int); 
#line 4332
extern unsigned __int64 __cdecl _mm_cvt_roundss_u64(__m128, int); 
#line 4333
extern unsigned __int64 __cdecl _mm_cvtt_roundsd_u64(__m128d, int); 
#line 4334
extern unsigned __int64 __cdecl _mm_cvtt_roundss_u64(__m128, int); 
#line 4336
extern __m128d __cdecl _mm_cvti64_sd(__m128d, __int64); 
#line 4337
extern __m128 __cdecl _mm_cvti64_ss(__m128, __int64); 
#line 4338
extern __int64 __cdecl _mm_cvtsd_i64(__m128d); 
#line 4339
extern __int64 __cdecl _mm_cvtss_i64(__m128); 
#line 4340
extern __int64 __cdecl _mm_cvttsd_i64(__m128d); 
#line 4341
extern __int64 __cdecl _mm_cvttss_i64(__m128); 
#line 4342
extern __int64 __cdecl _mm_cvtt_roundsd_i64(__m128d, int); 
#line 4343
extern __int64 __cdecl _mm_cvtt_roundsd_si64(__m128d, int); 
#line 4344
extern __int64 __cdecl _mm_cvtt_roundss_i64(__m128, int); 
#line 4345
extern __int64 __cdecl _mm_cvtt_roundss_si64(__m128, int); 
#line 4346
extern __m128d __cdecl _mm_cvtu64_sd(__m128d, unsigned __int64); 
#line 4347
extern __m128 __cdecl _mm_cvtu64_ss(__m128, unsigned __int64); 
#line 4348
extern __m128d __cdecl _mm_cvt_roundi64_sd(__m128d, __int64, int); 
#line 4349
extern __m128 __cdecl _mm_cvt_roundi64_ss(__m128, __int64, int); 
#line 4350
extern __int64 __cdecl _mm_cvt_roundsd_i64(__m128d, int); 
#line 4351
extern __int64 __cdecl _mm_cvt_roundsd_si64(__m128d, int); 
#line 4352
extern __m128d __cdecl _mm_cvt_roundsi64_sd(__m128d, __int64, int); 
#line 4353
extern __m128 __cdecl _mm_cvt_roundsi64_ss(__m128, __int64, int); 
#line 4354
extern __int64 __cdecl _mm_cvt_roundss_i64(__m128, int); 
#line 4355
extern __int64 __cdecl _mm_cvt_roundss_si64(__m128, int); 
#line 4356
extern __m128d __cdecl _mm_cvt_roundu64_sd(__m128d, unsigned __int64, int); 
#line 4357
extern __m128 __cdecl _mm_cvt_roundu64_ss(__m128, unsigned __int64, int); 
#line 4362 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"
extern __m512d __cdecl _mm512_zextpd128_pd512(__m128d); 
#line 4363
extern __m512d __cdecl _mm512_zextpd256_pd512(__m256d); 
#line 4364
extern __m512 __cdecl _mm512_zextps128_ps512(__m128); 
#line 4365
extern __m512 __cdecl _mm512_zextps256_ps512(__m256); 
#line 4366
extern __m512i __cdecl _mm512_zextsi128_si512(__m128i); 
#line 4367
extern __m512i __cdecl _mm512_zextsi256_si512(__m256i); 
#line 4398 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"
extern __m128i __cdecl _mm_madd52hi_epu64(__m128i, __m128i, __m128i); 
#line 4399
extern __m128i __cdecl _mm_mask_madd52hi_epu64(__m128i, __mmask8, __m128i, __m128i); 
#line 4400
extern __m128i __cdecl _mm_maskz_madd52hi_epu64(__mmask8, __m128i, __m128i, __m128i); 
#line 4401
extern __m256i __cdecl _mm256_madd52hi_epu64(__m256i, __m256i, __m256i); 
#line 4402
extern __m256i __cdecl _mm256_mask_madd52hi_epu64(__m256i, __mmask8, __m256i, __m256i); 
#line 4403
extern __m256i __cdecl _mm256_maskz_madd52hi_epu64(__mmask8, __m256i, __m256i, __m256i); 
#line 4404
extern __m512i __cdecl _mm512_madd52hi_epu64(__m512i, __m512i, __m512i); 
#line 4405
extern __m512i __cdecl _mm512_mask_madd52hi_epu64(__m512i, __mmask8, __m512i, __m512i); 
#line 4406
extern __m512i __cdecl _mm512_maskz_madd52hi_epu64(__mmask8, __m512i, __m512i, __m512i); 
#line 4408
extern __m128i __cdecl _mm_madd52lo_epu64(__m128i, __m128i, __m128i); 
#line 4409
extern __m128i __cdecl _mm_mask_madd52lo_epu64(__m128i, __mmask8, __m128i, __m128i); 
#line 4410
extern __m128i __cdecl _mm_maskz_madd52lo_epu64(__mmask8, __m128i, __m128i, __m128i); 
#line 4411
extern __m256i __cdecl _mm256_madd52lo_epu64(__m256i, __m256i, __m256i); 
#line 4412
extern __m256i __cdecl _mm256_mask_madd52lo_epu64(__m256i, __mmask8, __m256i, __m256i); 
#line 4413
extern __m256i __cdecl _mm256_maskz_madd52lo_epu64(__mmask8, __m256i, __m256i, __m256i); 
#line 4414
extern __m512i __cdecl _mm512_madd52lo_epu64(__m512i, __m512i, __m512i); 
#line 4415
extern __m512i __cdecl _mm512_mask_madd52lo_epu64(__m512i, __mmask8, __m512i, __m512i); 
#line 4416
extern __m512i __cdecl _mm512_maskz_madd52lo_epu64(__mmask8, __m512i, __m512i, __m512i); 
#line 4419
extern __m128i __cdecl _mm_permutexvar_epi8(__m128i, __m128i); 
#line 4420
extern __m128i __cdecl _mm_mask_permutexvar_epi8(__m128i, __mmask16, __m128i, __m128i); 
#line 4421
extern __m128i __cdecl _mm_maskz_permutexvar_epi8(__mmask16, __m128i, __m128i); 
#line 4422
extern __m256i __cdecl _mm256_permutexvar_epi8(__m256i, __m256i); 
#line 4423
extern __m256i __cdecl _mm256_mask_permutexvar_epi8(__m256i, __mmask32, __m256i, __m256i); 
#line 4424
extern __m256i __cdecl _mm256_maskz_permutexvar_epi8(__mmask32, __m256i, __m256i); 
#line 4425
extern __m512i __cdecl _mm512_permutexvar_epi8(__m512i, __m512i); 
#line 4426
extern __m512i __cdecl _mm512_mask_permutexvar_epi8(__m512i, __mmask64, __m512i, __m512i); 
#line 4427
extern __m512i __cdecl _mm512_maskz_permutexvar_epi8(__mmask64, __m512i, __m512i); 
#line 4429
extern __m128i __cdecl _mm_permutex2var_epi8(__m128i, __m128i, __m128i); 
#line 4430
extern __m128i __cdecl _mm_mask_permutex2var_epi8(__m128i, __mmask16, __m128i, __m128i); 
#line 4431
extern __m128i __cdecl _mm_mask2_permutex2var_epi8(__m128i, __m128i, __mmask16, __m128i); 
#line 4432
extern __m128i __cdecl _mm_maskz_permutex2var_epi8(__mmask16, __m128i, __m128i, __m128i); 
#line 4433
extern __m256i __cdecl _mm256_permutex2var_epi8(__m256i, __m256i, __m256i); 
#line 4434
extern __m256i __cdecl _mm256_mask_permutex2var_epi8(__m256i, __mmask32, __m256i, __m256i); 
#line 4435
extern __m256i __cdecl _mm256_mask2_permutex2var_epi8(__m256i, __m256i, __mmask32, __m256i); 
#line 4436
extern __m256i __cdecl _mm256_maskz_permutex2var_epi8(__mmask32, __m256i, __m256i, __m256i); 
#line 4437
extern __m512i __cdecl _mm512_permutex2var_epi8(__m512i, __m512i, __m512i); 
#line 4438
extern __m512i __cdecl _mm512_mask_permutex2var_epi8(__m512i, __mmask64, __m512i, __m512i); 
#line 4439
extern __m512i __cdecl _mm512_mask2_permutex2var_epi8(__m512i, __m512i, __mmask64, __m512i); 
#line 4440
extern __m512i __cdecl _mm512_maskz_permutex2var_epi8(__mmask64, __m512i, __m512i, __m512i); 
#line 4442
extern __m128i __cdecl _mm_multishift_epi64_epi8(__m128i, __m128i); 
#line 4443
extern __m128i __cdecl _mm_mask_multishift_epi64_epi8(__m128i, __mmask16, __m128i, __m128i); 
#line 4444
extern __m128i __cdecl _mm_maskz_multishift_epi64_epi8(__mmask16, __m128i, __m128i); 
#line 4445
extern __m256i __cdecl _mm256_multishift_epi64_epi8(__m256i, __m256i); 
#line 4446
extern __m256i __cdecl _mm256_mask_multishift_epi64_epi8(__m256i, __mmask32, __m256i, __m256i); 
#line 4447
extern __m256i __cdecl _mm256_maskz_multishift_epi64_epi8(__mmask32, __m256i, __m256i); 
#line 4448
extern __m512i __cdecl _mm512_multishift_epi64_epi8(__m512i, __m512i); 
#line 4449
extern __m512i __cdecl _mm512_mask_multishift_epi64_epi8(__m512i, __mmask64, __m512i, __m512i); 
#line 4450
extern __m512i __cdecl _mm512_maskz_multishift_epi64_epi8(__mmask64, __m512i, __m512i); 
#line 4453
extern __m128i __cdecl _mm_dpbusd_epi32(__m128i, __m128i, __m128i); 
#line 4454
extern __m128i __cdecl _mm_mask_dpbusd_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 4455
extern __m128i __cdecl _mm_maskz_dpbusd_epi32(__mmask8, __m128i, __m128i, __m128i); 
#line 4456
extern __m256i __cdecl _mm256_dpbusd_epi32(__m256i, __m256i, __m256i); 
#line 4457
extern __m256i __cdecl _mm256_mask_dpbusd_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 4458
extern __m256i __cdecl _mm256_maskz_dpbusd_epi32(__mmask8, __m256i, __m256i, __m256i); 
#line 4459
extern __m512i __cdecl _mm512_dpbusd_epi32(__m512i, __m512i, __m512i); 
#line 4460
extern __m512i __cdecl _mm512_mask_dpbusd_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 4461
extern __m512i __cdecl _mm512_maskz_dpbusd_epi32(__mmask16, __m512i, __m512i, __m512i); 
#line 4463
extern __m128i __cdecl _mm_dpbusds_epi32(__m128i, __m128i, __m128i); 
#line 4464
extern __m128i __cdecl _mm_mask_dpbusds_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 4465
extern __m128i __cdecl _mm_maskz_dpbusds_epi32(__mmask8, __m128i, __m128i, __m128i); 
#line 4466
extern __m256i __cdecl _mm256_dpbusds_epi32(__m256i, __m256i, __m256i); 
#line 4467
extern __m256i __cdecl _mm256_mask_dpbusds_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 4468
extern __m256i __cdecl _mm256_maskz_dpbusds_epi32(__mmask8, __m256i, __m256i, __m256i); 
#line 4469
extern __m512i __cdecl _mm512_dpbusds_epi32(__m512i, __m512i, __m512i); 
#line 4470
extern __m512i __cdecl _mm512_mask_dpbusds_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 4471
extern __m512i __cdecl _mm512_maskz_dpbusds_epi32(__mmask16, __m512i, __m512i, __m512i); 
#line 4473
extern __m128i __cdecl _mm_dpwssd_epi32(__m128i, __m128i, __m128i); 
#line 4474
extern __m128i __cdecl _mm_mask_dpwssd_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 4475
extern __m128i __cdecl _mm_maskz_dpwssd_epi32(__mmask8, __m128i, __m128i, __m128i); 
#line 4476
extern __m256i __cdecl _mm256_dpwssd_epi32(__m256i, __m256i, __m256i); 
#line 4477
extern __m256i __cdecl _mm256_mask_dpwssd_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 4478
extern __m256i __cdecl _mm256_maskz_dpwssd_epi32(__mmask8, __m256i, __m256i, __m256i); 
#line 4479
extern __m512i __cdecl _mm512_dpwssd_epi32(__m512i, __m512i, __m512i); 
#line 4480
extern __m512i __cdecl _mm512_mask_dpwssd_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 4481
extern __m512i __cdecl _mm512_maskz_dpwssd_epi32(__mmask16, __m512i, __m512i, __m512i); 
#line 4483
extern __m128i __cdecl _mm_dpwssds_epi32(__m128i, __m128i, __m128i); 
#line 4484
extern __m128i __cdecl _mm_mask_dpwssds_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 4485
extern __m128i __cdecl _mm_maskz_dpwssds_epi32(__mmask8, __m128i, __m128i, __m128i); 
#line 4486
extern __m256i __cdecl _mm256_dpwssds_epi32(__m256i, __m256i, __m256i); 
#line 4487
extern __m256i __cdecl _mm256_mask_dpwssds_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 4488
extern __m256i __cdecl _mm256_maskz_dpwssds_epi32(__mmask8, __m256i, __m256i, __m256i); 
#line 4489
extern __m512i __cdecl _mm512_dpwssds_epi32(__m512i, __m512i, __m512i); 
#line 4490
extern __m512i __cdecl _mm512_mask_dpwssds_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 4491
extern __m512i __cdecl _mm512_maskz_dpwssds_epi32(__mmask16, __m512i, __m512i, __m512i); 
#line 4494
extern __m256i __cdecl _mm256_aesenc_epi128(__m256i, __m256i); 
#line 4495
extern __m512i __cdecl _mm512_aesenc_epi128(__m512i, __m512i); 
#line 4496
extern __m256i __cdecl _mm256_aesenclast_epi128(__m256i, __m256i); 
#line 4497
extern __m512i __cdecl _mm512_aesenclast_epi128(__m512i, __m512i); 
#line 4498
extern __m256i __cdecl _mm256_aesdec_epi128(__m256i, __m256i); 
#line 4499
extern __m512i __cdecl _mm512_aesdec_epi128(__m512i, __m512i); 
#line 4500
extern __m256i __cdecl _mm256_aesdeclast_epi128(__m256i, __m256i); 
#line 4501
extern __m512i __cdecl _mm512_aesdeclast_epi128(__m512i, __m512i); 
#line 4504
extern __m256i __cdecl _mm256_clmulepi64_epi128(__m256i, __m256i, const int); 
#line 4505
extern __m512i __cdecl _mm512_clmulepi64_epi128(__m512i, __m512i, const int); 
#line 4508
extern __m128i __cdecl _mm_popcnt_epi32(__m128i); 
#line 4509
extern __m128i __cdecl _mm_mask_popcnt_epi32(__m128i, __mmask8, __m128i); 
#line 4510
extern __m128i __cdecl _mm_maskz_popcnt_epi32(__mmask8, __m128i); 
#line 4511
extern __m256i __cdecl _mm256_popcnt_epi32(__m256i); 
#line 4512
extern __m256i __cdecl _mm256_mask_popcnt_epi32(__m256i, __mmask8, __m256i); 
#line 4513
extern __m256i __cdecl _mm256_maskz_popcnt_epi32(__mmask8, __m256i); 
#line 4514
extern __m512i __cdecl _mm512_popcnt_epi32(__m512i); 
#line 4515
extern __m512i __cdecl _mm512_mask_popcnt_epi32(__m512i, __mmask16, __m512i); 
#line 4516
extern __m512i __cdecl _mm512_maskz_popcnt_epi32(__mmask16, __m512i); 
#line 4518
extern __m128i __cdecl _mm_popcnt_epi64(__m128i); 
#line 4519
extern __m128i __cdecl _mm_mask_popcnt_epi64(__m128i, __mmask8, __m128i); 
#line 4520
extern __m128i __cdecl _mm_maskz_popcnt_epi64(__mmask8, __m128i); 
#line 4521
extern __m256i __cdecl _mm256_popcnt_epi64(__m256i); 
#line 4522
extern __m256i __cdecl _mm256_mask_popcnt_epi64(__m256i, __mmask8, __m256i); 
#line 4523
extern __m256i __cdecl _mm256_maskz_popcnt_epi64(__mmask8, __m256i); 
#line 4524
extern __m512i __cdecl _mm512_popcnt_epi64(__m512i); 
#line 4525
extern __m512i __cdecl _mm512_mask_popcnt_epi64(__m512i, __mmask8, __m512i); 
#line 4526
extern __m512i __cdecl _mm512_maskz_popcnt_epi64(__mmask8, __m512i); 
#line 4529
extern __m128i __cdecl _mm_popcnt_epi8(__m128i); 
#line 4530
extern __m128i __cdecl _mm_mask_popcnt_epi8(__m128i, __mmask16, __m128i); 
#line 4531
extern __m128i __cdecl _mm_maskz_popcnt_epi8(__mmask16, __m128i); 
#line 4532
extern __m256i __cdecl _mm256_popcnt_epi8(__m256i); 
#line 4533
extern __m256i __cdecl _mm256_mask_popcnt_epi8(__m256i, __mmask32, __m256i); 
#line 4534
extern __m256i __cdecl _mm256_maskz_popcnt_epi8(__mmask32, __m256i); 
#line 4535
extern __m512i __cdecl _mm512_popcnt_epi8(__m512i); 
#line 4536
extern __m512i __cdecl _mm512_mask_popcnt_epi8(__m512i, __mmask64, __m512i); 
#line 4537
extern __m512i __cdecl _mm512_maskz_popcnt_epi8(__mmask64, __m512i); 
#line 4539
extern __m128i __cdecl _mm_popcnt_epi16(__m128i); 
#line 4540
extern __m128i __cdecl _mm_mask_popcnt_epi16(__m128i, __mmask8, __m128i); 
#line 4541
extern __m128i __cdecl _mm_maskz_popcnt_epi16(__mmask8, __m128i); 
#line 4542
extern __m256i __cdecl _mm256_popcnt_epi16(__m256i); 
#line 4543
extern __m256i __cdecl _mm256_mask_popcnt_epi16(__m256i, __mmask16, __m256i); 
#line 4544
extern __m256i __cdecl _mm256_maskz_popcnt_epi16(__mmask16, __m256i); 
#line 4545
extern __m512i __cdecl _mm512_popcnt_epi16(__m512i); 
#line 4546
extern __m512i __cdecl _mm512_mask_popcnt_epi16(__m512i, __mmask32, __m512i); 
#line 4547
extern __m512i __cdecl _mm512_maskz_popcnt_epi16(__mmask32, __m512i); 
#line 4549
extern __mmask16 __cdecl _mm_bitshuffle_epi64_mask(__m128i, __m128i); 
#line 4550
extern __mmask16 __cdecl _mm_mask_bitshuffle_epi64_mask(__mmask16, __m128i, __m128i); 
#line 4551
extern __mmask32 __cdecl _mm256_bitshuffle_epi64_mask(__m256i, __m256i); 
#line 4552
extern __mmask32 __cdecl _mm256_mask_bitshuffle_epi64_mask(__mmask32, __m256i, __m256i); 
#line 4553
extern __mmask64 __cdecl _mm512_bitshuffle_epi64_mask(__m512i, __m512i); 
#line 4554
extern __mmask64 __cdecl _mm512_mask_bitshuffle_epi64_mask(__mmask64, __m512i, __m512i); 
#line 4557
extern __m128i __cdecl _mm_gf2p8affineinv_epi64_epi8(__m128i, __m128i, int); 
#line 4558
extern __m128i __cdecl _mm_mask_gf2p8affineinv_epi64_epi8(__m128i, __mmask16, __m128i, __m128i, int); 
#line 4559
extern __m128i __cdecl _mm_maskz_gf2p8affineinv_epi64_epi8(__mmask16, __m128i, __m128i, int); 
#line 4560
extern __m256i __cdecl _mm256_gf2p8affineinv_epi64_epi8(__m256i, __m256i, int); 
#line 4561
extern __m256i __cdecl _mm256_mask_gf2p8affineinv_epi64_epi8(__m256i, __mmask32, __m256i, __m256i, int); 
#line 4562
extern __m256i __cdecl _mm256_maskz_gf2p8affineinv_epi64_epi8(__mmask32, __m256i, __m256i, int); 
#line 4563
extern __m512i __cdecl _mm512_gf2p8affineinv_epi64_epi8(__m512i, __m512i, int); 
#line 4564
extern __m512i __cdecl _mm512_mask_gf2p8affineinv_epi64_epi8(__m512i, __mmask64, __m512i, __m512i, int); 
#line 4565
extern __m512i __cdecl _mm512_maskz_gf2p8affineinv_epi64_epi8(__mmask64, __m512i, __m512i, int); 
#line 4566
extern __m128i __cdecl _mm_gf2p8affine_epi64_epi8(__m128i, __m128i, int); 
#line 4567
extern __m128i __cdecl _mm_mask_gf2p8affine_epi64_epi8(__m128i, __mmask16, __m128i, __m128i, int); 
#line 4568
extern __m128i __cdecl _mm_maskz_gf2p8affine_epi64_epi8(__mmask16, __m128i, __m128i, int); 
#line 4569
extern __m256i __cdecl _mm256_gf2p8affine_epi64_epi8(__m256i, __m256i, int); 
#line 4570
extern __m256i __cdecl _mm256_mask_gf2p8affine_epi64_epi8(__m256i, __mmask32, __m256i, __m256i, int); 
#line 4571
extern __m256i __cdecl _mm256_maskz_gf2p8affine_epi64_epi8(__mmask32, __m256i, __m256i, int); 
#line 4572
extern __m512i __cdecl _mm512_gf2p8affine_epi64_epi8(__m512i, __m512i, int); 
#line 4573
extern __m512i __cdecl _mm512_mask_gf2p8affine_epi64_epi8(__m512i, __mmask64, __m512i, __m512i, int); 
#line 4574
extern __m512i __cdecl _mm512_maskz_gf2p8affine_epi64_epi8(__mmask64, __m512i, __m512i, int); 
#line 4575
extern __m128i __cdecl _mm_gf2p8mul_epi8(__m128i, __m128i); 
#line 4576
extern __m128i __cdecl _mm_mask_gf2p8mul_epi8(__m128i, __mmask16, __m128i, __m128i); 
#line 4577
extern __m128i __cdecl _mm_maskz_gf2p8mul_epi8(__mmask16, __m128i, __m128i); 
#line 4578
extern __m256i __cdecl _mm256_gf2p8mul_epi8(__m256i, __m256i); 
#line 4579
extern __m256i __cdecl _mm256_mask_gf2p8mul_epi8(__m256i, __mmask32, __m256i, __m256i); 
#line 4580
extern __m256i __cdecl _mm256_maskz_gf2p8mul_epi8(__mmask32, __m256i, __m256i); 
#line 4581
extern __m512i __cdecl _mm512_gf2p8mul_epi8(__m512i, __m512i); 
#line 4582
extern __m512i __cdecl _mm512_mask_gf2p8mul_epi8(__m512i, __mmask64, __m512i, __m512i); 
#line 4583
extern __m512i __cdecl _mm512_maskz_gf2p8mul_epi8(__mmask64, __m512i, __m512i); 
#line 4586
extern __m128i __cdecl _mm_shldi_epi16(__m128i, __m128i, int); 
#line 4587
extern __m128i __cdecl _mm_mask_shldi_epi16(__m128i, __mmask8, __m128i, __m128i, int); 
#line 4588
extern __m128i __cdecl _mm_maskz_shldi_epi16(__mmask8, __m128i, __m128i, int); 
#line 4589
extern __m256i __cdecl _mm256_shldi_epi16(__m256i, __m256i, int); 
#line 4590
extern __m256i __cdecl _mm256_mask_shldi_epi16(__m256i, __mmask16, __m256i, __m256i, int); 
#line 4591
extern __m256i __cdecl _mm256_maskz_shldi_epi16(__mmask16, __m256i, __m256i, int); 
#line 4592
extern __m512i __cdecl _mm512_shldi_epi16(__m512i, __m512i, int); 
#line 4593
extern __m512i __cdecl _mm512_mask_shldi_epi16(__m512i, __mmask32, __m512i, __m512i, int); 
#line 4594
extern __m512i __cdecl _mm512_maskz_shldi_epi16(__mmask32, __m512i, __m512i, int); 
#line 4595
extern __m128i __cdecl _mm_shldi_epi32(__m128i, __m128i, int); 
#line 4596
extern __m128i __cdecl _mm_mask_shldi_epi32(__m128i, __mmask8, __m128i, __m128i, int); 
#line 4597
extern __m128i __cdecl _mm_maskz_shldi_epi32(__mmask8, __m128i, __m128i, int); 
#line 4598
extern __m256i __cdecl _mm256_shldi_epi32(__m256i, __m256i, int); 
#line 4599
extern __m256i __cdecl _mm256_mask_shldi_epi32(__m256i, __mmask8, __m256i, __m256i, int); 
#line 4600
extern __m256i __cdecl _mm256_maskz_shldi_epi32(__mmask8, __m256i, __m256i, int); 
#line 4601
extern __m512i __cdecl _mm512_shldi_epi32(__m512i, __m512i, int); 
#line 4602
extern __m512i __cdecl _mm512_mask_shldi_epi32(__m512i, __mmask16, __m512i, __m512i, int); 
#line 4603
extern __m512i __cdecl _mm512_maskz_shldi_epi32(__mmask16, __m512i, __m512i, int); 
#line 4604
extern __m128i __cdecl _mm_shldi_epi64(__m128i, __m128i, int); 
#line 4605
extern __m128i __cdecl _mm_mask_shldi_epi64(__m128i, __mmask8, __m128i, __m128i, int); 
#line 4606
extern __m128i __cdecl _mm_maskz_shldi_epi64(__mmask8, __m128i, __m128i, int); 
#line 4607
extern __m256i __cdecl _mm256_shldi_epi64(__m256i, __m256i, int); 
#line 4608
extern __m256i __cdecl _mm256_mask_shldi_epi64(__m256i, __mmask8, __m256i, __m256i, int); 
#line 4609
extern __m256i __cdecl _mm256_maskz_shldi_epi64(__mmask8, __m256i, __m256i, int); 
#line 4610
extern __m512i __cdecl _mm512_shldi_epi64(__m512i, __m512i, int); 
#line 4611
extern __m512i __cdecl _mm512_mask_shldi_epi64(__m512i, __mmask8, __m512i, __m512i, int); 
#line 4612
extern __m512i __cdecl _mm512_maskz_shldi_epi64(__mmask8, __m512i, __m512i, int); 
#line 4613
extern __m128i __cdecl _mm_shldv_epi16(__m128i, __m128i, __m128i); 
#line 4614
extern __m128i __cdecl _mm_mask_shldv_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 4615
extern __m128i __cdecl _mm_maskz_shldv_epi16(__mmask8, __m128i, __m128i, __m128i); 
#line 4616
extern __m256i __cdecl _mm256_shldv_epi16(__m256i, __m256i, __m256i); 
#line 4617
extern __m256i __cdecl _mm256_mask_shldv_epi16(__m256i, __mmask16, __m256i, __m256i); 
#line 4618
extern __m256i __cdecl _mm256_maskz_shldv_epi16(__mmask16, __m256i, __m256i, __m256i); 
#line 4619
extern __m512i __cdecl _mm512_shldv_epi16(__m512i, __m512i, __m512i); 
#line 4620
extern __m512i __cdecl _mm512_mask_shldv_epi16(__m512i, __mmask32, __m512i, __m512i); 
#line 4621
extern __m512i __cdecl _mm512_maskz_shldv_epi16(__mmask32, __m512i, __m512i, __m512i); 
#line 4622
extern __m128i __cdecl _mm_shldv_epi32(__m128i, __m128i, __m128i); 
#line 4623
extern __m128i __cdecl _mm_mask_shldv_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 4624
extern __m128i __cdecl _mm_maskz_shldv_epi32(__mmask8, __m128i, __m128i, __m128i); 
#line 4625
extern __m256i __cdecl _mm256_shldv_epi32(__m256i, __m256i, __m256i); 
#line 4626
extern __m256i __cdecl _mm256_mask_shldv_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 4627
extern __m256i __cdecl _mm256_maskz_shldv_epi32(__mmask8, __m256i, __m256i, __m256i); 
#line 4628
extern __m512i __cdecl _mm512_shldv_epi32(__m512i, __m512i, __m512i); 
#line 4629
extern __m512i __cdecl _mm512_mask_shldv_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 4630
extern __m512i __cdecl _mm512_maskz_shldv_epi32(__mmask16, __m512i, __m512i, __m512i); 
#line 4631
extern __m128i __cdecl _mm_shldv_epi64(__m128i, __m128i, __m128i); 
#line 4632
extern __m128i __cdecl _mm_mask_shldv_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 4633
extern __m128i __cdecl _mm_maskz_shldv_epi64(__mmask8, __m128i, __m128i, __m128i); 
#line 4634
extern __m256i __cdecl _mm256_shldv_epi64(__m256i, __m256i, __m256i); 
#line 4635
extern __m256i __cdecl _mm256_mask_shldv_epi64(__m256i, __mmask8, __m256i, __m256i); 
#line 4636
extern __m256i __cdecl _mm256_maskz_shldv_epi64(__mmask8, __m256i, __m256i, __m256i); 
#line 4637
extern __m512i __cdecl _mm512_shldv_epi64(__m512i, __m512i, __m512i); 
#line 4638
extern __m512i __cdecl _mm512_mask_shldv_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 4639
extern __m512i __cdecl _mm512_maskz_shldv_epi64(__mmask8, __m512i, __m512i, __m512i); 
#line 4642
extern __m128i __cdecl _mm_shrdi_epi16(__m128i, __m128i, int); 
#line 4643
extern __m128i __cdecl _mm_mask_shrdi_epi16(__m128i, __mmask8, __m128i, __m128i, int); 
#line 4644
extern __m128i __cdecl _mm_maskz_shrdi_epi16(__mmask8, __m128i, __m128i, int); 
#line 4645
extern __m256i __cdecl _mm256_shrdi_epi16(__m256i, __m256i, int); 
#line 4646
extern __m256i __cdecl _mm256_mask_shrdi_epi16(__m256i, __mmask16, __m256i, __m256i, int); 
#line 4647
extern __m256i __cdecl _mm256_maskz_shrdi_epi16(__mmask16, __m256i, __m256i, int); 
#line 4648
extern __m512i __cdecl _mm512_shrdi_epi16(__m512i, __m512i, int); 
#line 4649
extern __m512i __cdecl _mm512_mask_shrdi_epi16(__m512i, __mmask32, __m512i, __m512i, int); 
#line 4650
extern __m512i __cdecl _mm512_maskz_shrdi_epi16(__mmask32, __m512i, __m512i, int); 
#line 4651
extern __m128i __cdecl _mm_shrdi_epi32(__m128i, __m128i, int); 
#line 4652
extern __m128i __cdecl _mm_mask_shrdi_epi32(__m128i, __mmask8, __m128i, __m128i, int); 
#line 4653
extern __m128i __cdecl _mm_maskz_shrdi_epi32(__mmask8, __m128i, __m128i, int); 
#line 4654
extern __m256i __cdecl _mm256_shrdi_epi32(__m256i, __m256i, int); 
#line 4655
extern __m256i __cdecl _mm256_mask_shrdi_epi32(__m256i, __mmask8, __m256i, __m256i, int); 
#line 4656
extern __m256i __cdecl _mm256_maskz_shrdi_epi32(__mmask8, __m256i, __m256i, int); 
#line 4657
extern __m512i __cdecl _mm512_shrdi_epi32(__m512i, __m512i, int); 
#line 4658
extern __m512i __cdecl _mm512_mask_shrdi_epi32(__m512i, __mmask16, __m512i, __m512i, int); 
#line 4659
extern __m512i __cdecl _mm512_maskz_shrdi_epi32(__mmask16, __m512i, __m512i, int); 
#line 4660
extern __m128i __cdecl _mm_shrdi_epi64(__m128i, __m128i, int); 
#line 4661
extern __m128i __cdecl _mm_mask_shrdi_epi64(__m128i, __mmask8, __m128i, __m128i, int); 
#line 4662
extern __m128i __cdecl _mm_maskz_shrdi_epi64(__mmask8, __m128i, __m128i, int); 
#line 4663
extern __m256i __cdecl _mm256_shrdi_epi64(__m256i, __m256i, int); 
#line 4664
extern __m256i __cdecl _mm256_mask_shrdi_epi64(__m256i, __mmask8, __m256i, __m256i, int); 
#line 4665
extern __m256i __cdecl _mm256_maskz_shrdi_epi64(__mmask8, __m256i, __m256i, int); 
#line 4666
extern __m512i __cdecl _mm512_shrdi_epi64(__m512i, __m512i, int); 
#line 4667
extern __m512i __cdecl _mm512_mask_shrdi_epi64(__m512i, __mmask8, __m512i, __m512i, int); 
#line 4668
extern __m512i __cdecl _mm512_maskz_shrdi_epi64(__mmask8, __m512i, __m512i, int); 
#line 4669
extern __m128i __cdecl _mm_shrdv_epi16(__m128i, __m128i, __m128i); 
#line 4670
extern __m128i __cdecl _mm_mask_shrdv_epi16(__m128i, __mmask8, __m128i, __m128i); 
#line 4671
extern __m128i __cdecl _mm_maskz_shrdv_epi16(__mmask8, __m128i, __m128i, __m128i); 
#line 4672
extern __m256i __cdecl _mm256_shrdv_epi16(__m256i, __m256i, __m256i); 
#line 4673
extern __m256i __cdecl _mm256_mask_shrdv_epi16(__m256i, __mmask16, __m256i, __m256i); 
#line 4674
extern __m256i __cdecl _mm256_maskz_shrdv_epi16(__mmask16, __m256i, __m256i, __m256i); 
#line 4675
extern __m512i __cdecl _mm512_shrdv_epi16(__m512i, __m512i, __m512i); 
#line 4676
extern __m512i __cdecl _mm512_mask_shrdv_epi16(__m512i, __mmask32, __m512i, __m512i); 
#line 4677
extern __m512i __cdecl _mm512_maskz_shrdv_epi16(__mmask32, __m512i, __m512i, __m512i); 
#line 4678
extern __m128i __cdecl _mm_shrdv_epi32(__m128i, __m128i, __m128i); 
#line 4679
extern __m128i __cdecl _mm_mask_shrdv_epi32(__m128i, __mmask8, __m128i, __m128i); 
#line 4680
extern __m128i __cdecl _mm_maskz_shrdv_epi32(__mmask8, __m128i, __m128i, __m128i); 
#line 4681
extern __m256i __cdecl _mm256_shrdv_epi32(__m256i, __m256i, __m256i); 
#line 4682
extern __m256i __cdecl _mm256_mask_shrdv_epi32(__m256i, __mmask8, __m256i, __m256i); 
#line 4683
extern __m256i __cdecl _mm256_maskz_shrdv_epi32(__mmask8, __m256i, __m256i, __m256i); 
#line 4684
extern __m512i __cdecl _mm512_shrdv_epi32(__m512i, __m512i, __m512i); 
#line 4685
extern __m512i __cdecl _mm512_mask_shrdv_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 4686
extern __m512i __cdecl _mm512_maskz_shrdv_epi32(__mmask16, __m512i, __m512i, __m512i); 
#line 4687
extern __m128i __cdecl _mm_shrdv_epi64(__m128i, __m128i, __m128i); 
#line 4688
extern __m128i __cdecl _mm_mask_shrdv_epi64(__m128i, __mmask8, __m128i, __m128i); 
#line 4689
extern __m128i __cdecl _mm_maskz_shrdv_epi64(__mmask8, __m128i, __m128i, __m128i); 
#line 4690
extern __m256i __cdecl _mm256_shrdv_epi64(__m256i, __m256i, __m256i); 
#line 4691
extern __m256i __cdecl _mm256_mask_shrdv_epi64(__m256i, __mmask8, __m256i, __m256i); 
#line 4692
extern __m256i __cdecl _mm256_maskz_shrdv_epi64(__mmask8, __m256i, __m256i, __m256i); 
#line 4693
extern __m512i __cdecl _mm512_shrdv_epi64(__m512i, __m512i, __m512i); 
#line 4694
extern __m512i __cdecl _mm512_mask_shrdv_epi64(__m512i, __mmask8, __m512i, __m512i); 
#line 4695
extern __m512i __cdecl _mm512_maskz_shrdv_epi64(__mmask8, __m512i, __m512i, __m512i); 
#line 4702
extern __m512i _mm512_div_epi8(__m512i, __m512i); 
#line 4703
extern __m512i _mm512_div_epi16(__m512i, __m512i); 
#line 4704
extern __m512i _mm512_div_epi32(__m512i, __m512i); 
#line 4705
extern __m512i _mm512_div_epi64(__m512i, __m512i); 
#line 4706
extern __m512i _mm512_div_epu8(__m512i, __m512i); 
#line 4707
extern __m512i _mm512_div_epu16(__m512i, __m512i); 
#line 4708
extern __m512i _mm512_div_epu32(__m512i, __m512i); 
#line 4709
extern __m512i _mm512_div_epu64(__m512i, __m512i); 
#line 4710
extern __m512i _mm512_mask_div_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 4711
extern __m512i _mm512_mask_div_epu32(__m512i, __mmask16, __m512i, __m512i); 
#line 4712
extern __m512i _mm512_rem_epi8(__m512i, __m512i); 
#line 4713
extern __m512i _mm512_rem_epi16(__m512i, __m512i); 
#line 4714
extern __m512i _mm512_rem_epi32(__m512i, __m512i); 
#line 4715
extern __m512i _mm512_rem_epi64(__m512i, __m512i); 
#line 4716
extern __m512i _mm512_rem_epu8(__m512i, __m512i); 
#line 4717
extern __m512i _mm512_rem_epu16(__m512i, __m512i); 
#line 4718
extern __m512i _mm512_rem_epu32(__m512i, __m512i); 
#line 4719
extern __m512i _mm512_rem_epu64(__m512i, __m512i); 
#line 4720
extern __m512i _mm512_mask_rem_epi32(__m512i, __mmask16, __m512i, __m512i); 
#line 4721
extern __m512i _mm512_mask_rem_epu32(__m512i, __mmask16, __m512i, __m512i); 
#line 4724
extern __m512 _mm512_sin_ps(__m512); 
#line 4725
extern __m512 _mm512_mask_sin_ps(__m512, __mmask16, __m512); 
#line 4726
extern __m512d _mm512_sin_pd(__m512d); 
#line 4727
extern __m512d _mm512_mask_sin_pd(__m512d, __mmask8, __m512d); 
#line 4728
extern __m512 _mm512_cos_ps(__m512); 
#line 4729
extern __m512 _mm512_mask_cos_ps(__m512, __mmask16, __m512); 
#line 4730
extern __m512d _mm512_cos_pd(__m512d); 
#line 4731
extern __m512d _mm512_mask_cos_pd(__m512d, __mmask8, __m512d); 
#line 4732
extern __m512 _mm512_sincos_ps(__m512 *, __m512); 
#line 4733
extern __m512 _mm512_mask_sincos_ps(__m512 *, __m512, __m512, __mmask16, __m512); 
#line 4734
extern __m512d _mm512_sincos_pd(__m512d *, __m512d); 
#line 4735
extern __m512d _mm512_mask_sincos_pd(__m512d *, __m512d, __m512d, __mmask8, __m512d); 
#line 4736
extern __m512 _mm512_tan_ps(__m512); 
#line 4737
extern __m512 _mm512_mask_tan_ps(__m512, __mmask16, __m512); 
#line 4738
extern __m512d _mm512_tan_pd(__m512d); 
#line 4739
extern __m512d _mm512_mask_tan_pd(__m512d, __mmask8, __m512d); 
#line 4740
extern __m512 _mm512_asin_ps(__m512); 
#line 4741
extern __m512 _mm512_mask_asin_ps(__m512, __mmask16, __m512); 
#line 4742
extern __m512d _mm512_asin_pd(__m512d); 
#line 4743
extern __m512d _mm512_mask_asin_pd(__m512d, __mmask8, __m512d); 
#line 4744
extern __m512 _mm512_acos_ps(__m512); 
#line 4745
extern __m512 _mm512_mask_acos_ps(__m512, __mmask16, __m512); 
#line 4746
extern __m512d _mm512_acos_pd(__m512d); 
#line 4747
extern __m512d _mm512_mask_acos_pd(__m512d, __mmask8, __m512d); 
#line 4748
extern __m512 _mm512_atan_ps(__m512); 
#line 4749
extern __m512 _mm512_mask_atan_ps(__m512, __mmask16, __m512); 
#line 4750
extern __m512d _mm512_atan_pd(__m512d); 
#line 4751
extern __m512d _mm512_mask_atan_pd(__m512d, __mmask8, __m512d); 
#line 4752
extern __m512 _mm512_atan2_ps(__m512, __m512); 
#line 4753
extern __m512 _mm512_mask_atan2_ps(__m512, __mmask16, __m512, __m512); 
#line 4754
extern __m512d _mm512_atan2_pd(__m512d, __m512d); 
#line 4755
extern __m512d _mm512_mask_atan2_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 4756
extern __m512 _mm512_sind_ps(__m512); 
#line 4757
extern __m512 _mm512_mask_sind_ps(__m512, __mmask16, __m512); 
#line 4758
extern __m512d _mm512_sind_pd(__m512d); 
#line 4759
extern __m512d _mm512_mask_sind_pd(__m512d, __mmask8, __m512d); 
#line 4760
extern __m512 _mm512_cosd_ps(__m512); 
#line 4761
extern __m512 _mm512_mask_cosd_ps(__m512, __mmask16, __m512); 
#line 4762
extern __m512d _mm512_cosd_pd(__m512d); 
#line 4763
extern __m512d _mm512_mask_cosd_pd(__m512d, __mmask8, __m512d); 
#line 4764
extern __m512 _mm512_tand_ps(__m512); 
#line 4765
extern __m512 _mm512_mask_tand_ps(__m512, __mmask16, __m512); 
#line 4766
extern __m512d _mm512_tand_pd(__m512d); 
#line 4767
extern __m512d _mm512_mask_tand_pd(__m512d, __mmask8, __m512d); 
#line 4768
extern __m512 _mm512_sinh_ps(__m512); 
#line 4769
extern __m512 _mm512_mask_sinh_ps(__m512, __mmask16, __m512); 
#line 4770
extern __m512d _mm512_sinh_pd(__m512d); 
#line 4771
extern __m512d _mm512_mask_sinh_pd(__m512d, __mmask8, __m512d); 
#line 4772
extern __m512 _mm512_cosh_ps(__m512); 
#line 4773
extern __m512 _mm512_mask_cosh_ps(__m512, __mmask16, __m512); 
#line 4774
extern __m512d _mm512_cosh_pd(__m512d); 
#line 4775
extern __m512d _mm512_mask_cosh_pd(__m512d, __mmask8, __m512d); 
#line 4776
extern __m512 _mm512_tanh_ps(__m512); 
#line 4777
extern __m512 _mm512_mask_tanh_ps(__m512, __mmask16, __m512); 
#line 4778
extern __m512d _mm512_tanh_pd(__m512d); 
#line 4779
extern __m512d _mm512_mask_tanh_pd(__m512d, __mmask8, __m512d); 
#line 4780
extern __m512 _mm512_asinh_ps(__m512); 
#line 4781
extern __m512 _mm512_mask_asinh_ps(__m512, __mmask16, __m512); 
#line 4782
extern __m512d _mm512_asinh_pd(__m512d); 
#line 4783
extern __m512d _mm512_mask_asinh_pd(__m512d, __mmask8, __m512d); 
#line 4784
extern __m512 _mm512_acosh_ps(__m512); 
#line 4785
extern __m512 _mm512_mask_acosh_ps(__m512, __mmask16, __m512); 
#line 4786
extern __m512d _mm512_acosh_pd(__m512d); 
#line 4787
extern __m512d _mm512_mask_acosh_pd(__m512d, __mmask8, __m512d); 
#line 4788
extern __m512 _mm512_atanh_ps(__m512); 
#line 4789
extern __m512 _mm512_mask_atanh_ps(__m512, __mmask16, __m512); 
#line 4790
extern __m512d _mm512_atanh_pd(__m512d); 
#line 4791
extern __m512d _mm512_mask_atanh_pd(__m512d, __mmask8, __m512d); 
#line 4792
extern __m512 _mm512_log_ps(__m512); 
#line 4793
extern __m512 _mm512_mask_log_ps(__m512, __mmask16, __m512); 
#line 4794
extern __m512d _mm512_log_pd(__m512d); 
#line 4795
extern __m512d _mm512_mask_log_pd(__m512d, __mmask8, __m512d); 
#line 4796
extern __m512 _mm512_log1p_ps(__m512); 
#line 4797
extern __m512 _mm512_mask_log1p_ps(__m512, __mmask16, __m512); 
#line 4798
extern __m512d _mm512_log1p_pd(__m512d); 
#line 4799
extern __m512d _mm512_mask_log1p_pd(__m512d, __mmask8, __m512d); 
#line 4800
extern __m512 _mm512_log10_ps(__m512); 
#line 4801
extern __m512 _mm512_mask_log10_ps(__m512, __mmask16, __m512); 
#line 4802
extern __m512d _mm512_log10_pd(__m512d); 
#line 4803
extern __m512d _mm512_mask_log10_pd(__m512d, __mmask8, __m512d); 
#line 4804
extern __m512 _mm512_log2_ps(__m512); 
#line 4805
extern __m512 _mm512_mask_log2_ps(__m512, __mmask16, __m512); 
#line 4806
extern __m512d _mm512_log2_pd(__m512d); 
#line 4807
extern __m512d _mm512_mask_log2_pd(__m512d, __mmask8, __m512d); 
#line 4808
extern __m512 _mm512_logb_ps(__m512); 
#line 4809
extern __m512 _mm512_mask_logb_ps(__m512, __mmask16, __m512); 
#line 4810
extern __m512d _mm512_logb_pd(__m512d); 
#line 4811
extern __m512d _mm512_mask_logb_pd(__m512d, __mmask8, __m512d); 
#line 4812
extern __m512 _mm512_exp_ps(__m512); 
#line 4813
extern __m512 _mm512_mask_exp_ps(__m512, __mmask16, __m512); 
#line 4814
extern __m512d _mm512_exp_pd(__m512d); 
#line 4815
extern __m512d _mm512_mask_exp_pd(__m512d, __mmask8, __m512d); 
#line 4816
extern __m512 _mm512_exp10_ps(__m512); 
#line 4817
extern __m512 _mm512_mask_exp10_ps(__m512, __mmask16, __m512); 
#line 4818
extern __m512d _mm512_exp10_pd(__m512d); 
#line 4819
extern __m512d _mm512_mask_exp10_pd(__m512d, __mmask8, __m512d); 
#line 4820
extern __m512 _mm512_exp2_ps(__m512); 
#line 4821
extern __m512 _mm512_mask_exp2_ps(__m512, __mmask16, __m512); 
#line 4822
extern __m512d _mm512_exp2_pd(__m512d); 
#line 4823
extern __m512d _mm512_mask_exp2_pd(__m512d, __mmask8, __m512d); 
#line 4824
extern __m512 _mm512_expm1_ps(__m512); 
#line 4825
extern __m512 _mm512_mask_expm1_ps(__m512, __mmask16, __m512); 
#line 4826
extern __m512d _mm512_expm1_pd(__m512d); 
#line 4827
extern __m512d _mm512_mask_expm1_pd(__m512d, __mmask8, __m512d); 
#line 4828
extern __m512 _mm512_pow_ps(__m512, __m512); 
#line 4829
extern __m512 _mm512_mask_pow_ps(__m512, __mmask16, __m512, __m512); 
#line 4830
extern __m512d _mm512_pow_pd(__m512d, __m512d); 
#line 4831
extern __m512d _mm512_mask_pow_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 4832
extern __m512 _mm512_trunc_ps(__m512); 
#line 4833
extern __m512 _mm512_mask_trunc_ps(__m512, __mmask16, __m512); 
#line 4834
extern __m512d _mm512_trunc_pd(__m512d); 
#line 4835
extern __m512d _mm512_mask_trunc_pd(__m512d, __mmask8, __m512d); 
#line 4836
extern __m512 _mm512_floor_ps(__m512); 
#line 4837
extern __m512 _mm512_mask_floor_ps(__m512, __mmask16, __m512); 
#line 4838
extern __m512d _mm512_floor_pd(__m512d); 
#line 4839
extern __m512d _mm512_mask_floor_pd(__m512d, __mmask8, __m512d); 
#line 4840
extern __m512 _mm512_ceil_ps(__m512); 
#line 4841
extern __m512 _mm512_mask_ceil_ps(__m512, __mmask16, __m512); 
#line 4842
extern __m512d _mm512_ceil_pd(__m512d); 
#line 4843
extern __m512d _mm512_mask_ceil_pd(__m512d, __mmask8, __m512d); 
#line 4844
extern __m512 _mm512_svml_round_ps(__m512); 
#line 4845
extern __m512 _mm512_mask_svml_round_ps(__m512, __mmask16, __m512); 
#line 4846
extern __m512d _mm512_svml_round_pd(__m512d); 
#line 4847
extern __m512d _mm512_mask_svml_round_pd(__m512d, __mmask8, __m512d); 
#line 4848
extern __m512 _mm512_fmod_ps(__m512, __m512); 
#line 4849
extern __m512 _mm512_mask_fmod_ps(__m512, __mmask16, __m512, __m512); 
#line 4850
extern __m512d _mm512_fmod_pd(__m512d, __m512d); 
#line 4851
extern __m512d _mm512_mask_fmod_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 4852
extern __m512 _mm512_rint_ps(__m512); 
#line 4853
extern __m512 _mm512_mask_rint_ps(__m512, __mmask16, __m512); 
#line 4854
extern __m512d _mm512_rint_pd(__m512d); 
#line 4855
extern __m512d _mm512_mask_rint_pd(__m512d, __mmask8, __m512d); 
#line 4862
extern __m512 _mm512_invsqrt_ps(__m512); 
#line 4863
extern __m512 _mm512_mask_invsqrt_ps(__m512, __mmask16, __m512); 
#line 4864
extern __m512d _mm512_invsqrt_pd(__m512d); 
#line 4865
extern __m512d _mm512_mask_invsqrt_pd(__m512d, __mmask8, __m512d); 
#line 4866
extern __m512 _mm512_cbrt_ps(__m512); 
#line 4867
extern __m512 _mm512_mask_cbrt_ps(__m512, __mmask16, __m512); 
#line 4868
extern __m512d _mm512_cbrt_pd(__m512d); 
#line 4869
extern __m512d _mm512_mask_cbrt_pd(__m512d, __mmask8, __m512d); 
#line 4870
extern __m512 _mm512_invcbrt_ps(__m512); 
#line 4871
extern __m512 _mm512_mask_invcbrt_ps(__m512, __mmask16, __m512); 
#line 4872
extern __m512d _mm512_invcbrt_pd(__m512d); 
#line 4873
extern __m512d _mm512_mask_invcbrt_pd(__m512d, __mmask8, __m512d); 
#line 4874
extern __m512 _mm512_hypot_ps(__m512, __m512); 
#line 4875
extern __m512 _mm512_mask_hypot_ps(__m512, __mmask16, __m512, __m512); 
#line 4876
extern __m512d _mm512_hypot_pd(__m512d, __m512d); 
#line 4877
extern __m512d _mm512_mask_hypot_pd(__m512d, __mmask8, __m512d, __m512d); 
#line 4878
extern __m512 _mm512_cdfnorm_ps(__m512); 
#line 4879
extern __m512 _mm512_mask_cdfnorm_ps(__m512, __mmask16, __m512); 
#line 4880
extern __m512d _mm512_cdfnorm_pd(__m512d); 
#line 4881
extern __m512d _mm512_mask_cdfnorm_pd(__m512d, __mmask8, __m512d); 
#line 4882
extern __m512 _mm512_cdfnorminv_ps(__m512); 
#line 4883
extern __m512 _mm512_mask_cdfnorminv_ps(__m512, __mmask16, __m512); 
#line 4884
extern __m512d _mm512_cdfnorminv_pd(__m512d); 
#line 4885
extern __m512d _mm512_mask_cdfnorminv_pd(__m512d, __mmask8, __m512d); 
#line 4886
extern __m512 _mm512_erf_ps(__m512); 
#line 4887
extern __m512 _mm512_mask_erf_ps(__m512, __mmask16, __m512); 
#line 4888
extern __m512d _mm512_erf_pd(__m512d); 
#line 4889
extern __m512d _mm512_mask_erf_pd(__m512d, __mmask8, __m512d); 
#line 4890
extern __m512 _mm512_erfc_ps(__m512); 
#line 4891
extern __m512 _mm512_mask_erfc_ps(__m512, __mmask16, __m512); 
#line 4892
extern __m512d _mm512_erfc_pd(__m512d); 
#line 4893
extern __m512d _mm512_mask_erfc_pd(__m512d, __mmask8, __m512d); 
#line 4894
extern __m512 _mm512_erfcinv_ps(__m512); 
#line 4895
extern __m512 _mm512_mask_erfcinv_ps(__m512, __mmask16, __m512); 
#line 4896
extern __m512d _mm512_erfcinv_pd(__m512d); 
#line 4897
extern __m512d _mm512_mask_erfcinv_pd(__m512d, __mmask8, __m512d); 
#line 4898
extern __m512 _mm512_erfinv_ps(__m512); 
#line 4899
extern __m512 _mm512_mask_erfinv_ps(__m512, __mmask16, __m512); 
#line 4900
extern __m512d _mm512_erfinv_pd(__m512d); 
#line 4901
extern __m512d _mm512_mask_erfinv_pd(__m512d, __mmask8, __m512d); 
#line 4902
extern __m512 _mm512_nearbyint_ps(__m512); 
#line 4903
extern __m512 _mm512_mask_nearbyint_ps(__m512, __mmask16, __m512); 
#line 4904
extern __m512d _mm512_nearbyint_pd(__m512d); 
#line 4905
extern __m512d _mm512_mask_nearbyint_pd(__m512d, __mmask8, __m512d); 
#line 4908
typedef __m128i __m128bh; 
#line 4909
typedef __m256i __m256bh; 
#line 4910
typedef __m512i __m512bh; 
#line 4911
typedef unsigned short __bfloat16; 
#line 4913
extern __m128bh _mm_cvtneps_pbh(__m128); 
#line 4914
extern __m128bh _mm_mask_cvtneps_pbh(__m128bh, __mmask8, __m128); 
#line 4915
extern __m128bh _mm_maskz_cvtneps_pbh(__mmask8, __m128); 
#line 4916
extern __m128bh _mm_cvtne2ps_pbh(__m128, __m128); 
#line 4917
extern __m128bh _mm_mask_cvtne2ps_pbh(__m128bh, __mmask8, __m128, __m128); 
#line 4918
extern __m128bh _mm_maskz_cvtne2ps_pbh(__mmask8, __m128, __m128); 
#line 4919
extern __m128 _mm_dpbf16_ps(__m128, __m128bh, __m128bh); 
#line 4920
extern __m128 _mm_mask_dpbf16_ps(__m128, __mmask8, __m128bh, __m128bh); 
#line 4921
extern __m128 _mm_maskz_dpbf16_ps(__mmask8, __m128, __m128bh, __m128bh); 
#line 4922
extern __m128bh _mm256_cvtneps_pbh(__m256); 
#line 4923
extern __m128bh _mm256_mask_cvtneps_pbh(__m128bh, __mmask8, __m256); 
#line 4924
extern __m128bh _mm256_maskz_cvtneps_pbh(__mmask8, __m256); 
#line 4925
extern __m256bh _mm256_cvtne2ps_pbh(__m256, __m256); 
#line 4926
extern __m256bh _mm256_mask_cvtne2ps_pbh(__m256bh, __mmask16, __m256, __m256); 
#line 4927
extern __m256bh _mm256_maskz_cvtne2ps_pbh(__mmask16, __m256, __m256); 
#line 4928
extern __m256 _mm256_dpbf16_ps(__m256, __m256bh, __m256bh); 
#line 4929
extern __m256 _mm256_mask_dpbf16_ps(__m256, __mmask8, __m256bh, __m256bh); 
#line 4930
extern __m256 _mm256_maskz_dpbf16_ps(__mmask8, __m256, __m256bh, __m256bh); 
#line 4931
extern __m256bh _mm512_cvtneps_pbh(__m512); 
#line 4932
extern __m256bh _mm512_mask_cvtneps_pbh(__m256bh, __mmask16, __m512); 
#line 4933
extern __m256bh _mm512_maskz_cvtneps_pbh(__mmask16, __m512); 
#line 4934
extern __m512bh _mm512_cvtne2ps_pbh(__m512, __m512); 
#line 4935
extern __m512bh _mm512_mask_cvtne2ps_pbh(__m512bh, __mmask32, __m512, __m512); 
#line 4936
extern __m512bh _mm512_maskz_cvtne2ps_pbh(__mmask32, __m512, __m512); 
#line 4937
extern __m512 _mm512_dpbf16_ps(__m512, __m512bh, __m512bh); 
#line 4938
extern __m512 _mm512_mask_dpbf16_ps(__m512, __mmask16, __m512bh, __m512bh); 
#line 4939
extern __m512 _mm512_maskz_dpbf16_ps(__mmask16, __m512, __m512bh, __m512bh); 
#line 4940
extern __bfloat16 _mm_cvtness_sbh(float); 
#line 4941
extern float _mm_cvtsbh_ss(__bfloat16); 
#line 4942
extern __m128 _mm_cvtpbh_ps(__m128bh); 
#line 4943
extern __m128 _mm_mask_cvtpbh_ps(__m128, __mmask8, __m128bh); 
#line 4944
extern __m128 _mm_maskz_cvtpbh_ps(__mmask8, __m128bh); 
#line 4945
extern __m256 _mm256_cvtpbh_ps(__m128bh); 
#line 4946
extern __m256 _mm256_mask_cvtpbh_ps(__m256, __mmask8, __m128bh); 
#line 4947
extern __m256 _mm256_maskz_cvtpbh_ps(__mmask8, __m128bh); 
#line 4948
extern __m512 _mm512_cvtpbh_ps(__m256bh); 
#line 4949
extern __m512 _mm512_mask_cvtpbh_ps(__m512, __mmask16, __m256bh); 
#line 4950
extern __m512 _mm512_maskz_cvtpbh_ps(__mmask16, __m256bh); 
#line 4971
extern __mmask8 __cdecl _kadd_mask8(__mmask8, __mmask8); 
#line 4972
extern __mmask16 __cdecl _kadd_mask16(__mmask16, __mmask16); 
#line 4973
extern __mmask32 __cdecl _kadd_mask32(__mmask32, __mmask32); 
#line 4974
extern __mmask64 __cdecl _kadd_mask64(__mmask64, __mmask64); 
#line 4975
extern __mmask8 __cdecl _kand_mask8(__mmask8, __mmask8); 
#line 4976
extern __mmask16 __cdecl _kand_mask16(__mmask16, __mmask16); 
#line 4977
extern __mmask32 __cdecl _kand_mask32(__mmask32, __mmask32); 
#line 4978
extern __mmask64 __cdecl _kand_mask64(__mmask64, __mmask64); 
#line 4979
extern __mmask8 __cdecl _kandn_mask8(__mmask8, __mmask8); 
#line 4980
extern __mmask16 __cdecl _kandn_mask16(__mmask16, __mmask16); 
#line 4981
extern __mmask32 __cdecl _kandn_mask32(__mmask32, __mmask32); 
#line 4982
extern __mmask64 __cdecl _kandn_mask64(__mmask64, __mmask64); 
#line 4983
extern __mmask8 __cdecl _knot_mask8(__mmask8); 
#line 4984
extern __mmask16 __cdecl _knot_mask16(__mmask16); 
#line 4985
extern __mmask32 __cdecl _knot_mask32(__mmask32); 
#line 4986
extern __mmask64 __cdecl _knot_mask64(__mmask64); 
#line 4987
extern __mmask8 __cdecl _kor_mask8(__mmask8, __mmask8); 
#line 4988
extern __mmask16 __cdecl _kor_mask16(__mmask16, __mmask16); 
#line 4989
extern __mmask32 __cdecl _kor_mask32(__mmask32, __mmask32); 
#line 4990
extern __mmask64 __cdecl _kor_mask64(__mmask64, __mmask64); 
#line 4991
extern __mmask8 __cdecl _kxnor_mask8(__mmask8, __mmask8); 
#line 4992
extern __mmask16 __cdecl _kxnor_mask16(__mmask16, __mmask16); 
#line 4993
extern __mmask32 __cdecl _kxnor_mask32(__mmask32, __mmask32); 
#line 4994
extern __mmask64 __cdecl _kxnor_mask64(__mmask64, __mmask64); 
#line 4995
extern __mmask8 __cdecl _kxor_mask8(__mmask8, __mmask8); 
#line 4996
extern __mmask16 __cdecl _kxor_mask16(__mmask16, __mmask16); 
#line 4997
extern __mmask32 __cdecl _kxor_mask32(__mmask32, __mmask32); 
#line 4998
extern __mmask64 __cdecl _kxor_mask64(__mmask64, __mmask64); 
#line 4999
extern __mmask8 __cdecl _kshiftli_mask8(__mmask8, unsigned); 
#line 5000
extern __mmask16 __cdecl _kshiftli_mask16(__mmask16, unsigned); 
#line 5001
extern __mmask32 __cdecl _kshiftli_mask32(__mmask32, unsigned); 
#line 5002
extern __mmask64 __cdecl _kshiftli_mask64(__mmask64, unsigned); 
#line 5003
extern __mmask8 __cdecl _kshiftri_mask8(__mmask8, unsigned); 
#line 5004
extern __mmask16 __cdecl _kshiftri_mask16(__mmask16, unsigned); 
#line 5005
extern __mmask32 __cdecl _kshiftri_mask32(__mmask32, unsigned); 
#line 5006
extern __mmask64 __cdecl _kshiftri_mask64(__mmask64, unsigned); 
#line 5007
extern __mmask8 __cdecl _load_mask8(__mmask8 *); 
#line 5008
extern __mmask16 __cdecl _load_mask16(__mmask16 *); 
#line 5009
extern __mmask32 __cdecl _load_mask32(__mmask32 *); 
#line 5010
extern __mmask64 __cdecl _load_mask64(__mmask64 *); 
#line 5011
extern void __cdecl _store_mask8(__mmask8 *, __mmask8); 
#line 5012
extern void __cdecl _store_mask16(__mmask16 *, __mmask16); 
#line 5013
extern void __cdecl _store_mask32(__mmask32 *, __mmask32); 
#line 5014
extern void __cdecl _store_mask64(__mmask64 *, __mmask64); 
#line 5015
extern unsigned __cdecl _cvtmask8_u32(__mmask8); 
#line 5016
extern unsigned __cdecl _cvtmask16_u32(__mmask16); 
#line 5017
extern unsigned __cdecl _cvtmask32_u32(__mmask32); 
#line 5018
extern unsigned __int64 __cdecl _cvtmask64_u64(__mmask64); 
#line 5019
extern __mmask8 __cdecl _cvtu32_mask8(unsigned); 
#line 5020
extern __mmask16 __cdecl _cvtu32_mask16(unsigned); 
#line 5021
extern __mmask32 __cdecl _cvtu32_mask32(unsigned); 
#line 5022
extern __mmask64 __cdecl _cvtu64_mask64(unsigned __int64); 
#line 5023
extern __mmask16 __cdecl _mm512_kmov(__mmask16); 
#line 5024
extern unsigned char __cdecl _kortest_mask8_u8(__mmask8, __mmask8, unsigned char *); 
#line 5025
extern unsigned char __cdecl _kortest_mask16_u8(__mmask16, __mmask16, unsigned char *); 
#line 5026
extern unsigned char __cdecl _kortest_mask32_u8(__mmask32, __mmask32, unsigned char *); 
#line 5027
extern unsigned char __cdecl _kortest_mask64_u8(__mmask64, __mmask64, unsigned char *); 
#line 5028
extern unsigned char __cdecl _ktest_mask8_u8(__mmask8, __mmask8, unsigned char *); 
#line 5029
extern unsigned char __cdecl _ktest_mask16_u8(__mmask16, __mmask16, unsigned char *); 
#line 5030
extern unsigned char __cdecl _ktest_mask32_u8(__mmask32, __mmask32, unsigned char *); 
#line 5031
extern unsigned char __cdecl _ktest_mask64_u8(__mmask64, __mmask64, unsigned char *); 
#line 5069
extern __m512 __cdecl _mm512_mask_exp2a23_round_ps(__m512, __mmask16, __m512, int); 
#line 5070
extern __m512 __cdecl _mm512_maskz_exp2a23_round_ps(__mmask16, __m512, int); 
#line 5071
extern __m512d __cdecl _mm512_mask_exp2a23_round_pd(__m512d, __mmask8, __m512d, int); 
#line 5072
extern __m512d __cdecl _mm512_maskz_exp2a23_round_pd(__mmask8, __m512d, int); 
#line 5091
extern __m512 __cdecl _mm512_mask_rcp28_round_ps(__m512, __mmask16, __m512, const int); 
#line 5092
extern __m512 __cdecl _mm512_maskz_rcp28_round_ps(__mmask16, __m512, const int); 
#line 5093
extern __m512d __cdecl _mm512_mask_rcp28_round_pd(__m512d, __mmask8, __m512d, const int); 
#line 5094
extern __m512d __cdecl _mm512_maskz_rcp28_round_pd(__mmask8, __m512d, const int); 
#line 5113
extern __m512 __cdecl _mm512_mask_rsqrt28_round_ps(__m512, __mmask16, __m512, const int); 
#line 5114
extern __m512 __cdecl _mm512_maskz_rsqrt28_round_ps(__mmask16, __m512, const int); 
#line 5115
extern __m512d __cdecl _mm512_mask_rsqrt28_round_pd(__m512d, __mmask8, __m512d, const int); 
#line 5116
extern __m512d __cdecl _mm512_maskz_rsqrt28_round_pd(__mmask8, __m512d, const int); 
#line 5135
extern void __cdecl _mm512_prefetch_i32gather_pd(__m256i vindex, const void * base_addr, int scale, const int hint); 
#line 5136
extern void __cdecl _mm512_prefetch_i32gather_ps(__m512i index, const void * mv, int scale, const int hint); 
#line 5137
extern void __cdecl _mm512_prefetch_i32scatter_pd(void * base_addr, __m256i vindex, int scale, const int hint); 
#line 5138
extern void __cdecl _mm512_prefetch_i32scatter_ps(void * mv, __m512i index, int scale, const int hint); 
#line 5139
extern void __cdecl _mm512_prefetch_i64gather_pd(__m512i vindex, const void * base_addr, int scale, const int hint); 
#line 5140
extern void __cdecl _mm512_prefetch_i64gather_ps(__m512i vindex, const void * base_addr, int scale, const int hint); 
#line 5141
extern void __cdecl _mm512_prefetch_i64scatter_pd(void * base_addr, __m512i vindex, int scale, const int hint); 
#line 5142
extern void __cdecl _mm512_prefetch_i64scatter_ps(void * base_addr, __m512i vindex, int scale, const int hint); 
#line 5143
extern void __cdecl _mm512_mask_prefetch_i32gather_pd(__m256i vindex, __mmask8 mask, const void * base_addr, int scale, const int hint); 
#line 5144
extern void __cdecl _mm512_mask_prefetch_i32gather_ps(__m512i vindex, __mmask16 mask, const void * base_addr, int scale, const int hint); 
#line 5145
extern void __cdecl _mm512_mask_prefetch_i32scatter_pd(void * base_addr, __mmask8 mask, __m256i vinde, int scale, const int hint); 
#line 5146
extern void __cdecl _mm512_mask_prefetch_i32scatter_ps(void * mv, __mmask16 k, __m512i index, int scale, const int hint); 
#line 5147
extern void __cdecl _mm512_mask_prefetch_i64gather_pd(__m512i vindex, __mmask8 mask, const void * base_addr, int scale, const int hint); 
#line 5148
extern void __cdecl _mm512_mask_prefetch_i64gather_ps(__m512i vindex, __mmask8 mask, const void * base_addr, int scale, const int hint); 
#line 5149
extern void __cdecl _mm512_mask_prefetch_i64scatter_pd(void * base_addr, __mmask8 mask, __m512i vindex, int scale, const int hint); 
#line 5150
extern void __cdecl _mm512_mask_prefetch_i64scatter_ps(void * base_addr, __mmask8 mask, __m512i vindex, int scale, const int hint); 
#line 5153
extern void __cdecl _mm_2intersect_epi32(__m128i, __m128i, __mmask8 *, __mmask8 *); 
#line 5154
extern void __cdecl _mm256_2intersect_epi32(__m256i, __m256i, __mmask8 *, __mmask8 *); 
#line 5155
extern void __cdecl _mm512_2intersect_epi32(__m512i, __m512i, __mmask16 *, __mmask16 *); 
#line 5156
extern void __cdecl _mm_2intersect_epi64(__m128i, __m128i, __mmask8 *, __mmask8 *); 
#line 5157
extern void __cdecl _mm256_2intersect_epi64(__m256i, __m256i, __mmask8 *, __mmask8 *); 
#line 5158
extern void __cdecl _mm512_2intersect_epi64(__m512i, __m512i, __mmask8 *, __mmask8 *); 
#line 5163
typedef int __tile; 
#line 5165
extern void __cdecl _tile_loadconfig(const void *); 
#line 5166
extern void __cdecl _tile_storeconfig(void *); 
#line 5167
extern void __cdecl _tile_release(); 
#line 5169
extern void __cdecl _tile_loadd(__tile dst, const void * base, int stride); 
#line 5170
extern void __cdecl _tile_loaddrs(__tile dst, const void * base, int stride); 
#line 5171
extern void __cdecl _tile_loaddrst1(__tile dst, const void * base, int stride); 
#line 5172
extern void __cdecl _tile_stream_loadd(__tile dst, const void * base, int stride); 
#line 5173
extern void __cdecl _tile_stored(__tile src, void * base, int stride); 
#line 5174
extern void __cdecl _tile_zero(__tile dst); 
#line 5176
extern void __cdecl _tile_dpbf16ps(__tile dst, __tile src1, __tile src2); 
#line 5177
extern void __cdecl _tile_dpfp16ps(__tile dst, __tile src1, __tile src2); 
#line 5178
extern void __cdecl _tile_dpbssd(__tile dst, __tile src1, __tile src2); 
#line 5179
extern void __cdecl _tile_dpbsud(__tile dst, __tile src1, __tile src2); 
#line 5180
extern void __cdecl _tile_dpbusd(__tile dst, __tile src1, __tile src2); 
#line 5181
extern void __cdecl _tile_dpbuud(__tile dst, __tile src1, __tile src2); 
#line 5184
extern void __cdecl _tile_cmmimfp16ps(__tile dst, __tile src1, __tile src2); 
#line 5185
extern void __cdecl _tile_cmmrlfp16ps(__tile dst, __tile src1, __tile src2); 
#line 5188
extern void __cdecl _tile_dpbf8ps(__tile dst, __tile src1, __tile src2); 
#line 5189
extern void __cdecl _tile_dpbhf8ps(__tile dst, __tile src1, __tile src2); 
#line 5190
extern void __cdecl _tile_dphbf8ps(__tile dst, __tile src1, __tile src2); 
#line 5191
extern void __cdecl _tile_dphf8ps(__tile dst, __tile src1, __tile src2); 
#line 5194
extern void __cdecl _tile_mmultf32ps(__tile dst, __tile src1, __tile src2); 
#line 5195
extern void __cdecl _tile_tmmultf32ps(__tile dst, __tile src1, __tile src2); 
#line 5198
extern void __cdecl _tile_2rpntlvwz0(__tile dst, const void * base, int stride); 
#line 5199
extern void __cdecl _tile_2rpntlvwz0t1(__tile dst, const void * base, int stride); 
#line 5200
extern void __cdecl _tile_2rpntlvwz1(__tile dst, const void * base, int stride); 
#line 5201
extern void __cdecl _tile_2rpntlvwz1t1(__tile dst, const void * base, int stride); 
#line 5202
extern void __cdecl _tile_transposed(__tile dst, __tile src1); 
#line 5205
extern void __cdecl _tile_2rpntlvwz0rs(__tile dst, const void * base, int stride); 
#line 5206
extern void __cdecl _tile_2rpntlvwz0rst1(__tile dst, const void * base, int stride); 
#line 5207
extern void __cdecl _tile_2rpntlvwz1rs(__tile dst, const void * base, int stride); 
#line 5208
extern void __cdecl _tile_2rpntlvwz1rst1(__tile dst, const void * base, int stride); 
#line 5211
extern void __cdecl _tile_conjtcmmimfp16ps(__tile dst, __tile src1, __tile src2); 
#line 5212
extern void __cdecl _tile_conjtfp16(__tile dst, __tile src1); 
#line 5213
extern void __cdecl _tile_tcmmimfp16ps(__tile dst, __tile src1, __tile src2); 
#line 5214
extern void __cdecl _tile_tcmmrlfp16ps(__tile dst, __tile src1, __tile src2); 
#line 5217
extern void __cdecl _tile_tdpbf16ps(__tile dst, __tile src1, __tile src2); 
#line 5220
extern void __cdecl _tile_tdpfp16ps(__tile dst, __tile src1, __tile src2); 
#line 5225 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"
typedef __m128i __m128h; 
#line 5226
typedef __m256i __m256h; 
#line 5227
typedef __m512i __m512h; 
#line 5232
extern __m512 __cdecl _tile_cvtrowd2ps(__tile dst, unsigned a); 
#line 5233
extern __m512 __cdecl _tile_cvtrowd2psi(__tile dst, const unsigned); 
#line 5234
extern __m512bh __cdecl _tile_cvtrowps2bf16h(__tile dst, unsigned a); 
#line 5235
extern __m512bh __cdecl _tile_cvtrowps2bf16hi(__tile dst, const unsigned); 
#line 5236
extern __m512bh __cdecl _tile_cvtrowps2bf16l(__tile dst, unsigned a); 
#line 5237
extern __m512bh __cdecl _tile_cvtrowps2bf16li(__tile dst, const unsigned); 
#line 5238
extern __m512h __cdecl _tile_cvtrowps2phh(__tile dst, unsigned a); 
#line 5239
extern __m512h __cdecl _tile_cvtrowps2phhi(__tile dst, const unsigned); 
#line 5240
extern __m512h __cdecl _tile_cvtrowps2phl(__tile dst, unsigned a); 
#line 5241
extern __m512h __cdecl _tile_cvtrowps2phli(__tile dst, const unsigned); 
#line 5242
extern __m512 __cdecl _tile_movrow(__tile dst, unsigned a); 
#line 5243
extern __m512 __cdecl _tile_movrowi(__tile dst, const unsigned); 
#line 5248 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"
extern __m128h __cdecl _mm_add_ph(__m128h, __m128h); 
#line 5249
extern __m128h __cdecl _mm_mask_add_ph(__m128h, __mmask8, __m128h, __m128h); 
#line 5250
extern __m128h __cdecl _mm_maskz_add_ph(__mmask8, __m128h, __m128h); 
#line 5251
extern __m256h __cdecl _mm256_add_ph(__m256h, __m256h); 
#line 5252
extern __m256h __cdecl _mm256_mask_add_ph(__m256h, __mmask16, __m256h, __m256h); 
#line 5253
extern __m256h __cdecl _mm256_maskz_add_ph(__mmask16, __m256h, __m256h); 
#line 5254
extern __m512h __cdecl _mm512_add_ph(__m512h, __m512h); 
#line 5255
extern __m512h __cdecl _mm512_mask_add_ph(__m512h, __mmask32, __m512h, __m512h); 
#line 5256
extern __m512h __cdecl _mm512_maskz_add_ph(__mmask32, __m512h, __m512h); 
#line 5257
extern __m512h __cdecl _mm512_add_round_ph(__m512h, __m512h, int); 
#line 5258
extern __m512h __cdecl _mm512_mask_add_round_ph(__m512h, __mmask32, __m512h, __m512h, int); 
#line 5259
extern __m512h __cdecl _mm512_maskz_add_round_ph(__mmask32, __m512h, __m512h, int); 
#line 5262
extern __m128h __cdecl _mm_add_sh(__m128h, __m128h); 
#line 5263
extern __m128h __cdecl _mm_mask_add_sh(__m128h, __mmask8, __m128h, __m128h); 
#line 5264
extern __m128h __cdecl _mm_maskz_add_sh(__mmask8, __m128h, __m128h); 
#line 5265
extern __m128h __cdecl _mm_add_round_sh(__m128h, __m128h, int); 
#line 5266
extern __m128h __cdecl _mm_mask_add_round_sh(__m128h, __mmask8, __m128h, __m128h, int); 
#line 5267
extern __m128h __cdecl _mm_maskz_add_round_sh(__mmask8, __m128h, __m128h, int); 
#line 5275
extern __mmask8 __cdecl _mm_cmp_ph_mask(__m128h, __m128h, const int); 
#line 5276
extern __mmask8 __cdecl _mm_mask_cmp_ph_mask(__mmask8, __m128h, __m128h, const int); 
#line 5277
extern __mmask16 __cdecl _mm256_cmp_ph_mask(__m256h, __m256h, const int); 
#line 5278
extern __mmask16 __cdecl _mm256_mask_cmp_ph_mask(__mmask16, __m256h, __m256h, const int); 
#line 5279
extern __mmask32 __cdecl _mm512_cmp_ph_mask(__m512h, __m512h, const int); 
#line 5280
extern __mmask32 __cdecl _mm512_mask_cmp_ph_mask(__mmask32, __m512h, __m512h, const int); 
#line 5281
extern __mmask32 __cdecl _mm512_cmp_round_ph_mask(__m512h, __m512h, const int, const int); 
#line 5282
extern __mmask32 __cdecl _mm512_mask_cmp_round_ph_mask(__mmask32, __m512h, __m512h, const int, const int); 
#line 5285
extern __mmask8 __cdecl _mm_cmp_sh_mask(__m128h, __m128h, const int); 
#line 5286
extern __mmask8 __cdecl _mm_mask_cmp_sh_mask(__mmask8, __m128h, __m128h, const int); 
#line 5287
extern __mmask8 __cdecl _mm_cmp_round_sh_mask(__m128h, __m128h, const int, const int); 
#line 5288
extern __mmask8 __cdecl _mm_mask_cmp_round_sh_mask(__mmask8, __m128h, __m128h, const int, const int); 
#line 5291
extern int __cdecl _mm_comi_sh(__m128h, __m128h, const int); 
#line 5292
extern int __cdecl _mm_comi_round_sh(__m128h, __m128h, const int, const int); 
#line 5295
extern __m128h __cdecl _mm_cvtepi32_ph(__m128i); 
#line 5296
extern __m128h __cdecl _mm_mask_cvtepi32_ph(__m128h, __mmask8, __m128i); 
#line 5297
extern __m128h __cdecl _mm_maskz_cvtepi32_ph(__mmask8, __m128i); 
#line 5298
extern __m128h __cdecl _mm256_cvtepi32_ph(__m256i); 
#line 5299
extern __m128h __cdecl _mm256_mask_cvtepi32_ph(__m128h, __mmask8, __m256i); 
#line 5300
extern __m128h __cdecl _mm256_maskz_cvtepi32_ph(__mmask8, __m256i); 
#line 5301
extern __m256h __cdecl _mm512_cvtepi32_ph(__m512i); 
#line 5302
extern __m256h __cdecl _mm512_mask_cvtepi32_ph(__m256h, __mmask16, __m512i); 
#line 5303
extern __m256h __cdecl _mm512_maskz_cvtepi32_ph(__mmask16, __m512i); 
#line 5304
extern __m256h __cdecl _mm512_cvt_roundepi32_ph(__m512i, int); 
#line 5305
extern __m256h __cdecl _mm512_mask_cvt_roundepi32_ph(__m256h, __mmask16, __m512i, int); 
#line 5306
extern __m256h __cdecl _mm512_maskz_cvt_roundepi32_ph(__mmask16, __m512i, int); 
#line 5309
extern __m128h __cdecl _mm_cvtpd_ph(__m128d); 
#line 5310
extern __m128h __cdecl _mm_mask_cvtpd_ph(__m128h, __mmask8, __m128d); 
#line 5311
extern __m128h __cdecl _mm_maskz_cvtpd_ph(__mmask8, __m128d); 
#line 5312
extern __m128h __cdecl _mm256_cvtpd_ph(__m256d); 
#line 5313
extern __m128h __cdecl _mm256_mask_cvtpd_ph(__m128h, __mmask8, __m256d); 
#line 5314
extern __m128h __cdecl _mm256_maskz_cvtpd_ph(__mmask8, __m256d); 
#line 5315
extern __m128h __cdecl _mm512_cvtpd_ph(__m512d); 
#line 5316
extern __m128h __cdecl _mm512_mask_cvtpd_ph(__m128h, __mmask8, __m512d); 
#line 5317
extern __m128h __cdecl _mm512_maskz_cvtpd_ph(__mmask8, __m512d); 
#line 5318
extern __m128h __cdecl _mm512_cvt_roundpd_ph(__m512d, int); 
#line 5319
extern __m128h __cdecl _mm512_mask_cvt_roundpd_ph(__m128h, __mmask8, __m512d, int); 
#line 5320
extern __m128h __cdecl _mm512_maskz_cvt_roundpd_ph(__mmask8, __m512d, int); 
#line 5323
extern __m128i __cdecl _mm_cvtph_epi32(__m128h); 
#line 5324
extern __m128i __cdecl _mm_mask_cvtph_epi32(__m128i, __mmask8, __m128h); 
#line 5325
extern __m128i __cdecl _mm_maskz_cvtph_epi32(__mmask8, __m128h); 
#line 5326
extern __m256i __cdecl _mm256_cvtph_epi32(__m128h); 
#line 5327
extern __m256i __cdecl _mm256_mask_cvtph_epi32(__m256i, __mmask8, __m128h); 
#line 5328
extern __m256i __cdecl _mm256_maskz_cvtph_epi32(__mmask8, __m128h); 
#line 5329
extern __m512i __cdecl _mm512_cvtph_epi32(__m256h); 
#line 5330
extern __m512i __cdecl _mm512_mask_cvtph_epi32(__m512i, __mmask16, __m256h); 
#line 5331
extern __m512i __cdecl _mm512_maskz_cvtph_epi32(__mmask16, __m256h); 
#line 5332
extern __m512i __cdecl _mm512_cvt_roundph_epi32(__m256h, int); 
#line 5333
extern __m512i __cdecl _mm512_mask_cvt_roundph_epi32(__m512i, __mmask16, __m256h, int); 
#line 5334
extern __m512i __cdecl _mm512_maskz_cvt_roundph_epi32(__mmask16, __m256h, int); 
#line 5337
extern __m128d __cdecl _mm_cvtph_pd(__m128h); 
#line 5338
extern __m128d __cdecl _mm_mask_cvtph_pd(__m128d, __mmask8, __m128h); 
#line 5339
extern __m128d __cdecl _mm_maskz_cvtph_pd(__mmask8, __m128h); 
#line 5340
extern __m256d __cdecl _mm256_cvtph_pd(__m128h); 
#line 5341
extern __m256d __cdecl _mm256_mask_cvtph_pd(__m256d, __mmask8, __m128h); 
#line 5342
extern __m256d __cdecl _mm256_maskz_cvtph_pd(__mmask8, __m128h); 
#line 5343
extern __m512d __cdecl _mm512_cvtph_pd(__m128h); 
#line 5344
extern __m512d __cdecl _mm512_mask_cvtph_pd(__m512d, __mmask8, __m128h); 
#line 5345
extern __m512d __cdecl _mm512_maskz_cvtph_pd(__mmask8, __m128h); 
#line 5346
extern __m512d __cdecl _mm512_cvt_roundph_pd(__m128h, int); 
#line 5347
extern __m512d __cdecl _mm512_mask_cvt_roundph_pd(__m512d, __mmask8, __m128h, int); 
#line 5348
extern __m512d __cdecl _mm512_maskz_cvt_roundph_pd(__mmask8, __m128h, int); 
#line 5351
extern __m128 __cdecl _mm_cvtxph_ps(__m128h); 
#line 5352
extern __m128 __cdecl _mm_mask_cvtxph_ps(__m128, __mmask8, __m128h); 
#line 5353
extern __m128 __cdecl _mm_maskz_cvtxph_ps(__mmask8, __m128h); 
#line 5354
extern __m256 __cdecl _mm256_cvtxph_ps(__m128h); 
#line 5355
extern __m256 __cdecl _mm256_mask_cvtxph_ps(__m256, __mmask8, __m128h); 
#line 5356
extern __m256 __cdecl _mm256_maskz_cvtxph_ps(__mmask8, __m128h); 
#line 5357
extern __m512 __cdecl _mm512_cvtxph_ps(__m256h); 
#line 5358
extern __m512 __cdecl _mm512_mask_cvtxph_ps(__m512, __mmask16, __m256h); 
#line 5359
extern __m512 __cdecl _mm512_maskz_cvtxph_ps(__mmask16, __m256h); 
#line 5360
extern __m512 __cdecl _mm512_cvtx_roundph_ps(__m256h, int); 
#line 5361
extern __m512 __cdecl _mm512_mask_cvtx_roundph_ps(__m512, __mmask16, __m256h, int); 
#line 5362
extern __m512 __cdecl _mm512_maskz_cvtx_roundph_ps(__mmask16, __m256h, int); 
#line 5365
extern __m128i __cdecl _mm_cvtph_epi64(__m128h); 
#line 5366
extern __m128i __cdecl _mm_mask_cvtph_epi64(__m128i, __mmask8, __m128h); 
#line 5367
extern __m128i __cdecl _mm_maskz_cvtph_epi64(__mmask8, __m128h); 
#line 5368
extern __m256i __cdecl _mm256_cvtph_epi64(__m128h); 
#line 5369
extern __m256i __cdecl _mm256_mask_cvtph_epi64(__m256i, __mmask8, __m128h); 
#line 5370
extern __m256i __cdecl _mm256_maskz_cvtph_epi64(__mmask8, __m128h); 
#line 5371
extern __m512i __cdecl _mm512_cvtph_epi64(__m128h); 
#line 5372
extern __m512i __cdecl _mm512_mask_cvtph_epi64(__m512i, __mmask8, __m128h); 
#line 5373
extern __m512i __cdecl _mm512_maskz_cvtph_epi64(__mmask8, __m128h); 
#line 5374
extern __m512i __cdecl _mm512_cvt_roundph_epi64(__m128h, int); 
#line 5375
extern __m512i __cdecl _mm512_mask_cvt_roundph_epi64(__m512i, __mmask8, __m128h, int); 
#line 5376
extern __m512i __cdecl _mm512_maskz_cvt_roundph_epi64(__mmask8, __m128h, int); 
#line 5379
extern __m128i __cdecl _mm_cvtph_epu32(__m128h); 
#line 5380
extern __m128i __cdecl _mm_mask_cvtph_epu32(__m128i, __mmask8, __m128h); 
#line 5381
extern __m128i __cdecl _mm_maskz_cvtph_epu32(__mmask8, __m128h); 
#line 5382
extern __m256i __cdecl _mm256_cvtph_epu32(__m128h); 
#line 5383
extern __m256i __cdecl _mm256_mask_cvtph_epu32(__m256i, __mmask8, __m128h); 
#line 5384
extern __m256i __cdecl _mm256_maskz_cvtph_epu32(__mmask8, __m128h); 
#line 5385
extern __m512i __cdecl _mm512_cvtph_epu32(__m256h); 
#line 5386
extern __m512i __cdecl _mm512_mask_cvtph_epu32(__m512i, __mmask16, __m256h); 
#line 5387
extern __m512i __cdecl _mm512_maskz_cvtph_epu32(__mmask16, __m256h); 
#line 5388
extern __m512i __cdecl _mm512_cvt_roundph_epu32(__m256h, int); 
#line 5389
extern __m512i __cdecl _mm512_mask_cvt_roundph_epu32(__m512i, __mmask16, __m256h, int); 
#line 5390
extern __m512i __cdecl _mm512_maskz_cvt_roundph_epu32(__mmask16, __m256h, int); 
#line 5393
extern __m128i __cdecl _mm_cvtph_epu64(__m128h); 
#line 5394
extern __m128i __cdecl _mm_mask_cvtph_epu64(__m128i, __mmask8, __m128h); 
#line 5395
extern __m128i __cdecl _mm_maskz_cvtph_epu64(__mmask8, __m128h); 
#line 5396
extern __m256i __cdecl _mm256_cvtph_epu64(__m128h); 
#line 5397
extern __m256i __cdecl _mm256_mask_cvtph_epu64(__m256i, __mmask8, __m128h); 
#line 5398
extern __m256i __cdecl _mm256_maskz_cvtph_epu64(__mmask8, __m128h); 
#line 5399
extern __m512i __cdecl _mm512_cvtph_epu64(__m128h); 
#line 5400
extern __m512i __cdecl _mm512_mask_cvtph_epu64(__m512i, __mmask8, __m128h); 
#line 5401
extern __m512i __cdecl _mm512_maskz_cvtph_epu64(__mmask8, __m128h); 
#line 5402
extern __m512i __cdecl _mm512_cvt_roundph_epu64(__m128h, int); 
#line 5403
extern __m512i __cdecl _mm512_mask_cvt_roundph_epu64(__m512i, __mmask8, __m128h, int); 
#line 5404
extern __m512i __cdecl _mm512_maskz_cvt_roundph_epu64(__mmask8, __m128h, int); 
#line 5407
extern __m128i __cdecl _mm_cvtph_epu16(__m128h); 
#line 5408
extern __m128i __cdecl _mm_mask_cvtph_epu16(__m128i, __mmask8, __m128h); 
#line 5409
extern __m128i __cdecl _mm_maskz_cvtph_epu16(__mmask8, __m128h); 
#line 5410
extern __m256i __cdecl _mm256_cvtph_epu16(__m256h); 
#line 5411
extern __m256i __cdecl _mm256_mask_cvtph_epu16(__m256i, __mmask16, __m256h); 
#line 5412
extern __m256i __cdecl _mm256_maskz_cvtph_epu16(__mmask16, __m256h); 
#line 5413
extern __m512i __cdecl _mm512_cvtph_epu16(__m512h); 
#line 5414
extern __m512i __cdecl _mm512_mask_cvtph_epu16(__m512i, __mmask32, __m512h); 
#line 5415
extern __m512i __cdecl _mm512_maskz_cvtph_epu16(__mmask32, __m512h); 
#line 5416
extern __m512i __cdecl _mm512_cvt_roundph_epu16(__m512h, int); 
#line 5417
extern __m512i __cdecl _mm512_mask_cvt_roundph_epu16(__m512i, __mmask32, __m512h, int); 
#line 5418
extern __m512i __cdecl _mm512_maskz_cvt_roundph_epu16(__mmask32, __m512h, int); 
#line 5421
extern __m128i __cdecl _mm_cvtph_epi16(__m128h); 
#line 5422
extern __m128i __cdecl _mm_mask_cvtph_epi16(__m128i, __mmask8, __m128h); 
#line 5423
extern __m128i __cdecl _mm_maskz_cvtph_epi16(__mmask8, __m128h); 
#line 5424
extern __m256i __cdecl _mm256_cvtph_epi16(__m256h); 
#line 5425
extern __m256i __cdecl _mm256_mask_cvtph_epi16(__m256i, __mmask16, __m256h); 
#line 5426
extern __m256i __cdecl _mm256_maskz_cvtph_epi16(__mmask16, __m256h); 
#line 5427
extern __m512i __cdecl _mm512_cvtph_epi16(__m512h); 
#line 5428
extern __m512i __cdecl _mm512_mask_cvtph_epi16(__m512i, __mmask32, __m512h); 
#line 5429
extern __m512i __cdecl _mm512_maskz_cvtph_epi16(__mmask32, __m512h); 
#line 5430
extern __m512i __cdecl _mm512_cvt_roundph_epi16(__m512h, int); 
#line 5431
extern __m512i __cdecl _mm512_mask_cvt_roundph_epi16(__m512i, __mmask32, __m512h, int); 
#line 5432
extern __m512i __cdecl _mm512_maskz_cvt_roundph_epi16(__mmask32, __m512h, int); 
#line 5435
extern __m128h __cdecl _mm_cvtxps_ph(__m128); 
#line 5436
extern __m128h __cdecl _mm_mask_cvtxps_ph(__m128h, __mmask8, __m128); 
#line 5437
extern __m128h __cdecl _mm_maskz_cvtxps_ph(__mmask8, __m128); 
#line 5438
extern __m128h __cdecl _mm256_cvtxps_ph(__m256); 
#line 5439
extern __m128h __cdecl _mm256_mask_cvtxps_ph(__m128h, __mmask8, __m256); 
#line 5440
extern __m128h __cdecl _mm256_maskz_cvtxps_ph(__mmask8, __m256); 
#line 5441
extern __m256h __cdecl _mm512_cvtxps_ph(__m512); 
#line 5442
extern __m256h __cdecl _mm512_mask_cvtxps_ph(__m256h, __mmask16, __m512); 
#line 5443
extern __m256h __cdecl _mm512_maskz_cvtxps_ph(__mmask16, __m512); 
#line 5444
extern __m256h __cdecl _mm512_cvtx_roundps_ph(__m512, int); 
#line 5445
extern __m256h __cdecl _mm512_mask_cvtx_roundps_ph(__m256h, __mmask16, __m512, int); 
#line 5446
extern __m256h __cdecl _mm512_maskz_cvtx_roundps_ph(__mmask16, __m512, int); 
#line 5449
extern __m128h __cdecl _mm_cvtepi64_ph(__m128i); 
#line 5450
extern __m128h __cdecl _mm_mask_cvtepi64_ph(__m128h, __mmask8, __m128i); 
#line 5451
extern __m128h __cdecl _mm_maskz_cvtepi64_ph(__mmask8, __m128i); 
#line 5452
extern __m128h __cdecl _mm256_cvtepi64_ph(__m256i); 
#line 5453
extern __m128h __cdecl _mm256_mask_cvtepi64_ph(__m128h, __mmask8, __m256i); 
#line 5454
extern __m128h __cdecl _mm256_maskz_cvtepi64_ph(__mmask8, __m256i); 
#line 5455
extern __m128h __cdecl _mm512_cvtepi64_ph(__m512i); 
#line 5456
extern __m128h __cdecl _mm512_mask_cvtepi64_ph(__m128h, __mmask8, __m512i); 
#line 5457
extern __m128h __cdecl _mm512_maskz_cvtepi64_ph(__mmask8, __m512i); 
#line 5458
extern __m128h __cdecl _mm512_cvt_roundepi64_ph(__m512i, int); 
#line 5459
extern __m128h __cdecl _mm512_mask_cvt_roundepi64_ph(__m128h, __mmask8, __m512i, int); 
#line 5460
extern __m128h __cdecl _mm512_maskz_cvt_roundepi64_ph(__mmask8, __m512i, int); 
#line 5463
extern __m128h __cdecl _mm_cvtsd_sh(__m128h, __m128d); 
#line 5464
extern __m128h __cdecl _mm_mask_cvtsd_sh(__m128h, __mmask8, __m128h, __m128d); 
#line 5465
extern __m128h __cdecl _mm_maskz_cvtsd_sh(__mmask8, __m128h, __m128d); 
#line 5466
extern __m128h __cdecl _mm_cvt_roundsd_sh(__m128h, __m128d, const int); 
#line 5467
extern __m128h __cdecl _mm_mask_cvt_roundsd_sh(__m128h, __mmask8, __m128h, __m128d, const int); 
#line 5468
extern __m128h __cdecl _mm_maskz_cvt_roundsd_sh(__mmask8, __m128h, __m128d, const int); 
#line 5471
extern __m128d __cdecl _mm_cvtsh_sd(__m128d, __m128h); 
#line 5472
extern __m128d __cdecl _mm_mask_cvtsh_sd(__m128d, __mmask8, __m128d, __m128h); 
#line 5473
extern __m128d __cdecl _mm_maskz_cvtsh_sd(__mmask8, __m128d, __m128h); 
#line 5474
extern __m128d __cdecl _mm_cvt_roundsh_sd(__m128d, __m128h, const int); 
#line 5475
extern __m128d __cdecl _mm_mask_cvt_roundsh_sd(__m128d, __mmask8, __m128d, __m128h, const int); 
#line 5476
extern __m128d __cdecl _mm_maskz_cvt_roundsh_sd(__mmask8, __m128d, __m128h, const int); 
#line 5479
extern int __cdecl _mm_cvtsh_i32(__m128h); 
#line 5480
extern __int64 __cdecl _mm_cvtsh_i64(__m128h); 
#line 5481
extern int __cdecl _mm_cvt_roundsh_i32(__m128h, int); 
#line 5482
extern __int64 __cdecl _mm_cvt_roundsh_i64(__m128h, int); 
#line 5485
extern __m128 __cdecl _mm_cvtsh_ss(__m128, __m128h); 
#line 5486
extern __m128 __cdecl _mm_mask_cvtsh_ss(__m128, __mmask8, __m128, __m128h); 
#line 5487
extern __m128 __cdecl _mm_maskz_cvtsh_ss(__mmask8, __m128, __m128h); 
#line 5488
extern __m128 __cdecl _mm_cvt_roundsh_ss(__m128, __m128h, const int); 
#line 5489
extern __m128 __cdecl _mm_mask_cvt_roundsh_ss(__m128, __mmask8, __m128, __m128h, const int); 
#line 5490
extern __m128 __cdecl _mm_maskz_cvt_roundsh_ss(__mmask8, __m128, __m128h, const int); 
#line 5493
extern unsigned __cdecl _mm_cvtsh_u32(__m128h); 
#line 5494
extern unsigned __int64 __cdecl _mm_cvtsh_u64(__m128h); 
#line 5495
extern unsigned __cdecl _mm_cvt_roundsh_u32(__m128h, int); 
#line 5496
extern unsigned __int64 __cdecl _mm_cvt_roundsh_u64(__m128h, int); 
#line 5499
extern __m128h __cdecl _mm_cvti32_sh(__m128h, int); 
#line 5500
extern __m128h __cdecl _mm_cvti64_sh(__m128h, __int64); 
#line 5501
extern __m128h __cdecl _mm_cvt_roundi32_sh(__m128h, int, int); 
#line 5502
extern __m128h __cdecl _mm_cvt_roundi64_sh(__m128h, __int64, int); 
#line 5505
extern __m128h __cdecl _mm_cvtss_sh(__m128h, __m128); 
#line 5506
extern __m128h __cdecl _mm_mask_cvtss_sh(__m128h, __mmask8, __m128h, __m128); 
#line 5507
extern __m128h __cdecl _mm_maskz_cvtss_sh(__mmask8, __m128h, __m128); 
#line 5508
extern __m128h __cdecl _mm_cvt_roundss_sh(__m128h, __m128, const int); 
#line 5509
extern __m128h __cdecl _mm_mask_cvt_roundss_sh(__m128h, __mmask8, __m128h, __m128, const int); 
#line 5510
extern __m128h __cdecl _mm_maskz_cvt_roundss_sh(__mmask8, __m128h, __m128, const int); 
#line 5513
extern __m128i __cdecl _mm_cvttph_epi32(__m128h); 
#line 5514
extern __m128i __cdecl _mm_mask_cvttph_epi32(__m128i, __mmask8, __m128h); 
#line 5515
extern __m128i __cdecl _mm_maskz_cvttph_epi32(__mmask8, __m128h); 
#line 5516
extern __m256i __cdecl _mm256_cvttph_epi32(__m128h); 
#line 5517
extern __m256i __cdecl _mm256_mask_cvttph_epi32(__m256i, __mmask8, __m128h); 
#line 5518
extern __m256i __cdecl _mm256_maskz_cvttph_epi32(__mmask8, __m128h); 
#line 5519
extern __m512i __cdecl _mm512_cvttph_epi32(__m256h); 
#line 5520
extern __m512i __cdecl _mm512_mask_cvttph_epi32(__m512i, __mmask16, __m256h); 
#line 5521
extern __m512i __cdecl _mm512_maskz_cvttph_epi32(__mmask16, __m256h); 
#line 5522
extern __m512i __cdecl _mm512_cvtt_roundph_epi32(__m256h, int); 
#line 5523
extern __m512i __cdecl _mm512_mask_cvtt_roundph_epi32(__m512i, __mmask16, __m256h, int); 
#line 5524
extern __m512i __cdecl _mm512_maskz_cvtt_roundph_epi32(__mmask16, __m256h, int); 
#line 5527
extern __m128i __cdecl _mm_cvttph_epi64(__m128h); 
#line 5528
extern __m128i __cdecl _mm_mask_cvttph_epi64(__m128i, __mmask8, __m128h); 
#line 5529
extern __m128i __cdecl _mm_maskz_cvttph_epi64(__mmask8, __m128h); 
#line 5530
extern __m256i __cdecl _mm256_cvttph_epi64(__m128h); 
#line 5531
extern __m256i __cdecl _mm256_mask_cvttph_epi64(__m256i, __mmask8, __m128h); 
#line 5532
extern __m256i __cdecl _mm256_maskz_cvttph_epi64(__mmask8, __m128h); 
#line 5533
extern __m512i __cdecl _mm512_cvttph_epi64(__m128h); 
#line 5534
extern __m512i __cdecl _mm512_mask_cvttph_epi64(__m512i, __mmask8, __m128h); 
#line 5535
extern __m512i __cdecl _mm512_maskz_cvttph_epi64(__mmask8, __m128h); 
#line 5536
extern __m512i __cdecl _mm512_cvtt_roundph_epi64(__m128h, int); 
#line 5537
extern __m512i __cdecl _mm512_mask_cvtt_roundph_epi64(__m512i, __mmask8, __m128h, int); 
#line 5538
extern __m512i __cdecl _mm512_maskz_cvtt_roundph_epi64(__mmask8, __m128h, int); 
#line 5541
extern __m128i __cdecl _mm_cvttph_epu32(__m128h); 
#line 5542
extern __m128i __cdecl _mm_mask_cvttph_epu32(__m128i, __mmask8, __m128h); 
#line 5543
extern __m128i __cdecl _mm_maskz_cvttph_epu32(__mmask8, __m128h); 
#line 5544
extern __m256i __cdecl _mm256_cvttph_epu32(__m128h); 
#line 5545
extern __m256i __cdecl _mm256_mask_cvttph_epu32(__m256i, __mmask8, __m128h); 
#line 5546
extern __m256i __cdecl _mm256_maskz_cvttph_epu32(__mmask8, __m128h); 
#line 5547
extern __m512i __cdecl _mm512_cvttph_epu32(__m256h); 
#line 5548
extern __m512i __cdecl _mm512_mask_cvttph_epu32(__m512i, __mmask16, __m256h); 
#line 5549
extern __m512i __cdecl _mm512_maskz_cvttph_epu32(__mmask16, __m256h); 
#line 5550
extern __m512i __cdecl _mm512_cvtt_roundph_epu32(__m256h, int); 
#line 5551
extern __m512i __cdecl _mm512_mask_cvtt_roundph_epu32(__m512i, __mmask16, __m256h, int); 
#line 5552
extern __m512i __cdecl _mm512_maskz_cvtt_roundph_epu32(__mmask16, __m256h, int); 
#line 5555
extern __m128i __cdecl _mm_cvttph_epu64(__m128h); 
#line 5556
extern __m128i __cdecl _mm_mask_cvttph_epu64(__m128i, __mmask8, __m128h); 
#line 5557
extern __m128i __cdecl _mm_maskz_cvttph_epu64(__mmask8, __m128h); 
#line 5558
extern __m256i __cdecl _mm256_cvttph_epu64(__m128h); 
#line 5559
extern __m256i __cdecl _mm256_mask_cvttph_epu64(__m256i, __mmask8, __m128h); 
#line 5560
extern __m256i __cdecl _mm256_maskz_cvttph_epu64(__mmask8, __m128h); 
#line 5561
extern __m512i __cdecl _mm512_cvttph_epu64(__m128h); 
#line 5562
extern __m512i __cdecl _mm512_mask_cvttph_epu64(__m512i, __mmask8, __m128h); 
#line 5563
extern __m512i __cdecl _mm512_maskz_cvttph_epu64(__mmask8, __m128h); 
#line 5564
extern __m512i __cdecl _mm512_cvtt_roundph_epu64(__m128h, int); 
#line 5565
extern __m512i __cdecl _mm512_mask_cvtt_roundph_epu64(__m512i, __mmask8, __m128h, int); 
#line 5566
extern __m512i __cdecl _mm512_maskz_cvtt_roundph_epu64(__mmask8, __m128h, int); 
#line 5569
extern __m128i __cdecl _mm_cvttph_epu16(__m128h); 
#line 5570
extern __m128i __cdecl _mm_mask_cvttph_epu16(__m128i, __mmask8, __m128h); 
#line 5571
extern __m128i __cdecl _mm_maskz_cvttph_epu16(__mmask8, __m128h); 
#line 5572
extern __m256i __cdecl _mm256_cvttph_epu16(__m256h); 
#line 5573
extern __m256i __cdecl _mm256_mask_cvttph_epu16(__m256i, __mmask16, __m256h); 
#line 5574
extern __m256i __cdecl _mm256_maskz_cvttph_epu16(__mmask16, __m256h); 
#line 5575
extern __m512i __cdecl _mm512_cvttph_epu16(__m512h); 
#line 5576
extern __m512i __cdecl _mm512_mask_cvttph_epu16(__m512i, __mmask32, __m512h); 
#line 5577
extern __m512i __cdecl _mm512_maskz_cvttph_epu16(__mmask32, __m512h); 
#line 5578
extern __m512i __cdecl _mm512_cvtt_roundph_epu16(__m512h, int); 
#line 5579
extern __m512i __cdecl _mm512_mask_cvtt_roundph_epu16(__m512i, __mmask32, __m512h, int); 
#line 5580
extern __m512i __cdecl _mm512_maskz_cvtt_roundph_epu16(__mmask32, __m512h, int); 
#line 5583
extern __m128i __cdecl _mm_cvttph_epi16(__m128h); 
#line 5584
extern __m128i __cdecl _mm_mask_cvttph_epi16(__m128i, __mmask8, __m128h); 
#line 5585
extern __m128i __cdecl _mm_maskz_cvttph_epi16(__mmask8, __m128h); 
#line 5586
extern __m256i __cdecl _mm256_cvttph_epi16(__m256h); 
#line 5587
extern __m256i __cdecl _mm256_mask_cvttph_epi16(__m256i, __mmask16, __m256h); 
#line 5588
extern __m256i __cdecl _mm256_maskz_cvttph_epi16(__mmask16, __m256h); 
#line 5589
extern __m512i __cdecl _mm512_cvttph_epi16(__m512h); 
#line 5590
extern __m512i __cdecl _mm512_mask_cvttph_epi16(__m512i, __mmask32, __m512h); 
#line 5591
extern __m512i __cdecl _mm512_maskz_cvttph_epi16(__mmask32, __m512h); 
#line 5592
extern __m512i __cdecl _mm512_cvtt_roundph_epi16(__m512h, int); 
#line 5593
extern __m512i __cdecl _mm512_mask_cvtt_roundph_epi16(__m512i, __mmask32, __m512h, int); 
#line 5594
extern __m512i __cdecl _mm512_maskz_cvtt_roundph_epi16(__mmask32, __m512h, int); 
#line 5597
extern int __cdecl _mm_cvttsh_i32(__m128h); 
#line 5598
extern __int64 __cdecl _mm_cvttsh_i64(__m128h); 
#line 5599
extern int __cdecl _mm_cvtt_roundsh_i32(__m128h, int); 
#line 5600
extern __int64 __cdecl _mm_cvtt_roundsh_i64(__m128h, int); 
#line 5603
extern unsigned __cdecl _mm_cvttsh_u32(__m128h); 
#line 5604
extern unsigned __int64 __cdecl _mm_cvttsh_u64(__m128h); 
#line 5605
extern unsigned __cdecl _mm_cvtt_roundsh_u32(__m128h, int); 
#line 5606
extern unsigned __int64 __cdecl _mm_cvtt_roundsh_u64(__m128h, int); 
#line 5609
extern __m128h __cdecl _mm_cvtepu32_ph(__m128i); 
#line 5610
extern __m128h __cdecl _mm_mask_cvtepu32_ph(__m128h, __mmask8, __m128i); 
#line 5611
extern __m128h __cdecl _mm_maskz_cvtepu32_ph(__mmask8, __m128i); 
#line 5612
extern __m128h __cdecl _mm256_cvtepu32_ph(__m256i); 
#line 5613
extern __m128h __cdecl _mm256_mask_cvtepu32_ph(__m128h, __mmask8, __m256i); 
#line 5614
extern __m128h __cdecl _mm256_maskz_cvtepu32_ph(__mmask8, __m256i); 
#line 5615
extern __m256h __cdecl _mm512_cvtepu32_ph(__m512i); 
#line 5616
extern __m256h __cdecl _mm512_mask_cvtepu32_ph(__m256h, __mmask16, __m512i); 
#line 5617
extern __m256h __cdecl _mm512_maskz_cvtepu32_ph(__mmask16, __m512i); 
#line 5618
extern __m256h __cdecl _mm512_cvt_roundepu32_ph(__m512i, int); 
#line 5619
extern __m256h __cdecl _mm512_mask_cvt_roundepu32_ph(__m256h, __mmask16, __m512i, int); 
#line 5620
extern __m256h __cdecl _mm512_maskz_cvt_roundepu32_ph(__mmask16, __m512i, int); 
#line 5623
extern __m128h __cdecl _mm_cvtepu64_ph(__m128i); 
#line 5624
extern __m128h __cdecl _mm_mask_cvtepu64_ph(__m128h, __mmask8, __m128i); 
#line 5625
extern __m128h __cdecl _mm_maskz_cvtepu64_ph(__mmask8, __m128i); 
#line 5626
extern __m128h __cdecl _mm256_cvtepu64_ph(__m256i); 
#line 5627
extern __m128h __cdecl _mm256_mask_cvtepu64_ph(__m128h, __mmask8, __m256i); 
#line 5628
extern __m128h __cdecl _mm256_maskz_cvtepu64_ph(__mmask8, __m256i); 
#line 5629
extern __m128h __cdecl _mm512_cvtepu64_ph(__m512i); 
#line 5630
extern __m128h __cdecl _mm512_mask_cvtepu64_ph(__m128h, __mmask8, __m512i); 
#line 5631
extern __m128h __cdecl _mm512_maskz_cvtepu64_ph(__mmask8, __m512i); 
#line 5632
extern __m128h __cdecl _mm512_cvt_roundepu64_ph(__m512i, int); 
#line 5633
extern __m128h __cdecl _mm512_mask_cvt_roundepu64_ph(__m128h, __mmask8, __m512i, int); 
#line 5634
extern __m128h __cdecl _mm512_maskz_cvt_roundepu64_ph(__mmask8, __m512i, int); 
#line 5637
extern __m128h __cdecl _mm_cvtu32_sh(__m128h, unsigned); 
#line 5638
extern __m128h __cdecl _mm_cvtu64_sh(__m128h, unsigned __int64); 
#line 5639
extern __m128h __cdecl _mm_cvt_roundu32_sh(__m128h, unsigned, int); 
#line 5640
extern __m128h __cdecl _mm_cvt_roundu64_sh(__m128h, unsigned __int64, int); 
#line 5643
extern __m128h __cdecl _mm_cvtepu16_ph(__m128i); 
#line 5644
extern __m128h __cdecl _mm_mask_cvtepu16_ph(__m128h, __mmask8, __m128i); 
#line 5645
extern __m128h __cdecl _mm_maskz_cvtepu16_ph(__mmask8, __m128i); 
#line 5646
extern __m256h __cdecl _mm256_cvtepu16_ph(__m256i); 
#line 5647
extern __m256h __cdecl _mm256_mask_cvtepu16_ph(__m256h, __mmask16, __m256i); 
#line 5648
extern __m256h __cdecl _mm256_maskz_cvtepu16_ph(__mmask16, __m256i); 
#line 5649
extern __m512h __cdecl _mm512_cvtepu16_ph(__m512i); 
#line 5650
extern __m512h __cdecl _mm512_mask_cvtepu16_ph(__m512h, __mmask32, __m512i); 
#line 5651
extern __m512h __cdecl _mm512_maskz_cvtepu16_ph(__mmask32, __m512i); 
#line 5652
extern __m512h __cdecl _mm512_cvt_roundepu16_ph(__m512i, int); 
#line 5653
extern __m512h __cdecl _mm512_mask_cvt_roundepu16_ph(__m512h, __mmask32, __m512i, int); 
#line 5654
extern __m512h __cdecl _mm512_maskz_cvt_roundepu16_ph(__mmask32, __m512i, int); 
#line 5657
extern __m128h __cdecl _mm_cvtepi16_ph(__m128i); 
#line 5658
extern __m128h __cdecl _mm_mask_cvtepi16_ph(__m128h, __mmask8, __m128i); 
#line 5659
extern __m128h __cdecl _mm_maskz_cvtepi16_ph(__mmask8, __m128i); 
#line 5660
extern __m256h __cdecl _mm256_cvtepi16_ph(__m256i); 
#line 5661
extern __m256h __cdecl _mm256_mask_cvtepi16_ph(__m256h, __mmask16, __m256i); 
#line 5662
extern __m256h __cdecl _mm256_maskz_cvtepi16_ph(__mmask16, __m256i); 
#line 5663
extern __m512h __cdecl _mm512_cvtepi16_ph(__m512i); 
#line 5664
extern __m512h __cdecl _mm512_mask_cvtepi16_ph(__m512h, __mmask32, __m512i); 
#line 5665
extern __m512h __cdecl _mm512_maskz_cvtepi16_ph(__mmask32, __m512i); 
#line 5666
extern __m512h __cdecl _mm512_cvt_roundepi16_ph(__m512i, int); 
#line 5667
extern __m512h __cdecl _mm512_mask_cvt_roundepi16_ph(__m512h, __mmask32, __m512i, int); 
#line 5668
extern __m512h __cdecl _mm512_maskz_cvt_roundepi16_ph(__mmask32, __m512i, int); 
#line 5671
extern __m128h __cdecl _mm_div_ph(__m128h, __m128h); 
#line 5672
extern __m128h __cdecl _mm_mask_div_ph(__m128h, __mmask8, __m128h, __m128h); 
#line 5673
extern __m128h __cdecl _mm_maskz_div_ph(__mmask8, __m128h, __m128h); 
#line 5674
extern __m256h __cdecl _mm256_div_ph(__m256h, __m256h); 
#line 5675
extern __m256h __cdecl _mm256_mask_div_ph(__m256h, __mmask16, __m256h, __m256h); 
#line 5676
extern __m256h __cdecl _mm256_maskz_div_ph(__mmask16, __m256h, __m256h); 
#line 5677
extern __m512h __cdecl _mm512_div_ph(__m512h, __m512h); 
#line 5678
extern __m512h __cdecl _mm512_mask_div_ph(__m512h, __mmask32, __m512h, __m512h); 
#line 5679
extern __m512h __cdecl _mm512_maskz_div_ph(__mmask32, __m512h, __m512h); 
#line 5680
extern __m512h __cdecl _mm512_div_round_ph(__m512h, __m512h, int); 
#line 5681
extern __m512h __cdecl _mm512_mask_div_round_ph(__m512h, __mmask32, __m512h, __m512h, int); 
#line 5682
extern __m512h __cdecl _mm512_maskz_div_round_ph(__mmask32, __m512h, __m512h, int); 
#line 5685
extern __m128h __cdecl _mm_div_sh(__m128h, __m128h); 
#line 5686
extern __m128h __cdecl _mm_mask_div_sh(__m128h, __mmask8, __m128h, __m128h); 
#line 5687
extern __m128h __cdecl _mm_maskz_div_sh(__mmask8, __m128h, __m128h); 
#line 5688
extern __m128h __cdecl _mm_div_round_sh(__m128h, __m128h, int); 
#line 5689
extern __m128h __cdecl _mm_mask_div_round_sh(__m128h, __mmask8, __m128h, __m128h, int); 
#line 5690
extern __m128h __cdecl _mm_maskz_div_round_sh(__mmask8, __m128h, __m128h, int); 
#line 5693
extern __m128h __cdecl _mm_fmaddsub_ph(__m128h, __m128h, __m128h); 
#line 5694
extern __m128h __cdecl _mm_mask_fmaddsub_ph(__m128h, __mmask8, __m128h, __m128h); 
#line 5695
extern __m128h __cdecl _mm_mask3_fmaddsub_ph(__m128h, __m128h, __m128h, __mmask8); 
#line 5696
extern __m128h __cdecl _mm_maskz_fmaddsub_ph(__mmask8, __m128h, __m128h, __m128h); 
#line 5697
extern __m256h __cdecl _mm256_fmaddsub_ph(__m256h, __m256h, __m256h); 
#line 5698
extern __m256h __cdecl _mm256_mask_fmaddsub_ph(__m256h, __mmask16, __m256h, __m256h); 
#line 5699
extern __m256h __cdecl _mm256_mask3_fmaddsub_ph(__m256h, __m256h, __m256h, __mmask16); 
#line 5700
extern __m256h __cdecl _mm256_maskz_fmaddsub_ph(__mmask16, __m256h, __m256h, __m256h); 
#line 5701
extern __m512h __cdecl _mm512_fmaddsub_ph(__m512h, __m512h, __m512h); 
#line 5702
extern __m512h __cdecl _mm512_mask_fmaddsub_ph(__m512h, __mmask32, __m512h, __m512h); 
#line 5703
extern __m512h __cdecl _mm512_mask3_fmaddsub_ph(__m512h, __m512h, __m512h, __mmask32); 
#line 5704
extern __m512h __cdecl _mm512_maskz_fmaddsub_ph(__mmask32, __m512h, __m512h, __m512h); 
#line 5705
extern __m512h __cdecl _mm512_fmaddsub_round_ph(__m512h, __m512h, __m512h, const int); 
#line 5706
extern __m512h __cdecl _mm512_mask_fmaddsub_round_ph(__m512h, __mmask32, __m512h, __m512h, const int); 
#line 5707
extern __m512h __cdecl _mm512_mask3_fmaddsub_round_ph(__m512h, __m512h, __m512h, __mmask32, const int); 
#line 5708
extern __m512h __cdecl _mm512_maskz_fmaddsub_round_ph(__mmask32, __m512h, __m512h, __m512h, const int); 
#line 5711
extern __m128h __cdecl _mm_fmsubadd_ph(__m128h, __m128h, __m128h); 
#line 5712
extern __m128h __cdecl _mm_mask_fmsubadd_ph(__m128h, __mmask8, __m128h, __m128h); 
#line 5713
extern __m128h __cdecl _mm_mask3_fmsubadd_ph(__m128h, __m128h, __m128h, __mmask8); 
#line 5714
extern __m128h __cdecl _mm_maskz_fmsubadd_ph(__mmask8, __m128h, __m128h, __m128h); 
#line 5715
extern __m256h __cdecl _mm256_fmsubadd_ph(__m256h, __m256h, __m256h); 
#line 5716
extern __m256h __cdecl _mm256_mask_fmsubadd_ph(__m256h, __mmask16, __m256h, __m256h); 
#line 5717
extern __m256h __cdecl _mm256_mask3_fmsubadd_ph(__m256h, __m256h, __m256h, __mmask16); 
#line 5718
extern __m256h __cdecl _mm256_maskz_fmsubadd_ph(__mmask16, __m256h, __m256h, __m256h); 
#line 5719
extern __m512h __cdecl _mm512_fmsubadd_ph(__m512h, __m512h, __m512h); 
#line 5720
extern __m512h __cdecl _mm512_mask_fmsubadd_ph(__m512h, __mmask32, __m512h, __m512h); 
#line 5721
extern __m512h __cdecl _mm512_mask3_fmsubadd_ph(__m512h, __m512h, __m512h, __mmask32); 
#line 5722
extern __m512h __cdecl _mm512_maskz_fmsubadd_ph(__mmask32, __m512h, __m512h, __m512h); 
#line 5723
extern __m512h __cdecl _mm512_fmsubadd_round_ph(__m512h, __m512h, __m512h, const int); 
#line 5724
extern __m512h __cdecl _mm512_mask_fmsubadd_round_ph(__m512h, __mmask32, __m512h, __m512h, const int); 
#line 5725
extern __m512h __cdecl _mm512_mask3_fmsubadd_round_ph(__m512h, __m512h, __m512h, __mmask32, const int); 
#line 5726
extern __m512h __cdecl _mm512_maskz_fmsubadd_round_ph(__mmask32, __m512h, __m512h, __m512h, const int); 
#line 5729
extern __mmask8 __cdecl _mm_fpclass_ph_mask(__m128h, int); 
#line 5730
extern __mmask8 __cdecl _mm_mask_fpclass_ph_mask(__mmask8, __m128h, int); 
#line 5731
extern __mmask16 __cdecl _mm256_fpclass_ph_mask(__m256h, int); 
#line 5732
extern __mmask16 __cdecl _mm256_mask_fpclass_ph_mask(__mmask16, __m256h, int); 
#line 5733
extern __mmask32 __cdecl _mm512_fpclass_ph_mask(__m512h, int); 
#line 5734
extern __mmask32 __cdecl _mm512_mask_fpclass_ph_mask(__mmask32, __m512h, int); 
#line 5737
extern __mmask8 __cdecl _mm_fpclass_sh_mask(__m128h, int); 
#line 5738
extern __mmask8 __cdecl _mm_mask_fpclass_sh_mask(__mmask8, __m128h, int); 
#line 5741
extern __m128h __cdecl _mm_fmadd_pch(__m128h, __m128h, __m128h); 
#line 5742
extern __m128h __cdecl _mm_mask_fmadd_pch(__m128h, __mmask8, __m128h, __m128h); 
#line 5743
extern __m128h __cdecl _mm_mask3_fmadd_pch(__m128h, __m128h, __m128h, __mmask8); 
#line 5744
extern __m128h __cdecl _mm_maskz_fmadd_pch(__mmask8, __m128h, __m128h, __m128h); 
#line 5745
extern __m256h __cdecl _mm256_fmadd_pch(__m256h, __m256h, __m256h); 
#line 5746
extern __m256h __cdecl _mm256_mask_fmadd_pch(__m256h, __mmask8, __m256h, __m256h); 
#line 5747
extern __m256h __cdecl _mm256_mask3_fmadd_pch(__m256h, __m256h, __m256h, __mmask8); 
#line 5748
extern __m256h __cdecl _mm256_maskz_fmadd_pch(__mmask8, __m256h, __m256h, __m256h); 
#line 5749
extern __m512h __cdecl _mm512_fmadd_pch(__m512h, __m512h, __m512h); 
#line 5750
extern __m512h __cdecl _mm512_mask_fmadd_pch(__m512h, __mmask16, __m512h, __m512h); 
#line 5751
extern __m512h __cdecl _mm512_mask3_fmadd_pch(__m512h, __m512h, __m512h, __mmask16); 
#line 5752
extern __m512h __cdecl _mm512_maskz_fmadd_pch(__mmask16, __m512h, __m512h, __m512h); 
#line 5753
extern __m512h __cdecl _mm512_fmadd_round_pch(__m512h, __m512h, __m512h, const int); 
#line 5754
extern __m512h __cdecl _mm512_mask_fmadd_round_pch(__m512h, __mmask16, __m512h, __m512h, const int); 
#line 5755
extern __m512h __cdecl _mm512_mask3_fmadd_round_pch(__m512h, __m512h, __m512h, __mmask16, const int); 
#line 5756
extern __m512h __cdecl _mm512_maskz_fmadd_round_pch(__mmask16, __m512h, __m512h, __m512h, const int); 
#line 5757
extern __m128h __cdecl _mm_fcmadd_pch(__m128h, __m128h, __m128h); 
#line 5758
extern __m128h __cdecl _mm_mask_fcmadd_pch(__m128h, __mmask8, __m128h, __m128h); 
#line 5759
extern __m128h __cdecl _mm_mask3_fcmadd_pch(__m128h, __m128h, __m128h, __mmask8); 
#line 5760
extern __m128h __cdecl _mm_maskz_fcmadd_pch(__mmask8, __m128h, __m128h, __m128h); 
#line 5761
extern __m256h __cdecl _mm256_fcmadd_pch(__m256h, __m256h, __m256h); 
#line 5762
extern __m256h __cdecl _mm256_mask_fcmadd_pch(__m256h, __mmask8, __m256h, __m256h); 
#line 5763
extern __m256h __cdecl _mm256_mask3_fcmadd_pch(__m256h, __m256h, __m256h, __mmask8); 
#line 5764
extern __m256h __cdecl _mm256_maskz_fcmadd_pch(__mmask8, __m256h, __m256h, __m256h); 
#line 5765
extern __m512h __cdecl _mm512_fcmadd_pch(__m512h, __m512h, __m512h); 
#line 5766
extern __m512h __cdecl _mm512_mask_fcmadd_pch(__m512h, __mmask16, __m512h, __m512h); 
#line 5767
extern __m512h __cdecl _mm512_mask3_fcmadd_pch(__m512h, __m512h, __m512h, __mmask16); 
#line 5768
extern __m512h __cdecl _mm512_maskz_fcmadd_pch(__mmask16, __m512h, __m512h, __m512h); 
#line 5769
extern __m512h __cdecl _mm512_fcmadd_round_pch(__m512h, __m512h, __m512h, const int); 
#line 5770
extern __m512h __cdecl _mm512_mask_fcmadd_round_pch(__m512h, __mmask16, __m512h, __m512h, const int); 
#line 5771
extern __m512h __cdecl _mm512_mask3_fcmadd_round_pch(__m512h, __m512h, __m512h, __mmask16, const int); 
#line 5772
extern __m512h __cdecl _mm512_maskz_fcmadd_round_pch(__mmask16, __m512h, __m512h, __m512h, const int); 
#line 5775
extern __m128h __cdecl _mm_fcmadd_sch(__m128h, __m128h, __m128h); 
#line 5776
extern __m128h __cdecl _mm_mask_fcmadd_sch(__m128h, __mmask8, __m128h, __m128h); 
#line 5777
extern __m128h __cdecl _mm_mask3_fcmadd_sch(__m128h, __m128h, __m128h, __mmask8); 
#line 5778
extern __m128h __cdecl _mm_maskz_fcmadd_sch(__mmask8, __m128h, __m128h, __m128h); 
#line 5779
extern __m128h __cdecl _mm_fcmadd_round_sch(__m128h, __m128h, __m128h, const int); 
#line 5780
extern __m128h __cdecl _mm_mask_fcmadd_round_sch(__m128h, __mmask8, __m128h, __m128h, const int); 
#line 5781
extern __m128h __cdecl _mm_mask3_fcmadd_round_sch(__m128h, __m128h, __m128h, __mmask8, const int); 
#line 5782
extern __m128h __cdecl _mm_maskz_fcmadd_round_sch(__mmask8, __m128h, __m128h, __m128h, const int); 
#line 5783
extern __m128h __cdecl _mm_fmadd_sch(__m128h, __m128h, __m128h); 
#line 5784
extern __m128h __cdecl _mm_mask_fmadd_sch(__m128h, __mmask8, __m128h, __m128h); 
#line 5785
extern __m128h __cdecl _mm_mask3_fmadd_sch(__m128h, __m128h, __m128h, __mmask8); 
#line 5786
extern __m128h __cdecl _mm_maskz_fmadd_sch(__mmask8, __m128h, __m128h, __m128h); 
#line 5787
extern __m128h __cdecl _mm_fmadd_round_sch(__m128h, __m128h, __m128h, const int); 
#line 5788
extern __m128h __cdecl _mm_mask_fmadd_round_sch(__m128h, __mmask8, __m128h, __m128h, const int); 
#line 5789
extern __m128h __cdecl _mm_mask3_fmadd_round_sch(__m128h, __m128h, __m128h, __mmask8, const int); 
#line 5790
extern __m128h __cdecl _mm_maskz_fmadd_round_sch(__mmask8, __m128h, __m128h, __m128h, const int); 
#line 5793
extern __m128h __cdecl _mm_fcmul_pch(__m128h, __m128h); 
#line 5794
extern __m128h __cdecl _mm_mask_fcmul_pch(__m128h, __mmask8, __m128h, __m128h); 
#line 5795
extern __m128h __cdecl _mm_maskz_fcmul_pch(__mmask8, __m128h, __m128h); 
#line 5796
extern __m256h __cdecl _mm256_fcmul_pch(__m256h, __m256h); 
#line 5797
extern __m256h __cdecl _mm256_mask_fcmul_pch(__m256h, __mmask8, __m256h, __m256h); 
#line 5798
extern __m256h __cdecl _mm256_maskz_fcmul_pch(__mmask8, __m256h, __m256h); 
#line 5799
extern __m512h __cdecl _mm512_fcmul_pch(__m512h, __m512h); 
#line 5800
extern __m512h __cdecl _mm512_mask_fcmul_pch(__m512h, __mmask16, __m512h, __m512h); 
#line 5801
extern __m512h __cdecl _mm512_maskz_fcmul_pch(__mmask16, __m512h, __m512h); 
#line 5802
extern __m512h __cdecl _mm512_fcmul_round_pch(__m512h, __m512h, const int); 
#line 5803
extern __m512h __cdecl _mm512_mask_fcmul_round_pch(__m512h, __mmask16, __m512h, __m512h, const int); 
#line 5804
extern __m512h __cdecl _mm512_maskz_fcmul_round_pch(__mmask16, __m512h, __m512h, const int); 
#line 5805
extern __m128h __cdecl _mm_fmul_pch(__m128h, __m128h); 
#line 5806
extern __m128h __cdecl _mm_mask_fmul_pch(__m128h, __mmask8, __m128h, __m128h); 
#line 5807
extern __m128h __cdecl _mm_maskz_fmul_pch(__mmask8, __m128h, __m128h); 
#line 5808
extern __m256h __cdecl _mm256_fmul_pch(__m256h, __m256h); 
#line 5809
extern __m256h __cdecl _mm256_mask_fmul_pch(__m256h, __mmask8, __m256h, __m256h); 
#line 5810
extern __m256h __cdecl _mm256_maskz_fmul_pch(__mmask8, __m256h, __m256h); 
#line 5811
extern __m512h __cdecl _mm512_fmul_pch(__m512h, __m512h); 
#line 5812
extern __m512h __cdecl _mm512_mask_fmul_pch(__m512h, __mmask16, __m512h, __m512h); 
#line 5813
extern __m512h __cdecl _mm512_maskz_fmul_pch(__mmask16, __m512h, __m512h); 
#line 5814
extern __m512h __cdecl _mm512_fmul_round_pch(__m512h, __m512h, const int); 
#line 5815
extern __m512h __cdecl _mm512_mask_fmul_round_pch(__m512h, __mmask16, __m512h, __m512h, const int); 
#line 5816
extern __m512h __cdecl _mm512_maskz_fmul_round_pch(__mmask16, __m512h, __m512h, const int); 
#line 5819
extern __m128h __cdecl _mm_fcmul_sch(__m128h, __m128h); 
#line 5820
extern __m128h __cdecl _mm_mask_fcmul_sch(__m128h, __mmask8, __m128h, __m128h); 
#line 5821
extern __m128h __cdecl _mm_maskz_fcmul_sch(__mmask8, __m128h, __m128h); 
#line 5822
extern __m128h __cdecl _mm_fcmul_round_sch(__m128h, __m128h, const int); 
#line 5823
extern __m128h __cdecl _mm_mask_fcmul_round_sch(__m128h, __mmask8, __m128h, __m128h, const int); 
#line 5824
extern __m128h __cdecl _mm_maskz_fcmul_round_sch(__mmask8, __m128h, __m128h, const int); 
#line 5825
extern __m128h __cdecl _mm_fmul_sch(__m128h, __m128h); 
#line 5826
extern __m128h __cdecl _mm_mask_fmul_sch(__m128h, __mmask8, __m128h, __m128h); 
#line 5827
extern __m128h __cdecl _mm_maskz_fmul_sch(__mmask8, __m128h, __m128h); 
#line 5828
extern __m128h __cdecl _mm_fmul_round_sch(__m128h, __m128h, const int); 
#line 5829
extern __m128h __cdecl _mm_mask_fmul_round_sch(__m128h, __mmask8, __m128h, __m128h, const int); 
#line 5830
extern __m128h __cdecl _mm_maskz_fmul_round_sch(__mmask8, __m128h, __m128h, const int); 
#line 5833
extern __m128h __cdecl _mm_fnmadd_ph(__m128h, __m128h, __m128h); 
#line 5834
extern __m128h __cdecl _mm_mask_fnmadd_ph(__m128h, __mmask8, __m128h, __m128h); 
#line 5835
extern __m128h __cdecl _mm_mask3_fnmadd_ph(__m128h, __m128h, __m128h, __mmask8); 
#line 5836
extern __m128h __cdecl _mm_maskz_fnmadd_ph(__mmask8, __m128h, __m128h, __m128h); 
#line 5837
extern __m256h __cdecl _mm256_fnmadd_ph(__m256h, __m256h, __m256h); 
#line 5838
extern __m256h __cdecl _mm256_mask_fnmadd_ph(__m256h, __mmask16, __m256h, __m256h); 
#line 5839
extern __m256h __cdecl _mm256_mask3_fnmadd_ph(__m256h, __m256h, __m256h, __mmask16); 
#line 5840
extern __m256h __cdecl _mm256_maskz_fnmadd_ph(__mmask16, __m256h, __m256h, __m256h); 
#line 5841
extern __m512h __cdecl _mm512_fnmadd_ph(__m512h, __m512h, __m512h); 
#line 5842
extern __m512h __cdecl _mm512_mask_fnmadd_ph(__m512h, __mmask32, __m512h, __m512h); 
#line 5843
extern __m512h __cdecl _mm512_mask3_fnmadd_ph(__m512h, __m512h, __m512h, __mmask32); 
#line 5844
extern __m512h __cdecl _mm512_maskz_fnmadd_ph(__mmask32, __m512h, __m512h, __m512h); 
#line 5845
extern __m512h __cdecl _mm512_fnmadd_round_ph(__m512h, __m512h, __m512h, const int); 
#line 5846
extern __m512h __cdecl _mm512_mask_fnmadd_round_ph(__m512h, __mmask32, __m512h, __m512h, const int); 
#line 5847
extern __m512h __cdecl _mm512_mask3_fnmadd_round_ph(__m512h, __m512h, __m512h, __mmask32, const int); 
#line 5848
extern __m512h __cdecl _mm512_maskz_fnmadd_round_ph(__mmask32, __m512h, __m512h, __m512h, const int); 
#line 5849
extern __m128h __cdecl _mm_fmadd_ph(__m128h, __m128h, __m128h); 
#line 5850
extern __m128h __cdecl _mm_mask_fmadd_ph(__m128h, __mmask8, __m128h, __m128h); 
#line 5851
extern __m128h __cdecl _mm_mask3_fmadd_ph(__m128h, __m128h, __m128h, __mmask8); 
#line 5852
extern __m128h __cdecl _mm_maskz_fmadd_ph(__mmask8, __m128h, __m128h, __m128h); 
#line 5853
extern __m256h __cdecl _mm256_fmadd_ph(__m256h, __m256h, __m256h); 
#line 5854
extern __m256h __cdecl _mm256_mask_fmadd_ph(__m256h, __mmask16, __m256h, __m256h); 
#line 5855
extern __m256h __cdecl _mm256_mask3_fmadd_ph(__m256h, __m256h, __m256h, __mmask16); 
#line 5856
extern __m256h __cdecl _mm256_maskz_fmadd_ph(__mmask16, __m256h, __m256h, __m256h); 
#line 5857
extern __m512h __cdecl _mm512_fmadd_ph(__m512h, __m512h, __m512h); 
#line 5858
extern __m512h __cdecl _mm512_mask_fmadd_ph(__m512h, __mmask32, __m512h, __m512h); 
#line 5859
extern __m512h __cdecl _mm512_mask3_fmadd_ph(__m512h, __m512h, __m512h, __mmask32); 
#line 5860
extern __m512h __cdecl _mm512_maskz_fmadd_ph(__mmask32, __m512h, __m512h, __m512h); 
#line 5861
extern __m512h __cdecl _mm512_fmadd_round_ph(__m512h, __m512h, __m512h, const int); 
#line 5862
extern __m512h __cdecl _mm512_mask_fmadd_round_ph(__m512h, __mmask32, __m512h, __m512h, const int); 
#line 5863
extern __m512h __cdecl _mm512_mask3_fmadd_round_ph(__m512h, __m512h, __m512h, __mmask32, const int); 
#line 5864
extern __m512h __cdecl _mm512_maskz_fmadd_round_ph(__mmask32, __m512h, __m512h, __m512h, const int); 
#line 5867
extern __m128h __cdecl _mm_fnmadd_sh(__m128h, __m128h, __m128h); 
#line 5868
extern __m128h __cdecl _mm_mask_fnmadd_sh(__m128h, __mmask8, __m128h, __m128h); 
#line 5869
extern __m128h __cdecl _mm_mask3_fnmadd_sh(__m128h, __m128h, __m128h, __mmask8); 
#line 5870
extern __m128h __cdecl _mm_maskz_fnmadd_sh(__mmask8, __m128h, __m128h, __m128h); 
#line 5871
extern __m128h __cdecl _mm_fnmadd_round_sh(__m128h, __m128h, __m128h, const int); 
#line 5872
extern __m128h __cdecl _mm_mask_fnmadd_round_sh(__m128h, __mmask8, __m128h, __m128h, const int); 
#line 5873
extern __m128h __cdecl _mm_mask3_fnmadd_round_sh(__m128h, __m128h, __m128h, __mmask8, const int); 
#line 5874
extern __m128h __cdecl _mm_maskz_fnmadd_round_sh(__mmask8, __m128h, __m128h, __m128h, const int); 
#line 5875
extern __m128h __cdecl _mm_fmadd_sh(__m128h, __m128h, __m128h); 
#line 5876
extern __m128h __cdecl _mm_mask_fmadd_sh(__m128h, __mmask8, __m128h, __m128h); 
#line 5877
extern __m128h __cdecl _mm_mask3_fmadd_sh(__m128h, __m128h, __m128h, __mmask8); 
#line 5878
extern __m128h __cdecl _mm_maskz_fmadd_sh(__mmask8, __m128h, __m128h, __m128h); 
#line 5879
extern __m128h __cdecl _mm_fmadd_round_sh(__m128h, __m128h, __m128h, const int); 
#line 5880
extern __m128h __cdecl _mm_mask_fmadd_round_sh(__m128h, __mmask8, __m128h, __m128h, const int); 
#line 5881
extern __m128h __cdecl _mm_mask3_fmadd_round_sh(__m128h, __m128h, __m128h, __mmask8, const int); 
#line 5882
extern __m128h __cdecl _mm_maskz_fmadd_round_sh(__mmask8, __m128h, __m128h, __m128h, const int); 
#line 5885
extern __m128h __cdecl _mm_fnmsub_ph(__m128h, __m128h, __m128h); 
#line 5886
extern __m128h __cdecl _mm_mask_fnmsub_ph(__m128h, __mmask8, __m128h, __m128h); 
#line 5887
extern __m128h __cdecl _mm_mask3_fnmsub_ph(__m128h, __m128h, __m128h, __mmask8); 
#line 5888
extern __m128h __cdecl _mm_maskz_fnmsub_ph(__mmask8, __m128h, __m128h, __m128h); 
#line 5889
extern __m256h __cdecl _mm256_fnmsub_ph(__m256h, __m256h, __m256h); 
#line 5890
extern __m256h __cdecl _mm256_mask_fnmsub_ph(__m256h, __mmask16, __m256h, __m256h); 
#line 5891
extern __m256h __cdecl _mm256_mask3_fnmsub_ph(__m256h, __m256h, __m256h, __mmask16); 
#line 5892
extern __m256h __cdecl _mm256_maskz_fnmsub_ph(__mmask16, __m256h, __m256h, __m256h); 
#line 5893
extern __m512h __cdecl _mm512_fnmsub_ph(__m512h, __m512h, __m512h); 
#line 5894
extern __m512h __cdecl _mm512_mask_fnmsub_ph(__m512h, __mmask32, __m512h, __m512h); 
#line 5895
extern __m512h __cdecl _mm512_mask3_fnmsub_ph(__m512h, __m512h, __m512h, __mmask32); 
#line 5896
extern __m512h __cdecl _mm512_maskz_fnmsub_ph(__mmask32, __m512h, __m512h, __m512h); 
#line 5897
extern __m512h __cdecl _mm512_fnmsub_round_ph(__m512h, __m512h, __m512h, const int); 
#line 5898
extern __m512h __cdecl _mm512_mask_fnmsub_round_ph(__m512h, __mmask32, __m512h, __m512h, const int); 
#line 5899
extern __m512h __cdecl _mm512_mask3_fnmsub_round_ph(__m512h, __m512h, __m512h, __mmask32, const int); 
#line 5900
extern __m512h __cdecl _mm512_maskz_fnmsub_round_ph(__mmask32, __m512h, __m512h, __m512h, const int); 
#line 5901
extern __m128h __cdecl _mm_fmsub_ph(__m128h, __m128h, __m128h); 
#line 5902
extern __m128h __cdecl _mm_mask_fmsub_ph(__m128h, __mmask8, __m128h, __m128h); 
#line 5903
extern __m128h __cdecl _mm_mask3_fmsub_ph(__m128h, __m128h, __m128h, __mmask8); 
#line 5904
extern __m128h __cdecl _mm_maskz_fmsub_ph(__mmask8, __m128h, __m128h, __m128h); 
#line 5905
extern __m256h __cdecl _mm256_fmsub_ph(__m256h, __m256h, __m256h); 
#line 5906
extern __m256h __cdecl _mm256_mask_fmsub_ph(__m256h, __mmask16, __m256h, __m256h); 
#line 5907
extern __m256h __cdecl _mm256_mask3_fmsub_ph(__m256h, __m256h, __m256h, __mmask16); 
#line 5908
extern __m256h __cdecl _mm256_maskz_fmsub_ph(__mmask16, __m256h, __m256h, __m256h); 
#line 5909
extern __m512h __cdecl _mm512_fmsub_ph(__m512h, __m512h, __m512h); 
#line 5910
extern __m512h __cdecl _mm512_mask_fmsub_ph(__m512h, __mmask32, __m512h, __m512h); 
#line 5911
extern __m512h __cdecl _mm512_mask3_fmsub_ph(__m512h, __m512h, __m512h, __mmask32); 
#line 5912
extern __m512h __cdecl _mm512_maskz_fmsub_ph(__mmask32, __m512h, __m512h, __m512h); 
#line 5913
extern __m512h __cdecl _mm512_fmsub_round_ph(__m512h, __m512h, __m512h, const int); 
#line 5914
extern __m512h __cdecl _mm512_mask_fmsub_round_ph(__m512h, __mmask32, __m512h, __m512h, const int); 
#line 5915
extern __m512h __cdecl _mm512_mask3_fmsub_round_ph(__m512h, __m512h, __m512h, __mmask32, const int); 
#line 5916
extern __m512h __cdecl _mm512_maskz_fmsub_round_ph(__mmask32, __m512h, __m512h, __m512h, const int); 
#line 5919
extern __m128h __cdecl _mm_fnmsub_sh(__m128h, __m128h, __m128h); 
#line 5920
extern __m128h __cdecl _mm_mask_fnmsub_sh(__m128h, __mmask8, __m128h, __m128h); 
#line 5921
extern __m128h __cdecl _mm_mask3_fnmsub_sh(__m128h, __m128h, __m128h, __mmask8); 
#line 5922
extern __m128h __cdecl _mm_maskz_fnmsub_sh(__mmask8, __m128h, __m128h, __m128h); 
#line 5923
extern __m128h __cdecl _mm_fnmsub_round_sh(__m128h, __m128h, __m128h, const int); 
#line 5924
extern __m128h __cdecl _mm_mask_fnmsub_round_sh(__m128h, __mmask8, __m128h, __m128h, const int); 
#line 5925
extern __m128h __cdecl _mm_mask3_fnmsub_round_sh(__m128h, __m128h, __m128h, __mmask8, const int); 
#line 5926
extern __m128h __cdecl _mm_maskz_fnmsub_round_sh(__mmask8, __m128h, __m128h, __m128h, const int); 
#line 5927
extern __m128h __cdecl _mm_fmsub_sh(__m128h, __m128h, __m128h); 
#line 5928
extern __m128h __cdecl _mm_mask_fmsub_sh(__m128h, __mmask8, __m128h, __m128h); 
#line 5929
extern __m128h __cdecl _mm_mask3_fmsub_sh(__m128h, __m128h, __m128h, __mmask8); 
#line 5930
extern __m128h __cdecl _mm_maskz_fmsub_sh(__mmask8, __m128h, __m128h, __m128h); 
#line 5931
extern __m128h __cdecl _mm_fmsub_round_sh(__m128h, __m128h, __m128h, const int); 
#line 5932
extern __m128h __cdecl _mm_mask_fmsub_round_sh(__m128h, __mmask8, __m128h, __m128h, const int); 
#line 5933
extern __m128h __cdecl _mm_mask3_fmsub_round_sh(__m128h, __m128h, __m128h, __mmask8, const int); 
#line 5934
extern __m128h __cdecl _mm_maskz_fmsub_round_sh(__mmask8, __m128h, __m128h, __m128h, const int); 
#line 5937
extern __m128h __cdecl _mm_getexp_ph(__m128h); 
#line 5938
extern __m128h __cdecl _mm_mask_getexp_ph(__m128h, __mmask8, __m128h); 
#line 5939
extern __m128h __cdecl _mm_maskz_getexp_ph(__mmask8, __m128h); 
#line 5940
extern __m256h __cdecl _mm256_getexp_ph(__m256h); 
#line 5941
extern __m256h __cdecl _mm256_mask_getexp_ph(__m256h, __mmask16, __m256h); 
#line 5942
extern __m256h __cdecl _mm256_maskz_getexp_ph(__mmask16, __m256h); 
#line 5943
extern __m512h __cdecl _mm512_getexp_ph(__m512h); 
#line 5944
extern __m512h __cdecl _mm512_mask_getexp_ph(__m512h, __mmask32, __m512h); 
#line 5945
extern __m512h __cdecl _mm512_maskz_getexp_ph(__mmask32, __m512h); 
#line 5946
extern __m512h __cdecl _mm512_getexp_round_ph(__m512h, const int); 
#line 5947
extern __m512h __cdecl _mm512_mask_getexp_round_ph(__m512h, __mmask32, __m512h, const int); 
#line 5948
extern __m512h __cdecl _mm512_maskz_getexp_round_ph(__mmask32, __m512h, const int); 
#line 5951
extern __m128h __cdecl _mm_getexp_sh(__m128h, __m128h); 
#line 5952
extern __m128h __cdecl _mm_mask_getexp_sh(__m128h, __mmask8, __m128h, __m128h); 
#line 5953
extern __m128h __cdecl _mm_maskz_getexp_sh(__mmask8, __m128h, __m128h); 
#line 5954
extern __m128h __cdecl _mm_getexp_round_sh(__m128h, __m128h, const int); 
#line 5955
extern __m128h __cdecl _mm_mask_getexp_round_sh(__m128h, __mmask8, __m128h, __m128h, const int); 
#line 5956
extern __m128h __cdecl _mm_maskz_getexp_round_sh(__mmask8, __m128h, __m128h, const int); 
#line 5959
extern __m128h __cdecl _mm_getmant_ph(__m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 5960
extern __m128h __cdecl _mm_mask_getmant_ph(__m128h, __mmask8, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 5961
extern __m128h __cdecl _mm_maskz_getmant_ph(__mmask8, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 5962
extern __m256h __cdecl _mm256_getmant_ph(__m256h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 5963
extern __m256h __cdecl _mm256_mask_getmant_ph(__m256h, __mmask16, __m256h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 5964
extern __m256h __cdecl _mm256_maskz_getmant_ph(__mmask16, __m256h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 5965
extern __m512h __cdecl _mm512_getmant_ph(__m512h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 5966
extern __m512h __cdecl _mm512_mask_getmant_ph(__m512h, __mmask32, __m512h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 5967
extern __m512h __cdecl _mm512_maskz_getmant_ph(__mmask32, __m512h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 5968
extern __m512h __cdecl _mm512_getmant_round_ph(__m512h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM, const int); 
#line 5969
extern __m512h __cdecl _mm512_mask_getmant_round_ph(__m512h, __mmask32, __m512h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM, const int); 
#line 5970
extern __m512h __cdecl _mm512_maskz_getmant_round_ph(__mmask32, __m512h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM, const int); 
#line 5973
extern __m128h __cdecl _mm_getmant_sh(__m128h, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 5974
extern __m128h __cdecl _mm_mask_getmant_sh(__m128h, __mmask8, __m128h, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 5975
extern __m128h __cdecl _mm_maskz_getmant_sh(__mmask8, __m128h, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 5976
extern __m128h __cdecl _mm_getmant_round_sh(__m128h, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM, const int); 
#line 5977
extern __m128h __cdecl _mm_mask_getmant_round_sh(__m128h, __mmask8, __m128h, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM, const int); 
#line 5978
extern __m128h __cdecl _mm_maskz_getmant_round_sh(__mmask8, __m128h, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM, const int); 
#line 5981
extern __m128h __cdecl _mm_max_ph(__m128h, __m128h); 
#line 5982
extern __m128h __cdecl _mm_mask_max_ph(__m128h, __mmask8, __m128h, __m128h); 
#line 5983
extern __m128h __cdecl _mm_maskz_max_ph(__mmask8, __m128h, __m128h); 
#line 5984
extern __m256h __cdecl _mm256_max_ph(__m256h, __m256h); 
#line 5985
extern __m256h __cdecl _mm256_mask_max_ph(__m256h, __mmask16, __m256h, __m256h); 
#line 5986
extern __m256h __cdecl _mm256_maskz_max_ph(__mmask16, __m256h, __m256h); 
#line 5987
extern __m512h __cdecl _mm512_max_ph(__m512h, __m512h); 
#line 5988
extern __m512h __cdecl _mm512_mask_max_ph(__m512h, __mmask32, __m512h, __m512h); 
#line 5989
extern __m512h __cdecl _mm512_maskz_max_ph(__mmask32, __m512h, __m512h); 
#line 5990
extern __m512h __cdecl _mm512_max_round_ph(__m512h, __m512h, int); 
#line 5991
extern __m512h __cdecl _mm512_mask_max_round_ph(__m512h, __mmask32, __m512h, __m512h, int); 
#line 5992
extern __m512h __cdecl _mm512_maskz_max_round_ph(__mmask32, __m512h, __m512h, int); 
#line 5995
extern __m128h __cdecl _mm_max_sh(__m128h, __m128h); 
#line 5996
extern __m128h __cdecl _mm_mask_max_sh(__m128h, __mmask8, __m128h, __m128h); 
#line 5997
extern __m128h __cdecl _mm_maskz_max_sh(__mmask8, __m128h, __m128h); 
#line 5998
extern __m128h __cdecl _mm_max_round_sh(__m128h, __m128h, int); 
#line 5999
extern __m128h __cdecl _mm_mask_max_round_sh(__m128h, __mmask8, __m128h, __m128h, int); 
#line 6000
extern __m128h __cdecl _mm_maskz_max_round_sh(__mmask8, __m128h, __m128h, int); 
#line 6003
extern __m128h __cdecl _mm_min_ph(__m128h, __m128h); 
#line 6004
extern __m128h __cdecl _mm_mask_min_ph(__m128h, __mmask8, __m128h, __m128h); 
#line 6005
extern __m128h __cdecl _mm_maskz_min_ph(__mmask8, __m128h, __m128h); 
#line 6006
extern __m256h __cdecl _mm256_min_ph(__m256h, __m256h); 
#line 6007
extern __m256h __cdecl _mm256_mask_min_ph(__m256h, __mmask16, __m256h, __m256h); 
#line 6008
extern __m256h __cdecl _mm256_maskz_min_ph(__mmask16, __m256h, __m256h); 
#line 6009
extern __m512h __cdecl _mm512_min_ph(__m512h, __m512h); 
#line 6010
extern __m512h __cdecl _mm512_mask_min_ph(__m512h, __mmask32, __m512h, __m512h); 
#line 6011
extern __m512h __cdecl _mm512_maskz_min_ph(__mmask32, __m512h, __m512h); 
#line 6012
extern __m512h __cdecl _mm512_min_round_ph(__m512h, __m512h, int); 
#line 6013
extern __m512h __cdecl _mm512_mask_min_round_ph(__m512h, __mmask32, __m512h, __m512h, int); 
#line 6014
extern __m512h __cdecl _mm512_maskz_min_round_ph(__mmask32, __m512h, __m512h, int); 
#line 6017
extern __m128h __cdecl _mm_min_sh(__m128h, __m128h); 
#line 6018
extern __m128h __cdecl _mm_mask_min_sh(__m128h, __mmask8, __m128h, __m128h); 
#line 6019
extern __m128h __cdecl _mm_maskz_min_sh(__mmask8, __m128h, __m128h); 
#line 6020
extern __m128h __cdecl _mm_min_round_sh(__m128h, __m128h, int); 
#line 6021
extern __m128h __cdecl _mm_mask_min_round_sh(__m128h, __mmask8, __m128h, __m128h, int); 
#line 6022
extern __m128h __cdecl _mm_maskz_min_round_sh(__mmask8, __m128h, __m128h, int); 
#line 6025
extern __m128h __cdecl _mm_load_sh(const void *); 
#line 6026
extern __m128h __cdecl _mm_mask_load_sh(__m128h, __mmask8, const void *); 
#line 6027
extern __m128h __cdecl _mm_maskz_load_sh(__mmask8, const void *); 
#line 6028
extern void __cdecl _mm_store_sh(void *, __m128h); 
#line 6029
extern void __cdecl _mm_mask_store_sh(void *, __mmask8, __m128h); 
#line 6030
extern __m128h __cdecl _mm_move_sh(__m128h, __m128h); 
#line 6031
extern __m128h __cdecl _mm_mask_move_sh(__m128h, __mmask8, __m128h, __m128h); 
#line 6032
extern __m128h __cdecl _mm_maskz_move_sh(__mmask8, __m128h, __m128h); 
#line 6035
extern __m128i __cdecl _mm_cvtsi16_si128(short); 
#line 6036
extern short __cdecl _mm_cvtsi128_si16(__m128i); 
#line 6039
extern __m128h __cdecl _mm_mul_ph(__m128h, __m128h); 
#line 6040
extern __m128h __cdecl _mm_mask_mul_ph(__m128h, __mmask8, __m128h, __m128h); 
#line 6041
extern __m128h __cdecl _mm_maskz_mul_ph(__mmask8, __m128h, __m128h); 
#line 6042
extern __m256h __cdecl _mm256_mul_ph(__m256h, __m256h); 
#line 6043
extern __m256h __cdecl _mm256_mask_mul_ph(__m256h, __mmask16, __m256h, __m256h); 
#line 6044
extern __m256h __cdecl _mm256_maskz_mul_ph(__mmask16, __m256h, __m256h); 
#line 6045
extern __m512h __cdecl _mm512_mul_ph(__m512h, __m512h); 
#line 6046
extern __m512h __cdecl _mm512_mask_mul_ph(__m512h, __mmask32, __m512h, __m512h); 
#line 6047
extern __m512h __cdecl _mm512_maskz_mul_ph(__mmask32, __m512h, __m512h); 
#line 6048
extern __m512h __cdecl _mm512_mul_round_ph(__m512h, __m512h, int); 
#line 6049
extern __m512h __cdecl _mm512_mask_mul_round_ph(__m512h, __mmask32, __m512h, __m512h, int); 
#line 6050
extern __m512h __cdecl _mm512_maskz_mul_round_ph(__mmask32, __m512h, __m512h, int); 
#line 6053
extern __m128h __cdecl _mm_mul_sh(__m128h, __m128h); 
#line 6054
extern __m128h __cdecl _mm_mask_mul_sh(__m128h, __mmask8, __m128h, __m128h); 
#line 6055
extern __m128h __cdecl _mm_maskz_mul_sh(__mmask8, __m128h, __m128h); 
#line 6056
extern __m128h __cdecl _mm_mul_round_sh(__m128h, __m128h, int); 
#line 6057
extern __m128h __cdecl _mm_mask_mul_round_sh(__m128h, __mmask8, __m128h, __m128h, int); 
#line 6058
extern __m128h __cdecl _mm_maskz_mul_round_sh(__mmask8, __m128h, __m128h, int); 
#line 6061
extern __m128h __cdecl _mm_rcp_ph(__m128h); 
#line 6062
extern __m128h __cdecl _mm_mask_rcp_ph(__m128h, __mmask8, __m128h); 
#line 6063
extern __m128h __cdecl _mm_maskz_rcp_ph(__mmask8, __m128h); 
#line 6064
extern __m256h __cdecl _mm256_rcp_ph(__m256h); 
#line 6065
extern __m256h __cdecl _mm256_mask_rcp_ph(__m256h, __mmask16, __m256h); 
#line 6066
extern __m256h __cdecl _mm256_maskz_rcp_ph(__mmask16, __m256h); 
#line 6067
extern __m512h __cdecl _mm512_rcp_ph(__m512h); 
#line 6068
extern __m512h __cdecl _mm512_mask_rcp_ph(__m512h, __mmask32, __m512h); 
#line 6069
extern __m512h __cdecl _mm512_maskz_rcp_ph(__mmask32, __m512h); 
#line 6072
extern __m128h __cdecl _mm_rcp_sh(__m128h, __m128h); 
#line 6073
extern __m128h __cdecl _mm_mask_rcp_sh(__m128h, __mmask8, __m128h, __m128h); 
#line 6074
extern __m128h __cdecl _mm_maskz_rcp_sh(__mmask8, __m128h, __m128h); 
#line 6077
extern __m128h __cdecl _mm_reduce_ph(__m128h, int); 
#line 6078
extern __m128h __cdecl _mm_mask_reduce_ph(__m128h, __mmask8, __m128h, int); 
#line 6079
extern __m128h __cdecl _mm_maskz_reduce_ph(__mmask8, __m128h, int); 
#line 6080
extern __m256h __cdecl _mm256_reduce_ph(__m256h, int); 
#line 6081
extern __m256h __cdecl _mm256_mask_reduce_ph(__m256h, __mmask16, __m256h, int); 
#line 6082
extern __m256h __cdecl _mm256_maskz_reduce_ph(__mmask16, __m256h, int); 
#line 6083
extern __m512h __cdecl _mm512_reduce_ph(__m512h, int); 
#line 6084
extern __m512h __cdecl _mm512_mask_reduce_ph(__m512h, __mmask32, __m512h, int); 
#line 6085
extern __m512h __cdecl _mm512_maskz_reduce_ph(__mmask32, __m512h, int); 
#line 6086
extern __m512h __cdecl _mm512_reduce_round_ph(__m512h, int, const int); 
#line 6087
extern __m512h __cdecl _mm512_mask_reduce_round_ph(__m512h, __mmask32, __m512h, int, const int); 
#line 6088
extern __m512h __cdecl _mm512_maskz_reduce_round_ph(__mmask32, __m512h, int, const int); 
#line 6091
extern __m128h __cdecl _mm_reduce_sh(__m128h, __m128h, int); 
#line 6092
extern __m128h __cdecl _mm_mask_reduce_sh(__m128h, __mmask8, __m128h, __m128h, int); 
#line 6093
extern __m128h __cdecl _mm_maskz_reduce_sh(__mmask8, __m128h, __m128h, int); 
#line 6094
extern __m128h __cdecl _mm_reduce_round_sh(__m128h, __m128h, int, const int); 
#line 6095
extern __m128h __cdecl _mm_mask_reduce_round_sh(__m128h, __mmask8, __m128h, __m128h, int, const int); 
#line 6096
extern __m128h __cdecl _mm_maskz_reduce_round_sh(__mmask8, __m128h, __m128h, int, const int); 
#line 6099
extern __m128h __cdecl _mm_roundscale_ph(__m128h, int); 
#line 6100
extern __m128h __cdecl _mm_mask_roundscale_ph(__m128h, __mmask8, __m128h, int); 
#line 6101
extern __m128h __cdecl _mm_maskz_roundscale_ph(__mmask8, __m128h, int); 
#line 6102
extern __m256h __cdecl _mm256_roundscale_ph(__m256h, int); 
#line 6103
extern __m256h __cdecl _mm256_mask_roundscale_ph(__m256h, __mmask16, __m256h, int); 
#line 6104
extern __m256h __cdecl _mm256_maskz_roundscale_ph(__mmask16, __m256h, int); 
#line 6105
extern __m512h __cdecl _mm512_roundscale_ph(__m512h, int); 
#line 6106
extern __m512h __cdecl _mm512_mask_roundscale_ph(__m512h, __mmask32, __m512h, int); 
#line 6107
extern __m512h __cdecl _mm512_maskz_roundscale_ph(__mmask32, __m512h, int); 
#line 6108
extern __m512h __cdecl _mm512_roundscale_round_ph(__m512h, int, const int); 
#line 6109
extern __m512h __cdecl _mm512_mask_roundscale_round_ph(__m512h, __mmask32, __m512h, int, const int); 
#line 6110
extern __m512h __cdecl _mm512_maskz_roundscale_round_ph(__mmask32, __m512h, int, const int); 
#line 6113
extern __m128h __cdecl _mm_roundscale_sh(__m128h, __m128h, int); 
#line 6114
extern __m128h __cdecl _mm_mask_roundscale_sh(__m128h, __mmask8, __m128h, __m128h, int); 
#line 6115
extern __m128h __cdecl _mm_maskz_roundscale_sh(__mmask8, __m128h, __m128h, int); 
#line 6116
extern __m128h __cdecl _mm_roundscale_round_sh(__m128h, __m128h, int, const int); 
#line 6117
extern __m128h __cdecl _mm_mask_roundscale_round_sh(__m128h, __mmask8, __m128h, __m128h, int, const int); 
#line 6118
extern __m128h __cdecl _mm_maskz_roundscale_round_sh(__mmask8, __m128h, __m128h, int, const int); 
#line 6121
extern __m128h __cdecl _mm_rsqrt_ph(__m128h); 
#line 6122
extern __m128h __cdecl _mm_mask_rsqrt_ph(__m128h, __mmask8, __m128h); 
#line 6123
extern __m128h __cdecl _mm_maskz_rsqrt_ph(__mmask8, __m128h); 
#line 6124
extern __m256h __cdecl _mm256_rsqrt_ph(__m256h); 
#line 6125
extern __m256h __cdecl _mm256_mask_rsqrt_ph(__m256h, __mmask16, __m256h); 
#line 6126
extern __m256h __cdecl _mm256_maskz_rsqrt_ph(__mmask16, __m256h); 
#line 6127
extern __m512h __cdecl _mm512_rsqrt_ph(__m512h); 
#line 6128
extern __m512h __cdecl _mm512_mask_rsqrt_ph(__m512h, __mmask32, __m512h); 
#line 6129
extern __m512h __cdecl _mm512_maskz_rsqrt_ph(__mmask32, __m512h); 
#line 6132
extern __m128h __cdecl _mm_rsqrt_sh(__m128h, __m128h); 
#line 6133
extern __m128h __cdecl _mm_mask_rsqrt_sh(__m128h, __mmask8, __m128h, __m128h); 
#line 6134
extern __m128h __cdecl _mm_maskz_rsqrt_sh(__mmask8, __m128h, __m128h); 
#line 6137
extern __m128h __cdecl _mm_scalef_ph(__m128h, __m128h); 
#line 6138
extern __m128h __cdecl _mm_mask_scalef_ph(__m128h, __mmask8, __m128h, __m128h); 
#line 6139
extern __m128h __cdecl _mm_maskz_scalef_ph(__mmask8, __m128h, __m128h); 
#line 6140
extern __m256h __cdecl _mm256_scalef_ph(__m256h, __m256h); 
#line 6141
extern __m256h __cdecl _mm256_mask_scalef_ph(__m256h, __mmask16, __m256h, __m256h); 
#line 6142
extern __m256h __cdecl _mm256_maskz_scalef_ph(__mmask16, __m256h, __m256h); 
#line 6143
extern __m512h __cdecl _mm512_scalef_ph(__m512h, __m512h); 
#line 6144
extern __m512h __cdecl _mm512_mask_scalef_ph(__m512h, __mmask32, __m512h, __m512h); 
#line 6145
extern __m512h __cdecl _mm512_maskz_scalef_ph(__mmask32, __m512h, __m512h); 
#line 6146
extern __m512h __cdecl _mm512_scalef_round_ph(__m512h, __m512h, const int); 
#line 6147
extern __m512h __cdecl _mm512_mask_scalef_round_ph(__m512h, __mmask32, __m512h, __m512h, const int); 
#line 6148
extern __m512h __cdecl _mm512_maskz_scalef_round_ph(__mmask32, __m512h, __m512h, const int); 
#line 6151
extern __m128h __cdecl _mm_scalef_sh(__m128h, __m128h); 
#line 6152
extern __m128h __cdecl _mm_mask_scalef_sh(__m128h, __mmask8, __m128h, __m128h); 
#line 6153
extern __m128h __cdecl _mm_maskz_scalef_sh(__mmask8, __m128h, __m128h); 
#line 6154
extern __m128h __cdecl _mm_scalef_round_sh(__m128h, __m128h, const int); 
#line 6155
extern __m128h __cdecl _mm_mask_scalef_round_sh(__m128h, __mmask8, __m128h, __m128h, const int); 
#line 6156
extern __m128h __cdecl _mm_maskz_scalef_round_sh(__mmask8, __m128h, __m128h, const int); 
#line 6159
extern __m128h __cdecl _mm_sqrt_ph(__m128h); 
#line 6160
extern __m128h __cdecl _mm_mask_sqrt_ph(__m128h, __mmask8, __m128h); 
#line 6161
extern __m128h __cdecl _mm_maskz_sqrt_ph(__mmask8, __m128h); 
#line 6162
extern __m256h __cdecl _mm256_sqrt_ph(__m256h); 
#line 6163
extern __m256h __cdecl _mm256_mask_sqrt_ph(__m256h, __mmask16, __m256h); 
#line 6164
extern __m256h __cdecl _mm256_maskz_sqrt_ph(__mmask16, __m256h); 
#line 6165
extern __m512h __cdecl _mm512_sqrt_ph(__m512h); 
#line 6166
extern __m512h __cdecl _mm512_mask_sqrt_ph(__m512h, __mmask32, __m512h); 
#line 6167
extern __m512h __cdecl _mm512_maskz_sqrt_ph(__mmask32, __m512h); 
#line 6168
extern __m512h __cdecl _mm512_sqrt_round_ph(__m512h, const int); 
#line 6169
extern __m512h __cdecl _mm512_mask_sqrt_round_ph(__m512h, __mmask32, __m512h, const int); 
#line 6170
extern __m512h __cdecl _mm512_maskz_sqrt_round_ph(__mmask32, __m512h, const int); 
#line 6173
extern __m128h __cdecl _mm_sqrt_sh(__m128h, __m128h); 
#line 6174
extern __m128h __cdecl _mm_mask_sqrt_sh(__m128h, __mmask8, __m128h, __m128h); 
#line 6175
extern __m128h __cdecl _mm_maskz_sqrt_sh(__mmask8, __m128h, __m128h); 
#line 6176
extern __m128h __cdecl _mm_sqrt_round_sh(__m128h, __m128h, const int); 
#line 6177
extern __m128h __cdecl _mm_mask_sqrt_round_sh(__m128h, __mmask8, __m128h, __m128h, const int); 
#line 6178
extern __m128h __cdecl _mm_maskz_sqrt_round_sh(__mmask8, __m128h, __m128h, const int); 
#line 6181
extern __m128h __cdecl _mm_sub_ph(__m128h, __m128h); 
#line 6182
extern __m128h __cdecl _mm_mask_sub_ph(__m128h, __mmask8, __m128h, __m128h); 
#line 6183
extern __m128h __cdecl _mm_maskz_sub_ph(__mmask8, __m128h, __m128h); 
#line 6184
extern __m256h __cdecl _mm256_sub_ph(__m256h, __m256h); 
#line 6185
extern __m256h __cdecl _mm256_mask_sub_ph(__m256h, __mmask16, __m256h, __m256h); 
#line 6186
extern __m256h __cdecl _mm256_maskz_sub_ph(__mmask16, __m256h, __m256h); 
#line 6187
extern __m512h __cdecl _mm512_sub_ph(__m512h, __m512h); 
#line 6188
extern __m512h __cdecl _mm512_mask_sub_ph(__m512h, __mmask32, __m512h, __m512h); 
#line 6189
extern __m512h __cdecl _mm512_maskz_sub_ph(__mmask32, __m512h, __m512h); 
#line 6190
extern __m512h __cdecl _mm512_sub_round_ph(__m512h, __m512h, int); 
#line 6191
extern __m512h __cdecl _mm512_mask_sub_round_ph(__m512h, __mmask32, __m512h, __m512h, int); 
#line 6192
extern __m512h __cdecl _mm512_maskz_sub_round_ph(__mmask32, __m512h, __m512h, int); 
#line 6195
extern __m128h __cdecl _mm_sub_sh(__m128h, __m128h); 
#line 6196
extern __m128h __cdecl _mm_mask_sub_sh(__m128h, __mmask8, __m128h, __m128h); 
#line 6197
extern __m128h __cdecl _mm_maskz_sub_sh(__mmask8, __m128h, __m128h); 
#line 6198
extern __m128h __cdecl _mm_sub_round_sh(__m128h, __m128h, int); 
#line 6199
extern __m128h __cdecl _mm_mask_sub_round_sh(__m128h, __mmask8, __m128h, __m128h, int); 
#line 6200
extern __m128h __cdecl _mm_maskz_sub_round_sh(__mmask8, __m128h, __m128h, int); 
#line 6202
extern __m128h __cdecl _mm_mask_blend_ph(__mmask8, __m128h, __m128h); 
#line 6203
extern __m256h __cdecl _mm256_mask_blend_ph(__mmask16, __m256h, __m256h); 
#line 6204
extern __m512h __cdecl _mm512_mask_blend_ph(__mmask32, __m512h, __m512h); 
#line 6207
extern __m256 __cdecl _mm256_rsqrt14_ps(__m256); 
#line 6208
extern __m256d __cdecl _mm256_rsqrt14_pd(__m256d); 
#line 6209
extern __m128 __cdecl _mm_rsqrt14_ps(__m128); 
#line 6210
extern __m128d __cdecl _mm_rsqrt14_pd(__m128d); 
#line 6213
extern float __cdecl __getexp_ss(float); 
#line 6214
extern double __cdecl __getexp_sd(double); 
#line 6215
extern float __cdecl __getmant_ss(float, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 6216
extern double __cdecl __getmant_sd(double, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 6217
extern float __cdecl __scalef_ss(float, float); 
#line 6218
extern double __cdecl __scalef_sd(double, double); 
#line 6221
extern __m512i __cdecl _mm512_sm4key4_epi32(__m512i, __m512i); 
#line 6222
extern __m512i __cdecl _mm512_sm4rnds4_epi32(__m512i, __m512i); 
#line 6375
extern __m128i __cdecl _mm_loadrs_epi8(const void *); 
#line 6376
extern __m128i __cdecl _mm_mask_loadrs_epi8(__m128i, __mmask16, const void *); 
#line 6377
extern __m128i __cdecl _mm_maskz_loadrs_epi8(__mmask16, const void *); 
#line 6379
extern __m256i __cdecl _mm256_loadrs_epi8(const void *); 
#line 6380
extern __m256i __cdecl _mm256_mask_loadrs_epi8(__m256i, __mmask32, const void *); 
#line 6381
extern __m256i __cdecl _mm256_maskz_loadrs_epi8(__mmask32, const void *); 
#line 6383
extern __m512i __cdecl _mm512_loadrs_epi8(const void *); 
#line 6384
extern __m512i __cdecl _mm512_mask_loadrs_epi8(__m512i, __mmask64, const void *); 
#line 6385
extern __m512i __cdecl _mm512_maskz_loadrs_epi8(__mmask64, const void *); 
#line 6387
extern __m128i __cdecl _mm_loadrs_epi16(const void *); 
#line 6388
extern __m128i __cdecl _mm_mask_loadrs_epi16(__m128i, __mmask8, const void *); 
#line 6389
extern __m128i __cdecl _mm_maskz_loadrs_epi16(__mmask8, const void *); 
#line 6391
extern __m256i __cdecl _mm256_loadrs_epi16(const void *); 
#line 6392
extern __m256i __cdecl _mm256_mask_loadrs_epi16(__m256i, __mmask16, const void *); 
#line 6393
extern __m256i __cdecl _mm256_maskz_loadrs_epi16(__mmask16, const void *); 
#line 6395
extern __m512i __cdecl _mm512_loadrs_epi16(const void *); 
#line 6396
extern __m512i __cdecl _mm512_mask_loadrs_epi16(__m512i, __mmask32, const void *); 
#line 6397
extern __m512i __cdecl _mm512_maskz_loadrs_epi16(__mmask32, const void *); 
#line 6399
extern __m128i __cdecl _mm_loadrs_epi32(const void *); 
#line 6400
extern __m128i __cdecl _mm_mask_loadrs_epi32(__m128i, __mmask8, const void *); 
#line 6401
extern __m128i __cdecl _mm_maskz_loadrs_epi32(__mmask8, const void *); 
#line 6403
extern __m256i __cdecl _mm256_loadrs_epi32(const void *); 
#line 6404
extern __m256i __cdecl _mm256_mask_loadrs_epi32(__m256i, __mmask8, const void *); 
#line 6405
extern __m256i __cdecl _mm256_maskz_loadrs_epi32(__mmask8, const void *); 
#line 6407
extern __m512i __cdecl _mm512_loadrs_epi32(const void *); 
#line 6408
extern __m512i __cdecl _mm512_mask_loadrs_epi32(__m512i, __mmask16, const void *); 
#line 6409
extern __m512i __cdecl _mm512_maskz_loadrs_epi32(__mmask16, const void *); 
#line 6411
extern __m128i __cdecl _mm_loadrs_epi64(const void *); 
#line 6412
extern __m128i __cdecl _mm_mask_loadrs_epi64(__m128i, __mmask8, const void *); 
#line 6413
extern __m128i __cdecl _mm_maskz_loadrs_epi64(__mmask8, const void *); 
#line 6415
extern __m256i __cdecl _mm256_loadrs_epi64(const void *); 
#line 6416
extern __m256i __cdecl _mm256_mask_loadrs_epi64(__m256i, __mmask8, const void *); 
#line 6417
extern __m256i __cdecl _mm256_maskz_loadrs_epi64(__mmask8, const void *); 
#line 6419
extern __m512i __cdecl _mm512_loadrs_epi64(const void *); 
#line 6420
extern __m512i __cdecl _mm512_mask_loadrs_epi64(__m512i, __mmask8, const void *); 
#line 6421
extern __m512i __cdecl _mm512_maskz_loadrs_epi64(__mmask8, const void *); 
#line 6425 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"
extern __m128bh __cdecl _mm_add_pbh(__m128bh, __m128bh); 
#line 6426
extern __m128bh __cdecl _mm_mask_add_pbh(__m128bh, __mmask8, __m128bh, __m128bh); 
#line 6427
extern __m128bh __cdecl _mm_maskz_add_pbh(__mmask8, __m128bh, __m128bh); 
#line 6428
extern __m256bh __cdecl _mm256_add_pbh(__m256bh, __m256bh); 
#line 6429
extern __m256bh __cdecl _mm256_mask_add_pbh(__m256bh, __mmask16, __m256bh, __m256bh); 
#line 6430
extern __m256bh __cdecl _mm256_maskz_add_pbh(__mmask16, __m256bh, __m256bh); 
#line 6431
extern __m512bh __cdecl _mm512_add_pbh(__m512bh, __m512bh); 
#line 6432
extern __m512bh __cdecl _mm512_mask_add_pbh(__m512bh, __mmask32, __m512bh, __m512bh); 
#line 6433
extern __m512bh __cdecl _mm512_maskz_add_pbh(__mmask32, __m512bh, __m512bh); 
#line 6434
extern __mmask8 __cdecl _mm_cmp_pbh_mask(__m128bh, __m128bh, const int); 
#line 6435
extern __mmask8 __cdecl _mm_mask_cmp_pbh_mask(__mmask8, __m128bh, __m128bh, const int); 
#line 6436
extern __mmask16 __cdecl _mm256_cmp_pbh_mask(__m256bh, __m256bh, const int); 
#line 6437
extern __mmask16 __cdecl _mm256_mask_cmp_pbh_mask(__mmask16, __m256bh, __m256bh, const int); 
#line 6438
extern __mmask32 __cdecl _mm512_cmp_pbh_mask(__m512bh, __m512bh, const int); 
#line 6439
extern __mmask32 __cdecl _mm512_mask_cmp_pbh_mask(__mmask32, __m512bh, __m512bh, const int); 
#line 6440
extern int __cdecl _mm_comeq_sbh(__m128bh, __m128bh); 
#line 6441
extern int __cdecl _mm_comlt_sbh(__m128bh, __m128bh); 
#line 6442
extern int __cdecl _mm_comle_sbh(__m128bh, __m128bh); 
#line 6443
extern int __cdecl _mm_comgt_sbh(__m128bh, __m128bh); 
#line 6444
extern int __cdecl _mm_comge_sbh(__m128bh, __m128bh); 
#line 6445
extern int __cdecl _mm_comneq_sbh(__m128bh, __m128bh); 
#line 6446
extern __m128bh __cdecl _mm_div_pbh(__m128bh, __m128bh); 
#line 6447
extern __m128bh __cdecl _mm_mask_div_pbh(__m128bh, __mmask8, __m128bh, __m128bh); 
#line 6448
extern __m128bh __cdecl _mm_maskz_div_pbh(__mmask8, __m128bh, __m128bh); 
#line 6449
extern __m256bh __cdecl _mm256_div_pbh(__m256bh, __m256bh); 
#line 6450
extern __m256bh __cdecl _mm256_mask_div_pbh(__m256bh, __mmask16, __m256bh, __m256bh); 
#line 6451
extern __m256bh __cdecl _mm256_maskz_div_pbh(__mmask16, __m256bh, __m256bh); 
#line 6452
extern __m512bh __cdecl _mm512_div_pbh(__m512bh, __m512bh); 
#line 6453
extern __m512bh __cdecl _mm512_mask_div_pbh(__m512bh, __mmask32, __m512bh, __m512bh); 
#line 6454
extern __m512bh __cdecl _mm512_maskz_div_pbh(__mmask32, __m512bh, __m512bh); 
#line 6455
extern __m128bh __cdecl _mm_fmadd_pbh(__m128bh, __m128bh, __m128bh); 
#line 6456
extern __m128bh __cdecl _mm_mask_fmadd_pbh(__m128bh, __mmask8, __m128bh, __m128bh); 
#line 6457
extern __m128bh __cdecl _mm_mask3_fmadd_pbh(__m128bh, __m128bh, __m128bh, __mmask8); 
#line 6458
extern __m128bh __cdecl _mm_maskz_fmadd_pbh(__mmask8, __m128bh, __m128bh, __m128bh); 
#line 6459
extern __m256bh __cdecl _mm256_fmadd_pbh(__m256bh, __m256bh, __m256bh); 
#line 6460
extern __m256bh __cdecl _mm256_mask_fmadd_pbh(__m256bh, __mmask16, __m256bh, __m256bh); 
#line 6461
extern __m256bh __cdecl _mm256_mask3_fmadd_pbh(__m256bh, __m256bh, __m256bh, __mmask16); 
#line 6462
extern __m256bh __cdecl _mm256_maskz_fmadd_pbh(__mmask16, __m256bh, __m256bh, __m256bh); 
#line 6463
extern __m512bh __cdecl _mm512_fmadd_pbh(__m512bh, __m512bh, __m512bh); 
#line 6464
extern __m512bh __cdecl _mm512_mask_fmadd_pbh(__m512bh, __mmask32, __m512bh, __m512bh); 
#line 6465
extern __m512bh __cdecl _mm512_mask3_fmadd_pbh(__m512bh, __m512bh, __m512bh, __mmask32); 
#line 6466
extern __m512bh __cdecl _mm512_maskz_fmadd_pbh(__mmask32, __m512bh, __m512bh, __m512bh); 
#line 6467
extern __m128bh __cdecl _mm_fmsub_pbh(__m128bh, __m128bh, __m128bh); 
#line 6468
extern __m128bh __cdecl _mm_mask_fmsub_pbh(__m128bh, __mmask8, __m128bh, __m128bh); 
#line 6469
extern __m128bh __cdecl _mm_mask3_fmsub_pbh(__m128bh, __m128bh, __m128bh, __mmask8); 
#line 6470
extern __m128bh __cdecl _mm_maskz_fmsub_pbh(__mmask8, __m128bh, __m128bh, __m128bh); 
#line 6471
extern __m256bh __cdecl _mm256_fmsub_pbh(__m256bh, __m256bh, __m256bh); 
#line 6472
extern __m256bh __cdecl _mm256_mask_fmsub_pbh(__m256bh, __mmask16, __m256bh, __m256bh); 
#line 6473
extern __m256bh __cdecl _mm256_mask3_fmsub_pbh(__m256bh, __m256bh, __m256bh, __mmask16); 
#line 6474
extern __m256bh __cdecl _mm256_maskz_fmsub_pbh(__mmask16, __m256bh, __m256bh, __m256bh); 
#line 6475
extern __m512bh __cdecl _mm512_fmsub_pbh(__m512bh, __m512bh, __m512bh); 
#line 6476
extern __m512bh __cdecl _mm512_mask_fmsub_pbh(__m512bh, __mmask32, __m512bh, __m512bh); 
#line 6477
extern __m512bh __cdecl _mm512_mask3_fmsub_pbh(__m512bh, __m512bh, __m512bh, __mmask32); 
#line 6478
extern __m512bh __cdecl _mm512_maskz_fmsub_pbh(__mmask32, __m512bh, __m512bh, __m512bh); 
#line 6479
extern __m128bh __cdecl _mm_fnmadd_pbh(__m128bh, __m128bh, __m128bh); 
#line 6480
extern __m128bh __cdecl _mm_mask_fnmadd_pbh(__m128bh, __mmask8, __m128bh, __m128bh); 
#line 6481
extern __m128bh __cdecl _mm_mask3_fnmadd_pbh(__m128bh, __m128bh, __m128bh, __mmask8); 
#line 6482
extern __m128bh __cdecl _mm_maskz_fnmadd_pbh(__mmask8, __m128bh, __m128bh, __m128bh); 
#line 6483
extern __m256bh __cdecl _mm256_fnmadd_pbh(__m256bh, __m256bh, __m256bh); 
#line 6484
extern __m256bh __cdecl _mm256_mask_fnmadd_pbh(__m256bh, __mmask16, __m256bh, __m256bh); 
#line 6485
extern __m256bh __cdecl _mm256_mask3_fnmadd_pbh(__m256bh, __m256bh, __m256bh, __mmask16); 
#line 6486
extern __m256bh __cdecl _mm256_maskz_fnmadd_pbh(__mmask16, __m256bh, __m256bh, __m256bh); 
#line 6487
extern __m512bh __cdecl _mm512_fnmadd_pbh(__m512bh, __m512bh, __m512bh); 
#line 6488
extern __m512bh __cdecl _mm512_mask_fnmadd_pbh(__m512bh, __mmask32, __m512bh, __m512bh); 
#line 6489
extern __m512bh __cdecl _mm512_mask3_fnmadd_pbh(__m512bh, __m512bh, __m512bh, __mmask32); 
#line 6490
extern __m512bh __cdecl _mm512_maskz_fnmadd_pbh(__mmask32, __m512bh, __m512bh, __m512bh); 
#line 6491
extern __m128bh __cdecl _mm_fnmsub_pbh(__m128bh, __m128bh, __m128bh); 
#line 6492
extern __m128bh __cdecl _mm_mask_fnmsub_pbh(__m128bh, __mmask8, __m128bh, __m128bh); 
#line 6493
extern __m128bh __cdecl _mm_mask3_fnmsub_pbh(__m128bh, __m128bh, __m128bh, __mmask8); 
#line 6494
extern __m128bh __cdecl _mm_maskz_fnmsub_pbh(__mmask8, __m128bh, __m128bh, __m128bh); 
#line 6495
extern __m256bh __cdecl _mm256_fnmsub_pbh(__m256bh, __m256bh, __m256bh); 
#line 6496
extern __m256bh __cdecl _mm256_mask_fnmsub_pbh(__m256bh, __mmask16, __m256bh, __m256bh); 
#line 6497
extern __m256bh __cdecl _mm256_mask3_fnmsub_pbh(__m256bh, __m256bh, __m256bh, __mmask16); 
#line 6498
extern __m256bh __cdecl _mm256_maskz_fnmsub_pbh(__mmask16, __m256bh, __m256bh, __m256bh); 
#line 6499
extern __m512bh __cdecl _mm512_fnmsub_pbh(__m512bh, __m512bh, __m512bh); 
#line 6500
extern __m512bh __cdecl _mm512_mask_fnmsub_pbh(__m512bh, __mmask32, __m512bh, __m512bh); 
#line 6501
extern __m512bh __cdecl _mm512_mask3_fnmsub_pbh(__m512bh, __m512bh, __m512bh, __mmask32); 
#line 6502
extern __m512bh __cdecl _mm512_maskz_fnmsub_pbh(__mmask32, __m512bh, __m512bh, __m512bh); 
#line 6503
extern __mmask8 __cdecl _mm_fpclass_pbh_mask(__m128bh, const int); 
#line 6504
extern __mmask8 __cdecl _mm_mask_fpclass_pbh_mask(__mmask8, __m128bh, const int); 
#line 6505
extern __mmask16 __cdecl _mm256_fpclass_pbh_mask(__m256bh, const int); 
#line 6506
extern __mmask16 __cdecl _mm256_mask_fpclass_pbh_mask(__mmask16, __m256bh, const int); 
#line 6507
extern __mmask32 __cdecl _mm512_fpclass_pbh_mask(__m512bh, const int); 
#line 6508
extern __mmask32 __cdecl _mm512_mask_fpclass_pbh_mask(__mmask32, __m512bh, const int); 
#line 6509
extern __m128bh __cdecl _mm_getexp_pbh(__m128bh); 
#line 6510
extern __m128bh __cdecl _mm_mask_getexp_pbh(__m128bh, __mmask8, __m128bh); 
#line 6511
extern __m128bh __cdecl _mm_maskz_getexp_pbh(__mmask8, __m128bh); 
#line 6512
extern __m256bh __cdecl _mm256_getexp_pbh(__m256bh); 
#line 6513
extern __m256bh __cdecl _mm256_mask_getexp_pbh(__m256bh, __mmask16, __m256bh); 
#line 6514
extern __m256bh __cdecl _mm256_maskz_getexp_pbh(__mmask16, __m256bh); 
#line 6515
extern __m512bh __cdecl _mm512_getexp_pbh(__m512bh); 
#line 6516
extern __m512bh __cdecl _mm512_mask_getexp_pbh(__m512bh, __mmask32, __m512bh); 
#line 6517
extern __m512bh __cdecl _mm512_maskz_getexp_pbh(__mmask32, __m512bh); 
#line 6518
extern __m128bh __cdecl _mm_getmant_pbh(__m128bh, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 6519
extern __m128bh __cdecl _mm_mask_getmant_pbh(__m128bh, __mmask8, __m128bh, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 6520
extern __m128bh __cdecl _mm_maskz_getmant_pbh(__mmask8, __m128bh, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 6521
extern __m256bh __cdecl _mm256_getmant_pbh(__m256bh, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 6522
extern __m256bh __cdecl _mm256_mask_getmant_pbh(__m256bh, __mmask16, __m256bh, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 6523
extern __m256bh __cdecl _mm256_maskz_getmant_pbh(__mmask16, __m256bh, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 6524
extern __m512bh __cdecl _mm512_getmant_pbh(__m512bh, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 6525
extern __m512bh __cdecl _mm512_mask_getmant_pbh(__m512bh, __mmask32, __m512bh, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 6526
extern __m512bh __cdecl _mm512_maskz_getmant_pbh(__mmask32, __m512bh, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM); 
#line 6527
extern __m128bh __cdecl _mm_max_pbh(__m128bh, __m128bh); 
#line 6528
extern __m128bh __cdecl _mm_mask_max_pbh(__m128bh, __mmask8, __m128bh, __m128bh); 
#line 6529
extern __m128bh __cdecl _mm_maskz_max_pbh(__mmask8, __m128bh, __m128bh); 
#line 6530
extern __m256bh __cdecl _mm256_max_pbh(__m256bh, __m256bh); 
#line 6531
extern __m256bh __cdecl _mm256_mask_max_pbh(__m256bh, __mmask16, __m256bh, __m256bh); 
#line 6532
extern __m256bh __cdecl _mm256_maskz_max_pbh(__mmask16, __m256bh, __m256bh); 
#line 6533
extern __m512bh __cdecl _mm512_max_pbh(__m512bh, __m512bh); 
#line 6534
extern __m512bh __cdecl _mm512_mask_max_pbh(__m512bh, __mmask32, __m512bh, __m512bh); 
#line 6535
extern __m512bh __cdecl _mm512_maskz_max_pbh(__mmask32, __m512bh, __m512bh); 
#line 6536
extern __m128bh __cdecl _mm_min_pbh(__m128bh, __m128bh); 
#line 6537
extern __m128bh __cdecl _mm_mask_min_pbh(__m128bh, __mmask8, __m128bh, __m128bh); 
#line 6538
extern __m128bh __cdecl _mm_maskz_min_pbh(__mmask8, __m128bh, __m128bh); 
#line 6539
extern __m256bh __cdecl _mm256_min_pbh(__m256bh, __m256bh); 
#line 6540
extern __m256bh __cdecl _mm256_mask_min_pbh(__m256bh, __mmask16, __m256bh, __m256bh); 
#line 6541
extern __m256bh __cdecl _mm256_maskz_min_pbh(__mmask16, __m256bh, __m256bh); 
#line 6542
extern __m512bh __cdecl _mm512_min_pbh(__m512bh, __m512bh); 
#line 6543
extern __m512bh __cdecl _mm512_mask_min_pbh(__m512bh, __mmask32, __m512bh, __m512bh); 
#line 6544
extern __m512bh __cdecl _mm512_maskz_min_pbh(__mmask32, __m512bh, __m512bh); 
#line 6545
extern __m128bh __cdecl _mm_mul_pbh(__m128bh, __m128bh); 
#line 6546
extern __m128bh __cdecl _mm_mask_mul_pbh(__m128bh, __mmask8, __m128bh, __m128bh); 
#line 6547
extern __m128bh __cdecl _mm_maskz_mul_pbh(__mmask8, __m128bh, __m128bh); 
#line 6548
extern __m256bh __cdecl _mm256_mul_pbh(__m256bh, __m256bh); 
#line 6549
extern __m256bh __cdecl _mm256_mask_mul_pbh(__m256bh, __mmask16, __m256bh, __m256bh); 
#line 6550
extern __m256bh __cdecl _mm256_maskz_mul_pbh(__mmask16, __m256bh, __m256bh); 
#line 6551
extern __m512bh __cdecl _mm512_mul_pbh(__m512bh, __m512bh); 
#line 6552
extern __m512bh __cdecl _mm512_mask_mul_pbh(__m512bh, __mmask32, __m512bh, __m512bh); 
#line 6553
extern __m512bh __cdecl _mm512_maskz_mul_pbh(__mmask32, __m512bh, __m512bh); 
#line 6554
extern __m128bh __cdecl _mm_rcp_pbh(__m128bh); 
#line 6555
extern __m128bh __cdecl _mm_mask_rcp_pbh(__m128bh, __mmask8, __m128bh); 
#line 6556
extern __m128bh __cdecl _mm_maskz_rcp_pbh(__mmask8, __m128bh); 
#line 6557
extern __m256bh __cdecl _mm256_rcp_pbh(__m256bh); 
#line 6558
extern __m256bh __cdecl _mm256_mask_rcp_pbh(__m256bh, __mmask16, __m256bh); 
#line 6559
extern __m256bh __cdecl _mm256_maskz_rcp_pbh(__mmask16, __m256bh); 
#line 6560
extern __m512bh __cdecl _mm512_rcp_pbh(__m512bh); 
#line 6561
extern __m512bh __cdecl _mm512_mask_rcp_pbh(__m512bh, __mmask32, __m512bh); 
#line 6562
extern __m512bh __cdecl _mm512_maskz_rcp_pbh(__mmask32, __m512bh); 
#line 6563
extern __m128bh __cdecl _mm_reduce_pbh(__m128bh, int); 
#line 6564
extern __m128bh __cdecl _mm_mask_reduce_pbh(__m128bh, __mmask8, __m128bh, int); 
#line 6565
extern __m128bh __cdecl _mm_maskz_reduce_pbh(__mmask8, __m128bh, int); 
#line 6566
extern __m256bh __cdecl _mm256_reduce_pbh(__m256bh, int); 
#line 6567
extern __m256bh __cdecl _mm256_mask_reduce_pbh(__m256bh, __mmask16, __m256bh, int); 
#line 6568
extern __m256bh __cdecl _mm256_maskz_reduce_pbh(__mmask16, __m256bh, int); 
#line 6569
extern __m512bh __cdecl _mm512_reduce_pbh(__m512bh, int); 
#line 6570
extern __m512bh __cdecl _mm512_mask_reduce_pbh(__m512bh, __mmask32, __m512bh, int); 
#line 6571
extern __m512bh __cdecl _mm512_maskz_reduce_pbh(__mmask32, __m512bh, int); 
#line 6572
extern __m128bh __cdecl _mm_rndscale_pbh(__m128bh, int); 
#line 6573
extern __m128bh __cdecl _mm_mask_rndscale_pbh(__m128bh, __mmask8, __m128bh, int); 
#line 6574
extern __m128bh __cdecl _mm_maskz_rndscale_pbh(__mmask8, __m128bh, int); 
#line 6575
extern __m256bh __cdecl _mm256_rndscale_pbh(__m256bh, int); 
#line 6576
extern __m256bh __cdecl _mm256_mask_rndscale_pbh(__m256bh, __mmask16, __m256bh, int); 
#line 6577
extern __m256bh __cdecl _mm256_maskz_rndscale_pbh(__mmask16, __m256bh, int); 
#line 6578
extern __m512bh __cdecl _mm512_rndscale_pbh(__m512bh, int); 
#line 6579
extern __m512bh __cdecl _mm512_mask_rndscale_pbh(__m512bh, __mmask32, __m512bh, int); 
#line 6580
extern __m512bh __cdecl _mm512_maskz_rndscale_pbh(__mmask32, __m512bh, int); 
#line 6581
extern __m128bh __cdecl _mm_rsqrt_pbh(__m128bh); 
#line 6582
extern __m128bh __cdecl _mm_mask_rsqrt_pbh(__m128bh, __mmask8, __m128bh); 
#line 6583
extern __m128bh __cdecl _mm_maskz_rsqrt_pbh(__mmask8, __m128bh); 
#line 6584
extern __m256bh __cdecl _mm256_rsqrt_pbh(__m256bh); 
#line 6585
extern __m256bh __cdecl _mm256_mask_rsqrt_pbh(__m256bh, __mmask16, __m256bh); 
#line 6586
extern __m256bh __cdecl _mm256_maskz_rsqrt_pbh(__mmask16, __m256bh); 
#line 6587
extern __m512bh __cdecl _mm512_rsqrt_pbh(__m512bh); 
#line 6588
extern __m512bh __cdecl _mm512_mask_rsqrt_pbh(__m512bh, __mmask32, __m512bh); 
#line 6589
extern __m512bh __cdecl _mm512_maskz_rsqrt_pbh(__mmask32, __m512bh); 
#line 6590
extern __m128bh __cdecl _mm_scalef_pbh(__m128bh, __m128bh); 
#line 6591
extern __m128bh __cdecl _mm_mask_scalef_pbh(__m128bh, __mmask8, __m128bh, __m128bh); 
#line 6592
extern __m128bh __cdecl _mm_maskz_scalef_pbh(__mmask8, __m128bh, __m128bh); 
#line 6593
extern __m256bh __cdecl _mm256_scalef_pbh(__m256bh, __m256bh); 
#line 6594
extern __m256bh __cdecl _mm256_mask_scalef_pbh(__m256bh, __mmask16, __m256bh, __m256bh); 
#line 6595
extern __m256bh __cdecl _mm256_maskz_scalef_pbh(__mmask16, __m256bh, __m256bh); 
#line 6596
extern __m512bh __cdecl _mm512_scalef_pbh(__m512bh, __m512bh); 
#line 6597
extern __m512bh __cdecl _mm512_mask_scalef_pbh(__m512bh, __mmask32, __m512bh, __m512bh); 
#line 6598
extern __m512bh __cdecl _mm512_maskz_scalef_pbh(__mmask32, __m512bh, __m512bh); 
#line 6599
extern __m128bh __cdecl _mm_sqrt_pbh(__m128bh); 
#line 6600
extern __m128bh __cdecl _mm_mask_sqrt_pbh(__m128bh, __mmask8, __m128bh); 
#line 6601
extern __m128bh __cdecl _mm_maskz_sqrt_pbh(__mmask8, __m128bh); 
#line 6602
extern __m256bh __cdecl _mm256_sqrt_pbh(__m256bh); 
#line 6603
extern __m256bh __cdecl _mm256_mask_sqrt_pbh(__m256bh, __mmask16, __m256bh); 
#line 6604
extern __m256bh __cdecl _mm256_maskz_sqrt_pbh(__mmask16, __m256bh); 
#line 6605
extern __m512bh __cdecl _mm512_sqrt_pbh(__m512bh); 
#line 6606
extern __m512bh __cdecl _mm512_mask_sqrt_pbh(__m512bh, __mmask32, __m512bh); 
#line 6607
extern __m512bh __cdecl _mm512_maskz_sqrt_pbh(__mmask32, __m512bh); 
#line 6608
extern __m128bh __cdecl _mm_sub_pbh(__m128bh, __m128bh); 
#line 6609
extern __m128bh __cdecl _mm_mask_sub_pbh(__m128bh, __mmask8, __m128bh, __m128bh); 
#line 6610
extern __m128bh __cdecl _mm_maskz_sub_pbh(__mmask8, __m128bh, __m128bh); 
#line 6611
extern __m256bh __cdecl _mm256_sub_pbh(__m256bh, __m256bh); 
#line 6612
extern __m256bh __cdecl _mm256_mask_sub_pbh(__m256bh, __mmask16, __m256bh, __m256bh); 
#line 6613
extern __m256bh __cdecl _mm256_maskz_sub_pbh(__mmask16, __m256bh, __m256bh); 
#line 6614
extern __m512bh __cdecl _mm512_sub_pbh(__m512bh, __m512bh); 
#line 6615
extern __m512bh __cdecl _mm512_mask_sub_pbh(__m512bh, __mmask32, __m512bh, __m512bh); 
#line 6616
extern __m512bh __cdecl _mm512_maskz_sub_pbh(__mmask32, __m512bh, __m512bh); 
#line 6619
extern __m128h __cdecl _mm_cvtx2ps_ph(__m128, __m128); 
#line 6620
extern __m128h __cdecl _mm_mask_cvtx2ps_ph(__m128h, __mmask8, __m128, __m128); 
#line 6621
extern __m128h __cdecl _mm_maskz_cvtx2ps_ph(__mmask8, __m128, __m128); 
#line 6622
extern __m256h __cdecl _mm256_cvtx2ps_ph(__m256, __m256); 
#line 6623
extern __m256h __cdecl _mm256_mask_cvtx2ps_ph(__m256h, __mmask16, __m256, __m256); 
#line 6624
extern __m256h __cdecl _mm256_maskz_cvtx2ps_ph(__mmask16, __m256, __m256); 
#line 6625
extern __m512h __cdecl _mm512_cvtx2ps_ph(__m512, __m512); 
#line 6626
extern __m512h __cdecl _mm512_mask_cvtx2ps_ph(__m512h, __mmask32, __m512, __m512); 
#line 6627
extern __m512h __cdecl _mm512_maskz_cvtx2ps_ph(__mmask32, __m512, __m512); 
#line 6628
extern __m512h __cdecl _mm512_cvtx_round2ps_ph(__m512, __m512, const int); 
#line 6629
extern __m512h __cdecl _mm512_mask_cvtx_round2ps_ph(__m512h, __mmask32, __m512, __m512, const int); 
#line 6630
extern __m512h __cdecl _mm512_maskz_cvtx_round2ps_ph(__mmask32, __m512, __m512, const int); 
#line 6631
extern __m128i __cdecl _mm_cvtbiasph_pbf8(__m128i, __m128h); 
#line 6632
extern __m128i __cdecl _mm_mask_cvtbiasph_pbf8(__m128i, __mmask8, __m128i, __m128h); 
#line 6633
extern __m128i __cdecl _mm_maskz_cvtbiasph_pbf8(__mmask8, __m128i, __m128h); 
#line 6634
extern __m128i __cdecl _mm256_cvtbiasph_pbf8(__m256i, __m256h); 
#line 6635
extern __m128i __cdecl _mm256_mask_cvtbiasph_pbf8(__m128i, __mmask16, __m256i, __m256h); 
#line 6636
extern __m128i __cdecl _mm256_maskz_cvtbiasph_pbf8(__mmask16, __m256i, __m256h); 
#line 6637
extern __m256i __cdecl _mm512_cvtbiasph_pbf8(__m512i, __m512h); 
#line 6638
extern __m256i __cdecl _mm512_mask_cvtbiasph_pbf8(__m256i, __mmask32, __m512i, __m512h); 
#line 6639
extern __m256i __cdecl _mm512_maskz_cvtbiasph_pbf8(__mmask32, __m512i, __m512h); 
#line 6640
extern __m128i __cdecl _mm_cvtbiassph_pbf8(__m128i, __m128h); 
#line 6641
extern __m128i __cdecl _mm_mask_cvtbiassph_pbf8(__m128i, __mmask8, __m128i, __m128h); 
#line 6642
extern __m128i __cdecl _mm_maskz_cvtbiassph_pbf8(__mmask8, __m128i, __m128h); 
#line 6643
extern __m128i __cdecl _mm256_cvtbiassph_pbf8(__m256i, __m256h); 
#line 6644
extern __m128i __cdecl _mm256_mask_cvtbiassph_pbf8(__m128i, __mmask16, __m256i, __m256h); 
#line 6645
extern __m128i __cdecl _mm256_maskz_cvtbiassph_pbf8(__mmask16, __m256i, __m256h); 
#line 6646
extern __m256i __cdecl _mm512_cvtbiassph_pbf8(__m512i, __m512h); 
#line 6647
extern __m256i __cdecl _mm512_mask_cvtbiassph_pbf8(__m256i, __mmask32, __m512i, __m512h); 
#line 6648
extern __m256i __cdecl _mm512_maskz_cvtbiassph_pbf8(__mmask32, __m512i, __m512h); 
#line 6649
extern __m128i __cdecl _mm_cvtbiasph_phf8(__m128i, __m128h); 
#line 6650
extern __m128i __cdecl _mm_mask_cvtbiasph_phf8(__m128i, __mmask8, __m128i, __m128h); 
#line 6651
extern __m128i __cdecl _mm_maskz_cvtbiasph_phf8(__mmask8, __m128i, __m128h); 
#line 6652
extern __m128i __cdecl _mm256_cvtbiasph_phf8(__m256i, __m256h); 
#line 6653
extern __m128i __cdecl _mm256_mask_cvtbiasph_phf8(__m128i, __mmask16, __m256i, __m256h); 
#line 6654
extern __m128i __cdecl _mm256_maskz_cvtbiasph_phf8(__mmask16, __m256i, __m256h); 
#line 6655
extern __m256i __cdecl _mm512_cvtbiasph_phf8(__m512i, __m512h); 
#line 6656
extern __m256i __cdecl _mm512_mask_cvtbiasph_phf8(__m256i, __mmask32, __m512i, __m512h); 
#line 6657
extern __m256i __cdecl _mm512_maskz_cvtbiasph_phf8(__mmask32, __m512i, __m512h); 
#line 6658
extern __m128i __cdecl _mm_cvtbiassph_phf8(__m128i, __m128h); 
#line 6659
extern __m128i __cdecl _mm_mask_cvtbiassph_phf8(__m128i, __mmask8, __m128i, __m128h); 
#line 6660
extern __m128i __cdecl _mm_maskz_cvtbiassph_phf8(__mmask8, __m128i, __m128h); 
#line 6661
extern __m128i __cdecl _mm256_cvtbiassph_phf8(__m256i, __m256h); 
#line 6662
extern __m128i __cdecl _mm256_mask_cvtbiassph_phf8(__m128i, __mmask16, __m256i, __m256h); 
#line 6663
extern __m128i __cdecl _mm256_maskz_cvtbiassph_phf8(__mmask16, __m256i, __m256h); 
#line 6664
extern __m256i __cdecl _mm512_cvtbiassph_phf8(__m512i, __m512h); 
#line 6665
extern __m256i __cdecl _mm512_mask_cvtbiassph_phf8(__m256i, __mmask32, __m512i, __m512h); 
#line 6666
extern __m256i __cdecl _mm512_maskz_cvtbiassph_phf8(__mmask32, __m512i, __m512h); 
#line 6667
extern __m128h __cdecl _mm_cvthf8_ph(__m128i); 
#line 6668
extern __m128h __cdecl _mm_mask_cvthf8_ph(__m128h, __mmask8, __m128i); 
#line 6669
extern __m128h __cdecl _mm_maskz_cvthf8_ph(__mmask8, __m128i); 
#line 6670
extern __m256h __cdecl _mm256_cvthf8_ph(__m128i); 
#line 6671
extern __m256h __cdecl _mm256_mask_cvthf8_ph(__m256h, __mmask16, __m128i); 
#line 6672
extern __m256h __cdecl _mm256_maskz_cvthf8_ph(__mmask16, __m128i); 
#line 6673
extern __m512h __cdecl _mm512_cvthf8_ph(__m256i); 
#line 6674
extern __m512h __cdecl _mm512_mask_cvthf8_ph(__m512h, __mmask32, __m256i); 
#line 6675
extern __m512h __cdecl _mm512_maskz_cvthf8_ph(__mmask32, __m256i); 
#line 6676
extern __m128i __cdecl _mm_cvt2ph_bf8(__m128h, __m128h); 
#line 6677
extern __m128i __cdecl _mm_mask_cvt2ph_bf8(__m128i, __mmask16, __m128h, __m128h); 
#line 6678
extern __m128i __cdecl _mm_maskz_cvt2ph_bf8(__mmask16, __m128h, __m128h); 
#line 6679
extern __m256i __cdecl _mm256_cvt2ph_bf8(__m256h, __m256h); 
#line 6680
extern __m256i __cdecl _mm256_mask_cvt2ph_bf8(__m256i, __mmask32, __m256h, __m256h); 
#line 6681
extern __m256i __cdecl _mm256_maskz_cvt2ph_bf8(__mmask32, __m256h, __m256h); 
#line 6682
extern __m512i __cdecl _mm512_cvt2ph_bf8(__m512h, __m512h); 
#line 6683
extern __m512i __cdecl _mm512_mask_cvt2ph_bf8(__m512i, __mmask64, __m512h, __m512h); 
#line 6684
extern __m512i __cdecl _mm512_maskz_cvt2ph_bf8(__mmask64, __m512h, __m512h); 
#line 6685
extern __m128i __cdecl _mm_cvts2ph_bf8(__m128h, __m128h); 
#line 6686
extern __m128i __cdecl _mm_mask_cvts2ph_bf8(__m128i, __mmask16, __m128h, __m128h); 
#line 6687
extern __m128i __cdecl _mm_maskz_cvts2ph_bf8(__mmask16, __m128h, __m128h); 
#line 6688
extern __m256i __cdecl _mm256_cvts2ph_bf8(__m256h, __m256h); 
#line 6689
extern __m256i __cdecl _mm256_mask_cvts2ph_bf8(__m256i, __mmask32, __m256h, __m256h); 
#line 6690
extern __m256i __cdecl _mm256_maskz_cvts2ph_bf8(__mmask32, __m256h, __m256h); 
#line 6691
extern __m512i __cdecl _mm512_cvts2ph_bf8(__m512h, __m512h); 
#line 6692
extern __m512i __cdecl _mm512_mask_cvts2ph_bf8(__m512i, __mmask64, __m512h, __m512h); 
#line 6693
extern __m512i __cdecl _mm512_maskz_cvts2ph_bf8(__mmask64, __m512h, __m512h); 
#line 6694
extern __m128i __cdecl _mm_cvt2ph_hf8(__m128h, __m128h); 
#line 6695
extern __m128i __cdecl _mm_mask_cvt2ph_hf8(__m128i, __mmask16, __m128h, __m128h); 
#line 6696
extern __m128i __cdecl _mm_maskz_cvt2ph_hf8(__mmask16, __m128h, __m128h); 
#line 6697
extern __m256i __cdecl _mm256_cvt2ph_hf8(__m256h, __m256h); 
#line 6698
extern __m256i __cdecl _mm256_mask_cvt2ph_hf8(__m256i, __mmask32, __m256h, __m256h); 
#line 6699
extern __m256i __cdecl _mm256_maskz_cvt2ph_hf8(__mmask32, __m256h, __m256h); 
#line 6700
extern __m512i __cdecl _mm512_cvt2ph_hf8(__m512h, __m512h); 
#line 6701
extern __m512i __cdecl _mm512_mask_cvt2ph_hf8(__m512i, __mmask64, __m512h, __m512h); 
#line 6702
extern __m512i __cdecl _mm512_maskz_cvt2ph_hf8(__mmask64, __m512h, __m512h); 
#line 6703
extern __m128i __cdecl _mm_cvts2ph_hf8(__m128h, __m128h); 
#line 6704
extern __m128i __cdecl _mm_mask_cvts2ph_hf8(__m128i, __mmask16, __m128h, __m128h); 
#line 6705
extern __m128i __cdecl _mm_maskz_cvts2ph_hf8(__mmask16, __m128h, __m128h); 
#line 6706
extern __m256i __cdecl _mm256_cvts2ph_hf8(__m256h, __m256h); 
#line 6707
extern __m256i __cdecl _mm256_mask_cvts2ph_hf8(__m256i, __mmask32, __m256h, __m256h); 
#line 6708
extern __m256i __cdecl _mm256_maskz_cvts2ph_hf8(__mmask32, __m256h, __m256h); 
#line 6709
extern __m512i __cdecl _mm512_cvts2ph_hf8(__m512h, __m512h); 
#line 6710
extern __m512i __cdecl _mm512_mask_cvts2ph_hf8(__m512i, __mmask64, __m512h, __m512h); 
#line 6711
extern __m512i __cdecl _mm512_maskz_cvts2ph_hf8(__mmask64, __m512h, __m512h); 
#line 6712
extern __m128i __cdecl _mm_cvtph_bf8(__m128h); 
#line 6713
extern __m128i __cdecl _mm_mask_cvtph_bf8(__m128i, __mmask8, __m128h); 
#line 6714
extern __m128i __cdecl _mm_maskz_cvtph_bf8(__mmask8, __m128h); 
#line 6715
extern __m128i __cdecl _mm256_cvtph_bf8(__m256h); 
#line 6716
extern __m128i __cdecl _mm256_mask_cvtph_bf8(__m128i, __mmask16, __m256h); 
#line 6717
extern __m128i __cdecl _mm256_maskz_cvtph_bf8(__mmask16, __m256h); 
#line 6718
extern __m256i __cdecl _mm512_cvtph_bf8(__m512h); 
#line 6719
extern __m256i __cdecl _mm512_mask_cvtph_bf8(__m256i, __mmask32, __m512h); 
#line 6720
extern __m256i __cdecl _mm512_maskz_cvtph_bf8(__mmask32, __m512h); 
#line 6721
extern __m128i __cdecl _mm_cvtsph_bf8(__m128h); 
#line 6722
extern __m128i __cdecl _mm_mask_cvtsph_bf8(__m128i, __mmask8, __m128h); 
#line 6723
extern __m128i __cdecl _mm_maskz_cvtsph_bf8(__mmask8, __m128h); 
#line 6724
extern __m128i __cdecl _mm256_cvtsph_bf8(__m256h); 
#line 6725
extern __m128i __cdecl _mm256_mask_cvtsph_bf8(__m128i, __mmask16, __m256h); 
#line 6726
extern __m128i __cdecl _mm256_maskz_cvtsph_bf8(__mmask16, __m256h); 
#line 6727
extern __m256i __cdecl _mm512_cvtsph_bf8(__m512h); 
#line 6728
extern __m256i __cdecl _mm512_mask_cvtsph_bf8(__m256i, __mmask32, __m512h); 
#line 6729
extern __m256i __cdecl _mm512_maskz_cvtsph_bf8(__mmask32, __m512h); 
#line 6730
extern __m128i __cdecl _mm_cvtph_hf8(__m128h); 
#line 6731
extern __m128i __cdecl _mm_mask_cvtph_hf8(__m128i, __mmask8, __m128h); 
#line 6732
extern __m128i __cdecl _mm_maskz_cvtph_hf8(__mmask8, __m128h); 
#line 6733
extern __m128i __cdecl _mm256_cvtph_hf8(__m256h); 
#line 6734
extern __m128i __cdecl _mm256_mask_cvtph_hf8(__m128i, __mmask16, __m256h); 
#line 6735
extern __m128i __cdecl _mm256_maskz_cvtph_hf8(__mmask16, __m256h); 
#line 6736
extern __m256i __cdecl _mm512_cvtph_hf8(__m512h); 
#line 6737
extern __m256i __cdecl _mm512_mask_cvtph_hf8(__m256i, __mmask32, __m512h); 
#line 6738
extern __m256i __cdecl _mm512_maskz_cvtph_hf8(__mmask32, __m512h); 
#line 6739
extern __m128i __cdecl _mm_cvtsph_hf8(__m128h); 
#line 6740
extern __m128i __cdecl _mm_mask_cvtsph_hf8(__m128i, __mmask8, __m128h); 
#line 6741
extern __m128i __cdecl _mm_maskz_cvtsph_hf8(__mmask8, __m128h); 
#line 6742
extern __m128i __cdecl _mm256_cvtsph_hf8(__m256h); 
#line 6743
extern __m128i __cdecl _mm256_mask_cvtsph_hf8(__m128i, __mmask16, __m256h); 
#line 6744
extern __m128i __cdecl _mm256_maskz_cvtsph_hf8(__mmask16, __m256h); 
#line 6745
extern __m256i __cdecl _mm512_cvtsph_hf8(__m512h); 
#line 6746
extern __m256i __cdecl _mm512_mask_cvtsph_hf8(__m256i, __mmask32, __m512h); 
#line 6747
extern __m256i __cdecl _mm512_maskz_cvtsph_hf8(__mmask32, __m512h); 
#line 6751
extern unsigned __cdecl _mm_cvttsss_u32(__m128); 
#line 6752
extern unsigned __cdecl _mm_cvtts_roundss_u32(__m128, const int); 
#line 6754
extern unsigned __int64 __cdecl _mm_cvttsss_u64(__m128); 
#line 6755
extern unsigned __int64 __cdecl _mm_cvtts_roundss_u64(__m128, const int); 
#line 6759 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"
extern int __cdecl _mm_cvttsss_i32(__m128); 
#line 6760
extern int __cdecl _mm_cvtts_roundss_i32(__m128, const int); 
#line 6762
extern __int64 __cdecl _mm_cvtts_roundss_i64(__m128, const int); 
#line 6763
extern __int64 __cdecl _mm_cvttsss_i64(__m128); 
#line 6767 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"
extern unsigned __cdecl _mm_cvttsds_u32(__m128d); 
#line 6768
extern unsigned __cdecl _mm_cvtts_roundsd_u32(__m128d, const int); 
#line 6770
extern unsigned __int64 __cdecl _mm_cvttsds_u64(__m128d); 
#line 6771
extern unsigned __int64 __cdecl _mm_cvtts_roundsd_u64(__m128d, const int); 
#line 6775 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"
extern int __cdecl _mm_cvttsds_i32(__m128d); 
#line 6776
extern int __cdecl _mm_cvtts_roundsd_i32(__m128d, const int); 
#line 6778
extern __int64 __cdecl _mm_cvtts_roundsd_i64(__m128d, const int); 
#line 6779
extern __int64 __cdecl _mm_cvttsds_i64(__m128d); 
#line 6783 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"
extern __m128i __cdecl _mm_cvttsps_epu64(__m128); 
#line 6784
extern __m128i __cdecl _mm_mask_cvttsps_epu64(__m128i, __mmask8, __m128); 
#line 6785
extern __m128i __cdecl _mm_maskz_cvttsps_epu64(__mmask8, __m128); 
#line 6786
extern __m256i __cdecl _mm256_cvttsps_epu64(__m128); 
#line 6787
extern __m256i __cdecl _mm256_mask_cvttsps_epu64(__m256i, __mmask8, __m128); 
#line 6788
extern __m256i __cdecl _mm256_maskz_cvttsps_epu64(__mmask8, __m128); 
#line 6789
extern __m512i __cdecl _mm512_cvttsps_epu64(__m256); 
#line 6790
extern __m512i __cdecl _mm512_mask_cvttsps_epu64(__m512i, __mmask8, __m256); 
#line 6791
extern __m512i __cdecl _mm512_maskz_cvttsps_epu64(__mmask8, __m256); 
#line 6792
extern __m512i __cdecl _mm512_cvtts_roundps_epu64(__m256, const int); 
#line 6793
extern __m512i __cdecl _mm512_mask_cvtts_roundps_epu64(__m512i, __mmask8, __m256, const int); 
#line 6794
extern __m512i __cdecl _mm512_maskz_cvtts_roundps_epu64(__mmask8, __m256, const int); 
#line 6797
extern __m128i __cdecl _mm_cvttsps_epu32(__m128); 
#line 6798
extern __m128i __cdecl _mm_mask_cvttsps_epu32(__m128i, __mmask8, __m128); 
#line 6799
extern __m128i __cdecl _mm_maskz_cvttsps_epu32(__mmask8, __m128); 
#line 6800
extern __m256i __cdecl _mm256_cvttsps_epu32(__m256); 
#line 6801
extern __m256i __cdecl _mm256_mask_cvttsps_epu32(__m256i, __mmask8, __m256); 
#line 6802
extern __m256i __cdecl _mm256_maskz_cvttsps_epu32(__mmask8, __m256); 
#line 6803
extern __m512i __cdecl _mm512_cvttsps_epu32(__m512); 
#line 6804
extern __m512i __cdecl _mm512_mask_cvttsps_epu32(__m512i, __mmask16, __m512); 
#line 6805
extern __m512i __cdecl _mm512_maskz_cvttsps_epu32(__mmask16, __m512); 
#line 6806
extern __m512i __cdecl _mm512_cvtts_roundps_epu32(__m512, const int); 
#line 6807
extern __m512i __cdecl _mm512_mask_cvtts_roundps_epu32(__m512i, __mmask16, __m512, const int); 
#line 6808
extern __m512i __cdecl _mm512_maskz_cvtts_roundps_epu32(__mmask16, __m512, const int); 
#line 6811
extern __m128i __cdecl _mm_cvttsps_epi64(__m128); 
#line 6812
extern __m128i __cdecl _mm_mask_cvttsps_epi64(__m128i, __mmask8, __m128); 
#line 6813
extern __m128i __cdecl _mm_maskz_cvttsps_epi64(__mmask8, __m128); 
#line 6814
extern __m256i __cdecl _mm256_cvttsps_epi64(__m128); 
#line 6815
extern __m256i __cdecl _mm256_mask_cvttsps_epi64(__m256i, __mmask8, __m128); 
#line 6816
extern __m256i __cdecl _mm256_maskz_cvttsps_epi64(__mmask8, __m128); 
#line 6817
extern __m512i __cdecl _mm512_cvttsps_epi64(__m256); 
#line 6818
extern __m512i __cdecl _mm512_mask_cvttsps_epi64(__m512i, __mmask8, __m256); 
#line 6819
extern __m512i __cdecl _mm512_maskz_cvttsps_epi64(__mmask8, __m256); 
#line 6820
extern __m512i __cdecl _mm512_cvtts_roundps_epi64(__m256, const int); 
#line 6821
extern __m512i __cdecl _mm512_mask_cvtts_roundps_epi64(__m512i, __mmask8, __m256, const int); 
#line 6822
extern __m512i __cdecl _mm512_maskz_cvtts_roundps_epi64(__mmask8, __m256, const int); 
#line 6825
extern __m128i __cdecl _mm_cvttsps_epi32(__m128); 
#line 6826
extern __m128i __cdecl _mm_mask_cvttsps_epi32(__m128i, __mmask8, __m128); 
#line 6827
extern __m128i __cdecl _mm_maskz_cvttsps_epi32(__mmask8, __m128); 
#line 6828
extern __m256i __cdecl _mm256_cvttsps_epi32(__m256); 
#line 6829
extern __m256i __cdecl _mm256_mask_cvttsps_epi32(__m256i, __mmask8, __m256); 
#line 6830
extern __m256i __cdecl _mm256_maskz_cvttsps_epi32(__mmask8, __m256); 
#line 6831
extern __m512i __cdecl _mm512_cvttsps_epi32(__m512); 
#line 6832
extern __m512i __cdecl _mm512_mask_cvttsps_epi32(__m512i, __mmask16, __m512); 
#line 6833
extern __m512i __cdecl _mm512_maskz_cvttsps_epi32(__mmask16, __m512); 
#line 6834
extern __m512i __cdecl _mm512_cvtts_roundps_epi32(__m512, const int); 
#line 6835
extern __m512i __cdecl _mm512_mask_cvtts_roundps_epi32(__m512i, __mmask16, __m512, const int); 
#line 6836
extern __m512i __cdecl _mm512_maskz_cvtts_roundps_epi32(__mmask16, __m512, const int); 
#line 6839
extern __m128i __cdecl _mm_cvttspd_epu64(__m128d); 
#line 6840
extern __m128i __cdecl _mm_mask_cvttspd_epu64(__m128i, __mmask8, __m128d); 
#line 6841
extern __m128i __cdecl _mm_maskz_cvttspd_epu64(__mmask8, __m128d); 
#line 6842
extern __m256i __cdecl _mm256_cvttspd_epu64(__m256d); 
#line 6843
extern __m256i __cdecl _mm256_mask_cvttspd_epu64(__m256i, __mmask8, __m256d); 
#line 6844
extern __m256i __cdecl _mm256_maskz_cvttspd_epu64(__mmask8, __m256d); 
#line 6845
extern __m512i __cdecl _mm512_cvttspd_epu64(__m512d); 
#line 6846
extern __m512i __cdecl _mm512_mask_cvttspd_epu64(__m512i, __mmask8, __m512d); 
#line 6847
extern __m512i __cdecl _mm512_maskz_cvttspd_epu64(__mmask8, __m512d); 
#line 6848
extern __m512i __cdecl _mm512_cvtts_roundpd_epu64(__m512d, const int); 
#line 6849
extern __m512i __cdecl _mm512_mask_cvtts_roundpd_epu64(__m512i, __mmask8, __m512d, const int); 
#line 6850
extern __m512i __cdecl _mm512_maskz_cvtts_roundpd_epu64(__mmask8, __m512d, const int); 
#line 6853
extern __m128i __cdecl _mm_cvttspd_epu32(__m128d); 
#line 6854
extern __m128i __cdecl _mm_mask_cvttspd_epu32(__m128i, __mmask8, __m128d); 
#line 6855
extern __m128i __cdecl _mm_maskz_cvttspd_epu32(__mmask8, __m128d); 
#line 6856
extern __m128i __cdecl _mm256_cvttspd_epu32(__m256d); 
#line 6857
extern __m128i __cdecl _mm256_mask_cvttspd_epu32(__m128i, __mmask8, __m256d); 
#line 6858
extern __m128i __cdecl _mm256_maskz_cvttspd_epu32(__mmask8, __m256d); 
#line 6859
extern __m256i __cdecl _mm512_cvttspd_epu32(__m512d); 
#line 6860
extern __m256i __cdecl _mm512_mask_cvttspd_epu32(__m256i, __mmask8, __m512d); 
#line 6861
extern __m256i __cdecl _mm512_maskz_cvttspd_epu32(__mmask8, __m512d); 
#line 6862
extern __m256i __cdecl _mm512_cvtts_roundpd_epu32(__m512d, const int); 
#line 6863
extern __m256i __cdecl _mm512_mask_cvtts_roundpd_epu32(__m256i, __mmask8, __m512d, const int); 
#line 6864
extern __m256i __cdecl _mm512_maskz_cvtts_roundpd_epu32(__mmask8, __m512d, const int); 
#line 6867
extern __m128i __cdecl _mm_cvttspd_epi64(__m128d); 
#line 6868
extern __m128i __cdecl _mm_mask_cvttspd_epi64(__m128i, __mmask8, __m128d); 
#line 6869
extern __m128i __cdecl _mm_maskz_cvttspd_epi64(__mmask8, __m128d); 
#line 6870
extern __m256i __cdecl _mm256_cvttspd_epi64(__m256d); 
#line 6871
extern __m256i __cdecl _mm256_mask_cvttspd_epi64(__m256i, __mmask8, __m256d); 
#line 6872
extern __m256i __cdecl _mm256_maskz_cvttspd_epi64(__mmask8, __m256d); 
#line 6873
extern __m512i __cdecl _mm512_cvttspd_epi64(__m512d); 
#line 6874
extern __m512i __cdecl _mm512_mask_cvttspd_epi64(__m512i, __mmask8, __m512d); 
#line 6875
extern __m512i __cdecl _mm512_maskz_cvttspd_epi64(__mmask8, __m512d); 
#line 6876
extern __m512i __cdecl _mm512_cvtts_roundpd_epi64(__m512d, const int); 
#line 6877
extern __m512i __cdecl _mm512_mask_cvtts_roundpd_epi64(__m512i, __mmask8, __m512d, const int); 
#line 6878
extern __m512i __cdecl _mm512_maskz_cvtts_roundpd_epi64(__mmask8, __m512d, const int); 
#line 6881
extern __m128i __cdecl _mm_cvttspd_epi32(__m128d); 
#line 6882
extern __m128i __cdecl _mm_mask_cvttspd_epi32(__m128i, __mmask8, __m128d); 
#line 6883
extern __m128i __cdecl _mm_maskz_cvttspd_epi32(__mmask8, __m128d); 
#line 6884
extern __m128i __cdecl _mm256_cvttspd_epi32(__m256d); 
#line 6885
extern __m128i __cdecl _mm256_mask_cvttspd_epi32(__m128i, __mmask8, __m256d); 
#line 6886
extern __m128i __cdecl _mm256_maskz_cvttspd_epi32(__mmask8, __m256d); 
#line 6887
extern __m256i __cdecl _mm512_cvttspd_epi32(__m512d); 
#line 6888
extern __m256i __cdecl _mm512_mask_cvttspd_epi32(__m256i, __mmask8, __m512d); 
#line 6889
extern __m256i __cdecl _mm512_maskz_cvttspd_epi32(__mmask8, __m512d); 
#line 6890
extern __m256i __cdecl _mm512_cvtts_roundpd_epi32(__m512d, const int); 
#line 6891
extern __m256i __cdecl _mm512_mask_cvtts_roundpd_epi32(__m256i, __mmask8, __m512d, const int); 
#line 6892
extern __m256i __cdecl _mm512_maskz_cvtts_roundpd_epi32(__mmask8, __m512d, const int); 
#line 6895
extern __m128i __cdecl _mm_ipcvtbf16_epi16(__m128bh); 
#line 6896
extern __m128i __cdecl _mm_mask_ipcvtbf16_epi16(__m128i, __mmask8, __m128bh); 
#line 6897
extern __m128i __cdecl _mm_maskz_ipcvtbf16_epi16(__mmask8, __m128bh); 
#line 6898
extern __m256i __cdecl _mm256_ipcvtbf16_epi16(__m256bh); 
#line 6899
extern __m256i __cdecl _mm256_mask_ipcvtbf16_epi16(__m256i, __mmask16, __m256bh); 
#line 6900
extern __m256i __cdecl _mm256_maskz_ipcvtbf16_epi16(__mmask16, __m256bh); 
#line 6901
extern __m512i __cdecl _mm512_ipcvtbf16_epi16(__m512bh); 
#line 6902
extern __m512i __cdecl _mm512_mask_ipcvtbf16_epi16(__m512i, __mmask32, __m512bh); 
#line 6903
extern __m512i __cdecl _mm512_maskz_ipcvtbf16_epi16(__mmask32, __m512bh); 
#line 6906
extern __m128i __cdecl _mm_ipcvttbf16_epi16(__m128bh); 
#line 6907
extern __m128i __cdecl _mm_mask_ipcvttbf16_epi16(__m128i, __mmask8, __m128bh); 
#line 6908
extern __m128i __cdecl _mm_maskz_ipcvttbf16_epi16(__mmask8, __m128bh); 
#line 6909
extern __m256i __cdecl _mm256_ipcvttbf16_epi16(__m256bh); 
#line 6910
extern __m256i __cdecl _mm256_mask_ipcvttbf16_epi16(__m256i, __mmask16, __m256bh); 
#line 6911
extern __m256i __cdecl _mm256_maskz_ipcvttbf16_epi16(__mmask16, __m256bh); 
#line 6912
extern __m512i __cdecl _mm512_ipcvttbf16_epi16(__m512bh); 
#line 6913
extern __m512i __cdecl _mm512_mask_ipcvttbf16_epi16(__m512i, __mmask32, __m512bh); 
#line 6914
extern __m512i __cdecl _mm512_maskz_ipcvttbf16_epi16(__mmask32, __m512bh); 
#line 6917
extern __m128i __cdecl _mm_ipcvtbf16_epu16(__m128bh); 
#line 6918
extern __m128i __cdecl _mm_mask_ipcvtbf16_epu16(__m128i, __mmask8, __m128bh); 
#line 6919
extern __m128i __cdecl _mm_maskz_ipcvtbf16_epu16(__mmask8, __m128bh); 
#line 6920
extern __m256i __cdecl _mm256_ipcvtbf16_epu16(__m256bh); 
#line 6921
extern __m256i __cdecl _mm256_mask_ipcvtbf16_epu16(__m256i, __mmask16, __m256bh); 
#line 6922
extern __m256i __cdecl _mm256_maskz_ipcvtbf16_epu16(__mmask16, __m256bh); 
#line 6923
extern __m512i __cdecl _mm512_ipcvtbf16_epu16(__m512bh); 
#line 6924
extern __m512i __cdecl _mm512_mask_ipcvtbf16_epu16(__m512i, __mmask32, __m512bh); 
#line 6925
extern __m512i __cdecl _mm512_maskz_ipcvtbf16_epu16(__mmask32, __m512bh); 
#line 6928
extern __m128i __cdecl _mm_ipcvttbf16_epu16(__m128bh); 
#line 6929
extern __m128i __cdecl _mm_mask_ipcvttbf16_epu16(__m128i, __mmask8, __m128bh); 
#line 6930
extern __m128i __cdecl _mm_maskz_ipcvttbf16_epu16(__mmask8, __m128bh); 
#line 6931
extern __m256i __cdecl _mm256_ipcvttbf16_epu16(__m256bh); 
#line 6932
extern __m256i __cdecl _mm256_mask_ipcvttbf16_epu16(__m256i, __mmask16, __m256bh); 
#line 6933
extern __m256i __cdecl _mm256_maskz_ipcvttbf16_epu16(__mmask16, __m256bh); 
#line 6934
extern __m512i __cdecl _mm512_ipcvttbf16_epu16(__m512bh); 
#line 6935
extern __m512i __cdecl _mm512_mask_ipcvttbf16_epu16(__m512i, __mmask32, __m512bh); 
#line 6936
extern __m512i __cdecl _mm512_maskz_ipcvttbf16_epu16(__mmask32, __m512bh); 
#line 6939
extern __m128i __cdecl _mm_ipcvtph_epi16(__m128h); 
#line 6940
extern __m128i __cdecl _mm_mask_ipcvtph_epi16(__m128i, __mmask8, __m128h); 
#line 6941
extern __m128i __cdecl _mm_maskz_ipcvtph_epi16(__mmask8, __m128h); 
#line 6942
extern __m256i __cdecl _mm256_ipcvtph_epi16(__m256h); 
#line 6943
extern __m256i __cdecl _mm256_mask_ipcvtph_epi16(__m256i, __mmask16, __m256h); 
#line 6944
extern __m256i __cdecl _mm256_maskz_ipcvtph_epi16(__mmask16, __m256h); 
#line 6945
extern __m512i __cdecl _mm512_ipcvtph_epi16(__m512h); 
#line 6946
extern __m512i __cdecl _mm512_mask_ipcvtph_epi16(__m512i, __mmask32, __m512h); 
#line 6947
extern __m512i __cdecl _mm512_maskz_ipcvtph_epi16(__mmask32, __m512h); 
#line 6948
extern __m512i __cdecl _mm512_ipcvt_roundph_epi16(__m512h, const int); 
#line 6949
extern __m512i __cdecl _mm512_mask_ipcvt_roundph_epi16(__m512i, __mmask32, __m512h, const int); 
#line 6950
extern __m512i __cdecl _mm512_maskz_ipcvt_roundph_epi16(__mmask32, __m512h, const int); 
#line 6953
extern __m128i __cdecl _mm_ipcvttph_epi16(__m128h); 
#line 6954
extern __m128i __cdecl _mm_mask_ipcvttph_epi16(__m128i, __mmask8, __m128h); 
#line 6955
extern __m128i __cdecl _mm_maskz_ipcvttph_epi16(__mmask8, __m128h); 
#line 6956
extern __m256i __cdecl _mm256_ipcvttph_epi16(__m256h); 
#line 6957
extern __m256i __cdecl _mm256_mask_ipcvttph_epi16(__m256i, __mmask16, __m256h); 
#line 6958
extern __m256i __cdecl _mm256_maskz_ipcvttph_epi16(__mmask16, __m256h); 
#line 6959
extern __m512i __cdecl _mm512_ipcvttph_epi16(__m512h); 
#line 6960
extern __m512i __cdecl _mm512_mask_ipcvttph_epi16(__m512i, __mmask32, __m512h); 
#line 6961
extern __m512i __cdecl _mm512_maskz_ipcvttph_epi16(__mmask32, __m512h); 
#line 6962
extern __m512i __cdecl _mm512_ipcvtt_roundph_epi16(__m512h, const int); 
#line 6963
extern __m512i __cdecl _mm512_mask_ipcvtt_roundph_epi16(__m512i, __mmask32, __m512h, const int); 
#line 6964
extern __m512i __cdecl _mm512_maskz_ipcvtt_roundph_epi16(__mmask32, __m512h, const int); 
#line 6967
extern __m128i __cdecl _mm_ipcvtph_epu16(__m128h); 
#line 6968
extern __m128i __cdecl _mm_mask_ipcvtph_epu16(__m128i, __mmask8, __m128h); 
#line 6969
extern __m128i __cdecl _mm_maskz_ipcvtph_epu16(__mmask8, __m128h); 
#line 6970
extern __m256i __cdecl _mm256_ipcvtph_epu16(__m256h); 
#line 6971
extern __m256i __cdecl _mm256_mask_ipcvtph_epu16(__m256i, __mmask16, __m256h); 
#line 6972
extern __m256i __cdecl _mm256_maskz_ipcvtph_epu16(__mmask16, __m256h); 
#line 6973
extern __m512i __cdecl _mm512_ipcvtph_epu16(__m512h); 
#line 6974
extern __m512i __cdecl _mm512_mask_ipcvtph_epu16(__m512i, __mmask32, __m512h); 
#line 6975
extern __m512i __cdecl _mm512_maskz_ipcvtph_epu16(__mmask32, __m512h); 
#line 6976
extern __m512i __cdecl _mm512_ipcvt_roundph_epu16(__m512h, const int); 
#line 6977
extern __m512i __cdecl _mm512_mask_ipcvt_roundph_epu16(__m512i, __mmask32, __m512h, const int); 
#line 6978
extern __m512i __cdecl _mm512_maskz_ipcvt_roundph_epu16(__mmask32, __m512h, const int); 
#line 6981
extern __m128i __cdecl _mm_ipcvttph_epu16(__m128h); 
#line 6982
extern __m128i __cdecl _mm_mask_ipcvttph_epu16(__m128i, __mmask8, __m128h); 
#line 6983
extern __m128i __cdecl _mm_maskz_ipcvttph_epu16(__mmask8, __m128h); 
#line 6984
extern __m256i __cdecl _mm256_ipcvttph_epu16(__m256h); 
#line 6985
extern __m256i __cdecl _mm256_mask_ipcvttph_epu16(__m256i, __mmask16, __m256h); 
#line 6986
extern __m256i __cdecl _mm256_maskz_ipcvttph_epu16(__mmask16, __m256h); 
#line 6987
extern __m512i __cdecl _mm512_ipcvttph_epu16(__m512h); 
#line 6988
extern __m512i __cdecl _mm512_mask_ipcvttph_epu16(__m512i, __mmask32, __m512h); 
#line 6989
extern __m512i __cdecl _mm512_maskz_ipcvttph_epu16(__mmask32, __m512h); 
#line 6990
extern __m512i __cdecl _mm512_ipcvtt_roundph_epu16(__m512h, const int); 
#line 6991
extern __m512i __cdecl _mm512_mask_ipcvtt_roundph_epu16(__m512i, __mmask32, __m512h, const int); 
#line 6992
extern __m512i __cdecl _mm512_maskz_ipcvtt_roundph_epu16(__mmask32, __m512h, const int); 
#line 6995
extern __m128i __cdecl _mm_ipcvtps_epi32(__m128); 
#line 6996
extern __m128i __cdecl _mm_mask_ipcvtps_epi32(__m128i, __mmask8, __m128); 
#line 6997
extern __m128i __cdecl _mm_maskz_ipcvtps_epi32(__mmask8, __m128); 
#line 6998
extern __m256i __cdecl _mm256_ipcvtps_epi32(__m256); 
#line 6999
extern __m256i __cdecl _mm256_mask_ipcvtps_epi32(__m256i, __mmask8, __m256); 
#line 7000
extern __m256i __cdecl _mm256_maskz_ipcvtps_epi32(__mmask8, __m256); 
#line 7001
extern __m512i __cdecl _mm512_ipcvtps_epi32(__m512); 
#line 7002
extern __m512i __cdecl _mm512_mask_ipcvtps_epi32(__m512i, __mmask16, __m512); 
#line 7003
extern __m512i __cdecl _mm512_maskz_ipcvtps_epi32(__mmask16, __m512); 
#line 7004
extern __m512i __cdecl _mm512_ipcvt_roundps_epi32(__m512, const int); 
#line 7005
extern __m512i __cdecl _mm512_mask_ipcvt_roundps_epi32(__m512i, __mmask16, __m512, const int); 
#line 7006
extern __m512i __cdecl _mm512_maskz_ipcvt_roundps_epi32(__mmask16, __m512, const int); 
#line 7009
extern __m128i __cdecl _mm_ipcvttps_epi32(__m128); 
#line 7010
extern __m128i __cdecl _mm_mask_ipcvttps_epi32(__m128i, __mmask8, __m128); 
#line 7011
extern __m128i __cdecl _mm_maskz_ipcvttps_epi32(__mmask8, __m128); 
#line 7012
extern __m256i __cdecl _mm256_ipcvttps_epi32(__m256); 
#line 7013
extern __m256i __cdecl _mm256_mask_ipcvttps_epi32(__m256i, __mmask8, __m256); 
#line 7014
extern __m256i __cdecl _mm256_maskz_ipcvttps_epi32(__mmask8, __m256); 
#line 7015
extern __m512i __cdecl _mm512_ipcvttps_epi32(__m512); 
#line 7016
extern __m512i __cdecl _mm512_mask_ipcvttps_epi32(__m512i, __mmask16, __m512); 
#line 7017
extern __m512i __cdecl _mm512_maskz_ipcvttps_epi32(__mmask16, __m512); 
#line 7018
extern __m512i __cdecl _mm512_ipcvtt_roundps_epi32(__m512, const int); 
#line 7019
extern __m512i __cdecl _mm512_mask_ipcvtt_roundps_epi32(__m512i, __mmask16, __m512, const int); 
#line 7020
extern __m512i __cdecl _mm512_maskz_ipcvtt_roundps_epi32(__mmask16, __m512, const int); 
#line 7023
extern __m128i __cdecl _mm_ipcvtps_epu32(__m128); 
#line 7024
extern __m128i __cdecl _mm_mask_ipcvtps_epu32(__m128i, __mmask8, __m128); 
#line 7025
extern __m128i __cdecl _mm_maskz_ipcvtps_epu32(__mmask8, __m128); 
#line 7026
extern __m256i __cdecl _mm256_ipcvtps_epu32(__m256); 
#line 7027
extern __m256i __cdecl _mm256_mask_ipcvtps_epu32(__m256i, __mmask8, __m256); 
#line 7028
extern __m256i __cdecl _mm256_maskz_ipcvtps_epu32(__mmask8, __m256); 
#line 7029
extern __m512i __cdecl _mm512_ipcvtps_epu32(__m512); 
#line 7030
extern __m512i __cdecl _mm512_mask_ipcvtps_epu32(__m512i, __mmask16, __m512); 
#line 7031
extern __m512i __cdecl _mm512_maskz_ipcvtps_epu32(__mmask16, __m512); 
#line 7032
extern __m512i __cdecl _mm512_ipcvt_roundps_epu32(__m512, const int); 
#line 7033
extern __m512i __cdecl _mm512_mask_ipcvt_roundps_epu32(__m512i, __mmask16, __m512, const int); 
#line 7034
extern __m512i __cdecl _mm512_maskz_ipcvt_roundps_epu32(__mmask16, __m512, const int); 
#line 7037
extern __m128i __cdecl _mm_ipcvttps_epu32(__m128); 
#line 7038
extern __m128i __cdecl _mm_mask_ipcvttps_epu32(__m128i, __mmask8, __m128); 
#line 7039
extern __m128i __cdecl _mm_maskz_ipcvttps_epu32(__mmask8, __m128); 
#line 7040
extern __m256i __cdecl _mm256_ipcvttps_epu32(__m256); 
#line 7041
extern __m256i __cdecl _mm256_mask_ipcvttps_epu32(__m256i, __mmask8, __m256); 
#line 7042
extern __m256i __cdecl _mm256_maskz_ipcvttps_epu32(__mmask8, __m256); 
#line 7043
extern __m512i __cdecl _mm512_ipcvttps_epu32(__m512); 
#line 7044
extern __m512i __cdecl _mm512_mask_ipcvttps_epu32(__m512i, __mmask16, __m512); 
#line 7045
extern __m512i __cdecl _mm512_maskz_ipcvttps_epu32(__mmask16, __m512); 
#line 7046
extern __m512i __cdecl _mm512_ipcvtt_roundps_epu32(__m512, const int); 
#line 7047
extern __m512i __cdecl _mm512_mask_ipcvtt_roundps_epu32(__m512i, __mmask16, __m512, const int); 
#line 7048
extern __m512i __cdecl _mm512_maskz_ipcvtt_roundps_epu32(__mmask16, __m512, const int); 
#line 7052
extern __m128bh __cdecl _mm_minmax_pbh(__m128bh, __m128bh, const int); 
#line 7053
extern __m128bh __cdecl _mm_mask_minmax_pbh(__m128bh, __mmask8, __m128bh, __m128bh, const int); 
#line 7054
extern __m128bh __cdecl _mm_maskz_minmax_pbh(__mmask8, __m128bh, __m128bh, const int); 
#line 7055
extern __m256bh __cdecl _mm256_minmax_pbh(__m256bh, __m256bh, const int); 
#line 7056
extern __m256bh __cdecl _mm256_mask_minmax_pbh(__m256bh, __mmask16, __m256bh, __m256bh, const int); 
#line 7057
extern __m256bh __cdecl _mm256_maskz_minmax_pbh(__mmask16, __m256bh, __m256bh, const int); 
#line 7058
extern __m512bh __cdecl _mm512_minmax_pbh(__m512bh, __m512bh, const int); 
#line 7059
extern __m512bh __cdecl _mm512_mask_minmax_pbh(__m512bh, __mmask32, __m512bh, __m512bh, const int); 
#line 7060
extern __m512bh __cdecl _mm512_maskz_minmax_pbh(__mmask32, __m512bh, __m512bh, const int); 
#line 7063
extern __m128d __cdecl _mm_minmax_pd(__m128d, __m128d, const int); 
#line 7064
extern __m128d __cdecl _mm_mask_minmax_pd(__m128d, __mmask8, __m128d, __m128d, const int); 
#line 7065
extern __m128d __cdecl _mm_maskz_minmax_pd(__mmask8, __m128d, __m128d, const int); 
#line 7066
extern __m256d __cdecl _mm256_minmax_pd(__m256d, __m256d, const int); 
#line 7067
extern __m256d __cdecl _mm256_mask_minmax_pd(__m256d, __mmask8, __m256d, __m256d, const int); 
#line 7068
extern __m256d __cdecl _mm256_maskz_minmax_pd(__mmask8, __m256d, __m256d, const int); 
#line 7069
extern __m512d __cdecl _mm512_minmax_pd(__m512d, __m512d, const int); 
#line 7070
extern __m512d __cdecl _mm512_mask_minmax_pd(__m512d, __mmask8, __m512d, __m512d, const int); 
#line 7071
extern __m512d __cdecl _mm512_maskz_minmax_pd(__mmask8, __m512d, __m512d, const int); 
#line 7072
extern __m512d __cdecl _mm512_minmax_round_pd(__m512d, __m512d, const int, const int); 
#line 7073
extern __m512d __cdecl _mm512_mask_minmax_round_pd(__m512d, __mmask8, __m512d, __m512d, const int, const int); 
#line 7074
extern __m512d __cdecl _mm512_maskz_minmax_round_pd(__mmask8, __m512d, __m512d, const int, const int); 
#line 7077
extern __m128 __cdecl _mm_minmax_ps(__m128, __m128, const int); 
#line 7078
extern __m128 __cdecl _mm_mask_minmax_ps(__m128, __mmask8, __m128, __m128, const int); 
#line 7079
extern __m128 __cdecl _mm_maskz_minmax_ps(__mmask8, __m128, __m128, const int); 
#line 7080
extern __m256 __cdecl _mm256_minmax_ps(__m256, __m256, const int); 
#line 7081
extern __m256 __cdecl _mm256_mask_minmax_ps(__m256, __mmask8, __m256, __m256, const int); 
#line 7082
extern __m256 __cdecl _mm256_maskz_minmax_ps(__mmask8, __m256, __m256, const int); 
#line 7083
extern __m512 __cdecl _mm512_minmax_ps(__m512, __m512, const int); 
#line 7084
extern __m512 __cdecl _mm512_mask_minmax_ps(__m512, __mmask16, __m512, __m512, const int); 
#line 7085
extern __m512 __cdecl _mm512_maskz_minmax_ps(__mmask16, __m512, __m512, const int); 
#line 7086
extern __m512 __cdecl _mm512_minmax_round_ps(__m512, __m512, const int, const int); 
#line 7087
extern __m512 __cdecl _mm512_mask_minmax_round_ps(__m512, __mmask16, __m512, __m512, const int, const int); 
#line 7088
extern __m512 __cdecl _mm512_maskz_minmax_round_ps(__mmask16, __m512, __m512, const int, const int); 
#line 7091
extern __m128h __cdecl _mm_minmax_ph(__m128h, __m128h, const int); 
#line 7092
extern __m128h __cdecl _mm_mask_minmax_ph(__m128h, __mmask8, __m128h, __m128h, const int); 
#line 7093
extern __m128h __cdecl _mm_maskz_minmax_ph(__mmask8, __m128h, __m128h, const int); 
#line 7094
extern __m256h __cdecl _mm256_minmax_ph(__m256h, __m256h, const int); 
#line 7095
extern __m256h __cdecl _mm256_mask_minmax_ph(__m256h, __mmask16, __m256h, __m256h, const int); 
#line 7096
extern __m256h __cdecl _mm256_maskz_minmax_ph(__mmask16, __m256h, __m256h, const int); 
#line 7097
extern __m512h __cdecl _mm512_minmax_ph(__m512h, __m512h, const int); 
#line 7098
extern __m512h __cdecl _mm512_mask_minmax_ph(__m512h, __mmask32, __m512h, __m512h, const int); 
#line 7099
extern __m512h __cdecl _mm512_maskz_minmax_ph(__mmask32, __m512h, __m512h, const int); 
#line 7100
extern __m512h __cdecl _mm512_minmax_round_ph(__m512h, __m512h, const int, const int); 
#line 7101
extern __m512h __cdecl _mm512_mask_minmax_round_ph(__m512h, __mmask32, __m512h, __m512h, const int, const int); 
#line 7102
extern __m512h __cdecl _mm512_maskz_minmax_round_ph(__mmask32, __m512h, __m512h, const int, const int); 
#line 7105
extern __m128d __cdecl _mm_minmax_sd(__m128d, __m128d, const int); 
#line 7106
extern __m128d __cdecl _mm_mask_minmax_sd(__m128d, __mmask8, __m128d, __m128d, const int); 
#line 7107
extern __m128d __cdecl _mm_maskz_minmax_sd(__mmask8, __m128d, __m128d, const int); 
#line 7108
extern __m128d __cdecl _mm_minmax_round_sd(__m128d, __m128d, const int, const int); 
#line 7109
extern __m128d __cdecl _mm_mask_minmax_round_sd(__m128d, __mmask8, __m128d, __m128d, const int, const int); 
#line 7110
extern __m128d __cdecl _mm_maskz_minmax_round_sd(__mmask8, __m128d, __m128d, const int, const int); 
#line 7111
extern __m128h __cdecl _mm_minmax_sh(__m128h, __m128h, const int); 
#line 7112
extern __m128h __cdecl _mm_mask_minmax_sh(__m128h, __mmask8, __m128h, __m128h, const int); 
#line 7113
extern __m128h __cdecl _mm_maskz_minmax_sh(__mmask8, __m128h, __m128h, const int); 
#line 7114
extern __m128h __cdecl _mm_minmax_round_sh(__m128h, __m128h, const int, const int); 
#line 7115
extern __m128h __cdecl _mm_mask_minmax_round_sh(__m128h, __mmask8, __m128h, __m128h, const int, const int); 
#line 7116
extern __m128h __cdecl _mm_maskz_minmax_round_sh(__mmask8, __m128h, __m128h, const int, const int); 
#line 7117
extern __m128 __cdecl _mm_minmax_ss(__m128, __m128, const int); 
#line 7118
extern __m128 __cdecl _mm_mask_minmax_ss(__m128, __mmask8, __m128, __m128, const int); 
#line 7119
extern __m128 __cdecl _mm_maskz_minmax_ss(__mmask8, __m128, __m128, const int); 
#line 7120
extern __m128 __cdecl _mm_minmax_round_ss(__m128, __m128, const int, const int); 
#line 7121
extern __m128 __cdecl _mm_mask_minmax_round_ss(__m128, __mmask8, __m128, __m128, const int, const int); 
#line 7122
extern __m128 __cdecl _mm_maskz_minmax_round_ss(__mmask8, __m128, __m128, const int, const int); 
#line 7126
extern __m128i __cdecl _mm_move_epi32(__m128i); 
#line 7127
extern __m128i __cdecl _mm_move_epi16(__m128i); 
#line 7131
extern int __cdecl _mm_comx_sd(__m128d, __m128d, const int); 
#line 7132
extern int __cdecl _mm_comx_round_sd(__m128d, __m128d, const int, const int); 
#line 7133
extern int __cdecl _mm_comx_sh(__m128h, __m128h, const int); 
#line 7134
extern int __cdecl _mm_comx_round_sh(__m128h, __m128h, const int, const int); 
#line 7135
extern int __cdecl _mm_comx_ss(__m128, __m128, const int); 
#line 7136
extern int __cdecl _mm_comx_round_ss(__m128, __m128, const int, const int); 
#line 7137
extern int __cdecl _mm_ucomx_sd(__m128d, __m128d, const int); 
#line 7138
extern int __cdecl _mm_ucomx_round_sd(__m128d, __m128d, const int, const int); 
#line 7139
extern int __cdecl _mm_ucomx_sh(__m128h, __m128h, const int); 
#line 7140
extern int __cdecl _mm_ucomx_round_sh(__m128h, __m128h, const int, const int); 
#line 7141
extern int __cdecl _mm_ucomx_ss(__m128, __m128, const int); 
#line 7142
extern int __cdecl _mm_ucomx_round_ss(__m128, __m128, const int, const int); 
#line 7187
}
#line 2541 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern "C" {
#line 2547 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern __m128i __cdecl _mm_madd52hi_avx_epu64(__m128i, __m128i, __m128i); 
#line 2548
extern __m256i __cdecl _mm256_madd52hi_avx_epu64(__m256i, __m256i, __m256i); 
#line 2549
extern __m128i __cdecl _mm_madd52lo_avx_epu64(__m128i, __m128i, __m128i); 
#line 2550
extern __m256i __cdecl _mm256_madd52lo_avx_epu64(__m256i, __m256i, __m256i); 
#line 2553
extern __m128 __cdecl _mm_bcstnebf16_ps(const __bfloat16 *); 
#line 2554
extern __m256 __cdecl _mm256_bcstnebf16_ps(const __bfloat16 *); 
#line 2555
extern __m128 __cdecl _mm_bcstnesh_ps(const void *); 
#line 2556
extern __m256 __cdecl _mm256_bcstnesh_ps(const void *); 
#line 2557
extern __m128 __cdecl _mm_cvtneebf16_ps(const __m128bh *); 
#line 2558
extern __m256 __cdecl _mm256_cvtneebf16_ps(const __m256bh *); 
#line 2559
extern __m128 __cdecl _mm_cvtneeph_ps(const __m128h *); 
#line 2560
extern __m256 __cdecl _mm256_cvtneeph_ps(const __m256h *); 
#line 2561
extern __m128 __cdecl _mm_cvtneobf16_ps(const __m128bh *); 
#line 2562
extern __m256 __cdecl _mm256_cvtneobf16_ps(const __m256bh *); 
#line 2563
extern __m128 __cdecl _mm_cvtneoph_ps(const __m128h *); 
#line 2564
extern __m256 __cdecl _mm256_cvtneoph_ps(const __m256h *); 
#line 2565
extern __m128bh __cdecl _mm_cvtneps_avx_pbh(__m128); 
#line 2566
extern __m128bh __cdecl _mm256_cvtneps_avx_pbh(__m256); 
#line 2569
extern __m128i __cdecl _mm_dpbssd_epi32(__m128i, __m128i, __m128i); 
#line 2570
extern __m256i __cdecl _mm256_dpbssd_epi32(__m256i, __m256i, __m256i); 
#line 2571
extern __m128i __cdecl _mm_dpbssds_epi32(__m128i, __m128i, __m128i); 
#line 2572
extern __m256i __cdecl _mm256_dpbssds_epi32(__m256i, __m256i, __m256i); 
#line 2573
extern __m128i __cdecl _mm_dpbsud_epi32(__m128i, __m128i, __m128i); 
#line 2574
extern __m256i __cdecl _mm256_dpbsud_epi32(__m256i, __m256i, __m256i); 
#line 2575
extern __m128i __cdecl _mm_dpbsuds_epi32(__m128i, __m128i, __m128i); 
#line 2576
extern __m256i __cdecl _mm256_dpbsuds_epi32(__m256i, __m256i, __m256i); 
#line 2577
extern __m128i __cdecl _mm_dpbuud_epi32(__m128i, __m128i, __m128i); 
#line 2578
extern __m256i __cdecl _mm256_dpbuud_epi32(__m256i, __m256i, __m256i); 
#line 2579
extern __m128i __cdecl _mm_dpbuuds_epi32(__m128i, __m128i, __m128i); 
#line 2580
extern __m256i __cdecl _mm256_dpbuuds_epi32(__m256i, __m256i, __m256i); 
#line 2583
extern void __cdecl _aadd_i32(int *, int); 
#line 2584
extern void __cdecl _aand_i32(int *, int); 
#line 2585
extern void __cdecl _aor_i32(int *, int); 
#line 2586
extern void __cdecl _axor_i32(int *, int); 
#line 2588
extern void __cdecl _aadd_i64(__int64 *, __int64); 
#line 2589
extern void __cdecl _aand_i64(__int64 *, __int64); 
#line 2590
extern void __cdecl _aor_i64(__int64 *, __int64); 
#line 2591
extern void __cdecl _axor_i64(__int64 *, __int64); 
#line 2597 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern float __cdecl __rsqrt14_ss(float); 
#line 2598
extern double __cdecl __rsqrt14_sd(double); 
#line 2599
extern float __cdecl __rsqrt_ss(float); 
#line 2600
extern float __cdecl __sqrt_ss(float); 
#line 2601
extern double __cdecl __sqrt_sd(double); 
#line 2602
extern float __cdecl __max_ss(float, float); 
#line 2603
extern double __cdecl __max_sd(double, double); 
#line 2604
extern float __cdecl __min_ss(float, float); 
#line 2605
extern double __cdecl __min_sd(double, double); 
#line 2627
typedef 
#line 2610
enum { 
#line 2611
_CMPCCX_O, 
#line 2612
_CMPCCX_NO, 
#line 2613
_CMPCCX_B, 
#line 2614
_CMPCCX_NB, 
#line 2615
_CMPCCX_Z, 
#line 2616
_CMPCCX_NZ, 
#line 2617
_CMPCCX_BE, 
#line 2618
_CMPCCX_NBE, 
#line 2619
_CMPCCX_S, 
#line 2620
_CMPCCX_NS, 
#line 2621
_CMPCCX_P, 
#line 2622
_CMPCCX_NP, 
#line 2623
_CMPCCX_L, 
#line 2624
_CMPCCX_NL, 
#line 2625
_CMPCCX_LE, 
#line 2626
_CMPCCX_NLE
#line 2627
} _CMPCCX_ENUM; 
#line 2629
extern int __cdecl _cmpccxadd_epi32(void *, int, int, const int); 
#line 2630
extern __int64 __cdecl _cmpccxadd_epi64(void *, __int64, __int64, const int); 
#line 2635 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern double __round_sd(double, int); 
#line 2636
extern float __round_ss(float, int); 
#line 2638
extern __m128i __cdecl _mm_dpwsud_epi32(__m128i, __m128i, __m128i); 
#line 2639
extern __m256i __cdecl _mm256_dpwsud_epi32(__m256i, __m256i, __m256i); 
#line 2640
extern __m128i __cdecl _mm_dpwsuds_epi32(__m128i, __m128i, __m128i); 
#line 2641
extern __m256i __cdecl _mm256_dpwsuds_epi32(__m256i, __m256i, __m256i); 
#line 2642
extern __m128i __cdecl _mm_dpwusd_epi32(__m128i, __m128i, __m128i); 
#line 2643
extern __m256i __cdecl _mm256_dpwusd_epi32(__m256i, __m256i, __m256i); 
#line 2644
extern __m128i __cdecl _mm_dpwusds_epi32(__m128i, __m128i, __m128i); 
#line 2645
extern __m256i __cdecl _mm256_dpwusds_epi32(__m256i, __m256i, __m256i); 
#line 2646
extern __m128i __cdecl _mm_dpwuud_epi32(__m128i, __m128i, __m128i); 
#line 2647
extern __m256i __cdecl _mm256_dpwuud_epi32(__m256i, __m256i, __m256i); 
#line 2648
extern __m128i __cdecl _mm_dpwuuds_epi32(__m128i, __m128i, __m128i); 
#line 2649
extern __m256i __cdecl _mm256_dpwuuds_epi32(__m256i, __m256i, __m256i); 
#line 2653
extern __int64 __cdecl _pbndkb(const void *, void *); 
#line 2657 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern __m256i __cdecl _mm256_sha512msg1_epi64(__m256i, __m128i); 
#line 2658
extern __m256i __cdecl _mm256_sha512msg2_epi64(__m256i, __m256i); 
#line 2659
extern __m256i __cdecl _mm256_sha512rnds2_epi64(__m256i, __m256i, __m128i); 
#line 2662
extern __m128i __cdecl _mm_sm3msg1_epi32(__m128i, __m128i, __m128i); 
#line 2663
extern __m128i __cdecl _mm_sm3msg2_epi32(__m128i, __m128i, __m128i); 
#line 2664
extern __m128i __cdecl _mm_sm3rnds2_epi32(__m128i, __m128i, __m128i, const int); 
#line 2667
extern __m128i __cdecl _mm_sm4key4_epi32(__m128i, __m128i); 
#line 2668
extern __m256i __cdecl _mm256_sm4key4_epi32(__m256i, __m256i); 
#line 2669
extern __m128i __cdecl _mm_sm4rnds4_epi32(__m128i, __m128i); 
#line 2670
extern __m256i __cdecl _mm256_sm4rnds4_epi32(__m256i, __m256i); 
#line 2673
extern unsigned __int64 __cdecl _urdmsr(unsigned __int64); 
#line 2674
extern void __cdecl _uwrmsr(unsigned __int64, unsigned __int64); 
#line 2677 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
__m128i __iso_volatile_ia_load128(const volatile __m128i *); 
#line 2678
__m256i __iso_volatile_ia_load256(const volatile __m256i *); 
#line 2679
__m512i __iso_volatile_ia_load512(const volatile __m512i *); 
#line 2680
void __iso_volatile_ia_store128(volatile __m128i *, __m128i); 
#line 2681
void __iso_volatile_ia_store256(volatile __m256i *, __m256i); 
#line 2682
void __iso_volatile_ia_store512(volatile __m512i *, __m512i); 
#line 2683
__m128i __iso_volatile_ia_nt_load128(const volatile __m128i *); 
#line 2684
__m256i __iso_volatile_ia_nt_load256(const volatile __m256i *); 
#line 2685
__m512i __iso_volatile_ia_nt_load512(const volatile __m512i *); 
#line 2686
void __iso_volatile_ia_nt_store128(volatile __m128i *, __m128i); 
#line 2687
void __iso_volatile_ia_nt_store256(volatile __m256i *, __m256i); 
#line 2688
void __iso_volatile_ia_nt_store512(volatile __m512i *, __m512i); 
#line 2692
extern void _m_prefetchrs(const void *); 
#line 2695
extern char __cdecl _movrs_i8(const void *); 
#line 2696
extern short __cdecl _movrs_i16(const void *); 
#line 2697
extern int __cdecl _movrs_i32(const void *); 
#line 2698
extern __int64 __cdecl _movrs_i64(const void *); 
#line 2702 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
}
#line 51 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"
extern "C" {
#line 146 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"
__m128 _mm_macc_ps(__m128, __m128, __m128); 
#line 147
__m128d _mm_macc_pd(__m128d, __m128d, __m128d); 
#line 148
__m128 _mm_macc_ss(__m128, __m128, __m128); 
#line 149
__m128d _mm_macc_sd(__m128d, __m128d, __m128d); 
#line 150
__m128 _mm_maddsub_ps(__m128, __m128, __m128); 
#line 151
__m128d _mm_maddsub_pd(__m128d, __m128d, __m128d); 
#line 152
__m128 _mm_msubadd_ps(__m128, __m128, __m128); 
#line 153
__m128d _mm_msubadd_pd(__m128d, __m128d, __m128d); 
#line 154
__m128 _mm_msub_ps(__m128, __m128, __m128); 
#line 155
__m128d _mm_msub_pd(__m128d, __m128d, __m128d); 
#line 156
__m128 _mm_msub_ss(__m128, __m128, __m128); 
#line 157
__m128d _mm_msub_sd(__m128d, __m128d, __m128d); 
#line 158
__m128 _mm_nmacc_ps(__m128, __m128, __m128); 
#line 159
__m128d _mm_nmacc_pd(__m128d, __m128d, __m128d); 
#line 160
__m128 _mm_nmacc_ss(__m128, __m128, __m128); 
#line 161
__m128d _mm_nmacc_sd(__m128d, __m128d, __m128d); 
#line 162
__m128 _mm_nmsub_ps(__m128, __m128, __m128); 
#line 163
__m128d _mm_nmsub_pd(__m128d, __m128d, __m128d); 
#line 164
__m128 _mm_nmsub_ss(__m128, __m128, __m128); 
#line 165
__m128d _mm_nmsub_sd(__m128d, __m128d, __m128d); 
#line 168
__m128i _mm_maccs_epi16(__m128i, __m128i, __m128i); 
#line 169
__m128i _mm_macc_epi16(__m128i, __m128i, __m128i); 
#line 170
__m128i _mm_maccsd_epi16(__m128i, __m128i, __m128i); 
#line 171
__m128i _mm_maccd_epi16(__m128i, __m128i, __m128i); 
#line 172
__m128i _mm_maccs_epi32(__m128i, __m128i, __m128i); 
#line 173
__m128i _mm_macc_epi32(__m128i, __m128i, __m128i); 
#line 174
__m128i _mm_maccslo_epi32(__m128i, __m128i, __m128i); 
#line 175
__m128i _mm_macclo_epi32(__m128i, __m128i, __m128i); 
#line 176
__m128i _mm_maccshi_epi32(__m128i, __m128i, __m128i); 
#line 177
__m128i _mm_macchi_epi32(__m128i, __m128i, __m128i); 
#line 178
__m128i _mm_maddsd_epi16(__m128i, __m128i, __m128i); 
#line 179
__m128i _mm_maddd_epi16(__m128i, __m128i, __m128i); 
#line 182
__m128i _mm_haddw_epi8(__m128i); 
#line 183
__m128i _mm_haddd_epi8(__m128i); 
#line 184
__m128i _mm_haddq_epi8(__m128i); 
#line 185
__m128i _mm_haddd_epi16(__m128i); 
#line 186
__m128i _mm_haddq_epi16(__m128i); 
#line 187
__m128i _mm_haddq_epi32(__m128i); 
#line 188
__m128i _mm_haddw_epu8(__m128i); 
#line 189
__m128i _mm_haddd_epu8(__m128i); 
#line 190
__m128i _mm_haddq_epu8(__m128i); 
#line 191
__m128i _mm_haddd_epu16(__m128i); 
#line 192
__m128i _mm_haddq_epu16(__m128i); 
#line 193
__m128i _mm_haddq_epu32(__m128i); 
#line 194
__m128i _mm_hsubw_epi8(__m128i); 
#line 195
__m128i _mm_hsubd_epi16(__m128i); 
#line 196
__m128i _mm_hsubq_epi32(__m128i); 
#line 199
__m128i _mm_cmov_si128(__m128i, __m128i, __m128i); 
#line 200
__m128i _mm_perm_epi8(__m128i, __m128i, __m128i); 
#line 203
__m128i _mm_rot_epi8(__m128i, __m128i); 
#line 204
__m128i _mm_rot_epi16(__m128i, __m128i); 
#line 205
__m128i _mm_rot_epi32(__m128i, __m128i); 
#line 206
__m128i _mm_rot_epi64(__m128i, __m128i); 
#line 207
__m128i _mm_roti_epi8(__m128i, int); 
#line 208
__m128i _mm_roti_epi16(__m128i, int); 
#line 209
__m128i _mm_roti_epi32(__m128i, int); 
#line 210
__m128i _mm_roti_epi64(__m128i, int); 
#line 211
__m128i _mm_shl_epi8(__m128i, __m128i); 
#line 212
__m128i _mm_shl_epi16(__m128i, __m128i); 
#line 213
__m128i _mm_shl_epi32(__m128i, __m128i); 
#line 214
__m128i _mm_shl_epi64(__m128i, __m128i); 
#line 215
__m128i _mm_sha_epi8(__m128i, __m128i); 
#line 216
__m128i _mm_sha_epi16(__m128i, __m128i); 
#line 217
__m128i _mm_sha_epi32(__m128i, __m128i); 
#line 218
__m128i _mm_sha_epi64(__m128i, __m128i); 
#line 222
__m128i _mm_com_epu8(__m128i, __m128i, int); 
#line 223
__m128i _mm_com_epu16(__m128i, __m128i, int); 
#line 224
__m128i _mm_com_epu32(__m128i, __m128i, int); 
#line 225
__m128i _mm_com_epu64(__m128i, __m128i, int); 
#line 226
__m128i _mm_com_epi8(__m128i, __m128i, int); 
#line 227
__m128i _mm_com_epi16(__m128i, __m128i, int); 
#line 228
__m128i _mm_com_epi32(__m128i, __m128i, int); 
#line 229
__m128i _mm_com_epi64(__m128i, __m128i, int); 
#line 233
__m128 _mm_frcz_ps(__m128); 
#line 234
__m128d _mm_frcz_pd(__m128d); 
#line 235
__m128 _mm_frcz_ss(__m128, __m128); 
#line 236
__m128d _mm_frcz_sd(__m128d, __m128d); 
#line 245
__m128 _mm_permute2_ps(__m128, __m128, __m128i, int); 
#line 246
__m128d _mm_permute2_pd(__m128d, __m128d, __m128i, int); 
#line 250
__m256 _mm256_macc_ps(__m256, __m256, __m256); 
#line 251
__m256d _mm256_macc_pd(__m256d, __m256d, __m256d); 
#line 252
__m256 _mm256_maddsub_ps(__m256, __m256, __m256); 
#line 253
__m256d _mm256_maddsub_pd(__m256d, __m256d, __m256d); 
#line 254
__m256 _mm256_msubadd_ps(__m256, __m256, __m256); 
#line 255
__m256d _mm256_msubadd_pd(__m256d, __m256d, __m256d); 
#line 256
__m256 _mm256_msub_ps(__m256, __m256, __m256); 
#line 257
__m256d _mm256_msub_pd(__m256d, __m256d, __m256d); 
#line 258
__m256 _mm256_nmacc_ps(__m256, __m256, __m256); 
#line 259
__m256d _mm256_nmacc_pd(__m256d, __m256d, __m256d); 
#line 260
__m256 _mm256_nmsub_ps(__m256, __m256, __m256); 
#line 261
__m256d _mm256_nmsub_pd(__m256d, __m256d, __m256d); 
#line 262
__m256i _mm256_cmov_si256(__m256i, __m256i, __m256i); 
#line 263
__m256 _mm256_frcz_ps(__m256); 
#line 264
__m256d _mm256_frcz_pd(__m256d); 
#line 265
__m256 _mm256_permute2_ps(__m256, __m256, __m256i, int); 
#line 266
__m256d _mm256_permute2_pd(__m256d, __m256d, __m256i, int); 
#line 269
void __llwpcb(void *); 
#line 270
void *__slwpcb(); 
#line 271
void __lwpval32(unsigned, unsigned, unsigned); 
#line 272
unsigned char __lwpins32(unsigned, unsigned, unsigned); 
#line 274
void __lwpval64(unsigned __int64, unsigned, unsigned); 
#line 275
unsigned char __lwpins64(unsigned __int64, unsigned, unsigned); 
#line 279 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"
unsigned _bextr_u32(unsigned, unsigned, unsigned); 
#line 280
unsigned _andn_u32(unsigned, unsigned); 
#line 281
unsigned _tzcnt_u32(unsigned); 
#line 282
unsigned _lzcnt_u32(unsigned); 
#line 283
unsigned _blsr_u32(unsigned); 
#line 284
unsigned _blsmsk_u32(unsigned); 
#line 285
unsigned _blsi_u32(unsigned); 
#line 287
unsigned __int64 _bextr_u64(unsigned __int64, unsigned, unsigned); 
#line 288
unsigned __int64 _andn_u64(unsigned __int64, unsigned __int64); 
#line 289
unsigned __int64 _tzcnt_u64(unsigned __int64); 
#line 290
unsigned __int64 _lzcnt_u64(unsigned __int64); 
#line 291
unsigned __int64 _blsr_u64(unsigned __int64); 
#line 292
unsigned __int64 _blsmsk_u64(unsigned __int64); 
#line 293
unsigned __int64 _blsi_u64(unsigned __int64); 
#line 297 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"
unsigned _bextri_u32(unsigned, unsigned); 
#line 298
unsigned _blcfill_u32(unsigned); 
#line 299
unsigned _blsfill_u32(unsigned); 
#line 300
unsigned _blcs_u32(unsigned); 
#line 301
unsigned _tzmsk_u32(unsigned); 
#line 302
unsigned _blcic_u32(unsigned); 
#line 303
unsigned _blsic_u32(unsigned); 
#line 304
unsigned _t1mskc_u32(unsigned); 
#line 305
unsigned _blcmsk_u32(unsigned); 
#line 306
unsigned _blci_u32(unsigned); 
#line 308
unsigned __int64 _bextri_u64(unsigned __int64, unsigned); 
#line 309
unsigned __int64 _blcfill_u64(unsigned __int64); 
#line 310
unsigned __int64 _blsfill_u64(unsigned __int64); 
#line 311
unsigned __int64 _blcs_u64(unsigned __int64); 
#line 312
unsigned __int64 _tzmsk_u64(unsigned __int64); 
#line 313
unsigned __int64 _blcic_u64(unsigned __int64); 
#line 314
unsigned __int64 _blsic_u64(unsigned __int64); 
#line 315
unsigned __int64 _t1mskc_u64(unsigned __int64); 
#line 316
unsigned __int64 _blcmsk_u64(unsigned __int64); 
#line 317
unsigned __int64 _blci_u64(unsigned __int64); 
#line 320 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"
void _mm_monitorx(const void *, unsigned, unsigned); 
#line 321
void _mm_mwaitx(unsigned, unsigned, unsigned); 
#line 323
void _mm_clzero(const void *); 
#line 324
unsigned __int64 _rdpru(unsigned); 
#line 357 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"
typedef 
#line 348
struct rmp_entry { 
#line 349
unsigned __int64 guest_pa; 
#line 350
unsigned char assigned; 
#line 351
unsigned char page_size: 1; 
#line 352
unsigned char rmp_2mb_region_status: 1; 
#line 353
unsigned char reserved1: 6; 
#line 354
unsigned char immutable; 
#line 355
unsigned char reserved2; 
#line 356
unsigned asid; 
#line 357
} rmp_entry; 
#line 363
typedef 
#line 359
struct rmpquery_result { 
#line 360
unsigned char target_perm_mask; 
#line 361
unsigned char vmsa; 
#line 362
unsigned char page_size; 
#line 363
} rmpquery_result; 
#line 365
unsigned __rmpupdate(unsigned __int64, rmp_entry *); 
#line 366
unsigned __pvalidate(unsigned __int64, unsigned char, unsigned char, unsigned char *); 
#line 367
unsigned __psmash(unsigned __int64); 
#line 368
unsigned __rmpadjust(unsigned __int64, unsigned char, unsigned char, unsigned char); 
#line 369
unsigned __rmpquery(unsigned __int64, unsigned char, rmpquery_result *); 
#line 370
unsigned __rmpread(unsigned __int64, rmp_entry *); 
#line 377 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"
void __svm_invlpgb(void *, int); 
#line 378
void __svm_tlbsync(); 
#line 382
}
#line 55 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"
extern "C" {
#line 61 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"
#pragma warning(push)
#pragma warning(disable: 28251)
#line 65
void *_AddressOfReturnAddress(); 
#line 76
int _cvt_dtoi_fast(double); 
#line 77
int _cvt_dtoi_sat(double); 
#line 78
int _cvt_dtoi_sent(double); 
#line 79
__int64 _cvt_dtoll_fast(double); 
#line 80
__int64 _cvt_dtoll_sat(double); 
#line 81
__int64 _cvt_dtoll_sent(double); 
#line 82
unsigned _cvt_dtoui_fast(double); 
#line 83
unsigned _cvt_dtoui_sat(double); 
#line 84
unsigned _cvt_dtoui_sent(double); 
#line 85
unsigned __int64 _cvt_dtoull_fast(double); 
#line 86
unsigned __int64 _cvt_dtoull_sat(double); 
#line 87
unsigned __int64 _cvt_dtoull_sent(double); 
#line 88
int _cvt_ftoi_fast(float); 
#line 89
int _cvt_ftoi_sat(float); 
#line 90
int _cvt_ftoi_sent(float); 
#line 91
__int64 _cvt_ftoll_fast(float); 
#line 92
__int64 _cvt_ftoll_sat(float); 
#line 93
__int64 _cvt_ftoll_sent(float); 
#line 94
unsigned _cvt_ftoui_fast(float); 
#line 95
unsigned _cvt_ftoui_sat(float); 
#line 96
unsigned _cvt_ftoui_sent(float); 
#line 97
unsigned __int64 _cvt_ftoull_fast(float); 
#line 98
unsigned __int64 _cvt_ftoull_sat(float); 
#line 99
unsigned __int64 _cvt_ftoull_sent(float); 
#line 105
long _interlockedadd(volatile long * _Addend, long _Value); 
#line 107
__int64 _interlockedadd64(volatile __int64 * _Addend, __int64 _Value); 
#line 115
short _InterlockedAnd16_np(volatile short * _Value, short _Mask); 
#line 116
__int64 _InterlockedAnd64_np(volatile __int64 * _Value, __int64 _Mask); 
#line 117
char _InterlockedAnd8_np(volatile char * _Value, char _Mask); 
#line 118
long _InterlockedAnd_np(volatile long * _Value, long _Mask); 
#line 119
unsigned char _interlockedbittestandset(volatile long *, long); 
#line 123
unsigned char _InterlockedCompareExchange128_np(volatile __int64 * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult); 
#line 124
short _InterlockedCompareExchange16_np(volatile short * _Destination, short _Exchange, short _Comparand); 
#line 125
__int64 _InterlockedCompareExchange64_np(volatile __int64 * _Destination, __int64 _Exchange, __int64 _Comparand); 
#line 126
void *_InterlockedCompareExchangePointer(void *volatile * _Destination, void * _Exchange, void * _Comparand); 
#line 129
void *_InterlockedCompareExchangePointer_np(void *volatile * _Destination, void * _Exchange, void * _Comparand); 
#line 131
long _InterlockedCompareExchange_np(volatile long * _Destination, long _Exchange, long _Comparand); 
#line 141
void *_InterlockedExchangePointer(void *volatile * _Target, void * _Value); 
#line 153
short _InterlockedOr16_np(volatile short * _Value, short _Mask); 
#line 154
__int64 _InterlockedOr64_np(volatile __int64 * _Value, __int64 _Mask); 
#line 155
char _InterlockedOr8_np(volatile char * _Value, char _Mask); 
#line 156
long _InterlockedOr_np(volatile long * _Value, long _Mask); 
#line 157
short _InterlockedXor16_np(volatile short * _Value, short _Mask); 
#line 158
__int64 _InterlockedXor64_np(volatile __int64 * _Value, __int64 _Mask); 
#line 159
char _InterlockedXor8_np(volatile char * _Value, char _Mask); 
#line 160
long _InterlockedXor_np(volatile long * _Value, long _Mask); 
#line 169
void _ReadBarrier(); 
#line 176
void *_ReturnAddress(); 
#line 178
void _WriteBarrier(); 
#line 188
void __addgsbyte(unsigned long, unsigned char); 
#line 189
void __addgsdword(unsigned long, unsigned long); 
#line 190
void __addgsqword(unsigned long, unsigned __int64); 
#line 191
void __addgsword(unsigned long, unsigned short); 
#line 196
void __clts(); 
#line 197
void __code_seg(const char *); 
#line 198
void __cpuid(int [4], int); 
#line 199
void __cpuidex(int [4], int, int); 
#line 200
void __cdecl __debugbreak(); 
#line 202
__int64 __emul(int, int); 
#line 203
unsigned __int64 __emulu(unsigned, unsigned); 
#line 204
__declspec(noreturn) void __fastfail(unsigned); 
#line 205
void __faststorefence(); 
#line 206
unsigned __getcallerseflags(); 
#line 207
void __halt(); 
#line 210
unsigned char __inbyte(unsigned short); 
#line 211
void __inbytestring(unsigned short, unsigned char *, unsigned long); 
#line 215
void __incgsbyte(unsigned long); 
#line 216
void __incgsdword(unsigned long); 
#line 217
void __incgsqword(unsigned long); 
#line 218
void __incgsword(unsigned long); 
#line 223
unsigned long __indword(unsigned short); 
#line 224
void __indwordstring(unsigned short, unsigned long *, unsigned long); 
#line 225
void __int2c(); 
#line 226
void __invlpg(void *); 
#line 227
unsigned short __inword(unsigned short); 
#line 228
void __inwordstring(unsigned short, unsigned short *, unsigned long); 
#line 229
void __lidt(void *); 
#line 230
unsigned __int64 __ll_lshift(unsigned __int64, int); 
#line 231
__int64 __ll_rshift(__int64, int); 
#line 232
void __movsb(unsigned char *, const unsigned char *, size_t); 
#line 233
void __movsd(unsigned long *, const unsigned long *, size_t); 
#line 234
void __movsq(unsigned __int64 *, const unsigned __int64 *, size_t); 
#line 235
void __movsw(unsigned short *, const unsigned short *, size_t); 
#line 236
__int64 __mulh(__int64, __int64); 
#line 237
void __nop(); 
#line 238
void __nvreg_restore_fence(); 
#line 239
void __nvreg_save_fence(); 
#line 240
void __outbyte(unsigned short, unsigned char); 
#line 241
void __outbytestring(unsigned short, unsigned char *, unsigned long); 
#line 242
void __outdword(unsigned short, unsigned long); 
#line 243
void __outdwordstring(unsigned short, unsigned long *, unsigned long); 
#line 244
void __outword(unsigned short, unsigned short); 
#line 245
void __outwordstring(unsigned short, unsigned short *, unsigned long); 
#line 250
unsigned __int64 __rdtsc(); 
#line 251
unsigned __int64 __rdtscp(unsigned *); 
#line 252
unsigned __int64 __readcr0(); 
#line 254
unsigned __int64 __readcr2(); 
#line 256
unsigned __int64 __readcr3(); 
#line 258
unsigned __int64 __readcr4(); 
#line 260
unsigned __int64 __readcr8(); 
#line 262
unsigned __int64 __readdr(unsigned); 
#line 264
unsigned __int64 __readeflags(); 
#line 270
unsigned char __readgsbyte(unsigned long); 
#line 271
unsigned long __readgsdword(unsigned long); 
#line 272
unsigned __int64 __readgsqword(unsigned long); 
#line 273
unsigned short __readgsword(unsigned long); 
#line 274
unsigned __int64 __readmsr(unsigned long); 
#line 275
void __readmsrlist(unsigned __int64, unsigned __int64 *, unsigned __int64 *); 
#line 276
unsigned __int64 __readpmc(unsigned long); 
#line 281
double __rint(double); 
#line 282
float __rintf(float); 
#line 283
double __nearbyint(double); 
#line 284
float __nearbyintf(float); 
#line 285
unsigned long __segmentlimit(unsigned long); 
#line 287
void __sidt(void *); 
#line 289
void __stosb(unsigned char *, unsigned char, size_t); 
#line 290
void __stosd(unsigned long *, unsigned long, size_t); 
#line 291
void __stosq(unsigned __int64 *, unsigned __int64, size_t); 
#line 292
void __stosw(unsigned short *, unsigned short, size_t); 
#line 293
void __svm_clgi(); 
#line 294
void __svm_invlpga(void *, int); 
#line 295
void __svm_skinit(int); 
#line 296
void __svm_stgi(); 
#line 297
void __svm_vmload(size_t); 
#line 298
void __svm_vmrun(size_t); 
#line 299
void __svm_vmsave(size_t); 
#line 305
void __ud2(); 
#line 306
unsigned __int64 __ull_rshift(unsigned __int64, int); 
#line 307
void __vmx_off(); 
#line 308
unsigned char __vmx_on(unsigned __int64 *); 
#line 309
unsigned char __vmx_vmclear(unsigned __int64 *); 
#line 310
unsigned char __vmx_vmlaunch(); 
#line 311
unsigned char __vmx_vmptrld(unsigned __int64 *); 
#line 312
void __vmx_vmptrst(unsigned __int64 *); 
#line 313
unsigned char __vmx_vmread(size_t, size_t *); 
#line 314
unsigned char __vmx_vmresume(); 
#line 315
unsigned char __vmx_vmwrite(size_t, size_t); 
#line 316
void __wbinvd(); 
#line 319
void __writecr0(unsigned __int64); 
#line 321
void __writecr2(unsigned __int64); 
#line 323
void __writecr3(unsigned __int64); 
#line 325
void __writecr4(unsigned __int64); 
#line 327
void __writecr8(unsigned __int64); 
#line 329
void __writedr(unsigned, unsigned __int64); 
#line 331
void __writeeflags(unsigned __int64); 
#line 337
void __writegsbyte(unsigned long, unsigned char); 
#line 338
void __writegsdword(unsigned long, unsigned long); 
#line 339
void __writegsqword(unsigned long, unsigned __int64); 
#line 340
void __writegsword(unsigned long, unsigned short); 
#line 341
void __writemsr(unsigned long, unsigned __int64); 
#line 342
void __writemsrlist(unsigned __int64, unsigned __int64 *, unsigned __int64 *); 
#line 343
void __writemsrns(unsigned long, unsigned __int64); 
#line 348
unsigned char _bittest64(const __int64 *, __int64); 
#line 349
unsigned char _bittestandcomplement(long *, long); 
#line 350
unsigned char _bittestandcomplement64(__int64 *, __int64); 
#line 351
unsigned char _bittestandreset(long *, long); 
#line 352
unsigned char _bittestandreset64(__int64 *, __int64); 
#line 353
unsigned char _bittestandset(long *, long); 
#line 354
unsigned char _bittestandset64(__int64 *, __int64); 
#line 355
[[nodiscard]] unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64); 
#line 356
[[nodiscard]] unsigned long __cdecl _byteswap_ulong(unsigned long); 
#line 357
[[nodiscard]] unsigned short __cdecl _byteswap_ushort(unsigned short); 
#line 358
void __cdecl _disable(); 
#line 359
void __cdecl _enable(); 
#line 360
unsigned char _interlockedbittestandreset(volatile long *, long); 
#line 361
unsigned char _interlockedbittestandreset64(volatile __int64 *, __int64); 
#line 368
unsigned char _interlockedbittestandset64(volatile __int64 *, __int64); 
#line 382
[[nodiscard]] unsigned long __cdecl _lrotl(unsigned long, int); 
#line 383
[[nodiscard]] unsigned long __cdecl _lrotr(unsigned long, int); 
#line 444
void _m_prefetch(void *); 
#line 445
void _m_prefetchw(const volatile void *); 
#line 481
__m128i _mm_abs_epi16(__m128i); 
#line 482
__m128i _mm_abs_epi32(__m128i); 
#line 483
__m128i _mm_abs_epi8(__m128i); 
#line 487
__m128i _mm_add_epi16(__m128i, __m128i); 
#line 488
__m128i _mm_add_epi32(__m128i, __m128i); 
#line 489
__m128i _mm_add_epi64(__m128i, __m128i); 
#line 490
__m128i _mm_add_epi8(__m128i, __m128i); 
#line 491
__m128d _mm_add_pd(__m128d, __m128d); 
#line 492
__m128 _mm_add_ps(__m128, __m128); 
#line 493
__m128d _mm_add_sd(__m128d, __m128d); 
#line 495
__m128 _mm_add_ss(__m128, __m128); 
#line 496
__m128i _mm_adds_epi16(__m128i, __m128i); 
#line 497
__m128i _mm_adds_epi8(__m128i, __m128i); 
#line 498
__m128i _mm_adds_epu16(__m128i, __m128i); 
#line 499
__m128i _mm_adds_epu8(__m128i, __m128i); 
#line 500
__m128d _mm_addsub_pd(__m128d, __m128d); 
#line 501
__m128 _mm_addsub_ps(__m128, __m128); 
#line 502
__m128i _mm_alignr_epi8(__m128i, __m128i, int); 
#line 504
__m128d _mm_and_pd(__m128d, __m128d); 
#line 505
__m128 _mm_and_ps(__m128, __m128); 
#line 506
__m128i _mm_and_si128(__m128i, __m128i); 
#line 507
__m128d _mm_andnot_pd(__m128d, __m128d); 
#line 508
__m128 _mm_andnot_ps(__m128, __m128); 
#line 509
__m128i _mm_andnot_si128(__m128i, __m128i); 
#line 510
__m128i _mm_avg_epu16(__m128i, __m128i); 
#line 511
__m128i _mm_avg_epu8(__m128i, __m128i); 
#line 512
__m128i _mm_blend_epi16(__m128i, __m128i, int); 
#line 513
__m128d _mm_blend_pd(__m128d, __m128d, int); 
#line 514
__m128 _mm_blend_ps(__m128, __m128, int); 
#line 515
__m128i _mm_blendv_epi8(__m128i, __m128i, __m128i); 
#line 516
__m128d _mm_blendv_pd(__m128d, __m128d, __m128d); 
#line 517
__m128 _mm_blendv_ps(__m128, __m128, __m128); 
#line 518
void _mm_clflush(const void *); 
#line 519
void _mm_clflushopt(const void *); 
#line 520
void _mm_clwb(const void *); 
#line 521
void _mm_clzero(const void *); 
#line 522
__m128i _mm_cmpeq_epi16(__m128i, __m128i); 
#line 523
__m128i _mm_cmpeq_epi32(__m128i, __m128i); 
#line 524
__m128i _mm_cmpeq_epi64(__m128i, __m128i); 
#line 525
__m128i _mm_cmpeq_epi8(__m128i, __m128i); 
#line 526
__m128d _mm_cmpeq_pd(__m128d, __m128d); 
#line 527
__m128 _mm_cmpeq_ps(__m128, __m128); 
#line 528
__m128d _mm_cmpeq_sd(__m128d, __m128d); 
#line 529
__m128 _mm_cmpeq_ss(__m128, __m128); 
#line 530
int _mm_cmpestra(__m128i, int, __m128i, int, int); 
#line 531
int _mm_cmpestrc(__m128i, int, __m128i, int, int); 
#line 532
int _mm_cmpestri(__m128i, int, __m128i, int, int); 
#line 533
__m128i _mm_cmpestrm(__m128i, int, __m128i, int, int); 
#line 534
int _mm_cmpestro(__m128i, int, __m128i, int, int); 
#line 535
int _mm_cmpestrs(__m128i, int, __m128i, int, int); 
#line 536
int _mm_cmpestrz(__m128i, int, __m128i, int, int); 
#line 537
__m128d _mm_cmpge_pd(__m128d, __m128d); 
#line 538
__m128 _mm_cmpge_ps(__m128, __m128); 
#line 539
__m128d _mm_cmpge_sd(__m128d, __m128d); 
#line 540
__m128 _mm_cmpge_ss(__m128, __m128); 
#line 541
__m128i _mm_cmpgt_epi16(__m128i, __m128i); 
#line 542
__m128i _mm_cmpgt_epi32(__m128i, __m128i); 
#line 543
__m128i _mm_cmpgt_epi64(__m128i, __m128i); 
#line 544
__m128i _mm_cmpgt_epi8(__m128i, __m128i); 
#line 545
__m128d _mm_cmpgt_pd(__m128d, __m128d); 
#line 546
__m128 _mm_cmpgt_ps(__m128, __m128); 
#line 547
__m128d _mm_cmpgt_sd(__m128d, __m128d); 
#line 548
__m128 _mm_cmpgt_ss(__m128, __m128); 
#line 549
int _mm_cmpistra(__m128i, __m128i, int); 
#line 550
int _mm_cmpistrc(__m128i, __m128i, int); 
#line 551
int _mm_cmpistri(__m128i, __m128i, int); 
#line 552
__m128i _mm_cmpistrm(__m128i, __m128i, int); 
#line 553
int _mm_cmpistro(__m128i, __m128i, int); 
#line 554
int _mm_cmpistrs(__m128i, __m128i, int); 
#line 555
int _mm_cmpistrz(__m128i, __m128i, int); 
#line 556
__m128d _mm_cmple_pd(__m128d, __m128d); 
#line 557
__m128 _mm_cmple_ps(__m128, __m128); 
#line 558
__m128d _mm_cmple_sd(__m128d, __m128d); 
#line 559
__m128 _mm_cmple_ss(__m128, __m128); 
#line 560
__m128i _mm_cmplt_epi16(__m128i, __m128i); 
#line 561
__m128i _mm_cmplt_epi32(__m128i, __m128i); 
#line 562
__m128i _mm_cmplt_epi8(__m128i, __m128i); 
#line 563
__m128d _mm_cmplt_pd(__m128d, __m128d); 
#line 564
__m128 _mm_cmplt_ps(__m128, __m128); 
#line 565
__m128d _mm_cmplt_sd(__m128d, __m128d); 
#line 566
__m128 _mm_cmplt_ss(__m128, __m128); 
#line 567
__m128d _mm_cmpneq_pd(__m128d, __m128d); 
#line 568
__m128 _mm_cmpneq_ps(__m128, __m128); 
#line 569
__m128d _mm_cmpneq_sd(__m128d, __m128d); 
#line 570
__m128 _mm_cmpneq_ss(__m128, __m128); 
#line 571
__m128d _mm_cmpnge_pd(__m128d, __m128d); 
#line 572
__m128 _mm_cmpnge_ps(__m128, __m128); 
#line 573
__m128d _mm_cmpnge_sd(__m128d, __m128d); 
#line 574
__m128 _mm_cmpnge_ss(__m128, __m128); 
#line 575
__m128d _mm_cmpngt_pd(__m128d, __m128d); 
#line 576
__m128 _mm_cmpngt_ps(__m128, __m128); 
#line 577
__m128d _mm_cmpngt_sd(__m128d, __m128d); 
#line 578
__m128 _mm_cmpngt_ss(__m128, __m128); 
#line 579
__m128d _mm_cmpnle_pd(__m128d, __m128d); 
#line 580
__m128 _mm_cmpnle_ps(__m128, __m128); 
#line 581
__m128d _mm_cmpnle_sd(__m128d, __m128d); 
#line 582
__m128 _mm_cmpnle_ss(__m128, __m128); 
#line 583
__m128d _mm_cmpnlt_pd(__m128d, __m128d); 
#line 584
__m128 _mm_cmpnlt_ps(__m128, __m128); 
#line 585
__m128d _mm_cmpnlt_sd(__m128d, __m128d); 
#line 586
__m128 _mm_cmpnlt_ss(__m128, __m128); 
#line 587
__m128d _mm_cmpord_pd(__m128d, __m128d); 
#line 588
__m128 _mm_cmpord_ps(__m128, __m128); 
#line 589
__m128d _mm_cmpord_sd(__m128d, __m128d); 
#line 590
__m128 _mm_cmpord_ss(__m128, __m128); 
#line 591
__m128d _mm_cmpunord_pd(__m128d, __m128d); 
#line 592
__m128 _mm_cmpunord_ps(__m128, __m128); 
#line 593
__m128d _mm_cmpunord_sd(__m128d, __m128d); 
#line 594
__m128 _mm_cmpunord_ss(__m128, __m128); 
#line 595
int _mm_comieq_sd(__m128d, __m128d); 
#line 596
int _mm_comieq_ss(__m128, __m128); 
#line 597
int _mm_comige_sd(__m128d, __m128d); 
#line 598
int _mm_comige_ss(__m128, __m128); 
#line 599
int _mm_comigt_sd(__m128d, __m128d); 
#line 600
int _mm_comigt_ss(__m128, __m128); 
#line 601
int _mm_comile_sd(__m128d, __m128d); 
#line 602
int _mm_comile_ss(__m128, __m128); 
#line 603
int _mm_comilt_sd(__m128d, __m128d); 
#line 604
int _mm_comilt_ss(__m128, __m128); 
#line 605
int _mm_comineq_sd(__m128d, __m128d); 
#line 606
int _mm_comineq_ss(__m128, __m128); 
#line 607
unsigned _mm_crc32_u16(unsigned, unsigned short); 
#line 608
unsigned _mm_crc32_u32(unsigned, unsigned); 
#line 609
unsigned __int64 _mm_crc32_u64(unsigned __int64, unsigned __int64); 
#line 610
unsigned _mm_crc32_u8(unsigned, unsigned char); 
#line 613
__m128 _mm_cvt_si2ss(__m128, int); 
#line 614
int _mm_cvt_ss2si(__m128); 
#line 615
__m128i _mm_cvtepi16_epi32(__m128i); 
#line 616
__m128i _mm_cvtepi16_epi64(__m128i); 
#line 617
__m128i _mm_cvtepi32_epi64(__m128i); 
#line 618
__m128d _mm_cvtepi32_pd(__m128i); 
#line 619
__m128 _mm_cvtepi32_ps(__m128i); 
#line 620
__m128i _mm_cvtepi8_epi16(__m128i); 
#line 621
__m128i _mm_cvtepi8_epi32(__m128i); 
#line 622
__m128i _mm_cvtepi8_epi64(__m128i); 
#line 623
__m128i _mm_cvtepu16_epi32(__m128i); 
#line 624
__m128i _mm_cvtepu16_epi64(__m128i); 
#line 625
__m128i _mm_cvtepu32_epi64(__m128i); 
#line 626
__m128i _mm_cvtepu8_epi16(__m128i); 
#line 627
__m128i _mm_cvtepu8_epi32(__m128i); 
#line 628
__m128i _mm_cvtepu8_epi64(__m128i); 
#line 629
__m128i _mm_cvtpd_epi32(__m128d); 
#line 631
__m128 _mm_cvtpd_ps(__m128d); 
#line 633
__m128i _mm_cvtps_epi32(__m128); 
#line 634
__m128d _mm_cvtps_pd(__m128); 
#line 635
int _mm_cvtsd_si32(__m128d); 
#line 636
__int64 _mm_cvtsd_si64(__m128d); 
#line 637
__int64 _mm_cvtsd_si64x(__m128d); 
#line 638
__m128 _mm_cvtsd_ss(__m128, __m128d); 
#line 639
int _mm_cvtsi128_si32(__m128i); 
#line 640
__int64 _mm_cvtsi128_si64(__m128i); 
#line 641
__int64 _mm_cvtsi128_si64x(__m128i); 
#line 642
__m128d _mm_cvtsi32_sd(__m128d, int); 
#line 643
__m128i _mm_cvtsi32_si128(int); 
#line 644
__m128d _mm_cvtsi64_sd(__m128d, __int64); 
#line 645
__m128i _mm_cvtsi64_si128(__int64); 
#line 646
__m128 _mm_cvtsi64_ss(__m128, __int64); 
#line 647
__m128d _mm_cvtsi64x_sd(__m128d, __int64); 
#line 648
__m128i _mm_cvtsi64x_si128(__int64); 
#line 649
__m128 _mm_cvtsi64x_ss(__m128, __int64); 
#line 650
__m128d _mm_cvtss_sd(__m128d, __m128); 
#line 651
__int64 _mm_cvtss_si64(__m128); 
#line 652
__int64 _mm_cvtss_si64x(__m128); 
#line 654
int _mm_cvtt_ss2si(__m128); 
#line 655
__m128i _mm_cvttpd_epi32(__m128d); 
#line 657
__m128i _mm_cvttps_epi32(__m128); 
#line 658
int _mm_cvttsd_si32(__m128d); 
#line 659
__int64 _mm_cvttsd_si64(__m128d); 
#line 660
__int64 _mm_cvttsd_si64x(__m128d); 
#line 661
__int64 _mm_cvttss_si64(__m128); 
#line 662
__int64 _mm_cvttss_si64x(__m128); 
#line 663
__m128d _mm_div_pd(__m128d, __m128d); 
#line 664
__m128 _mm_div_ps(__m128, __m128); 
#line 665
__m128d _mm_div_sd(__m128d, __m128d); 
#line 666
__m128 _mm_div_ss(__m128, __m128); 
#line 667
__m128d _mm_dp_pd(__m128d, __m128d, int); 
#line 668
__m128 _mm_dp_ps(__m128, __m128, int); 
#line 669
int _mm_extract_epi16(__m128i, int); 
#line 670
int _mm_extract_epi32(__m128i, int); 
#line 671
__int64 _mm_extract_epi64(__m128i, int); 
#line 672
int _mm_extract_epi8(__m128i, int); 
#line 673
int _mm_extract_ps(__m128, int); 
#line 674
__m128i _mm_extract_si64(__m128i, __m128i); 
#line 675
__m128i _mm_extracti_si64(__m128i, int, int); 
#line 676
unsigned _mm_getcsr(); 
#line 677
__m128i _mm_hadd_epi16(__m128i, __m128i); 
#line 678
__m128i _mm_hadd_epi32(__m128i, __m128i); 
#line 679
__m128d _mm_hadd_pd(__m128d, __m128d); 
#line 682
__m128 _mm_hadd_ps(__m128, __m128); 
#line 683
__m128i _mm_hadds_epi16(__m128i, __m128i); 
#line 685
__m128i _mm_hsub_epi16(__m128i, __m128i); 
#line 686
__m128i _mm_hsub_epi32(__m128i, __m128i); 
#line 687
__m128d _mm_hsub_pd(__m128d, __m128d); 
#line 690
__m128 _mm_hsub_ps(__m128, __m128); 
#line 691
__m128i _mm_hsubs_epi16(__m128i, __m128i); 
#line 693
__m128i _mm_insert_epi16(__m128i, int, int); 
#line 694
__m128i _mm_insert_epi32(__m128i, int, int); 
#line 695
__m128i _mm_insert_epi64(__m128i, __int64, int); 
#line 696
__m128i _mm_insert_epi8(__m128i, int, int); 
#line 697
__m128 _mm_insert_ps(__m128, __m128, int); 
#line 698
__m128i _mm_insert_si64(__m128i, __m128i); 
#line 699
__m128i _mm_inserti_si64(__m128i, __m128i, int, int); 
#line 700
__m128i _mm_lddqu_si128(const __m128i *); 
#line 701
void _mm_lfence(); 
#line 702
__m128d _mm_load1_pd(const double *); 
#line 703
__m128d _mm_load_pd(const double *); 
#line 704
__m128 _mm_load_ps(const float *); 
#line 705
__m128 _mm_load_ps1(const float *); 
#line 706
__m128d _mm_load_sd(const double *); 
#line 707
__m128i _mm_load_si128(const __m128i *); 
#line 708
__m128 _mm_load_ss(const float *); 
#line 709
__m128d _mm_loaddup_pd(const double *); 
#line 710
__m128d _mm_loadh_pd(__m128d, const double *); 
#line 711
__m128 _mm_loadh_pi(__m128, const __m64 *); 
#line 712
__m128i _mm_loadl_epi64(const __m128i *); 
#line 713
__m128d _mm_loadl_pd(__m128d, const double *); 
#line 714
__m128 _mm_loadl_pi(__m128, const __m64 *); 
#line 715
__m128d _mm_loadr_pd(const double *); 
#line 716
__m128 _mm_loadr_ps(const float *); 
#line 717
__m128d _mm_loadu_pd(const double *); 
#line 718
__m128 _mm_loadu_ps(const float *); 
#line 719
__m128i _mm_loadu_si128(const __m128i *); 
#line 720
__m128i _mm_madd_epi16(__m128i, __m128i); 
#line 721
__m128i _mm_maddubs_epi16(__m128i, __m128i); 
#line 723
void _mm_maskmoveu_si128(__m128i, __m128i, char *); 
#line 724
__m128i _mm_max_epi16(__m128i, __m128i); 
#line 725
__m128i _mm_max_epi32(__m128i, __m128i); 
#line 726
__m128i _mm_max_epi8(__m128i, __m128i); 
#line 727
__m128i _mm_max_epu16(__m128i, __m128i); 
#line 728
__m128i _mm_max_epu32(__m128i, __m128i); 
#line 729
__m128i _mm_max_epu8(__m128i, __m128i); 
#line 730
__m128d _mm_max_pd(__m128d, __m128d); 
#line 731
__m128 _mm_max_ps(__m128, __m128); 
#line 732
__m128d _mm_max_sd(__m128d, __m128d); 
#line 733
__m128 _mm_max_ss(__m128, __m128); 
#line 734
void _mm_mfence(); 
#line 735
__m128i _mm_min_epi16(__m128i, __m128i); 
#line 736
__m128i _mm_min_epi32(__m128i, __m128i); 
#line 737
__m128i _mm_min_epi8(__m128i, __m128i); 
#line 738
__m128i _mm_min_epu16(__m128i, __m128i); 
#line 739
__m128i _mm_min_epu32(__m128i, __m128i); 
#line 740
__m128i _mm_min_epu8(__m128i, __m128i); 
#line 741
__m128d _mm_min_pd(__m128d, __m128d); 
#line 742
__m128 _mm_min_ps(__m128, __m128); 
#line 743
__m128d _mm_min_sd(__m128d, __m128d); 
#line 744
__m128 _mm_min_ss(__m128, __m128); 
#line 745
__m128i _mm_minpos_epu16(__m128i); 
#line 746
void _mm_monitor(const void *, unsigned, unsigned); 
#line 747
__m128i _mm_move_epi64(__m128i); 
#line 748
__m128d _mm_move_sd(__m128d, __m128d); 
#line 749
__m128 _mm_move_ss(__m128, __m128); 
#line 750
__m128d _mm_movedup_pd(__m128d); 
#line 751
__m128 _mm_movehdup_ps(__m128); 
#line 752
__m128 _mm_movehl_ps(__m128, __m128); 
#line 753
__m128 _mm_moveldup_ps(__m128); 
#line 754
__m128 _mm_movelh_ps(__m128, __m128); 
#line 755
int _mm_movemask_epi8(__m128i); 
#line 756
int _mm_movemask_pd(__m128d); 
#line 757
int _mm_movemask_ps(__m128); 
#line 760
__m128i _mm_mpsadbw_epu8(__m128i, __m128i, int); 
#line 761
__m128i _mm_mul_epi32(__m128i, __m128i); 
#line 762
__m128i _mm_mul_epu32(__m128i, __m128i); 
#line 763
__m128d _mm_mul_pd(__m128d, __m128d); 
#line 764
__m128 _mm_mul_ps(__m128, __m128); 
#line 765
__m128d _mm_mul_sd(__m128d, __m128d); 
#line 766
__m128 _mm_mul_ss(__m128, __m128); 
#line 768
__m128i _mm_mulhi_epi16(__m128i, __m128i); 
#line 769
__m128i _mm_mulhi_epu16(__m128i, __m128i); 
#line 770
__m128i _mm_mulhrs_epi16(__m128i, __m128i); 
#line 772
__m128i _mm_mullo_epi16(__m128i, __m128i); 
#line 773
__m128i _mm_mullo_epi32(__m128i, __m128i); 
#line 774
void _mm_mwait(unsigned, unsigned); 
#line 775
__m128d _mm_or_pd(__m128d, __m128d); 
#line 776
__m128 _mm_or_ps(__m128, __m128); 
#line 777
__m128i _mm_or_si128(__m128i, __m128i); 
#line 778
__m128i _mm_packs_epi16(__m128i, __m128i); 
#line 779
__m128i _mm_packs_epi32(__m128i, __m128i); 
#line 780
__m128i _mm_packus_epi16(__m128i, __m128i); 
#line 781
__m128i _mm_packus_epi32(__m128i, __m128i); 
#line 782
int _mm_popcnt_u32(unsigned); 
#line 783
__int64 _mm_popcnt_u64(unsigned __int64); 
#line 784
void _mm_prefetch(const char *, int); 
#line 785
__m128 _mm_rcp_ps(__m128); 
#line 786
__m128 _mm_rcp_ss(__m128); 
#line 787
__m128d _mm_round_pd(__m128d, int); 
#line 788
__m128 _mm_round_ps(__m128, int); 
#line 789
__m128d _mm_round_sd(__m128d, __m128d, int); 
#line 790
__m128 _mm_round_ss(__m128, __m128, int); 
#line 791
__m128 _mm_rsqrt_ps(__m128); 
#line 792
__m128 _mm_rsqrt_ss(__m128); 
#line 793
__m128i _mm_sad_epu8(__m128i, __m128i); 
#line 794
__m128i _mm_set1_epi16(short); 
#line 795
__m128i _mm_set1_epi32(int); 
#line 797
__m128i _mm_set1_epi64x(__int64); 
#line 798
__m128i _mm_set1_epi8(char); 
#line 799
__m128d _mm_set1_pd(double); 
#line 803
__m128i _mm_set_epi16(short, short, short, short, short, short, short, short); 
#line 804
__m128i _mm_set_epi32(int, int, int, int); 
#line 806
__m128i _mm_set_epi64x(__int64, __int64); 
#line 807
__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char); 
#line 808
__m128d _mm_set_pd(double, double); 
#line 812
__m128 _mm_set_ps(float, float, float, float); 
#line 813
__m128 _mm_set_ps1(float); 
#line 814
__m128d _mm_set_sd(double); 
#line 815
__m128 _mm_set_ss(float); 
#line 816
void _mm_setcsr(unsigned); 
#line 817
__m128i _mm_setl_epi64(__m128i); 
#line 818
__m128i _mm_setr_epi16(short, short, short, short, short, short, short, short); 
#line 819
__m128i _mm_setr_epi32(int, int, int, int); 
#line 821
__m128i _mm_setr_epi64x(__int64, __int64); 
#line 822
__m128i _mm_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char); 
#line 823
__m128d _mm_setr_pd(double, double); 
#line 827
__m128 _mm_setr_ps(float, float, float, float); 
#line 828
__m128d _mm_setzero_pd(); 
#line 829
__m128 _mm_setzero_ps(); 
#line 830
__m128i _mm_setzero_si128(); 
#line 832
void _mm_sfence(); 
#line 833
__m128i _mm_shuffle_epi32(__m128i, int); 
#line 834
__m128i _mm_shuffle_epi8(__m128i, __m128i); 
#line 835
__m128d _mm_shuffle_pd(__m128d, __m128d, int); 
#line 837
__m128 _mm_shuffle_ps(__m128, __m128, unsigned); 
#line 838
__m128i _mm_shufflehi_epi16(__m128i, int); 
#line 839
__m128i _mm_shufflelo_epi16(__m128i, int); 
#line 840
__m128i _mm_sign_epi16(__m128i, __m128i); 
#line 841
__m128i _mm_sign_epi32(__m128i, __m128i); 
#line 842
__m128i _mm_sign_epi8(__m128i, __m128i); 
#line 846
__m128i _mm_sll_epi16(__m128i, __m128i); 
#line 847
__m128i _mm_sll_epi32(__m128i, __m128i); 
#line 848
__m128i _mm_sll_epi64(__m128i, __m128i); 
#line 849
__m128i _mm_slli_epi16(__m128i, int); 
#line 850
__m128i _mm_slli_epi32(__m128i, int); 
#line 851
__m128i _mm_slli_epi64(__m128i, int); 
#line 852
__m128i _mm_slli_si128(__m128i, int); 
#line 853
__m128d _mm_sqrt_pd(__m128d); 
#line 854
__m128 _mm_sqrt_ps(__m128); 
#line 855
__m128d _mm_sqrt_sd(__m128d, __m128d); 
#line 856
__m128 _mm_sqrt_ss(__m128); 
#line 857
__m128i _mm_sra_epi16(__m128i, __m128i); 
#line 858
__m128i _mm_sra_epi32(__m128i, __m128i); 
#line 859
__m128i _mm_srai_epi16(__m128i, int); 
#line 860
__m128i _mm_srai_epi32(__m128i, int); 
#line 861
__m128i _mm_srl_epi16(__m128i, __m128i); 
#line 862
__m128i _mm_srl_epi32(__m128i, __m128i); 
#line 863
__m128i _mm_srl_epi64(__m128i, __m128i); 
#line 864
__m128i _mm_srli_epi16(__m128i, int); 
#line 865
__m128i _mm_srli_epi32(__m128i, int); 
#line 866
__m128i _mm_srli_epi64(__m128i, int); 
#line 867
__m128i _mm_srli_si128(__m128i, int); 
#line 868
void _mm_store1_pd(double *, __m128d); 
#line 869
void _mm_store_pd(double *, __m128d); 
#line 870
void _mm_store_ps(float *, __m128); 
#line 871
void _mm_store_ps1(float *, __m128); 
#line 872
void _mm_store_sd(double *, __m128d); 
#line 873
void _mm_store_si128(__m128i *, __m128i); 
#line 874
void _mm_store_ss(float *, __m128); 
#line 875
void _mm_storeh_pd(double *, __m128d); 
#line 876
void _mm_storeh_pi(__m64 *, __m128); 
#line 877
void _mm_storel_epi64(__m128i *, __m128i); 
#line 878
void _mm_storel_pd(double *, __m128d); 
#line 879
void _mm_storel_pi(__m64 *, __m128); 
#line 880
void _mm_storer_pd(double *, __m128d); 
#line 881
void _mm_storer_ps(float *, __m128); 
#line 882
void _mm_storeu_pd(double *, __m128d); 
#line 883
void _mm_storeu_ps(float *, __m128); 
#line 884
void _mm_storeu_si128(__m128i *, __m128i); 
#line 888 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"
__m128i _mm_stream_load_si128(const __m128i *); 
#line 890 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"
void _mm_stream_pd(double *, __m128d); 
#line 892
void _mm_stream_ps(float *, __m128); 
#line 893
void _mm_stream_sd(double *, __m128d); 
#line 894
void _mm_stream_si128(__m128i *, __m128i); 
#line 895
void _mm_stream_si32(int *, int); 
#line 896
void _mm_stream_si64x(__int64 *, __int64); 
#line 897
void _mm_stream_ss(float *, __m128); 
#line 898
__m128i _mm_sub_epi16(__m128i, __m128i); 
#line 899
__m128i _mm_sub_epi32(__m128i, __m128i); 
#line 900
__m128i _mm_sub_epi64(__m128i, __m128i); 
#line 901
__m128i _mm_sub_epi8(__m128i, __m128i); 
#line 902
__m128d _mm_sub_pd(__m128d, __m128d); 
#line 903
__m128 _mm_sub_ps(__m128, __m128); 
#line 904
__m128d _mm_sub_sd(__m128d, __m128d); 
#line 906
__m128 _mm_sub_ss(__m128, __m128); 
#line 907
__m128i _mm_subs_epi16(__m128i, __m128i); 
#line 908
__m128i _mm_subs_epi8(__m128i, __m128i); 
#line 909
__m128i _mm_subs_epu16(__m128i, __m128i); 
#line 910
__m128i _mm_subs_epu8(__m128i, __m128i); 
#line 911
int _mm_testc_si128(__m128i, __m128i); 
#line 912
int _mm_testnzc_si128(__m128i, __m128i); 
#line 913
int _mm_testz_si128(__m128i, __m128i); 
#line 914
int _mm_ucomieq_sd(__m128d, __m128d); 
#line 915
int _mm_ucomieq_ss(__m128, __m128); 
#line 916
int _mm_ucomige_sd(__m128d, __m128d); 
#line 917
int _mm_ucomige_ss(__m128, __m128); 
#line 918
int _mm_ucomigt_sd(__m128d, __m128d); 
#line 919
int _mm_ucomigt_ss(__m128, __m128); 
#line 920
int _mm_ucomile_sd(__m128d, __m128d); 
#line 921
int _mm_ucomile_ss(__m128, __m128); 
#line 922
int _mm_ucomilt_sd(__m128d, __m128d); 
#line 923
int _mm_ucomilt_ss(__m128, __m128); 
#line 924
int _mm_ucomineq_sd(__m128d, __m128d); 
#line 925
int _mm_ucomineq_ss(__m128, __m128); 
#line 926
__m128i _mm_unpackhi_epi16(__m128i, __m128i); 
#line 927
__m128i _mm_unpackhi_epi32(__m128i, __m128i); 
#line 928
__m128i _mm_unpackhi_epi64(__m128i, __m128i); 
#line 929
__m128i _mm_unpackhi_epi8(__m128i, __m128i); 
#line 930
__m128d _mm_unpackhi_pd(__m128d, __m128d); 
#line 931
__m128 _mm_unpackhi_ps(__m128, __m128); 
#line 932
__m128i _mm_unpacklo_epi16(__m128i, __m128i); 
#line 933
__m128i _mm_unpacklo_epi32(__m128i, __m128i); 
#line 934
__m128i _mm_unpacklo_epi64(__m128i, __m128i); 
#line 935
__m128i _mm_unpacklo_epi8(__m128i, __m128i); 
#line 936
__m128d _mm_unpacklo_pd(__m128d, __m128d); 
#line 937
__m128 _mm_unpacklo_ps(__m128, __m128); 
#line 938
__m128d _mm_xor_pd(__m128d, __m128d); 
#line 939
__m128 _mm_xor_ps(__m128, __m128); 
#line 940
__m128i _mm_xor_si128(__m128i, __m128i); 
#line 941
__int64 _mul128(__int64 _Multiplier, __int64 _Multiplicand, __int64 * _HighProduct); 
#line 942
int __cdecl _setjmp(jmp_buf); 
#line 943
int __cdecl _setjmpex(jmp_buf); 
#line 944
void _rsm(); 
#line 945
void _lgdt(void *); 
#line 946
void _sgdt(void *); 
#line 947
void _clac(); 
#line 948
void _stac(); 
#line 949
unsigned char _addcarry_u8(unsigned char, unsigned char, unsigned char, unsigned char *); 
#line 950
unsigned char _subborrow_u8(unsigned char, unsigned char, unsigned char, unsigned char *); 
#line 951
unsigned char _addcarry_u16(unsigned char, unsigned short, unsigned short, unsigned short *); 
#line 952
unsigned char _subborrow_u16(unsigned char, unsigned short, unsigned short, unsigned short *); 
#line 953
unsigned char _addcarry_u32(unsigned char, unsigned, unsigned, unsigned *); 
#line 954
unsigned char _subborrow_u32(unsigned char, unsigned, unsigned, unsigned *); 
#line 955
unsigned char _add_overflow_i8(unsigned char, signed char, signed char, signed char *); 
#line 956
unsigned char _add_overflow_i16(unsigned char, signed short, signed short, signed short *); 
#line 957
unsigned char _add_overflow_i32(unsigned char, signed int, signed int, signed int *); 
#line 958
unsigned char _add_overflow_i64(unsigned char, signed __int64, signed __int64, signed __int64 *); 
#line 959
unsigned char _sub_overflow_i8(unsigned char, signed char, signed char, signed char *); 
#line 960
unsigned char _sub_overflow_i16(unsigned char, signed short, signed short, signed short *); 
#line 961
unsigned char _sub_overflow_i32(unsigned char, signed int, signed int, signed int *); 
#line 962
unsigned char _sub_overflow_i64(unsigned char, signed __int64, signed __int64, signed __int64 *); 
#line 963
unsigned char _mul_overflow_i16(signed short, signed short, signed short *); 
#line 964
unsigned char _mul_overflow_i32(signed int, signed int, signed int *); 
#line 965
unsigned char _mul_overflow_i64(signed __int64, signed __int64, signed __int64 *); 
#line 966
unsigned char _mul_full_overflow_i8(signed char, signed char, signed short *); 
#line 967
unsigned char _mul_full_overflow_i16(signed short, signed short, signed short *, signed short *); 
#line 968
unsigned char _mul_full_overflow_i32(signed int, signed int, signed int *, signed int *); 
#line 969
unsigned char _mul_full_overflow_i64(signed __int64, signed __int64, signed __int64 *, signed __int64 *); 
#line 970
unsigned char _mul_full_overflow_u8(unsigned char, unsigned char, unsigned short *); 
#line 971
unsigned char _mul_full_overflow_u16(unsigned short, unsigned short, unsigned short *, unsigned short *); 
#line 972
unsigned char _mul_full_overflow_u32(unsigned, unsigned, unsigned *, unsigned *); 
#line 973
unsigned char _mul_full_overflow_u64(unsigned __int64, unsigned __int64, unsigned __int64 *, unsigned __int64 *); 
#line 974
void _mm_monitorx(const void *, unsigned, unsigned); 
#line 975
void _mm_mwaitx(unsigned, unsigned, unsigned); 
#line 976
unsigned __int64 _rdpru(unsigned); 
#line 983 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"
unsigned __rmpupdate(unsigned __int64, rmp_entry *); 
#line 984
unsigned __psmash(unsigned __int64); 
#line 985
unsigned __rmpadjust(unsigned __int64, unsigned char, unsigned char, unsigned char); 
#line 986
unsigned __pvalidate(unsigned __int64, unsigned char, unsigned char, unsigned char *); 
#line 987
unsigned __rmpquery(unsigned __int64, unsigned char, rmpquery_result *); 
#line 988
unsigned __rmpread(unsigned __int64, rmp_entry *); 
#line 990 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"
void __svm_invlpgb(void *, int); 
#line 991
void __svm_tlbsync(); 
#line 992
void *_AddressOfNextInstruction(); 
#line 993
unsigned char __is_unorderedf(float, float); 
#line 994
unsigned char __is_unordered(double, double); 
#line 995
unsigned char __is_unorderedl(long double, long double); 
#line 996
unsigned char __is_nanf(float); 
#line 997
unsigned char __is_nan(double); 
#line 998
unsigned char __is_nanl(long double); 
#line 999
unsigned char __is_normalf(float); 
#line 1000
unsigned char __is_normal(double); 
#line 1001
unsigned char __is_normall(long double); 
#line 1002
unsigned char __is_finitef(float); 
#line 1003
unsigned char __is_finite(double); 
#line 1004
unsigned char __is_finitel(long double); 
#line 1005
unsigned char __is_infinityf(float); 
#line 1006
unsigned char __is_infinity(double); 
#line 1007
unsigned char __is_infinityl(long double); 
#line 1008
unsigned char __is_subnormalf(float); 
#line 1009
unsigned char __is_subnormal(double); 
#line 1010
unsigned char __is_subnormall(long double); 
#line 1011
float __fminf(float, float); 
#line 1012
double __fmin(double, double); 
#line 1013
long double __fminl(long double, long double); 
#line 1014
float __fmaxf(float, float); 
#line 1015
double __fmax(double, double); 
#line 1016
long double __fmaxl(long double, long double); 
#line 1017
signed char _sat_add_i8(signed char, signed char); 
#line 1018
signed short _sat_add_i16(signed short, signed short); 
#line 1019
signed int _sat_add_i32(signed int, signed int); 
#line 1020
signed __int64 _sat_add_i64(signed __int64, signed __int64); 
#line 1021
unsigned char _sat_add_u8(unsigned char, unsigned char); 
#line 1022
unsigned short _sat_add_u16(unsigned short, unsigned short); 
#line 1023
unsigned _sat_add_u32(unsigned, unsigned); 
#line 1024
unsigned __int64 _sat_add_u64(unsigned __int64, unsigned __int64); 
#line 1025
signed char _sat_sub_i8(signed char, signed char); 
#line 1026
signed short _sat_sub_i16(signed short, signed short); 
#line 1027
signed int _sat_sub_i32(signed int, signed int); 
#line 1028
signed __int64 _sat_sub_i64(signed __int64, signed __int64); 
#line 1029
unsigned char _sat_sub_u8(unsigned char, unsigned char); 
#line 1030
unsigned short _sat_sub_u16(unsigned short, unsigned short); 
#line 1031
unsigned _sat_sub_u32(unsigned, unsigned); 
#line 1032
unsigned __int64 _sat_sub_u64(unsigned __int64, unsigned __int64); 
#line 1033
long _InterlockedNand(volatile long *, long); 
#line 1037
char _InterlockedNand8(volatile char *, char); 
#line 1041
short _InterlockedNand16(volatile short *, short); 
#line 1045
__int64 _InterlockedNand64(volatile __int64 *, __int64); 
#line 1049
long _InterlockedMax(volatile long *, long); 
#line 1053
char _InterlockedMax8(volatile char *, char); 
#line 1057
short _InterlockedMax16(volatile short *, short); 
#line 1061
__int64 _InterlockedMax64(volatile __int64 *, __int64); 
#line 1065
long _InterlockedMin(volatile long *, long); 
#line 1069
char _InterlockedMin8(volatile char *, char); 
#line 1073
short _InterlockedMin16(volatile short *, short); 
#line 1077
__int64 _InterlockedMin64(volatile __int64 *, __int64); 
#line 1081
unsigned long _InterlockedUMax(volatile unsigned long *, unsigned long); 
#line 1085
unsigned char _InterlockedUMax8(volatile unsigned char *, unsigned char); 
#line 1089
unsigned short _InterlockedUMax16(volatile unsigned short *, unsigned short); 
#line 1093
unsigned __int64 _InterlockedUMax64(volatile unsigned __int64 *, unsigned __int64); 
#line 1097
unsigned long _InterlockedUMin(volatile unsigned long *, unsigned long); 
#line 1101
unsigned char _InterlockedUMin8(volatile unsigned char *, unsigned char); 
#line 1105
unsigned short _InterlockedUMin16(volatile unsigned short *, unsigned short); 
#line 1109
unsigned __int64 _InterlockedUMin64(volatile unsigned __int64 *, unsigned __int64); 
#line 1129 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"
}
#line 1114 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"
#pragma warning(pop)
#line 1131 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"
#pragma warning(pop)
#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\wchar.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 39
__pragma( pack ( push, 8 )) extern "C" {
#line 48
typedef __wchar_t _Wint_t; 
#line 55
__wchar_t *__cdecl _wsetlocale(int _Category, const __wchar_t * _Locale); 
#line 61
_locale_t __cdecl _wcreate_locale(int _Category, const __wchar_t * _Locale); 
#line 68
wint_t __cdecl btowc(int _Ch); 
#line 72
size_t __cdecl mbrlen(const char * _Ch, size_t _SizeInBytes, mbstate_t * _State); 
#line 78
size_t __cdecl mbrtowc(__wchar_t * _DstCh, const char * _SrcCh, size_t _SizeInBytes, mbstate_t * _State); 
#line 86
errno_t __cdecl mbsrtowcs_s(size_t * _Retval, __wchar_t * _Dst, size_t _Size, const char ** _PSrc, size_t _N, mbstate_t * _State); 
#line 95
extern "C++" {template < size_t _Size > inline errno_t __cdecl mbsrtowcs_s ( size_t * _Retval, wchar_t ( & _Dest ) [ _Size ], char const * * _PSource, size_t _Count, mbstate_t * _State ) throw ( ) { return mbsrtowcs_s ( _Retval, _Dest, _Size, _PSource, _Count, _State ); }}
#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\wchar.h"
size_t __cdecl mbsrtowcs(__wchar_t * _Dest, const char ** _PSrc, size_t _Count, mbstate_t * _State); 
#line 114 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\wchar.h"
errno_t __cdecl wcrtomb_s(size_t * _Retval, char * _Dst, size_t _SizeInBytes, __wchar_t _Ch, mbstate_t * _State); 
#line 122
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcrtomb_s ( size_t * _Retval, char ( & _Dest ) [ _Size ], wchar_t _Source, mbstate_t * _State ) throw ( ) { return wcrtomb_s ( _Retval, _Dest, _Size, _Source, _State ); }}
#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\wchar.h"
size_t __cdecl wcrtomb(char * _Dest, __wchar_t _Source, mbstate_t * _State); 
#line 139 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\wchar.h"
errno_t __cdecl wcsrtombs_s(size_t * _Retval, char * _Dst, size_t _SizeInBytes, const __wchar_t ** _Src, size_t _Size, mbstate_t * _State); 
#line 148
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcsrtombs_s ( size_t * _Retval, char ( & _Dest ) [ _Size ], wchar_t const * * _PSrc, size_t _Count, mbstate_t * _State ) throw ( ) { return wcsrtombs_s ( _Retval, _Dest, _Size, _PSrc, _Count, _State ); }}
#line 158 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\wchar.h"
size_t __cdecl wcsrtombs(char * _Dest, const __wchar_t ** _PSource, size_t _Count, mbstate_t * _State); 
#line 166 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\wchar.h"
int __cdecl wctob(wint_t _WCh); 
#line 173
errno_t __cdecl wmemcpy_s(__wchar_t * _S1, rsize_t _N1, const __wchar_t * _S2, rsize_t _N); 
#line 181
errno_t __cdecl wmemmove_s(__wchar_t * _S1, rsize_t _N1, const __wchar_t * _S2, rsize_t _N); 
#line 190 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\wchar.h"
__inline int __cdecl fwide(FILE *
#line 191
_F, int 
#line 192
_M) 
#line 194
{ 
#line 195
(void)_F; 
#line 196
return _M; 
#line 197
} 
#line 199
__inline int __cdecl mbsinit(const mbstate_t *
#line 200
_P) 
#line 202
{ 
#line 203
return (_P == (0)) || ((_P->_Wchar) == (0)); 
#line 204
} 
#line 208
extern int _Avx2WmemEnabled; 
#line 209
__declspec(selectany) int _Avx2WmemEnabledWeakValue = 0; 
#line 213 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\wchar.h"
#pragma comment(linker, "/alternatename:_Avx2WmemEnabled=_Avx2WmemEnabledWeakValue")
#line 218 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\wchar.h"
__inline const __wchar_t *__cdecl wmemchr(const __wchar_t *
#line 219
_S, __wchar_t 
#line 220
_C, size_t 
#line 221
_N) 
#line 223
{ 
#line 224
size_t Count = (0); 
#line 228
unsigned long Index = (0); 
#line 229
const __wchar_t *S = _S; 
#line 271 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\wchar.h"
if (_Avx2WmemEnabled && (_N >= (16))) 
#line 272
{ 
#line 273
__m256i V2 = _mm256_broadcastw_epi16(_mm_cvtsi32_si128(_C)); 
#line 275
do 
#line 276
{ 
#line 277
__m256i V1 = _mm256_loadu_si256((const __m256i *)S); 
#line 278
V1 = _mm256_cmpeq_epi16(V1, V2); 
#line 279
unsigned Mask = (unsigned)_mm256_movemask_epi8(V1); 
#line 280
if (Mask != (0)) 
#line 281
{ 
#line 282
_BitScanForward(&Index, Mask); 
#line 283
Index >>= 1; 
#line 284
return (const __wchar_t *)(&(_S[Count + Index])); 
#line 285
}  
#line 286
Count += (16); 
#line 287
S += 16; 
#line 288
} while ((Count + (16)) <= _N); 
#line 289
}  
#line 292 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\wchar.h"
if ((Count + (4)) <= _N) 
#line 293
{ 
#line 294
__m128i V2 = _mm_set1_epi16((short)_C); 
#line 296
while ((Count + (8)) <= _N) 
#line 297
{ 
#line 298
__m128i V1 = _mm_loadu_si128((const __m128i *)S); 
#line 299
V1 = _mm_cmpeq_epi16(V1, V2); 
#line 300
unsigned short Mask = (unsigned short)_mm_movemask_epi8(V1); 
#line 301
if (Mask != 0) 
#line 302
{ 
#line 303
_BitScanForward(&Index, Mask); 
#line 304
Index >>= 1; 
#line 305
return (const __wchar_t *)(&(_S[Count + Index])); 
#line 306
}  
#line 307
Count += (8); 
#line 308
S += 8; 
#line 309
}  
#line 311
if ((Count + (4)) <= _N) 
#line 312
{ 
#line 313
__m128i V1 = _mm_loadl_epi64((const __m128i *)S); 
#line 314
V1 = _mm_cmpeq_epi16(V1, V2); 
#line 315
unsigned char Mask = (unsigned char)_mm_movemask_epi8(V1); 
#line 316
if (Mask != 0) 
#line 317
{ 
#line 318
_BitScanForward(&Index, Mask); 
#line 319
Index >>= 1; 
#line 320
return (const __wchar_t *)(&(_S[Count + Index])); 
#line 321
}  
#line 323
Count += (4); 
#line 324
}  
#line 325
}  
#line 330 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\wchar.h"
for (; Count < _N; ++Count) 
#line 331
{ 
#line 332
if ((_S[Count]) == _C) 
#line 333
{ 
#line 334
return (const __wchar_t *)(&(_S[Count])); 
#line 335
}  
#line 336
}  
#line 338
return 0; 
#line 339
} 
#line 341
__inline int __cdecl wmemcmp(const __wchar_t *
#line 342
_S1, const __wchar_t *
#line 343
_S2, size_t 
#line 344
_N) 
#line 346
{ 
#line 347
size_t Count = (0); 
#line 351
unsigned long Index = (0); 
#line 352
const __wchar_t *S1 = _S1; 
#line 353
const __wchar_t *S2 = _S2; 
#line 395 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\wchar.h"
if (_Avx2WmemEnabled) 
#line 396
{ 
#line 397
while ((Count + (16)) <= _N) 
#line 398
{ 
#line 399
__m256i V1 = _mm256_loadu_si256((const __m256i *)S1); 
#line 400
__m256i V2 = _mm256_loadu_si256((const __m256i *)S2); 
#line 401
V1 = _mm256_cmpeq_epi16(V1, V2); 
#line 402
unsigned Mask = (unsigned)_mm256_movemask_epi8(V1); 
#line 403
if (Mask != 4294967295U) 
#line 404
{ 
#line 405
_BitScanForward(&Index, ~Mask); 
#line 406
Index >>= 1; 
#line 407
return ((_S1[Count + Index]) < (_S2[Count + Index])) ? -1 : 1; 
#line 408
}  
#line 409
Count += (16); 
#line 410
S1 += 16; 
#line 411
S2 += 16; 
#line 412
}  
#line 413
}  
#line 416 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\wchar.h"
while ((Count + (8)) <= _N) 
#line 417
{ 
#line 418
__m128i V1 = _mm_loadu_si128((const __m128i *)S1); 
#line 419
__m128i V2 = _mm_loadu_si128((const __m128i *)S2); 
#line 420
V1 = _mm_cmpeq_epi16(V1, V2); 
#line 421
unsigned short Mask = (unsigned short)_mm_movemask_epi8(V1); 
#line 422
if (Mask != 65535) 
#line 423
{ 
#line 424
_BitScanForward(&Index, (unsigned long)(~Mask)); 
#line 425
Index >>= 1; 
#line 426
return ((_S1[Count + Index]) < (_S2[Count + Index])) ? -1 : 1; 
#line 427
}  
#line 428
Count += (8); 
#line 429
S1 += 8; 
#line 430
S2 += 8; 
#line 431
}  
#line 450 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\wchar.h"
if ((Count + (4)) <= _N) 
#line 451
{ 
#line 452
unsigned __int64 V1 = *((unsigned __int64 *)S1); 
#line 453
unsigned __int64 V2 = *((unsigned __int64 *)S2); 
#line 454
if (V1 != V2) 
#line 455
{ 
#line 456
_BitScanForward64(&Index, V1 ^ V2); 
#line 457
Index >>= 4; 
#line 458
return ((_S1[Count + Index]) < (_S2[Count + Index])) ? -1 : 1; 
#line 459
}  
#line 461
Count += (4); 
#line 462
}  
#line 467 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\wchar.h"
for (; Count < _N; ++Count) 
#line 468
{ 
#line 469
if ((_S1[Count]) != (_S2[Count])) 
#line 470
{ 
#line 471
return ((_S1[Count]) < (_S2[Count])) ? -1 : 1; 
#line 472
}  
#line 473
}  
#line 475
return 0; 
#line 476
} 
#line 481
__inline __wchar_t *__cdecl wmemcpy(__wchar_t *
#line 482
_S1, const __wchar_t *
#line 483
_S2, size_t 
#line 484
_N) 
#line 486
{ 
#pragma warning(suppress: 6386)
return (__wchar_t *)memcpy(_S1, _S2, _N * sizeof(__wchar_t)); 
#line 489
} 
#line 492
__inline __wchar_t *__cdecl wmemmove(__wchar_t *
#line 493
_S1, const __wchar_t *
#line 494
_S2, size_t 
#line 495
_N) 
#line 497
{ 
#pragma warning(suppress: 6386)
return (__wchar_t *)memmove(_S1, _S2, _N * sizeof(__wchar_t)); 
#line 500
} 
#line 504
__inline __wchar_t *__cdecl wmemset(__wchar_t *
#line 505
_S, __wchar_t 
#line 506
_C, size_t 
#line 507
_N) 
#line 509
{ 
#line 510
__wchar_t *_Su = _S; 
#line 511
for (; (0) < _N; (++_Su), (--_N)) 
#line 512
{ 
#line 513
(*_Su) = _C; 
#line 514
}  
#line 515
return _S; 
#line 516
} 
#line 520
extern "C++" inline __wchar_t *__cdecl wmemchr(__wchar_t *
#line 521
_S, __wchar_t 
#line 522
_C, size_t 
#line 523
_N) 
#line 525
{ 
#line 526
const __wchar_t *const _SC = _S; 
#line 527
return const_cast< __wchar_t *>(wmemchr(_SC, _C, _N)); 
#line 528
} 
#line 535 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\wchar.h"
}__pragma( pack ( pop )) 
#line 537
#pragma warning(pop)
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cwchar"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 22
extern "C" { using _Mbstatet = mbstate_t; }
#line 25
namespace std { 
#pragma warning(push)
#pragma warning(disable : 4995)
#line 31
using ::mbstate_t;
#line 33
using ::tm;
#line 34
using ::wint_t;
#line 36
using ::btowc;
#line 37
using ::fgetwc;
#line 38
using ::fgetws;
#line 39
using ::fputwc;
#line 40
using ::fputws;
#line 41
using ::fwide;
#line 42
using ::fwprintf;
#line 43
using ::fwscanf;
#line 44
using ::getwc;
#line 45
using ::getwchar;
#line 46
using ::mbrlen;
#line 47
using ::mbrtowc;
#line 48
using ::mbsrtowcs;
#line 49
using ::mbsinit;
#line 50
using ::putwc;
#line 51
using ::putwchar;
#line 52
using ::swprintf;
#line 53
using ::swscanf;
#line 54
using ::ungetwc;
#line 55
using ::vfwprintf;
#line 56
using ::vswprintf;
#line 57
using ::vwprintf;
#line 58
using ::wcrtomb;
#line 59
using ::wprintf;
#line 60
using ::wscanf;
#line 61
using ::wcsrtombs;
#line 62
using ::wcstol;
#line 63
using ::wcscat;
#line 64
using ::wcschr;
#line 65
using ::wcscmp;
#line 66
using ::wcscoll;
#line 67
using ::wcscpy;
#line 68
using ::wcscspn;
#line 69
using ::wcslen;
#line 70
using ::wcsncat;
#line 71
using ::wcsncmp;
#line 72
using ::wcsncpy;
#line 73
using ::wcspbrk;
#line 74
using ::wcsrchr;
#line 75
using ::wcsspn;
#line 76
using ::wcstod;
#line 77
using ::wcstoul;
#line 78
using ::wcsstr;
#line 79
using ::wcstok;
#line 80
using ::wcsxfrm;
#line 81
using ::wctob;
#line 82
using ::wmemchr;
#line 83
using ::wmemcmp;
#line 84
using ::wmemcpy;
#line 85
using ::wmemmove;
#line 86
using ::wmemset;
#line 87
using ::wcsftime;
#line 89
using ::vfwscanf;
#line 90
using ::vswscanf;
#line 91
using ::vwscanf;
#line 92
using ::wcstof;
#line 93
using ::wcstold;
#line 94
using ::wcstoll;
#line 95
using ::wcstoull;
#line 97
#pragma warning(pop)
}
#line 102
#pragma warning(pop)
#pragma pack ( pop )
#line 16 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iosfwd"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 23
namespace std { 
#line 46 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iosfwd"
using streamoff = __int64; 
#line 47
using streamsize = __int64; 
#line 49
template < class _Statetype >
class fpos {
public :
     fpos ( streamoff _Off = 0 ) : _Myoff ( _Off ), _Fpos ( 0 ), _Mystate ( ) { }

    fpos ( _Statetype _State, fpos_t _Fileposition ) : _Myoff ( _Fileposition ), _Fpos ( 0 ), _Mystate ( _State ) { }

    [ [ nodiscard ] ] _Statetype state ( ) const {
        return _Mystate;
    }

    void state ( _Statetype _State ) {
        _Mystate = _State;
    }

    operator streamoff ( ) const noexcept {


        return _Myoff + _Fpos;
    }

    [ [ nodiscard ] ] streamoff operator - ( const fpos & _Right ) const noexcept {
        return static_cast < streamoff > ( * this ) - static_cast < streamoff > ( _Right );
    }

    fpos & operator += ( streamoff _Off ) noexcept {
        _Myoff += _Off;
        return * this;
    }

    fpos & operator -= ( streamoff _Off ) noexcept {
        _Myoff -= _Off;
        return * this;
    }

    [ [ nodiscard ] ] fpos operator + ( streamoff _Off ) const {
        fpos _Tmp = * this;
        _Tmp += _Off;
        return _Tmp;
    }

    [ [ nodiscard ] ] fpos operator - ( streamoff _Off ) const {
        fpos _Tmp = * this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [ [ nodiscard ] ] bool operator == ( const fpos & _Right ) const noexcept {
        return static_cast < streamoff > ( * this ) == static_cast < streamoff > ( _Right );
    }

    template < class _Int, enable_if_t < is_integral_v < _Int >, int > = 0 >
    [ [ nodiscard ] ] friend bool operator == ( const fpos & _Left, const _Int _Right ) noexcept {
        return static_cast < streamoff > ( _Left ) == _Right;
    }


    template < class _Int, enable_if_t < is_integral_v < _Int >, int > = 0 >
    [ [ nodiscard ] ] friend bool operator == ( const _Int _Left, const fpos & _Right ) noexcept {
        return _Left == static_cast < streamoff > ( _Right );
    }

    [ [ nodiscard ] ] bool operator != ( const fpos & _Right ) const noexcept {
        return static_cast < streamoff > ( * this ) != static_cast < streamoff > ( _Right );
    }

    template < class _Int, enable_if_t < is_integral_v < _Int >, int > = 0 >
    [ [ nodiscard ] ] friend bool operator != ( const fpos & _Left, const _Int _Right ) noexcept {
        return static_cast < streamoff > ( _Left ) != _Right;
    }

    template < class _Int, enable_if_t < is_integral_v < _Int >, int > = 0 >
    [ [ nodiscard ] ] friend bool operator != ( const _Int _Left, const fpos & _Right ) noexcept {
        return _Left != static_cast < streamoff > ( _Right );
    }


private :
    streamoff _Myoff;
    fpos_t _Fpos;
    _Statetype _Mystate;
};
#line 132 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iosfwd"
using streampos = fpos< _Mbstatet> ; 
#line 133
using wstreampos = streampos; 
#line 137
using u16streampos = streampos; 
#line 138
using u32streampos = streampos; 
#line 140
class locale; 
#line 141
template < class _Facet >
const _Facet & __cdecl use_facet ( const locale & );
#line 144
template< class _Elem> struct char_traits; 
#line 147
template<> struct char_traits< char> ; 
#line 153
template<> struct char_traits< char16_t> ; 
#line 155
template<> struct char_traits< char32_t> ; 
#line 157
template<> struct char_traits< __wchar_t> ; 
#line 163
template < class _Ty >
class allocator;
#line 165
class ios_base; 
#line 166
template < class _Elem, class _Traits = char_traits < _Elem > >
class basic_ios;
#line 168
template < class _Elem, class _Traits = char_traits < _Elem > >
class istreambuf_iterator;
#line 170
template < class _Elem, class _Traits = char_traits < _Elem > >
class ostreambuf_iterator;
#line 172
template < class _Elem, class _Traits = char_traits < _Elem > >
class basic_streambuf;
#line 175
#pragma vtordisp(push, 2)
template < class _Elem, class _Traits = char_traits < _Elem > >
class basic_istream;
#line 178
template < class _Elem, class _Traits = char_traits < _Elem > >
class basic_ostream;
#pragma vtordisp(pop)
#line 182
template < class _Elem, class _Traits = char_traits < _Elem > >
class basic_iostream;
#line 184
template< class _Elem, class _Traits = char_traits< _Elem> , class _Alloc = allocator< _Elem> > class basic_stringbuf; 
#line 186
template< class _Elem, class _Traits = char_traits< _Elem> , class _Alloc = allocator< _Elem> > class basic_istringstream; 
#line 188
template< class _Elem, class _Traits = char_traits< _Elem> , class _Alloc = allocator< _Elem> > class basic_ostringstream; 
#line 190
template< class _Elem, class _Traits = char_traits< _Elem> , class _Alloc = allocator< _Elem> > class basic_stringstream; 
#line 202 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iosfwd"
template< class _Elem, class _Traits = char_traits< _Elem> > class basic_filebuf; 
#line 204
template< class _Elem, class _Traits = char_traits< _Elem> > class basic_ifstream; 
#line 206
template< class _Elem, class _Traits = char_traits< _Elem> > class basic_ofstream; 
#line 208
template< class _Elem, class _Traits = char_traits< _Elem> > class basic_fstream; 
#line 228 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iosfwd"
using ios = basic_ios< char, char_traits< char> > ; 
#line 229
using streambuf = basic_streambuf< char, char_traits< char> > ; 
#line 230
using istream = basic_istream< char, char_traits< char> > ; 
#line 231
using ostream = basic_ostream< char, char_traits< char> > ; 
#line 232
using iostream = basic_iostream< char, char_traits< char> > ; 
#line 233
using stringbuf = basic_stringbuf< char, char_traits< char> , allocator< char> > ; 
#line 234
using istringstream = basic_istringstream< char, char_traits< char> , allocator< char> > ; 
#line 235
using ostringstream = basic_ostringstream< char, char_traits< char> , allocator< char> > ; 
#line 236
using stringstream = basic_stringstream< char, char_traits< char> , allocator< char> > ; 
#line 237
using filebuf = basic_filebuf< char, char_traits< char> > ; 
#line 238
using ifstream = basic_ifstream< char, char_traits< char> > ; 
#line 239
using ofstream = basic_ofstream< char, char_traits< char> > ; 
#line 240
using fstream = basic_fstream< char, char_traits< char> > ; 
#line 252 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iosfwd"
using wios = basic_ios< __wchar_t, char_traits< __wchar_t> > ; 
#line 253
using wstreambuf = basic_streambuf< __wchar_t, char_traits< __wchar_t> > ; 
#line 254
using wistream = basic_istream< __wchar_t, char_traits< __wchar_t> > ; 
#line 255
using wostream = basic_ostream< __wchar_t, char_traits< __wchar_t> > ; 
#line 256
using wiostream = basic_iostream< __wchar_t, char_traits< __wchar_t> > ; 
#line 257
using wstringbuf = basic_stringbuf< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > ; 
#line 258
using wistringstream = basic_istringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > ; 
#line 259
using wostringstream = basic_ostringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > ; 
#line 260
using wstringstream = basic_stringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > ; 
#line 261
using wfilebuf = basic_filebuf< __wchar_t, char_traits< __wchar_t> > ; 
#line 262
using wifstream = basic_ifstream< __wchar_t, char_traits< __wchar_t> > ; 
#line 263
using wofstream = basic_ofstream< __wchar_t, char_traits< __wchar_t> > ; 
#line 264
using wfstream = basic_fstream< __wchar_t, char_traits< __wchar_t> > ; 
#line 276 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iosfwd"
}
#line 280
#pragma warning(pop)
#pragma pack ( pop )
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_iter_core.hpp"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 19
namespace std { 
#line 20
template< class _Ty, class _Alloc, class  = void> 
#line 21
struct _Has_allocator_type : public false_type { }; 
#line 23
template< class _Ty, class _Alloc> 
#line 24
struct _Has_allocator_type< _Ty, _Alloc, void_t< typename _Ty::allocator_type> >  : public is_convertible< _Alloc, typename _Ty::allocator_type> ::type { 
#line 25
}; 
#line 27
struct allocator_arg_t { 
#line 28
explicit allocator_arg_t() = default;
#line 29
}; 
#line 31
constexpr allocator_arg_t allocator_arg{}; 
#line 33
template< class _Ty, class _Alloc> 
#line 34
struct uses_allocator : public _Has_allocator_type< _Ty, _Alloc> ::type { }; 
#line 36
template< class _Ty, class _Alloc> constexpr bool 
#line 37
uses_allocator_v = (uses_allocator< _Ty, _Alloc> ::value); 
#line 40
struct input_iterator_tag { }; 
#line 42
struct output_iterator_tag { }; 
#line 44
struct forward_iterator_tag : public input_iterator_tag { }; 
#line 46
struct bidirectional_iterator_tag : public forward_iterator_tag { }; 
#line 48
struct random_access_iterator_tag : public bidirectional_iterator_tag { }; 
#line 468 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_iter_core.hpp"
template< class , class  = void> 
#line 469
struct _Iterator_traits_base { }; 
#line 471
template< class _Iter> 
#line 472
struct _Iterator_traits_base< _Iter, void_t< typename _Iter::iterator_category, typename _Iter::value_type, typename _Iter::difference_type, typename _Iter::pointer, typename _Iter::reference> >  { 
#line 476
using iterator_category = typename _Iter::iterator_category; 
#line 477
using value_type = typename _Iter::value_type; 
#line 478
using difference_type = typename _Iter::difference_type; 
#line 479
using pointer = typename _Iter::pointer; 
#line 480
using reference = typename _Iter::reference; 
#line 481
}; 
#line 483
template< class _Ty, bool  = is_object_v< _Ty> > 
#line 484
struct _Iterator_traits_pointer_base { 
#line 485
using iterator_category = random_access_iterator_tag; 
#line 486
using value_type = remove_cv_t< _Ty> ; 
#line 487
using difference_type = ptrdiff_t; 
#line 488
using pointer = _Ty *; 
#line 489
using reference = _Ty &; 
#line 490
}; 
#line 492
template< class _Ty> 
#line 493
struct _Iterator_traits_pointer_base< _Ty, false>  { }; 
#line 495
template< class _Iter> 
#line 496
struct iterator_traits : public _Iterator_traits_base< _Iter>  { }; 
#line 498
template< class _Ty> 
#line 499
struct iterator_traits< _Ty *>  : public _Iterator_traits_pointer_base< _Ty>  { }; 
#line 501
template< class _Ty> constexpr bool 
#line 502
_Integer_like = _Is_nonbool_integral< _Ty> ; 
#line 505 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_iter_core.hpp"
constexpr auto _Meta_npos = (~((size_t)0)); 
#line 507
constexpr size_t _Meta_find_index_i_(const bool *const _Ptr, const size_t _Count, size_t _Idx = 0) { 
#line 509
for (; _Idx < _Count; ++_Idx) { 
#line 510
if (_Ptr[_Idx]) { 
#line 511
return _Idx; 
#line 512
}  
#line 513
}  
#line 515
return _Meta_npos; 
#line 516
} 
#line 518
template< class _List, class _Ty> 
#line 519
struct _Meta_find_unique_index_ { 
#line 520
using type = integral_constant< size_t, _Meta_npos> ; 
#line 521
}; 
#line 522
template< class _List, class _Ty> using _Meta_find_unique_index = typename _Meta_find_unique_index_< _List, _Ty> ::type; 
#line 527
constexpr size_t _Meta_find_unique_index_i_2(const bool *const _Ptr, const size_t _Count, const size_t _First) { 
#line 529
return ((_First != _Meta_npos) && (::std::_Meta_find_index_i_(_Ptr, _Count, _First + (1)) == _Meta_npos)) ? _First : _Meta_npos; 
#line 531
} 
#line 533
constexpr size_t _Meta_find_unique_index_i_(const bool *const _Ptr, const size_t _Count) { 
#line 535
return ::std::_Meta_find_unique_index_i_2(_Ptr, _Count, ::std::_Meta_find_index_i_(_Ptr, _Count)); 
#line 536
} 
#line 538
template< template< class ...>  class _List, class _First, class ..._Rest, class _Ty> 
#line 539
struct _Meta_find_unique_index_< _List< _First, _Rest...> , _Ty>  { 
#line 540
static constexpr bool _Bools[] = {is_same_v< _First, _Ty> , (is_same_v< _Rest, _Ty> )...}; 
#line 541
using type = integral_constant< size_t, std::_Meta_find_unique_index_i_(_Bools, (1) + sizeof...(_Rest))> ; 
#line 542
}; 
#line 543
}
#line 547
#pragma warning(pop)
#pragma pack ( pop )
#line 17 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 67 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
extern "C" {
#line 75
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_1(void * _First, void * _Last) noexcept; 
#line 76
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_2(void * _First, void * _Last) noexcept; 
#line 77
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_4(void * _First, void * _Last) noexcept; 
#line 78
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_8(void * _First, void * _Last) noexcept; 
#line 79
__declspec(noalias) void __cdecl __std_swap_ranges_trivially_swappable_noalias(void * _First1, void * _Last1, void * _First2) noexcept; 
#line 82
__declspec(noalias) size_t __stdcall __std_count_trivial_1(const void * _First, const void * _Last, uint8_t _Val) noexcept; 
#line 84
__declspec(noalias) size_t __stdcall __std_count_trivial_2(const void * _First, const void * _Last, uint16_t _Val) noexcept; 
#line 86
__declspec(noalias) size_t __stdcall __std_count_trivial_4(const void * _First, const void * _Last, uint32_t _Val) noexcept; 
#line 88
__declspec(noalias) size_t __stdcall __std_count_trivial_8(const void * _First, const void * _Last, uint64_t _Val) noexcept; 
#line 91
const void *__stdcall __std_find_trivial_1(const void * _First, const void * _Last, uint8_t _Val) noexcept; 
#line 92
const void *__stdcall __std_find_trivial_2(const void * _First, const void * _Last, uint16_t _Val) noexcept; 
#line 93
const void *__stdcall __std_find_trivial_4(const void * _First, const void * _Last, uint32_t _Val) noexcept; 
#line 94
const void *__stdcall __std_find_trivial_8(const void * _First, const void * _Last, uint64_t _Val) noexcept; 
#line 96
const void *__stdcall __std_find_last_trivial_1(const void * _First, const void * _Last, uint8_t _Val) noexcept; 
#line 97
const void *__stdcall __std_find_last_trivial_2(const void * _First, const void * _Last, uint16_t _Val) noexcept; 
#line 98
const void *__stdcall __std_find_last_trivial_4(const void * _First, const void * _Last, uint32_t _Val) noexcept; 
#line 99
const void *__stdcall __std_find_last_trivial_8(const void * _First, const void * _Last, uint64_t _Val) noexcept; 
#line 101
const void *__stdcall __std_search_1(const void * _First1, const void * _Last1, const void * _First2, size_t _Count2) noexcept; 
#line 103
const void *__stdcall __std_search_2(const void * _First1, const void * _Last1, const void * _First2, size_t _Count2) noexcept; 
#line 106
const void *__stdcall __std_find_end_1(const void * _First1, const void * _Last1, const void * _First2, size_t _Count2) noexcept; 
#line 108
const void *__stdcall __std_find_end_2(const void * _First1, const void * _Last1, const void * _First2, size_t _Count2) noexcept; 
#line 111
const void *__stdcall __std_min_element_1(const void * _First, const void * _Last, bool _Signed) noexcept; 
#line 112
const void *__stdcall __std_min_element_2(const void * _First, const void * _Last, bool _Signed) noexcept; 
#line 113
const void *__stdcall __std_min_element_4(const void * _First, const void * _Last, bool _Signed) noexcept; 
#line 114
const void *__stdcall __std_min_element_8(const void * _First, const void * _Last, bool _Signed) noexcept; 
#line 115
const void *__stdcall __std_min_element_f(const void * _First, const void * _Last, bool _Unused) noexcept; 
#line 116
const void *__stdcall __std_min_element_d(const void * _First, const void * _Last, bool _Unused) noexcept; 
#line 118
const void *__stdcall __std_max_element_1(const void * _First, const void * _Last, bool _Signed) noexcept; 
#line 119
const void *__stdcall __std_max_element_2(const void * _First, const void * _Last, bool _Signed) noexcept; 
#line 120
const void *__stdcall __std_max_element_4(const void * _First, const void * _Last, bool _Signed) noexcept; 
#line 121
const void *__stdcall __std_max_element_8(const void * _First, const void * _Last, bool _Signed) noexcept; 
#line 122
const void *__stdcall __std_max_element_f(const void * _First, const void * _Last, bool _Unused) noexcept; 
#line 123
const void *__stdcall __std_max_element_d(const void * _First, const void * _Last, bool _Unused) noexcept; 
#line 125
__declspec(noalias) int8_t __stdcall __std_min_1i(const void * _First, const void * _Last) noexcept; 
#line 126
__declspec(noalias) uint8_t __stdcall __std_min_1u(const void * _First, const void * _Last) noexcept; 
#line 127
__declspec(noalias) int16_t __stdcall __std_min_2i(const void * _First, const void * _Last) noexcept; 
#line 128
__declspec(noalias) uint16_t __stdcall __std_min_2u(const void * _First, const void * _Last) noexcept; 
#line 129
__declspec(noalias) int32_t __stdcall __std_min_4i(const void * _First, const void * _Last) noexcept; 
#line 130
__declspec(noalias) uint32_t __stdcall __std_min_4u(const void * _First, const void * _Last) noexcept; 
#line 131
__declspec(noalias) int64_t __stdcall __std_min_8i(const void * _First, const void * _Last) noexcept; 
#line 132
__declspec(noalias) uint64_t __stdcall __std_min_8u(const void * _First, const void * _Last) noexcept; 
#line 133
__declspec(noalias) float __stdcall __std_min_f(const void * _First, const void * _Last) noexcept; 
#line 134
__declspec(noalias) double __stdcall __std_min_d(const void * _First, const void * _Last) noexcept; 
#line 135
__declspec(noalias) int8_t __stdcall __std_max_1i(const void * _First, const void * _Last) noexcept; 
#line 136
__declspec(noalias) uint8_t __stdcall __std_max_1u(const void * _First, const void * _Last) noexcept; 
#line 137
__declspec(noalias) int16_t __stdcall __std_max_2i(const void * _First, const void * _Last) noexcept; 
#line 138
__declspec(noalias) uint16_t __stdcall __std_max_2u(const void * _First, const void * _Last) noexcept; 
#line 139
__declspec(noalias) int32_t __stdcall __std_max_4i(const void * _First, const void * _Last) noexcept; 
#line 140
__declspec(noalias) uint32_t __stdcall __std_max_4u(const void * _First, const void * _Last) noexcept; 
#line 141
__declspec(noalias) int64_t __stdcall __std_max_8i(const void * _First, const void * _Last) noexcept; 
#line 142
__declspec(noalias) uint64_t __stdcall __std_max_8u(const void * _First, const void * _Last) noexcept; 
#line 143
__declspec(noalias) float __stdcall __std_max_f(const void * _First, const void * _Last) noexcept; 
#line 144
__declspec(noalias) double __stdcall __std_max_d(const void * _First, const void * _Last) noexcept; 
#line 146
__declspec(noalias) size_t __stdcall __std_mismatch_1(const void * _First1, const void * _First2, size_t _Count) noexcept; 
#line 147
__declspec(noalias) size_t __stdcall __std_mismatch_2(const void * _First1, const void * _First2, size_t _Count) noexcept; 
#line 148
__declspec(noalias) size_t __stdcall __std_mismatch_4(const void * _First1, const void * _First2, size_t _Count) noexcept; 
#line 149
__declspec(noalias) size_t __stdcall __std_mismatch_8(const void * _First1, const void * _First2, size_t _Count) noexcept; 
#line 150
}
#line 152
namespace std { 
#line 153
template < size_t _Nx >
__declspec ( noalias ) void _Reverse_vectorized ( void * _First, void * _Last ) noexcept {
    if constexpr ( _Nx == 1 ) {
        :: __std_reverse_trivially_swappable_1 ( _First, _Last );
    } else if constexpr ( _Nx == 2 ) {
        :: __std_reverse_trivially_swappable_2 ( _First, _Last );
    } else if constexpr ( _Nx == 4 ) {
        :: __std_reverse_trivially_swappable_4 ( _First, _Last );
    } else if constexpr ( _Nx == 8 ) {
        :: __std_reverse_trivially_swappable_8 ( _First, _Last );
    } else {
        ;
    }
}
#line 168
template < class _Ty, class _TVal >
__declspec ( noalias ) size_t _Count_vectorized ( _Ty * const _First, _Ty * const _Last, const _TVal _Val ) noexcept {
    if constexpr ( is_pointer_v < _TVal > || is_null_pointer_v < _TVal > ) {

        return :: __std_count_trivial_8 ( _First, _Last, reinterpret_cast < uint64_t > ( _Val ) );



    } else if constexpr ( sizeof ( _Ty ) == 1 ) {
        return :: __std_count_trivial_1 ( _First, _Last, static_cast < uint8_t > ( _Val ) );
    } else if constexpr ( sizeof ( _Ty ) == 2 ) {
        return :: __std_count_trivial_2 ( _First, _Last, static_cast < uint16_t > ( _Val ) );
    } else if constexpr ( sizeof ( _Ty ) == 4 ) {
        return :: __std_count_trivial_4 ( _First, _Last, static_cast < uint32_t > ( _Val ) );
    } else if constexpr ( sizeof ( _Ty ) == 8 ) {
        return :: __std_count_trivial_8 ( _First, _Last, static_cast < uint64_t > ( _Val ) );
    } else {
        ;
    }
}
#line 189 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Ty, class _TVal >
_Ty * _Find_vectorized ( _Ty * const _First, _Ty * const _Last, const _TVal _Val ) noexcept {
    if constexpr ( is_pointer_v < _TVal > || is_null_pointer_v < _TVal > ) {

        return const_cast < _Ty * > (
            static_cast < const _Ty * > ( :: __std_find_trivial_8 ( _First, _Last, reinterpret_cast < uint64_t > ( _Val ) ) ) );




    } else if constexpr ( sizeof ( _Ty ) == 1 ) {
        return const_cast < _Ty * > (
            static_cast < const _Ty * > ( :: __std_find_trivial_1 ( _First, _Last, static_cast < uint8_t > ( _Val ) ) ) );
    } else if constexpr ( sizeof ( _Ty ) == 2 ) {
        return const_cast < _Ty * > (
            static_cast < const _Ty * > ( :: __std_find_trivial_2 ( _First, _Last, static_cast < uint16_t > ( _Val ) ) ) );
    } else if constexpr ( sizeof ( _Ty ) == 4 ) {
        return const_cast < _Ty * > (
            static_cast < const _Ty * > ( :: __std_find_trivial_4 ( _First, _Last, static_cast < uint32_t > ( _Val ) ) ) );
    } else if constexpr ( sizeof ( _Ty ) == 8 ) {
        return const_cast < _Ty * > (
            static_cast < const _Ty * > ( :: __std_find_trivial_8 ( _First, _Last, static_cast < uint64_t > ( _Val ) ) ) );
    } else {
        ;
    }
}
#line 216 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Ty, class _TVal >
_Ty * _Find_last_vectorized ( _Ty * const _First, _Ty * const _Last, const _TVal _Val ) noexcept {
    if constexpr ( is_pointer_v < _TVal > || is_null_pointer_v < _TVal > ) {

        return const_cast < _Ty * > (
            static_cast < const _Ty * > ( :: __std_find_last_trivial_8 ( _First, _Last, reinterpret_cast < uint64_t > ( _Val ) ) ) );




    } else if constexpr ( sizeof ( _Ty ) == 1 ) {
        return const_cast < _Ty * > (
            static_cast < const _Ty * > ( :: __std_find_last_trivial_1 ( _First, _Last, static_cast < uint8_t > ( _Val ) ) ) );
    } else if constexpr ( sizeof ( _Ty ) == 2 ) {
        return const_cast < _Ty * > (
            static_cast < const _Ty * > ( :: __std_find_last_trivial_2 ( _First, _Last, static_cast < uint16_t > ( _Val ) ) ) );
    } else if constexpr ( sizeof ( _Ty ) == 4 ) {
        return const_cast < _Ty * > (
            static_cast < const _Ty * > ( :: __std_find_last_trivial_4 ( _First, _Last, static_cast < uint32_t > ( _Val ) ) ) );
    } else if constexpr ( sizeof ( _Ty ) == 8 ) {
        return const_cast < _Ty * > (
            static_cast < const _Ty * > ( :: __std_find_last_trivial_8 ( _First, _Last, static_cast < uint64_t > ( _Val ) ) ) );
    } else {
        ;
    }
}
#line 244 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
constexpr ptrdiff_t _Threshold_find_first_of = (16); 
#line 246
template < class _Ty1, class _Ty2 >
_Ty1 * _Search_vectorized ( _Ty1 * const _First1, _Ty1 * const _Last1, _Ty2 * const _First2, const size_t _Count2 ) noexcept {
    ;
    if constexpr ( sizeof ( _Ty1 ) == 1 ) {
        return const_cast < _Ty1 * > ( static_cast < const _Ty1 * > ( :: __std_search_1 ( _First1, _Last1, _First2, _Count2 ) ) );
    } else if constexpr ( sizeof ( _Ty1 ) == 2 ) {
        return const_cast < _Ty1 * > ( static_cast < const _Ty1 * > ( :: __std_search_2 ( _First1, _Last1, _First2, _Count2 ) ) );
    } else {
        ;
    }
}
#line 258
template < class _Ty1, class _Ty2 >
_Ty1 * _Find_end_vectorized (
    _Ty1 * const _First1, _Ty1 * const _Last1, _Ty2 * const _First2, const size_t _Count2 ) noexcept {
    ;
    if constexpr ( sizeof ( _Ty1 ) == 1 ) {
        return const_cast < _Ty1 * > ( static_cast < const _Ty1 * > ( :: __std_find_end_1 ( _First1, _Last1, _First2, _Count2 ) ) );
    } else if constexpr ( sizeof ( _Ty1 ) == 2 ) {
        return const_cast < _Ty1 * > ( static_cast < const _Ty1 * > ( :: __std_find_end_2 ( _First1, _Last1, _First2, _Count2 ) ) );
    } else {
        ;
    }
}
#line 271
template < class _Ty >
_Ty * _Min_element_vectorized ( _Ty * const _First, _Ty * const _Last ) noexcept {
    constexpr bool _Signed = is_signed_v < _Ty >;

    if constexpr ( is_same_v < remove_const_t < _Ty >, float > ) {
        return const_cast < _Ty * > ( static_cast < const _Ty * > ( :: __std_min_element_f ( _First, _Last, false ) ) );
    } else if constexpr ( _Is_any_of_v < remove_const_t < _Ty >, double, long double > ) {
        return const_cast < _Ty * > ( static_cast < const _Ty * > ( :: __std_min_element_d ( _First, _Last, false ) ) );
    } else if constexpr ( sizeof ( _Ty ) == 1 ) {
        return const_cast < _Ty * > ( static_cast < const _Ty * > ( :: __std_min_element_1 ( _First, _Last, _Signed ) ) );
    } else if constexpr ( sizeof ( _Ty ) == 2 ) {
        return const_cast < _Ty * > ( static_cast < const _Ty * > ( :: __std_min_element_2 ( _First, _Last, _Signed ) ) );
    } else if constexpr ( sizeof ( _Ty ) == 4 ) {
        return const_cast < _Ty * > ( static_cast < const _Ty * > ( :: __std_min_element_4 ( _First, _Last, _Signed ) ) );
    } else if constexpr ( sizeof ( _Ty ) == 8 ) {
        return const_cast < _Ty * > ( static_cast < const _Ty * > ( :: __std_min_element_8 ( _First, _Last, _Signed ) ) );
    } else {
        ;
    }
}
#line 292
template < class _Ty >
_Ty * _Max_element_vectorized ( _Ty * const _First, _Ty * const _Last ) noexcept {
    constexpr bool _Signed = is_signed_v < _Ty >;

    if constexpr ( is_same_v < remove_const_t < _Ty >, float > ) {
        return const_cast < _Ty * > ( static_cast < const _Ty * > ( :: __std_max_element_f ( _First, _Last, false ) ) );
    } else if constexpr ( _Is_any_of_v < remove_const_t < _Ty >, double, long double > ) {
        return const_cast < _Ty * > ( static_cast < const _Ty * > ( :: __std_max_element_d ( _First, _Last, false ) ) );
    } else if constexpr ( sizeof ( _Ty ) == 1 ) {
        return const_cast < _Ty * > ( static_cast < const _Ty * > ( :: __std_max_element_1 ( _First, _Last, _Signed ) ) );
    } else if constexpr ( sizeof ( _Ty ) == 2 ) {
        return const_cast < _Ty * > ( static_cast < const _Ty * > ( :: __std_max_element_2 ( _First, _Last, _Signed ) ) );
    } else if constexpr ( sizeof ( _Ty ) == 4 ) {
        return const_cast < _Ty * > ( static_cast < const _Ty * > ( :: __std_max_element_4 ( _First, _Last, _Signed ) ) );
    } else if constexpr ( sizeof ( _Ty ) == 8 ) {
        return const_cast < _Ty * > ( static_cast < const _Ty * > ( :: __std_max_element_8 ( _First, _Last, _Signed ) ) );
    } else {
        ;
    }
}
#line 313
template < class _Ty >
auto _Min_vectorized ( _Ty * const _First, _Ty * const _Last ) noexcept {
    constexpr bool _Signed = is_signed_v < _Ty >;

    if constexpr ( is_pointer_v < _Ty > ) {

        return reinterpret_cast < void * > ( :: __std_min_8u ( _First, _Last ) );



    } else if constexpr ( is_same_v < remove_const_t < _Ty >, float > ) {
        return :: __std_min_f ( _First, _Last );
    } else if constexpr ( _Is_any_of_v < remove_const_t < _Ty >, double, long double > ) {
        return :: __std_min_d ( _First, _Last );
    } else if constexpr ( sizeof ( _Ty ) == 1 ) {
        if constexpr ( _Signed ) {
            return :: __std_min_1i ( _First, _Last );
        } else {
            return :: __std_min_1u ( _First, _Last );
        }
    } else if constexpr ( sizeof ( _Ty ) == 2 ) {
        if constexpr ( _Signed ) {
            return :: __std_min_2i ( _First, _Last );
        } else {
            return :: __std_min_2u ( _First, _Last );
        }
    } else if constexpr ( sizeof ( _Ty ) == 4 ) {
        if constexpr ( _Signed ) {
            return :: __std_min_4i ( _First, _Last );
        } else {
            return :: __std_min_4u ( _First, _Last );
        }
    } else if constexpr ( sizeof ( _Ty ) == 8 ) {
        if constexpr ( _Signed ) {
            return :: __std_min_8i ( _First, _Last );
        } else {
            return :: __std_min_8u ( _First, _Last );
        }
    } else {
        ;
    }
}
#line 356 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Ty >
auto _Max_vectorized ( _Ty * const _First, _Ty * const _Last ) noexcept {
    constexpr bool _Signed = is_signed_v < _Ty >;

    if constexpr ( is_pointer_v < _Ty > ) {

        return reinterpret_cast < void * > ( :: __std_max_8u ( _First, _Last ) );



    } else if constexpr ( is_same_v < remove_const_t < _Ty >, float > ) {
        return :: __std_max_f ( _First, _Last );
    } else if constexpr ( _Is_any_of_v < remove_const_t < _Ty >, double, long double > ) {
        return :: __std_max_d ( _First, _Last );
    } else if constexpr ( sizeof ( _Ty ) == 1 ) {
        if constexpr ( _Signed ) {
            return :: __std_max_1i ( _First, _Last );
        } else {
            return :: __std_max_1u ( _First, _Last );
        }
    } else if constexpr ( sizeof ( _Ty ) == 2 ) {
        if constexpr ( _Signed ) {
            return :: __std_max_2i ( _First, _Last );
        } else {
            return :: __std_max_2u ( _First, _Last );
        }
    } else if constexpr ( sizeof ( _Ty ) == 4 ) {
        if constexpr ( _Signed ) {
            return :: __std_max_4i ( _First, _Last );
        } else {
            return :: __std_max_4u ( _First, _Last );
        }
    } else if constexpr ( sizeof ( _Ty ) == 8 ) {
        if constexpr ( _Signed ) {
            return :: __std_max_8i ( _First, _Last );
        } else {
            return :: __std_max_8u ( _First, _Last );
        }
    } else {
        ;
    }
}
#line 399 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < size_t _Element_size >
inline size_t
    _Mismatch_vectorized ( const void * const _First1, const void * const _First2, const size_t _Count ) noexcept {
    if constexpr ( _Element_size == 1 ) {
        return __std_mismatch_1 ( _First1, _First2, _Count );
    } else if constexpr ( _Element_size == 2 ) {
        return __std_mismatch_2 ( _First1, _First2, _Count );
    } else if constexpr ( _Element_size == 4 ) {
        return __std_mismatch_4 ( _First1, _First2, _Count );
    } else if constexpr ( _Element_size == 8 ) {
        return __std_mismatch_8 ( _First1, _First2, _Count );
    } else {
        ;
    }
}
#line 414
}
#line 418 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
namespace std { 
#line 420
template< class _Ty> struct _Get_first_parameter; 
#line 423
template< template< class , class ...>  class _Ty, class _First, class ..._Rest> 
#line 424
struct _Get_first_parameter< _Ty< _First, _Rest...> >  { 
#line 425
using type = _First; 
#line 426
}; 
#line 428
template< class _Newfirst, class _Ty> struct _Replace_first_parameter; 
#line 431
template< class _Newfirst, template< class , class ...>  class _Ty, class _First, class ..._Rest> 
#line 432
struct _Replace_first_parameter< _Newfirst, _Ty< _First, _Rest...> >  { 
#line 433
using type = _Ty< _Newfirst, _Rest...> ; 
#line 434
}; 
#line 436
template< class _Ty, class  = void> 
#line 437
struct _Get_ptr_difference_type { 
#line 438
using type = ptrdiff_t; 
#line 439
}; 
#line 441
template< class _Ty> 
#line 442
struct _Get_ptr_difference_type< _Ty, void_t< typename _Ty::difference_type> >  { 
#line 443
using type = typename _Ty::difference_type; 
#line 444
}; 
#line 446
template< class _Ty, class _Other, class  = void> 
#line 447
struct _Get_rebind_alias { 
#line 448
using type = typename _Replace_first_parameter< _Other, _Ty> ::type; 
#line 449
}; 
#line 451
template< class _Ty, class _Other> 
#line 452
struct _Get_rebind_alias< _Ty, _Other, void_t< typename _Ty::template rebind< _Other> > >  { 
#line 453
using type = typename _Ty::template rebind< _Other> ; 
#line 454
}; 
#line 467 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Ty, class ... _Types >
inline void _Construct_in_place ( _Ty & _Obj, _Types && ... _Args )
    noexcept ( is_nothrow_constructible_v < _Ty, _Types ... > ) {





    {
        :: new ( static_cast < void * > ( :: std :: addressof ( _Obj ) ) ) _Ty ( :: std :: forward < _Types > ( _Args ) ... );
    }
}
#line 480 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Ty >
void _Default_construct_in_place ( _Ty & _Obj ) noexcept ( is_nothrow_default_constructible_v < _Ty > ) {
    :: new ( static_cast < void * > ( :: std :: addressof ( _Obj ) ) ) _Ty;
}
#line 485
template < class _Ty, class _Elem >
struct _Ptr_traits_base {
    using pointer = _Ty;
    using element_type = _Elem;
    using difference_type = typename _Get_ptr_difference_type < _Ty > :: type;

    template < class _Other >
    using rebind = typename _Get_rebind_alias < _Ty, _Other > :: type;

    using _Reftype = conditional_t < is_void_v < _Elem >, char, _Elem > &;

    [ [ nodiscard ] ] static inline pointer pointer_to ( _Reftype _Val )
        noexcept ( noexcept ( _Ty :: pointer_to ( _Val ) ) ) {
        return _Ty :: pointer_to ( _Val );
    }
};
#line 502
template< class , class  = void, class  = void> 
#line 503
struct _Ptr_traits_sfinae_layer { }; 
#line 505
template< class _Ty, class _Uty> 
#line 506
struct _Ptr_traits_sfinae_layer< _Ty, _Uty, void_t< typename _Get_first_parameter< _Ty> ::type> >  : public _Ptr_traits_base< _Ty, typename _Get_first_parameter< _Ty> ::type>  { 
#line 507
}; 
#line 509
template< class _Ty> 
#line 510
struct _Ptr_traits_sfinae_layer< _Ty, void_t< typename _Ty::element_type> , void>  : public _Ptr_traits_base< _Ty, typename _Ty::element_type>  { 
#line 511
}; 
#line 513
template< class _Ty> 
#line 514
struct pointer_traits : public _Ptr_traits_sfinae_layer< _Ty>  { }; 
#line 516
template < class _Ty >
struct pointer_traits < _Ty * > {
    using pointer = _Ty *;
    using element_type = _Ty;
    using difference_type = ptrdiff_t;

    template < class _Other >
    using rebind = _Other *;

    using _Reftype = conditional_t < is_void_v < _Ty >, char, _Ty > &;

    [ [ nodiscard ] ] static inline pointer pointer_to ( _Reftype _Val ) noexcept {
        return :: std :: addressof ( _Val );
    }
};
#line 564 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Ty = void >
struct plus {
    using first_argument_type = _Ty;
    using second_argument_type = _Ty;
    using result_type = _Ty;

    [ [ nodiscard ] ] constexpr _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const {
        return _Left + _Right;
    }
};
#line 575
template < class _Ty = void >
struct minus {
    using first_argument_type = _Ty;
    using second_argument_type = _Ty;
    using result_type = _Ty;

    [ [ nodiscard ] ] constexpr _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const {
        return _Left - _Right;
    }
};
#line 586
template < class _Ty = void >
struct multiplies {
    using first_argument_type = _Ty;
    using second_argument_type = _Ty;
    using result_type = _Ty;

    [ [ nodiscard ] ] constexpr _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const {
        return _Left * _Right;
    }
};
#line 597
template < class _Ty = void >
struct equal_to {
    using first_argument_type = _Ty;
    using second_argument_type = _Ty;
    using result_type = bool;

    [ [ nodiscard ] ] constexpr bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
        noexcept ( noexcept ( :: std :: _Fake_copy_init < bool > ( _Left == _Right ) ) ) {
        return _Left == _Right;
    }
};
#line 609
template < class _Ty = void >
struct not_equal_to {
    using first_argument_type = _Ty;
    using second_argument_type = _Ty;
    using result_type = bool;

    [ [ nodiscard ] ] constexpr bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
        noexcept ( noexcept ( :: std :: _Fake_copy_init < bool > ( _Left != _Right ) ) ) {
        return _Left != _Right;
    }
};
#line 621
template < class _Ty = void >
struct greater {
    using first_argument_type = _Ty;
    using second_argument_type = _Ty;
    using result_type = bool;

    [ [ nodiscard ] ] constexpr bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
        noexcept ( noexcept ( :: std :: _Fake_copy_init < bool > ( _Left > _Right ) ) ) {
        return _Left > _Right;
    }
};
#line 633
template < class _Ty = void >
struct greater_equal {
    using first_argument_type = _Ty;
    using second_argument_type = _Ty;
    using result_type = bool;

    [ [ nodiscard ] ] constexpr bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
        noexcept ( noexcept ( :: std :: _Fake_copy_init < bool > ( _Left >= _Right ) ) ) {
        return _Left >= _Right;
    }
};
#line 645
template < class _Ty = void >
struct less_equal {
    using first_argument_type = _Ty;
    using second_argument_type = _Ty;
    using result_type = bool;

    [ [ nodiscard ] ] constexpr bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
        noexcept ( noexcept ( :: std :: _Fake_copy_init < bool > ( _Left <= _Right ) ) ) {
        return _Left <= _Right;
    }
};
#line 658
template<> struct plus< void>  { 
#line 659
template < class _Ty1, class _Ty2 >
    [ [ nodiscard ] ] constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
        noexcept ( noexcept ( static_cast < _Ty1 && > ( _Left ) + static_cast < _Ty2 && > ( _Right ) ) )
        -> decltype ( static_cast < _Ty1 && > ( _Left ) + static_cast < _Ty2 && > ( _Right ) ) {
        return static_cast < _Ty1 && > ( _Left ) + static_cast < _Ty2 && > ( _Right );
    }
#line 666
using is_transparent = int; 
#line 667
}; 
#line 670
template<> struct minus< void>  { 
#line 671
template < class _Ty1, class _Ty2 >
    [ [ nodiscard ] ] constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
        noexcept ( noexcept ( static_cast < _Ty1 && > ( _Left ) - static_cast < _Ty2 && > ( _Right ) ) )
        -> decltype ( static_cast < _Ty1 && > ( _Left ) - static_cast < _Ty2 && > ( _Right ) ) {
        return static_cast < _Ty1 && > ( _Left ) - static_cast < _Ty2 && > ( _Right );
    }
#line 678
using is_transparent = int; 
#line 679
}; 
#line 682
template<> struct multiplies< void>  { 
#line 683
template < class _Ty1, class _Ty2 >
    [ [ nodiscard ] ] constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
        noexcept ( noexcept ( static_cast < _Ty1 && > ( _Left ) * static_cast < _Ty2 && > ( _Right ) ) )
        -> decltype ( static_cast < _Ty1 && > ( _Left ) * static_cast < _Ty2 && > ( _Right ) ) {
        return static_cast < _Ty1 && > ( _Left ) * static_cast < _Ty2 && > ( _Right );
    }
#line 690
using is_transparent = int; 
#line 691
}; 
#line 694
template<> struct equal_to<>  { 
#line 695
template < class _Ty1, class _Ty2 >
    [ [ nodiscard ] ] constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
        noexcept ( noexcept ( static_cast < _Ty1 && > ( _Left ) == static_cast < _Ty2 && > ( _Right ) ) )
        -> decltype ( static_cast < _Ty1 && > ( _Left ) == static_cast < _Ty2 && > ( _Right ) ) {
        return static_cast < _Ty1 && > ( _Left ) == static_cast < _Ty2 && > ( _Right );
    }
#line 702
using is_transparent = int; 
#line 703
}; 
#line 706
template<> struct not_equal_to< void>  { 
#line 707
template < class _Ty1, class _Ty2 >
    [ [ nodiscard ] ] constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
        noexcept ( noexcept ( static_cast < _Ty1 && > ( _Left ) != static_cast < _Ty2 && > ( _Right ) ) )
        -> decltype ( static_cast < _Ty1 && > ( _Left ) != static_cast < _Ty2 && > ( _Right ) ) {
        return static_cast < _Ty1 && > ( _Left ) != static_cast < _Ty2 && > ( _Right );
    }
#line 714
using is_transparent = int; 
#line 715
}; 
#line 718
template<> struct greater<>  { 
#line 719
template < class _Ty1, class _Ty2 >
    [ [ nodiscard ] ] constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
        noexcept ( noexcept ( static_cast < _Ty1 && > ( _Left ) > static_cast < _Ty2 && > ( _Right ) ) )
        -> decltype ( static_cast < _Ty1 && > ( _Left ) > static_cast < _Ty2 && > ( _Right ) ) {
        return static_cast < _Ty1 && > ( _Left ) > static_cast < _Ty2 && > ( _Right );
    }
#line 726
using is_transparent = int; 
#line 727
}; 
#line 730
template<> struct greater_equal< void>  { 
#line 731
template < class _Ty1, class _Ty2 >
    [ [ nodiscard ] ] constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
        noexcept ( noexcept ( static_cast < _Ty1 && > ( _Left ) >= static_cast < _Ty2 && > ( _Right ) ) )
        -> decltype ( static_cast < _Ty1 && > ( _Left ) >= static_cast < _Ty2 && > ( _Right ) ) {
        return static_cast < _Ty1 && > ( _Left ) >= static_cast < _Ty2 && > ( _Right );
    }
#line 738
using is_transparent = int; 
#line 739
}; 
#line 742
template<> struct less_equal< void>  { 
#line 743
template < class _Ty1, class _Ty2 >
    [ [ nodiscard ] ] constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
        noexcept ( noexcept ( static_cast < _Ty1 && > ( _Left ) <= static_cast < _Ty2 && > ( _Right ) ) )
        -> decltype ( static_cast < _Ty1 && > ( _Left ) <= static_cast < _Ty2 && > ( _Right ) ) {
        return static_cast < _Ty1 && > ( _Left ) <= static_cast < _Ty2 && > ( _Right );
    }
#line 750
using is_transparent = int; 
#line 751
}; 
#line 753
template< class _Fx> 
#line 754
struct _Ref_fn { 
#line 757
template < class ... _Args >
    constexpr decltype ( auto ) operator ( ) ( _Args && ... _Vals ) noexcept (
        _Select_invoke_traits < _Fx &, _Args ... > :: _Is_nothrow_invocable :: value ) {
        if constexpr ( is_member_pointer_v < _Fx > ) {
            return :: std :: invoke ( _Fn, :: std :: forward < _Args > ( _Vals ) ... );
        } else {
            return _Fn ( :: std :: forward < _Args > ( _Vals ) ... );
        }
    }
#line 767
_Fx &_Fn; 
#line 768
}; 
#line 770
template < class _Fn >
[ [ nodiscard ] ] constexpr auto _Pass_fn ( _Fn & _Func ) noexcept {
    constexpr bool _Pass_by_value = conjunction_v < bool_constant < sizeof ( _Fn ) <= sizeof ( void * ) >,
        is_trivially_copy_constructible < _Fn >, is_trivially_destructible < _Fn >>;
    if constexpr ( _Pass_by_value ) {
        return _Func;
    } else {
        return _Ref_fn < _Fn > { _Func };
    }
}
#line 794 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
struct _Unused_parameter { 
#line 795
constexpr _Unused_parameter() noexcept = default;
#line 796
template < class _Ty >
    constexpr _Unused_parameter ( _Ty && ) noexcept { }
#line 798
}; 
#line 800
template< class _Ty> using _Algorithm_int_t = conditional_t< is_integral_v< _Ty> , _Ty, __int64> ; 
#line 1238 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class _Iter> using _Iter_ref_t = typename iterator_traits< _Iter> ::reference; 
#line 1241
template< class _Iter> using _Iter_value_t = typename iterator_traits< _Iter> ::value_type; 
#line 1244
template< class _Iter> using _Iter_diff_t = typename iterator_traits< _Iter> ::difference_type; 
#line 1247
template< class _Ty> using _Make_unsigned_like_t = make_unsigned_t< _Ty> ; 
#line 1251 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class ..._Iters> using _Common_diff_t = common_type_t< _Iter_diff_t< _Iters> ...> ; 
#line 1254
template< class _Iter> using _Iter_cat_t = typename iterator_traits< _Iter> ::iterator_category; 
#line 1267 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class _Ty, class  = void> constexpr bool 
#line 1268
_Is_iterator_v = false; 
#line 1270
template< class _Ty> constexpr bool 
#line 1271
_Is_iterator_v< _Ty, void_t< _Iter_cat_t< _Ty> > >  = true; 
#line 1273
template< class _Ty> 
#line 1274
struct _Is_iterator : public bool_constant< _Is_iterator_v< _Ty, void> >  { }; 
#line 1277 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class _Iter> constexpr bool 
#line 1278
_Is_cpp17_input_iter_v = is_convertible_v< _Iter_cat_t< _Iter> , input_iterator_tag> ; 
#line 1280
template< class _Iter> constexpr bool 
#line 1281
_Is_ranges_input_iter_v = _Is_cpp17_input_iter_v< _Iter> ; 
#line 1287 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class _Iter> constexpr bool 
#line 1288
_Is_cpp17_fwd_iter_v = is_convertible_v< _Iter_cat_t< _Iter> , forward_iterator_tag> ; 
#line 1290
template< class _Iter> constexpr bool 
#line 1291
_Is_ranges_fwd_iter_v = _Is_cpp17_fwd_iter_v< _Iter> ; 
#line 1297 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class _Iter> constexpr bool 
#line 1298
_Is_cpp17_bidi_iter_v = is_convertible_v< _Iter_cat_t< _Iter> , bidirectional_iterator_tag> ; 
#line 1300
template< class _Iter> constexpr bool 
#line 1301
_Is_ranges_bidi_iter_v = _Is_cpp17_bidi_iter_v< _Iter> ; 
#line 1307 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class _Iter> constexpr bool 
#line 1308
_Is_cpp17_random_iter_v = is_convertible_v< _Iter_cat_t< _Iter> , random_access_iterator_tag> ; 
#line 1310
template< class _Iter> constexpr bool 
#line 1311
_Is_ranges_random_iter_v = _Is_cpp17_random_iter_v< _Iter> ; 
#line 1325 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class , class  = void> 
#line 1326
struct _Is_checked_helper { }; 
#line 1336 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class _Iter, class  = void> constexpr bool 
#line 1337
_Allow_inheriting_unwrap_v = true; 
#line 1339
template< class _Iter> constexpr bool 
#line 1340
_Allow_inheriting_unwrap_v< _Iter, void_t< typename _Iter::_Prevent_inheriting_unwrap> >  = is_same_v< _Iter, typename _Iter::_Prevent_inheriting_unwrap> ; 
#line 1343
template< class _Iter, class _Sentinel = _Iter, class  = void> constexpr bool 
#line 1344
_Range_verifiable_v = false; 
#line 1346
template< class _Iter, class _Sentinel> constexpr bool 
#line 1347
_Range_verifiable_v< _Iter, _Sentinel, void_t< decltype(_Verify_range(std::declval< const _Iter &> (), std::declval< const _Sentinel &> ()))> >  = _Allow_inheriting_unwrap_v< _Iter, void> ; 
#line 1351
template < class _Iter, class _Sentinel >
constexpr void _Adl_verify_range ( const _Iter & _First, const _Sentinel & _Last ) {

    if constexpr ( is_pointer_v < _Iter > && is_pointer_v < _Sentinel > ) {



    } else if constexpr ( _Range_verifiable_v < _Iter, _Sentinel > ) {
        _Verify_range ( _First, _Last );
    }
}
#line 1363 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class _Iter, class  = void> constexpr bool 
#line 1364
_Unwrappable_v = false; 
#line 1366
template< class _Iter> constexpr bool 
#line 1367
_Unwrappable_v< _Iter, void_t< decltype(std::declval< _Remove_cvref_t< _Iter>  &> ()._Seek_to(std::declval< _Iter> ()._Unwrapped()))> >  = _Allow_inheriting_unwrap_v< _Remove_cvref_t< _Iter> , void> ; 
#line 1371
template< class _Iter, class  = void> constexpr bool 
#line 1372
_Has_nothrow_unwrapped = false; 
#line 1373
template< class _Iter> constexpr bool 
#line 1374
_Has_nothrow_unwrapped< _Iter, void_t< decltype(std::declval< _Iter> ()._Unwrapped())> >  = noexcept(std::declval< _Iter> ()._Unwrapped()); 
#line 1377
template < class _Iter >
[ [ nodiscard ] ] constexpr decltype ( auto ) _Get_unwrapped ( _Iter && _It )
    noexcept ( ! _Unwrappable_v < _Iter > || _Has_nothrow_unwrapped < _Iter > ) {

    if constexpr ( is_pointer_v < decay_t < _Iter >> ) {
        return _It + 0;
    } else if constexpr ( _Unwrappable_v < _Iter > ) {
        return static_cast < _Iter && > ( _It ) . _Unwrapped ( );
    } else {
        return static_cast < _Iter && > ( _It );
    }
}
#line 1390
template< class _Iter> using _Unwrapped_t = _Remove_cvref_t< decltype(std::_Get_unwrapped(std::declval< _Iter> ()))> ; 
#line 1393
template< class _Iter, class  = bool> constexpr bool 
#line 1394
_Do_unwrap_when_unverified_v = false; 
#line 1396
template< class _Iter> constexpr bool 
#line 1397
_Do_unwrap_when_unverified_v< _Iter, decltype(static_cast< bool>(_Iter::_Unwrap_when_unverified))>  = (static_cast< bool>(_Iter::_Unwrap_when_unverified)); 
#line 1400
template< class _Iter> constexpr bool 
#line 1401
_Unwrappable_for_unverified_v = _Unwrappable_v< _Iter, void>  && _Do_unwrap_when_unverified_v< _Remove_cvref_t< _Iter> , bool> ; 
#line 1404
template < class _Iter >
[ [ nodiscard ] ] constexpr decltype ( auto ) _Get_unwrapped_unverified ( _Iter && _It ) {

    if constexpr ( is_pointer_v < decay_t < _Iter >> ) {
        return _It + 0;
    } else if constexpr ( _Unwrappable_for_unverified_v < _Iter > ) {
        return static_cast < _Iter && > ( _It ) . _Unwrapped ( );
    } else {
        return static_cast < _Iter && > ( _It );
    }
}
#line 1416
template< class _Iter> using _Unwrapped_unverified_t = _Remove_cvref_t< decltype(_Get_unwrapped_unverified(std::declval< _Iter> ()))> ; 
#line 1419
struct _Distance_unknown { 
#line 1420
constexpr _Distance_unknown operator-() const noexcept { 
#line 1421
return {}; 
#line 1422
} 
#line 1423
}; 
#line 1425
template< class _Diff> constexpr _Diff 
#line 1426
_Max_possible_v{((static_cast< _Make_unsigned_like_t< _Diff> >(-1)) >> 1)}; 
#line 1428
template< class _Diff> constexpr _Diff 
#line 1429
_Min_possible_v{((-_Max_possible_v< _Diff> ) - 1)}; 
#line 1431
template< class _Iter, class  = void> constexpr bool 
#line 1432
_Offset_verifiable_v = false; 
#line 1434
template< class _Iter> constexpr bool 
#line 1436
_Offset_verifiable_v< _Iter, void_t< decltype(std::declval< const _Iter &> ()._Verify_offset(_Iter_diff_t< _Iter> {}))> >  = true; 
#line 1439
template< class _Iter> constexpr bool 
#line 1440
_Unwrappable_for_offset_v = _Unwrappable_v< _Iter, void>  && _Offset_verifiable_v< _Remove_cvref_t< _Iter> , void> ; 
#line 1442
template < class _Iter, class _Diff >
[ [ nodiscard ] ] constexpr decltype ( auto ) _Get_unwrapped_n ( _Iter && _It, const _Diff _Off ) {
    if constexpr ( is_pointer_v < decay_t < _Iter >> ) {
        return _It + 0;
    } else if constexpr ( _Unwrappable_for_offset_v < _Iter > && _Integer_like < _Diff > ) {

        using _IDiff = _Iter_diff_t < _Remove_cvref_t < _Iter >>;
        using _CDiff = common_type_t < _Diff, _IDiff >;
        const auto _COff = static_cast < _CDiff > ( _Off );

        ;

        ( void ) _COff;

        _It . _Verify_offset ( static_cast < _IDiff > ( _Off ) );
        return static_cast < _Iter && > ( _It ) . _Unwrapped ( );
    } else if constexpr ( _Unwrappable_for_unverified_v < _Iter > ) {

        return static_cast < _Iter && > ( _It ) . _Unwrapped ( );
    } else {

        return static_cast < _Iter && > ( _It );
    }
}
#line 1468 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class _Iter, class _UIter, class  = void> constexpr bool 
#line 1469
_Wrapped_seekable_v = false; 
#line 1471
template< class _Iter, class _UIter> constexpr bool 
#line 1473
_Wrapped_seekable_v< _Iter, _UIter, void_t< decltype(std::declval< _Iter &> ()._Seek_to(std::declval< _UIter> ()))> >  = true; 
#line 1476
template < class _Iter, class _UIter >
constexpr void _Seek_wrapped ( _Iter & _It, _UIter && _UIt ) {
    if constexpr ( _Wrapped_seekable_v < _Iter, _UIter > ) {
        _It . _Seek_to ( :: std :: forward < _UIter > ( _UIt ) );
    } else {
        _It = :: std :: forward < _UIter > ( _UIt );
    }
}
#line 1549 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Checked, class _Iter >
[ [ nodiscard ] ] constexpr auto _Idl_distance ( const _Iter & _First, const _Iter & _Last ) {


    ;
    if constexpr ( _Is_ranges_random_iter_v < _Iter > ) {
        return static_cast < _Iter_diff_t < _Checked >> ( _Last - _First );
    } else {
        return _Distance_unknown { };
    }
}
#line 1561
template< class _Elem, bool _Is_enum = is_enum_v< _Elem> > 
#line 1562
struct _Unwrap_enum { 
#line 1563
using type = underlying_type_t< _Elem> ; 
#line 1564
}; 
#line 1566
template< class _Elem> 
#line 1567
struct _Unwrap_enum< _Elem, false>  { 
#line 1568
using type = _Elem; 
#line 1569
}; 
#line 1571
template< class _Elem> using _Unwrap_enum_t = typename _Unwrap_enum< _Elem> ::type; 
#line 1631 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _InIt, class _Diff >
inline void advance ( _InIt & _Where, _Diff _Off ) {
    if constexpr ( _Is_ranges_random_iter_v < _InIt > ) {
        _Where += _Off;
    } else {
        if constexpr ( is_signed_v < _Diff > && ! _Is_ranges_bidi_iter_v < _InIt > ) {
            ;
        }

        decltype ( auto ) _UWhere = :: std :: _Get_unwrapped_n ( :: std :: move ( _Where ), _Off );
        constexpr bool _Need_rewrap = ! is_reference_v < decltype ( :: std :: _Get_unwrapped_n ( :: std :: move ( _Where ), _Off ) ) >;

        if constexpr ( is_signed_v < _Diff > && _Is_ranges_bidi_iter_v < _InIt > ) {
            for (; _Off < 0; ++ _Off ) {
                -- _UWhere;
            }
        }

        for (; 0 < _Off; -- _Off ) {
            ++ _UWhere;
        }

        if constexpr ( _Need_rewrap ) {
            :: std :: _Seek_wrapped ( _Where, :: std :: move ( _UWhere ) );
        }
    }
}
#line 1659
template < class _InIt >
[ [ nodiscard ] ] inline _Iter_diff_t < _InIt > distance ( _InIt _First, _InIt _Last ) {
    if constexpr ( _Is_ranges_random_iter_v < _InIt > ) {
        return _Last - _First;
    } else {
        :: std :: _Adl_verify_range ( _First, _Last );
        auto _UFirst = :: std :: _Get_unwrapped ( _First );
        const auto _ULast = :: std :: _Get_unwrapped ( _Last );
        _Iter_diff_t < _InIt > _Off = 0;
        for (; _UFirst != _ULast; ++ _UFirst ) {
            ++ _Off;
        }

        return _Off;
    }
}
#line 1676
template < class _InIt >
constexpr _InIt _Next_iter ( _InIt _First ) {
    return ++ _First;
}
#line 1681
template < class _InIt >
[ [ nodiscard ] ] inline _InIt next (
    _InIt _First, typename iterator_traits < _InIt > :: difference_type _Off = 1 ) {
    static_assert ( _Is_ranges_input_iter_v < _InIt >, "next requires input iterator" );

    :: std :: advance ( _First, _Off );
    return _First;
}
#line 1690
template < class _BidIt >
constexpr _BidIt _Prev_iter ( _BidIt _First ) {
    return -- _First;
}
#line 1695
template < class _BidIt >
[ [ nodiscard ] ] inline _BidIt prev (
    _BidIt _First, typename iterator_traits < _BidIt > :: difference_type _Off = 1 ) {
    static_assert ( _Is_ranges_bidi_iter_v < _BidIt >, "prev requires bidirectional iterator" );

    :: std :: advance ( _First, - _Off );
    return _First;
}
#line 1704
template< class _Iter, class _Pointer, bool  = is_pointer_v< _Remove_cvref_t< _Iter> > > constexpr bool 
#line 1705
_Has_nothrow_operator_arrow = _Is_nothrow_convertible_v< _Iter, _Pointer, is_convertible_v< _Iter, _Pointer> , is_void_v< _Pointer> > ; 
#line 1707
template< class _Iter, class _Pointer> constexpr bool 
#line 1708
_Has_nothrow_operator_arrow< _Iter, _Pointer, false>  = noexcept(std::_Fake_copy_init< _Pointer> (std::declval< _Iter> ().operator->())); 
#line 1711
template < class _BidIt >
class reverse_iterator {
public :
    using iterator_type = _BidIt;







    using iterator_category = _Iter_cat_t < _BidIt >;

    using value_type = _Iter_value_t < _BidIt >;
    using difference_type = _Iter_diff_t < _BidIt >;
    using pointer = typename iterator_traits < _BidIt > :: pointer;
    using reference = _Iter_ref_t < _BidIt >;

    template < class >
    friend class reverse_iterator;

    inline reverse_iterator ( ) = default;

    inline explicit reverse_iterator ( _BidIt _Right )
        noexcept ( is_nothrow_move_constructible_v < _BidIt > )
        : current ( :: std :: move ( _Right ) ) { }

    template < class _Other >



    inline reverse_iterator ( const reverse_iterator < _Other > & _Right )
        noexcept ( is_nothrow_constructible_v < _BidIt, const _Other & > )
        : current ( _Right . current ) {
    }

    template < class _Other >




    inline reverse_iterator & operator = ( const reverse_iterator < _Other > & _Right )
        noexcept ( is_nothrow_assignable_v < _BidIt &, const _Other & > ) {
        current = _Right . current;
        return * this;
    }

    [ [ nodiscard ] ] inline _BidIt base ( ) const noexcept ( is_nothrow_copy_constructible_v < _BidIt > ) {
        return current;
    }

    [ [ nodiscard ] ] inline reference operator * ( ) const
        noexcept ( is_nothrow_copy_constructible_v < _BidIt > && noexcept ( * -- ( :: std :: declval < _BidIt & > ( ) ) ) ) {
        _BidIt _Tmp = current;
        return * -- _Tmp;
    }

    [ [ nodiscard ] ] inline pointer operator -> ( ) const
        noexcept ( is_nothrow_copy_constructible_v < _BidIt > && noexcept ( -- ( :: std :: declval < _BidIt & > ( ) ) )
                 && _Has_nothrow_operator_arrow < _BidIt &, pointer > )



    {
        _BidIt _Tmp = current;
        -- _Tmp;
        if constexpr ( is_pointer_v < _BidIt > ) {
            return _Tmp;
        } else {
            return _Tmp . operator -> ( );
        }
    }

    inline reverse_iterator & operator ++ ( ) noexcept ( noexcept ( -- current ) ) {
        -- current;
        return * this;
    }

    inline reverse_iterator operator ++ ( int ) noexcept ( is_nothrow_copy_constructible_v < _BidIt >
                                                           && noexcept ( -- current ) ) {
        reverse_iterator _Tmp = * this;
        -- current;
        return _Tmp;
    }

    inline reverse_iterator & operator -- ( ) noexcept ( noexcept ( ++ current ) ) {
        ++ current;
        return * this;
    }

    inline reverse_iterator operator -- ( int ) noexcept ( is_nothrow_copy_constructible_v < _BidIt >
                                                           && noexcept ( ++ current ) ) {
        reverse_iterator _Tmp = * this;
        ++ current;
        return _Tmp;
    }

    [ [ nodiscard ] ] inline reverse_iterator operator + ( const difference_type _Off ) const
        noexcept ( noexcept ( reverse_iterator ( current - _Off ) ) ) {
        return reverse_iterator ( current - _Off );
    }

    inline reverse_iterator & operator += ( const difference_type _Off )
        noexcept ( noexcept ( current -= _Off ) ) {
        current -= _Off;
        return * this;
    }

    [ [ nodiscard ] ] inline reverse_iterator operator - ( const difference_type _Off ) const
        noexcept ( noexcept ( reverse_iterator ( current + _Off ) ) ) {
        return reverse_iterator ( current + _Off );
    }

    inline reverse_iterator & operator -= ( const difference_type _Off )
        noexcept ( noexcept ( current += _Off ) ) {
        current += _Off;
        return * this;
    }

    [ [ nodiscard ] ] inline reference operator [ ] ( const difference_type _Off ) const
        noexcept ( noexcept ( :: std :: _Fake_copy_init < reference > ( current [ _Off ] ) ) ) {
        return current [ static_cast < difference_type > ( - _Off - 1 ) ];
    }





















    using _Prevent_inheriting_unwrap = reverse_iterator;

    template < class _BidIt2, enable_if_t < _Range_verifiable_v < _BidIt, _BidIt2 >, int > = 0 >
    friend constexpr void _Verify_range (
        const reverse_iterator & _First, const reverse_iterator < _BidIt2 > & _Last ) noexcept {
        _Verify_range ( _Last . _Get_current ( ), _First . current );
    }

    template < class _BidIt2 = _BidIt, enable_if_t < _Offset_verifiable_v < _BidIt2 >, int > = 0 >
    constexpr void _Verify_offset ( const difference_type _Off ) const noexcept {
        if ( ! ( _Off != _Min_possible_v < difference_type > ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };
        current . _Verify_offset ( - _Off );
    }

    template < class _BidIt2 = _BidIt, enable_if_t < _Unwrappable_v < const _BidIt2 & >, int > = 0 >
    [ [ nodiscard ] ] constexpr reverse_iterator < _Unwrapped_t < const _BidIt2 & >> _Unwrapped ( ) const & noexcept (
        noexcept ( static_cast < reverse_iterator < _Unwrapped_t < const _BidIt2 & >> > ( current . _Unwrapped ( ) ) ) ) {
        return static_cast < reverse_iterator < _Unwrapped_t < const _BidIt2 & >> > ( current . _Unwrapped ( ) );
    }
    template < class _BidIt2 = _BidIt, enable_if_t < _Unwrappable_v < _BidIt2 >, int > = 0 >
    [ [ nodiscard ] ] constexpr reverse_iterator < _Unwrapped_t < _BidIt2 >> _Unwrapped ( ) && noexcept (
        noexcept ( static_cast < reverse_iterator < _Unwrapped_t < _BidIt2 >> > ( :: std :: move ( current ) . _Unwrapped ( ) ) ) ) {
        return static_cast < reverse_iterator < _Unwrapped_t < _BidIt2 >> > ( :: std :: move ( current ) . _Unwrapped ( ) );
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v < _BidIt >;

    template < class _Src, enable_if_t < _Wrapped_seekable_v < _BidIt, const _Src & >, int > = 0 >
    constexpr void _Seek_to ( const reverse_iterator < _Src > & _It ) noexcept ( noexcept ( current . _Seek_to ( _It . current ) ) ) {
        current . _Seek_to ( _It . current );
    }

    [ [ nodiscard ] ] constexpr const _BidIt & _Get_current ( ) const noexcept {
        return current;
    }

protected :
    _BidIt current { };
};
#line 1895 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _BidIt1, class _BidIt2 >
[ [ nodiscard ] ] inline bool operator == ( const reverse_iterator < _BidIt1 > & _Left, const reverse_iterator < _BidIt2 > & _Right )
    noexcept ( noexcept ( :: std :: _Fake_copy_init < bool > ( _Left . _Get_current ( ) == _Right . _Get_current ( ) ) ) )





{
    return _Left . _Get_current ( ) == _Right . _Get_current ( );
}
#line 1907 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _BidIt1, class _BidIt2 >
[ [ nodiscard ] ] inline bool operator != ( const reverse_iterator < _BidIt1 > & _Left, const reverse_iterator < _BidIt2 > & _Right )
    noexcept ( noexcept ( :: std :: _Fake_copy_init < bool > ( _Left . _Get_current ( ) != _Right . _Get_current ( ) ) ) )





{
    return _Left . _Get_current ( ) != _Right . _Get_current ( );
}
#line 1919 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _BidIt1, class _BidIt2 >
[ [ nodiscard ] ] inline bool operator < ( const reverse_iterator < _BidIt1 > & _Left, const reverse_iterator < _BidIt2 > & _Right )
    noexcept ( noexcept ( :: std :: _Fake_copy_init < bool > ( _Left . _Get_current ( ) > _Right . _Get_current ( ) ) ) )





{
    return _Left . _Get_current ( ) > _Right . _Get_current ( );
}
#line 1931 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _BidIt1, class _BidIt2 >
[ [ nodiscard ] ] inline bool operator > ( const reverse_iterator < _BidIt1 > & _Left, const reverse_iterator < _BidIt2 > & _Right )
    noexcept ( noexcept ( :: std :: _Fake_copy_init < bool > ( _Left . _Get_current ( ) < _Right . _Get_current ( ) ) ) )





{
    return _Left . _Get_current ( ) < _Right . _Get_current ( );
}
#line 1943 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _BidIt1, class _BidIt2 >
[ [ nodiscard ] ] inline bool operator <= ( const reverse_iterator < _BidIt1 > & _Left, const reverse_iterator < _BidIt2 > & _Right )
    noexcept ( noexcept ( :: std :: _Fake_copy_init < bool > ( _Left . _Get_current ( ) >= _Right . _Get_current ( ) ) ) )





{
    return _Left . _Get_current ( ) >= _Right . _Get_current ( );
}
#line 1955 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _BidIt1, class _BidIt2 >
[ [ nodiscard ] ] inline bool operator >= ( const reverse_iterator < _BidIt1 > & _Left, const reverse_iterator < _BidIt2 > & _Right )
    noexcept ( noexcept ( :: std :: _Fake_copy_init < bool > ( _Left . _Get_current ( ) <= _Right . _Get_current ( ) ) ) )





{
    return _Left . _Get_current ( ) <= _Right . _Get_current ( );
}
#line 1976 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _BidIt1, class _BidIt2 >
[ [ nodiscard ] ] inline auto operator - ( const reverse_iterator < _BidIt1 > & _Left, const reverse_iterator < _BidIt2 > & _Right )
    noexcept ( noexcept ( _Right . _Get_current ( ) - _Left . _Get_current ( ) ) )
    -> decltype ( _Right . _Get_current ( ) - _Left . _Get_current ( ) ) {
    return _Right . _Get_current ( ) - _Left . _Get_current ( );
}
#line 1983
template < class _BidIt >
[ [ nodiscard ] ] inline reverse_iterator < _BidIt > operator + ( typename reverse_iterator < _BidIt > :: difference_type _Off,
    const reverse_iterator < _BidIt > & _Right ) noexcept ( noexcept ( _Right + _Off ) ) {
    return _Right + _Off;
}
#line 1989
template < class _BidIt >
[ [ nodiscard ] ] inline reverse_iterator < _BidIt > make_reverse_iterator ( _BidIt _Iter )
    noexcept ( is_nothrow_move_constructible_v < _BidIt > ) {
    return reverse_iterator < _BidIt > ( :: std :: move ( _Iter ) );
}
#line 2001 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Container >
[ [ nodiscard ] ] inline auto begin ( _Container & _Cont ) noexcept ( noexcept ( _Cont . begin ( ) ) )
    -> decltype ( _Cont . begin ( ) ) {
    return _Cont . begin ( );
}
#line 2007
template < class _Container >
[ [ nodiscard ] ] inline auto begin ( const _Container & _Cont ) noexcept ( noexcept ( _Cont . begin ( ) ) )
    -> decltype ( _Cont . begin ( ) ) {
    return _Cont . begin ( );
}
#line 2013
template < class _Container >
[ [ nodiscard ] ] inline auto end ( _Container & _Cont ) noexcept ( noexcept ( _Cont . end ( ) ) )
    -> decltype ( _Cont . end ( ) ) {
    return _Cont . end ( );
}
#line 2019
template < class _Container >
[ [ nodiscard ] ] inline auto end ( const _Container & _Cont ) noexcept ( noexcept ( _Cont . end ( ) ) )
    -> decltype ( _Cont . end ( ) ) {
    return _Cont . end ( );
}
#line 2025
template < class _Ty, size_t _Size >
[ [ nodiscard ] ] constexpr _Ty * begin ( _Ty ( & _Array ) [ _Size ] ) noexcept {
    return _Array;
}
#line 2030
template < class _Ty, size_t _Size >
[ [ nodiscard ] ] constexpr _Ty * end ( _Ty ( & _Array ) [ _Size ] ) noexcept {
    return _Array + _Size;
}
#line 2035
template < class _Container >
[ [ nodiscard ] ] constexpr auto cbegin ( const _Container & _Cont ) noexcept ( noexcept ( :: std :: begin ( _Cont ) ) )
    -> decltype ( :: std :: begin ( _Cont ) ) {
    return :: std :: begin ( _Cont );
}
#line 2041
template < class _Container >
[ [ nodiscard ] ] constexpr auto cend ( const _Container & _Cont ) noexcept ( noexcept ( :: std :: end ( _Cont ) ) )
    -> decltype ( :: std :: end ( _Cont ) ) {
    return :: std :: end ( _Cont );
}
#line 2047
template < class _Container >
[ [ nodiscard ] ] inline auto rbegin ( _Container & _Cont ) noexcept ( noexcept ( _Cont . rbegin ( ) ) )
    -> decltype ( _Cont . rbegin ( ) ) {
    return _Cont . rbegin ( );
}
#line 2053
template < class _Container >
[ [ nodiscard ] ] inline auto rbegin ( const _Container & _Cont ) noexcept ( noexcept ( _Cont . rbegin ( ) ) )
    -> decltype ( _Cont . rbegin ( ) ) {
    return _Cont . rbegin ( );
}
#line 2059
template < class _Container >
[ [ nodiscard ] ] inline auto rend ( _Container & _Cont ) noexcept ( noexcept ( _Cont . rend ( ) ) )
    -> decltype ( _Cont . rend ( ) ) {
    return _Cont . rend ( );
}
#line 2065
template < class _Container >
[ [ nodiscard ] ] inline auto rend ( const _Container & _Cont ) noexcept ( noexcept ( _Cont . rend ( ) ) )
    -> decltype ( _Cont . rend ( ) ) {
    return _Cont . rend ( );
}
#line 2071
template < class _Ty, size_t _Size >
[ [ nodiscard ] ] inline reverse_iterator < _Ty * > rbegin ( _Ty ( & _Array ) [ _Size ] ) noexcept {
    return reverse_iterator < _Ty * > ( _Array + _Size );
}
#line 2076
template < class _Ty, size_t _Size >
[ [ nodiscard ] ] inline reverse_iterator < _Ty * > rend ( _Ty ( & _Array ) [ _Size ] ) noexcept {
    return reverse_iterator < _Ty * > ( _Array );
}
#line 2081
template < class _Elem >
[ [ nodiscard ] ] inline reverse_iterator < const _Elem * > rbegin ( initializer_list < _Elem > _Ilist ) noexcept
 {
    return reverse_iterator < const _Elem * > ( _Ilist . end ( ) );
}
#line 2087
template < class _Elem >
[ [ nodiscard ] ] inline reverse_iterator < const _Elem * > rend ( initializer_list < _Elem > _Ilist ) noexcept
 {
    return reverse_iterator < const _Elem * > ( _Ilist . begin ( ) );
}
#line 2093
template < class _Container >
[ [ nodiscard ] ] inline auto crbegin ( const _Container & _Cont ) noexcept ( noexcept ( :: std :: rbegin ( _Cont ) ) )
    -> decltype ( :: std :: rbegin ( _Cont ) ) {
    return :: std :: rbegin ( _Cont );
}
#line 2099
template < class _Container >
[ [ nodiscard ] ] inline auto crend ( const _Container & _Cont ) noexcept ( noexcept ( :: std :: rend ( _Cont ) ) )
    -> decltype ( :: std :: rend ( _Cont ) ) {
    return :: std :: rend ( _Cont );
}
#line 2105
template < class _Container >
[ [ nodiscard ] ] constexpr auto size ( const _Container & _Cont ) noexcept ( noexcept ( _Cont . size ( ) ) )
    -> decltype ( _Cont . size ( ) ) {
    return _Cont . size ( );
}
#line 2111
template < class _Ty, size_t _Size >
[ [ nodiscard ] ] constexpr size_t size ( const _Ty ( & ) [ _Size ] ) noexcept {
    return _Size;
}
#line 2131 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Container >
[ [ nodiscard ( "This function returns a bool indicating whether the collection is empty and has no other effects. It is not useful to call this " "function and discard the return value." ) ] ] constexpr auto empty ( const _Container & _Cont )
    noexcept ( noexcept ( _Cont . empty ( ) ) )
    -> decltype ( _Cont . empty ( ) ) {
    return _Cont . empty ( );
}
#line 2138
template < class _Ty, size_t _Size >
[ [ nodiscard ( "This function returns a bool indicating whether the collection is empty and has no other effects. It is not useful to call this " "function and discard the return value." ) ] ] constexpr bool empty ( const _Ty ( & ) [ _Size ] ) noexcept {
    return false;
}
#line 2143
template < class _Elem >
[ [ nodiscard ( "This function returns a bool indicating whether the collection is empty and has no other effects. It is not useful to call this " "function and discard the return value." ) ] ] constexpr bool empty ( initializer_list < _Elem > _Ilist ) noexcept {
    return _Ilist . size ( ) == 0;
}
#line 2148
template < class _Container >
[ [ nodiscard ] ] constexpr auto data ( _Container & _Cont ) noexcept ( noexcept ( _Cont . data ( ) ) )
    -> decltype ( _Cont . data ( ) ) {
    return _Cont . data ( );
}
#line 2154
template < class _Container >
[ [ nodiscard ] ] constexpr auto data ( const _Container & _Cont ) noexcept ( noexcept ( _Cont . data ( ) ) )
    -> decltype ( _Cont . data ( ) ) {
    return _Cont . data ( );
}
#line 2160
template < class _Ty, size_t _Size >
[ [ nodiscard ] ] constexpr _Ty * data ( _Ty ( & _Array ) [ _Size ] ) noexcept {
    return _Array;
}
#line 2165
template < class _Elem >
[ [ nodiscard ] ] constexpr const _Elem * data ( initializer_list < _Elem > _Ilist ) noexcept {
    return _Ilist . begin ( );
}
#line 4186 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
struct _Container_proxy; 
#line 4187
struct _Iterator_base12; 
#line 4189
struct _Default_sentinel { }; 
#line 4205 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class _Iter> 
#line 4206
struct _Move_iterator_category { 
#line 4207
using iterator_category = _Iter_cat_t< _Iter> ; 
#line 4208
}; 
#line 4211 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Iter >
class move_iterator : public _Move_iterator_category < _Iter > {
private :
    _Iter _Current { };

public :
    using iterator_type = _Iter;
    using value_type = _Iter_value_t < _Iter >;
    using difference_type = _Iter_diff_t < _Iter >;
    using pointer = _Iter;




















    using reference =
        conditional_t < is_reference_v < _Iter_ref_t < _Iter >>, remove_reference_t < _Iter_ref_t < _Iter >> &&, _Iter_ref_t < _Iter >>;


    inline move_iterator ( ) = default;

    inline explicit move_iterator ( _Iter _Right ) noexcept ( is_nothrow_move_constructible_v < _Iter > )
        : _Current ( :: std :: move ( _Right ) ) { }

    template < class _Other >



    inline move_iterator ( const move_iterator < _Other > & _Right )
        noexcept ( is_nothrow_constructible_v < _Iter, const _Other & > )
        : _Current ( _Right . base ( ) ) {
    }

    template < class _Other >




    inline move_iterator & operator = ( const move_iterator < _Other > & _Right )
        noexcept ( is_nothrow_assignable_v < _Iter &, const _Other & > ) {
        _Current = _Right . base ( );
        return * this;
    }









    [ [ nodiscard ] ] inline iterator_type base ( ) const
        noexcept ( is_nothrow_copy_constructible_v < _Iter > ) {
        return _Current;
    }


    [ [ nodiscard ] ] inline reference operator * ( ) const





        noexcept ( noexcept ( static_cast < reference > ( * _Current ) ) ) {
        return static_cast < reference > ( * _Current );
    }


     [ [ nodiscard ] ] inline pointer operator -> ( ) const
        noexcept ( is_nothrow_copy_constructible_v < _Iter > ) {
        return _Current;
    }

    inline move_iterator & operator ++ ( ) noexcept ( noexcept ( ++ _Current ) ) {
        ++ _Current;
        return * this;
    }

    inline auto operator ++ ( int ) noexcept ( is_nothrow_copy_constructible_v < _Iter >
                                               && noexcept ( ++ _Current ) ) {



            move_iterator _Tmp = * this;
            ++ _Current;
            return _Tmp;





    }

    inline move_iterator & operator -- ( ) noexcept ( noexcept ( -- _Current ) ) {
        -- _Current;
        return * this;
    }

    inline move_iterator operator -- ( int ) noexcept ( is_nothrow_copy_constructible_v < _Iter >
                                                        && noexcept ( -- _Current ) ) {
        move_iterator _Tmp = * this;
        -- _Current;
        return _Tmp;
    }

    template < class _Iter2 = _Iter >
    [ [ nodiscard ] ] auto operator == ( _Default_sentinel _Sentinel ) const noexcept
        -> decltype ( :: std :: declval < const _Iter2 & > ( ) == _Sentinel ) {
        return _Current == _Sentinel;
    }

    template < class _Iter2 = _Iter >
    [ [ nodiscard ] ] auto operator != ( _Default_sentinel _Sentinel ) const noexcept
        -> decltype ( :: std :: declval < const _Iter2 & > ( ) != _Sentinel ) {
        return _Current != _Sentinel;
    }

    [ [ nodiscard ] ] inline move_iterator operator + ( const difference_type _Off ) const
        noexcept ( noexcept ( move_iterator ( _Current + _Off ) ) ) {
        return move_iterator ( _Current + _Off );
    }

    inline move_iterator & operator += ( const difference_type _Off )
        noexcept ( noexcept ( _Current += _Off ) ) {
        _Current += _Off;
        return * this;
    }

    [ [ nodiscard ] ] inline move_iterator operator - ( const difference_type _Off ) const
        noexcept ( noexcept ( move_iterator ( _Current - _Off ) ) ) {
        return move_iterator ( _Current - _Off );
    }

    inline move_iterator & operator -= ( const difference_type _Off )
        noexcept ( noexcept ( _Current -= _Off ) ) {
        _Current -= _Off;
        return * this;
    }

    [ [ nodiscard ] ] inline reference operator [ ] ( const difference_type _Off ) const




        noexcept ( noexcept ( :: std :: move ( _Current [ _Off ] ) ) ) {
        return :: std :: move ( _Current [ _Off ] );

    }
































    template < class _Iter2, enable_if_t < _Range_verifiable_v < _Iter, _Iter2 >, int > = 0 >
    friend constexpr void _Verify_range ( const move_iterator & _First, const move_iterator < _Iter2 > & _Last ) noexcept {
        _Verify_range ( _First . _Current, _Last . _Get_current ( ) );
    }








    using _Prevent_inheriting_unwrap = move_iterator;

    template < class _Iter2 = iterator_type, enable_if_t < _Offset_verifiable_v < _Iter2 >, int > = 0 >
    constexpr void _Verify_offset ( const difference_type _Off ) const noexcept {
        _Current . _Verify_offset ( _Off );
    }

    template < class _Iter2 = iterator_type, enable_if_t < _Unwrappable_v < const _Iter2 & >, int > = 0 >
    [ [ nodiscard ] ] constexpr move_iterator < _Unwrapped_t < const _Iter2 & >> _Unwrapped ( ) const & noexcept (
        noexcept ( static_cast < move_iterator < _Unwrapped_t < const _Iter2 & >> > ( _Current . _Unwrapped ( ) ) ) ) {
        return static_cast < move_iterator < _Unwrapped_t < const _Iter2 & >> > ( _Current . _Unwrapped ( ) );
    }
    template < class _Iter2 = iterator_type, enable_if_t < _Unwrappable_v < _Iter2 >, int > = 0 >
    [ [ nodiscard ] ] constexpr move_iterator < _Unwrapped_t < _Iter2 >> _Unwrapped ( ) && noexcept (
        noexcept ( static_cast < move_iterator < _Unwrapped_t < _Iter2 >> > ( :: std :: move ( _Current ) . _Unwrapped ( ) ) ) ) {
        return static_cast < move_iterator < _Unwrapped_t < _Iter2 >> > ( :: std :: move ( _Current ) . _Unwrapped ( ) );
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v < iterator_type >;

    template < class _Src, enable_if_t < _Wrapped_seekable_v < iterator_type, const _Src & >, int > = 0 >
    constexpr void _Seek_to ( const move_iterator < _Src > & _It ) noexcept ( noexcept ( _Current . _Seek_to ( _It . _Get_current ( ) ) ) ) {
        _Current . _Seek_to ( _It . _Get_current ( ) );
    }
    template < class _Src, enable_if_t < _Wrapped_seekable_v < iterator_type, _Src >, int > = 0 >
    constexpr void _Seek_to ( move_iterator < _Src > && _It )
        noexcept ( noexcept ( _Current . _Seek_to ( :: std :: move ( _It ) . _Get_current ( ) ) ) ) {
        _Current . _Seek_to ( :: std :: move ( _It ) . _Get_current ( ) );
    }

    [ [ nodiscard ] ] constexpr const iterator_type & _Get_current ( ) const & noexcept {
        return _Current;
    }
    [ [ nodiscard ] ] constexpr iterator_type && _Get_current ( ) && noexcept {
        return :: std :: move ( _Current );
    }
};
#line 4457 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Iter1, class _Iter2 >
[ [ nodiscard ] ] inline bool operator == ( const move_iterator < _Iter1 > & _Left, const move_iterator < _Iter2 > & _Right )
    noexcept ( noexcept ( :: std :: _Fake_copy_init < bool > ( _Left . base ( ) == _Right . base ( ) ) ) )





{
    return _Left . base ( ) == _Right . base ( );
}
#line 4470 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Iter1, class _Iter2 >
[ [ nodiscard ] ] inline bool operator != ( const move_iterator < _Iter1 > & _Left, const move_iterator < _Iter2 > & _Right )
    noexcept ( noexcept ( _Left == _Right ) ) {
    return ! ( _Left == _Right );
}
#line 4477 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Iter1, class _Iter2 >
[ [ nodiscard ] ] inline bool operator < ( const move_iterator < _Iter1 > & _Left, const move_iterator < _Iter2 > & _Right )
    noexcept ( noexcept ( :: std :: _Fake_copy_init < bool > ( _Left . base ( ) < _Right . base ( ) ) ) )





{
    return _Left . base ( ) < _Right . base ( );
}
#line 4489 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Iter1, class _Iter2 >
[ [ nodiscard ] ] inline bool operator > ( const move_iterator < _Iter1 > & _Left, const move_iterator < _Iter2 > & _Right )
    noexcept ( noexcept ( _Right < _Left ) )



{
    return _Right < _Left;
}
#line 4499 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Iter1, class _Iter2 >
[ [ nodiscard ] ] inline bool operator <= ( const move_iterator < _Iter1 > & _Left, const move_iterator < _Iter2 > & _Right )
    noexcept ( noexcept ( _Right < _Left ) )



{
    return ! ( _Right < _Left );
}
#line 4509 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Iter1, class _Iter2 >
[ [ nodiscard ] ] inline bool operator >= ( const move_iterator < _Iter1 > & _Left, const move_iterator < _Iter2 > & _Right )
    noexcept ( noexcept ( _Left < _Right ) )



{
    return ! ( _Left < _Right );
}
#line 4527 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Iter1, class _Iter2 >
[ [ nodiscard ] ] inline auto operator - ( const move_iterator < _Iter1 > & _Left, const move_iterator < _Iter2 > & _Right )
    noexcept ( noexcept ( _Left . base ( ) - _Right . base ( ) ) )
    -> decltype ( _Left . base ( ) - _Right . base ( ) ) {
    return _Left . base ( ) - _Right . base ( );
}
#line 4534
template < class _Iter >
[ [ nodiscard ] ] inline move_iterator < _Iter > operator + (
    typename move_iterator < _Iter > :: difference_type _Off, const move_iterator < _Iter > & _Right )
    noexcept ( noexcept ( move_iterator < _Iter > ( _Right . base ( ) + _Off ) ) )





{
    return move_iterator < _Iter > ( _Right . base ( ) + _Off );
}
#line 4547 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Iter >
[ [ nodiscard ] ] inline move_iterator < _Iter > make_move_iterator ( _Iter _It )
    noexcept ( is_nothrow_move_constructible_v < _Iter > ) {
    return move_iterator < _Iter > ( :: std :: move ( _It ) );
}
#line 4621 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class _Iter> constexpr bool 
#line 4622
_Iterator_is_contiguous = is_pointer_v< _Iter> ; 
#line 4624
template < class _Iter >
[ [ nodiscard ] ] constexpr auto _To_address ( const _Iter & _Val ) noexcept {
    ;
    return _Val;
}
#line 4631 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Iter >
[ [ nodiscard ] ] constexpr auto _To_address ( const move_iterator < _Iter > & _Val ) noexcept {
    return _To_address ( _Val . base ( ) );
}
#line 4638
template< class _Iter1, class _Iter2> constexpr bool 
#line 4639
_Iterators_are_contiguous = _Iterator_is_contiguous< _Iter1>  && _Iterator_is_contiguous< _Iter2> ; 
#line 4641
template< class _Iter> constexpr bool 
#line 4642
_Iterator_is_volatile = is_volatile_v< remove_reference_t< _Iter_ref_t< _Iter> > > ; 
#line 4644
template< class _Source, class _Dest> constexpr bool 
#line 4645
_Is_pointer_address_convertible = (is_void_v< _Source>  || is_void_v< _Dest> ) || is_same_v< remove_cv_t< _Source> , remove_cv_t< _Dest> > ; 
#line 4654
template< class _Source, class _Dest, class _SourceRef, class _DestRef> 
#line 4655
struct _Trivial_cat { 
#line 4656
using _USource = _Unwrap_enum_t< _Source> ; 
#line 4657
using _UDest = _Unwrap_enum_t< _Dest> ; 
#line 4659
static constexpr bool _Same_size_and_compatible = (((sizeof(_Source) == sizeof(_Dest)) && (is_same_v< bool, _USource>  >= is_same_v< bool, _UDest> )) && ((is_same_v< _USource, _UDest>  || (is_integral_v< _USource>  && is_integral_v< _UDest> )) || (is_floating_point_v< _USource>  && is_floating_point_v< _UDest> ))); 
#line 4668
static constexpr bool _Bitcopy_constructible = (_Same_size_and_compatible && is_trivially_constructible_v< _Dest, _SourceRef> ); 
#line 4671
static constexpr bool _Bitcopy_assignable = (_Same_size_and_compatible && is_trivially_assignable_v< _DestRef, _SourceRef> ); 
#line 4673
}; 
#line 4675
template< class _Source, class _Dest, class _SourceRef, class _DestRef> 
#line 4676
struct _Trivial_cat< _Source *, _Dest *, _SourceRef, _DestRef>  { 
#line 4677
static constexpr bool _Bitcopy_constructible = (_Is_pointer_address_convertible< _Source, _Dest>  && is_trivially_constructible_v< _Dest *, _SourceRef> ); 
#line 4680
static constexpr bool _Bitcopy_assignable = (_Is_pointer_address_convertible< _Source, _Dest>  && is_trivially_assignable_v< _DestRef, _SourceRef> ); 
#line 4682
}; 
#line 4684
struct _False_trivial_cat { 
#line 4685
static constexpr bool _Bitcopy_constructible = false; 
#line 4686
static constexpr bool _Bitcopy_assignable = false; 
#line 4687
}; 
#line 4689
template< class _SourceIt, class _DestIt, bool 
#line 4690
_Are_contiguous = (_Iterators_are_contiguous< _SourceIt, _DestIt>  && (!_Iterator_is_volatile< _SourceIt> )) && (!_Iterator_is_volatile< _DestIt> )> 
#line 4692
struct _Iter_move_cat : public _Trivial_cat< _Iter_value_t< _SourceIt> , _Iter_value_t< _DestIt> , remove_reference_t< _Iter_ref_t< _SourceIt> >  &&, _Iter_ref_t< _DestIt> >  { 
#line 4693
}; 
#line 4695
template< class _SourceIt, class _DestIt> 
#line 4696
struct _Iter_move_cat< _SourceIt, _DestIt, false>  : public _False_trivial_cat { }; 
#line 4698
template< class _SourceIt, class _DestIt> 
#line 4699
struct _Iter_move_cat< move_iterator< _SourceIt> , _DestIt, false>  : public std::_Iter_move_cat< _SourceIt, _DestIt>  { }; 
#line 4701
template< class _SourceIt, class _DestIt, bool 
#line 4702
_Are_contiguous = (_Iterators_are_contiguous< _SourceIt, _DestIt>  && (!_Iterator_is_volatile< _SourceIt> )) && (!_Iterator_is_volatile< _DestIt> )> 
#line 4704
struct _Iter_copy_cat : public _Trivial_cat< _Iter_value_t< _SourceIt> , _Iter_value_t< _DestIt> , _Iter_ref_t< _SourceIt> , _Iter_ref_t< _DestIt> >  { 
#line 4705
}; 
#line 4707
template< class _SourceIt, class _DestIt> 
#line 4708
struct _Iter_copy_cat< _SourceIt, _DestIt, false>  : public _False_trivial_cat { }; 
#line 4710
template< class _SourceIt, class _DestIt> 
#line 4711
struct _Iter_copy_cat< move_iterator< _SourceIt> , _DestIt, false>  : public _Iter_move_cat< _SourceIt, _DestIt>  { }; 
#line 4713
template < class _Iter1, class _Sent1, class _Iter2 >
inline void _Verify_ranges_do_not_overlap ( const _Iter1 & _First1, const _Sent1 & _Last1, const _Iter2 & _First2 ) {
























    ( void ) _First1;
    ( void ) _Last1;
    ( void ) _First2;

}
#line 4745 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _OutCtgIt >
_OutCtgIt _Copy_memmove_tail (
    const char * const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count ) {
    ;
    const auto _Dest_ptr = :: std :: _To_address ( _Dest );
    const auto _Dest_ch = const_cast < char * > ( reinterpret_cast < const volatile char * > ( _Dest_ptr ) );
    :: memmove ( _Dest_ch, _First_ch, _Byte_count );
    if constexpr ( is_pointer_v < _OutCtgIt > ) {
        ( void ) _Object_count;

        return reinterpret_cast < _OutCtgIt > ( _Dest_ch + _Byte_count );
    } else {
        return _Dest + static_cast < _Iter_diff_t < _OutCtgIt >> ( _Object_count );
    }
}
#line 4761
template < class _CtgIt, class _OutCtgIt >
_OutCtgIt _Copy_memmove ( _CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest ) {
    ;
    const auto _First_ptr = :: std :: _To_address ( _First );
    const auto _Last_ptr = :: std :: _To_address ( _Last );
    const auto _Object_count = static_cast < size_t > ( _Last_ptr - _First_ptr );
    const auto _First_ch = const_cast < const char * > ( reinterpret_cast < const volatile char * > ( _First_ptr ) );
    const auto _Last_ch = const_cast < const char * > ( reinterpret_cast < const volatile char * > ( _Last_ptr ) );
    const auto _Byte_count = static_cast < size_t > ( _Last_ch - _First_ch );
    return :: std :: _Copy_memmove_tail ( _First_ch, :: std :: move ( _Dest ), _Byte_count, _Object_count );
}
#line 4773
template < class _CtgIt, class _OutCtgIt >
_OutCtgIt _Copy_memmove_n ( _CtgIt _First, const size_t _Object_count, _OutCtgIt _Dest ) {
    const auto _First_ptr = :: std :: _To_address ( _First );
    const auto _First_ch = const_cast < const char * > ( reinterpret_cast < const volatile char * > ( _First_ptr ) );
    const auto _Byte_count = _Object_count * sizeof ( * _First_ptr );
    return :: std :: _Copy_memmove_tail ( _First_ch, :: std :: move ( _Dest ), _Byte_count, _Object_count );
}
#line 4781
template< class _It, bool _RequiresMutable = false> constexpr bool 
#line 4782
_Is_vb_iterator = false; 
#line 4784
template< class _VbIt, class _OutIt> inline _OutIt _Copy_vbool(_VbIt _First, _VbIt _Last, _OutIt _Dest); 
#line 4787
template< class _VbIt> 
#line 4788
[[nodiscard]] inline _Iter_diff_t< _VbIt>  
#line 4787
_Count_vbool(_VbIt _First, _VbIt _Last, bool _Val) noexcept; 
#line 4790
template< class _VbIt> inline void _Fill_vbool(_VbIt _First, _VbIt _Last, bool _Val) noexcept; 
#line 4793
template< class _VbIt> 
#line 4794
[[nodiscard]] inline _VbIt 
#line 4793
_Find_vbool(_VbIt _First, _VbIt _Last, bool _Val) noexcept; 
#line 4796
template < class _InIt, class _SizeTy, class _OutIt >
inline _OutIt _Copy_n_unchecked4 ( _InIt _First, _SizeTy _Count, _OutIt _Dest ) {


    ;
    ;

    if constexpr ( _Iter_copy_cat < _InIt, _OutIt > :: _Bitcopy_assignable ) {



        {
            return _Copy_memmove_n ( _First, static_cast < size_t > ( _Count ), _Dest );
        }
    }

    for (; _Count != 0; ++ _Dest, ( void ) ++ _First, -- _Count ) {
        * _Dest = * _First;
    }

    return _Dest;
}
#line 4819 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class _InIt, class _Sent, class _OutIt> using _Sent_copy_cat = conditional_t< is_same_v< _Sent, _InIt> , _Iter_copy_cat< _InIt, _OutIt> , _False_trivial_cat> ; 
#line 4828 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _InIt, class _Sent, class _OutIt >
inline _OutIt _Copy_unchecked ( _InIt _First, _Sent _Last, _OutIt _Dest ) {


    if constexpr ( _Is_vb_iterator < _InIt > && _Is_vb_iterator < _OutIt, true > ) {
        return :: std :: _Copy_vbool ( _First, _Last, _Dest );
    } else {
        if constexpr ( _Sent_copy_cat < _InIt, _Sent, _OutIt > :: _Bitcopy_assignable ) {



            {





                {
                    return :: std :: _Copy_memmove ( _First, _Last, _Dest );
                }
            }
        }

        for (; _First != _Last; ++ _Dest, ( void ) ++ _First ) {
            * _Dest = * _First;
        }

        return _Dest;
    }
}
#line 4859 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _InIt, class _OutIt >
inline _OutIt copy ( _InIt _First, _InIt _Last, _OutIt _Dest ) {
    :: std :: _Adl_verify_range ( _First, _Last );
    const auto _UFirst = :: std :: _Get_unwrapped ( _First );
    const auto _ULast = :: std :: _Get_unwrapped ( _Last );
    auto _UDest = :: std :: _Get_unwrapped_n ( :: std :: move ( _Dest ), :: std :: _Idl_distance < _InIt > ( _UFirst, _ULast ) );
    :: std :: _Seek_wrapped ( _Dest, :: std :: _Copy_unchecked ( _UFirst, _ULast, :: std :: move ( _UDest ) ) );
    return _Dest;
}
#line 5031 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _InIt, class _Diff, class _OutIt >
inline _OutIt copy_n ( _InIt _First, _Diff _Count_raw, _OutIt _Dest ) {

    _Algorithm_int_t < _Diff > _Count = _Count_raw;
    if ( 0 < _Count ) {
        if constexpr ( _Is_vb_iterator < _InIt > && _Is_vb_iterator < _OutIt, true > ) {
            return :: std :: _Copy_vbool ( _First, _First + _Count, _Dest );
        } else {
            auto _UFirst = :: std :: _Get_unwrapped_n ( _First, _Count );
            auto _UDest = :: std :: _Get_unwrapped_n ( _Dest, _Count );
            if constexpr ( _Iter_copy_cat < decltype ( _UFirst ), decltype ( _UDest ) > :: _Bitcopy_assignable ) {



                {
                    _UDest = :: std :: _Copy_memmove_n ( _UFirst, static_cast < size_t > ( _Count ), _UDest );
                    :: std :: _Seek_wrapped ( _Dest, _UDest );
                    return _Dest;
                }
            }

            for (;; ) {
                * _UDest = * _UFirst;
                ++ _UDest;
                -- _Count;

                if ( _Count == 0 ) {
                    break;
                }

                ++ _UFirst;
            }

            :: std :: _Seek_wrapped ( _Dest, _UDest );
        }
    }

    return _Dest;
}
#line 5082 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _CtgIt1, class _CtgIt2 >
_CtgIt2 _Copy_backward_memmove ( _CtgIt1 _First, _CtgIt1 _Last, _CtgIt2 _Dest ) {

    const auto _First_ptr = :: std :: _To_address ( _First );
    const auto _Last_ptr = :: std :: _To_address ( _Last );
    const auto _Dest_ptr = :: std :: _To_address ( _Dest );
    const auto _First_ch = const_cast < const char * > ( reinterpret_cast < const volatile char * > ( _First_ptr ) );
    const auto _Last_ch = const_cast < const char * > ( reinterpret_cast < const volatile char * > ( _Last_ptr ) );
    const auto _Dest_ch = const_cast < char * > ( reinterpret_cast < const volatile char * > ( _Dest_ptr ) );
    const auto _Count = static_cast < size_t > ( _Last_ch - _First_ch );
    const auto _Result = :: memmove ( _Dest_ch - _Count, _First_ch, _Count );
    if constexpr ( is_pointer_v < _CtgIt2 > ) {
        return static_cast < _CtgIt2 > ( _Result );
    } else {
        return _Dest - static_cast < _Iter_diff_t < _CtgIt2 >> ( _Last_ptr - _First_ptr );
    }
}
#line 5100
template < class _BidIt1, class _BidIt2 >
_BidIt2 _Copy_backward_memmove ( move_iterator < _BidIt1 > _First, move_iterator < _BidIt1 > _Last, _BidIt2 _Dest ) {
    return :: std :: _Copy_backward_memmove ( _First . base ( ), _Last . base ( ), _Dest );
}
#line 5105
template < class _BidIt1, class _BidIt2 >
[ [ nodiscard ] ] inline _BidIt2 _Copy_backward_unchecked ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest ) {

    if constexpr ( _Iter_copy_cat < _BidIt1, _BidIt2 > :: _Bitcopy_assignable ) {



        {
            return :: std :: _Copy_backward_memmove ( _First, _Last, _Dest );
        }
    }

    while ( _First != _Last ) {
        * -- _Dest = * -- _Last;
    }

    return _Dest;
}
#line 5124 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _BidIt1, class _BidIt2 >
inline _BidIt2 copy_backward ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest ) {

    :: std :: _Adl_verify_range ( _First, _Last );
    const auto _UFirst = :: std :: _Get_unwrapped ( _First );
    const auto _ULast = :: std :: _Get_unwrapped ( _Last );
    const auto _UDest = :: std :: _Get_unwrapped_n ( _Dest, - :: std :: _Idl_distance < _BidIt1 > ( _UFirst, _ULast ) );
    :: std :: _Seek_wrapped ( _Dest, :: std :: _Copy_backward_unchecked ( _UFirst, _ULast, _UDest ) );
    return _Dest;
}
#line 5135
template < class _InIt, class _OutIt >
inline _OutIt _Move_unchecked ( _InIt _First, _InIt _Last, _OutIt _Dest ) {


    if constexpr ( _Is_vb_iterator < _InIt > && _Is_vb_iterator < _OutIt, true > ) {
        return :: std :: _Copy_vbool ( _First, _Last, _Dest );
    } else {
        if constexpr ( _Iter_move_cat < _InIt, _OutIt > :: _Bitcopy_assignable ) {



            {
                return :: std :: _Copy_memmove ( _First, _Last, _Dest );
            }
        }

        for (; _First != _Last; ++ _Dest, ( void ) ++ _First ) {
            * _Dest = :: std :: move ( * _First );
        }

        return _Dest;
    }
}
#line 5159 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _InIt, class _OutIt >
inline _OutIt move ( _InIt _First, _InIt _Last, _OutIt _Dest ) {

    :: std :: _Adl_verify_range ( _First, _Last );
    const auto _UFirst = :: std :: _Get_unwrapped ( _First );
    const auto _ULast = :: std :: _Get_unwrapped ( _Last );
    const auto _UDest = :: std :: _Get_unwrapped_n ( _Dest, :: std :: _Idl_distance < _InIt > ( _UFirst, _ULast ) );
    :: std :: _Seek_wrapped ( _Dest, :: std :: _Move_unchecked ( _UFirst, _ULast, _UDest ) );
    return _Dest;
}
#line 5181 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _BidIt1, class _BidIt2 >
inline _BidIt2 _Move_backward_unchecked ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest ) {


    if constexpr ( _Iter_move_cat < _BidIt1, _BidIt2 > :: _Bitcopy_assignable ) {



        {
            return :: std :: _Copy_backward_memmove ( _First, _Last, _Dest );
        }
    }

    while ( _First != _Last ) {
        * -- _Dest = :: std :: move ( * -- _Last );
    }

    return _Dest;
}
#line 5201 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _BidIt1, class _BidIt2 >
inline _BidIt2 move_backward ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest ) {

    :: std :: _Adl_verify_range ( _First, _Last );
    const auto _UFirst = :: std :: _Get_unwrapped ( _First );
    const auto _ULast = :: std :: _Get_unwrapped ( _Last );
    const auto _UDest = :: std :: _Get_unwrapped_n ( _Dest, - :: std :: _Idl_distance < _BidIt1 > ( _UFirst, _ULast ) );
    :: std :: _Seek_wrapped ( _Dest, :: std :: _Move_backward_unchecked ( _UFirst, _ULast, _UDest ) );
    return _Dest;
}
#line 5212
template< class _Ty> 
#line 5213
struct _Is_character : public false_type { }; 
#line 5216
template<> struct _Is_character< char>  : public true_type { }; 
#line 5219
template<> struct _Is_character< signed char>  : public true_type { }; 
#line 5222
template<> struct _Is_character< unsigned char>  : public true_type { }; 
#line 5229
template< class _Ty> 
#line 5230
struct _Is_character_or_bool : public _Is_character< _Ty> ::type { }; 
#line 5233
template<> struct _Is_character_or_bool< bool>  : public true_type { }; 
#line 5235
template< class _Ty> 
#line 5236
struct _Is_character_or_byte_or_bool : public _Is_character_or_bool< _Ty> ::type { }; 
#line 5245
template< class _FwdIt, class _Ty, bool  = _Iterator_is_contiguous< _FwdIt> > constexpr bool 
#line 5246
_Fill_memset_is_safe = conjunction_v< is_scalar< _Ty> , _Is_character_or_byte_or_bool< _Unwrap_enum_t< remove_reference_t< _Iter_ref_t< _FwdIt> > > > , negation< is_volatile< remove_reference_t< _Iter_ref_t< _FwdIt> > > > , is_assignable< _Iter_ref_t< _FwdIt> , const _Ty &> > ; 
#line 5250
template< class _FwdIt, class _Ty> constexpr bool 
#line 5251
_Fill_memset_is_safe< _FwdIt, _Ty, false>  = false; 
#line 5253
template< class _FwdIt, class _Ty, bool  = _Iterator_is_contiguous< _FwdIt> > constexpr bool 
#line 5254
_Fill_zero_memset_is_safe = conjunction_v< is_scalar< _Ty> , is_scalar< _Iter_value_t< _FwdIt> > , negation< is_member_pointer< _Iter_value_t< _FwdIt> > > , negation< is_volatile< remove_reference_t< _Iter_ref_t< _FwdIt> > > > , is_assignable< _Iter_ref_t< _FwdIt> , const _Ty &> > ; 
#line 5258
template< class _FwdIt, class _Ty> constexpr bool 
#line 5259
_Fill_zero_memset_is_safe< _FwdIt, _Ty, false>  = false; 
#line 5261
template < class _CtgIt, class _Ty >
void _Fill_memset ( _CtgIt _Dest, const _Ty _Val, const size_t _Count ) {

    _Iter_value_t < _CtgIt > _Dest_val = _Val;
    :: memset ( :: std :: _To_address ( _Dest ), static_cast < unsigned char > ( _Dest_val ), _Count );
}
#line 5268
template < class _CtgIt >
void _Fill_zero_memset ( _CtgIt _Dest, const size_t _Count ) {
    :: memset ( :: std :: _To_address ( _Dest ), 0, _Count * sizeof ( _Iter_value_t < _CtgIt > ) );
}
#line 5273
template < class _Ty >
[ [ nodiscard ] ] bool _Is_all_bits_zero ( const _Ty & _Val ) {

    ;
    if constexpr ( is_same_v < _Ty, nullptr_t > ) {
        return true;
    } else {
        constexpr _Ty _Zero { };
        return :: memcmp ( & _Val, & _Zero, sizeof ( _Ty ) ) == 0;
    }
}
#line 5285
template < class _FwdIt, class _Ty >
inline void fill ( const _FwdIt _First, const _FwdIt _Last, const _Ty & _Val ) {

    :: std :: _Adl_verify_range ( _First, _Last );
    if constexpr ( _Is_vb_iterator < _FwdIt, true > ) {
        :: std :: _Fill_vbool ( _First, _Last, _Val );
    } else {
        auto _UFirst = :: std :: _Get_unwrapped ( _First );
        const auto _ULast = :: std :: _Get_unwrapped ( _Last );



        {
            if constexpr ( _Fill_memset_is_safe < decltype ( _UFirst ), _Ty > ) {
                :: std :: _Fill_memset ( _UFirst, _Val, static_cast < size_t > ( _ULast - _UFirst ) );
                return;
            } else if constexpr ( _Fill_zero_memset_is_safe < decltype ( _UFirst ), _Ty > ) {
                if ( :: std :: _Is_all_bits_zero ( _Val ) ) {
                    :: std :: _Fill_zero_memset ( _UFirst, static_cast < size_t > ( _ULast - _UFirst ) );
                    return;
                }
            }
        }

        for (; _UFirst != _ULast; ++ _UFirst ) {
            * _UFirst = _Val;
        }
    }
}
#line 5325 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _OutIt, class _Diff, class _Ty >
inline _OutIt fill_n ( _OutIt _Dest, const _Diff _Count_raw, const _Ty & _Val ) {

    _Algorithm_int_t < _Diff > _Count = _Count_raw;
    if ( 0 < _Count ) {
        if constexpr ( _Is_vb_iterator < _OutIt, true > ) {
            const auto _Last = _Dest + static_cast < typename _OutIt :: difference_type > ( _Count );
            :: std :: _Fill_vbool ( _Dest, _Last, _Val );
            return _Last;
        } else {
            auto _UDest = :: std :: _Get_unwrapped_n ( _Dest, _Count );



            {
                if constexpr ( _Fill_memset_is_safe < decltype ( _UDest ), _Ty > ) {
                    :: std :: _Fill_memset ( _UDest, _Val, static_cast < size_t > ( _Count ) );
                    :: std :: _Seek_wrapped ( _Dest, _UDest + _Count );
                    return _Dest;
                } else if constexpr ( _Fill_zero_memset_is_safe < decltype ( _UDest ), _Ty > ) {
                    if ( :: std :: _Is_all_bits_zero ( _Val ) ) {
                        :: std :: _Fill_zero_memset ( _UDest, static_cast < size_t > ( _Count ) );
                        :: std :: _Seek_wrapped ( _Dest, _UDest + _Count );
                        return _Dest;
                    }
                }
            }

            for (; 0 < _Count; -- _Count, ( void ) ++ _UDest ) {
                * _UDest = _Val;
            }

            :: std :: _Seek_wrapped ( _Dest, _UDest );
        }
    }
    return _Dest;
}
#line 5411 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class _Ty1, class _Ty2, class  = void> constexpr bool 
#line 5412
_Can_compare_with_operator_equal = false; 
#line 5414
template< class _Ty1, class _Ty2> constexpr bool 
#line 5416
_Can_compare_with_operator_equal< _Ty1, _Ty2, void_t< decltype(std::declval< _Ty1 &> () == std::declval< _Ty2 &> ())> >  = true; 
#line 5419
template< class _Ty1, class _Ty2> constexpr bool 
#line 5420
_Is_pointer_address_comparable = _Can_compare_with_operator_equal< _Ty1 *, _Ty2 *, void>  && (_Is_pointer_address_convertible< _Ty1, _Ty2>  || _Is_pointer_address_convertible< _Ty2, _Ty1> ); 
#line 5431
#pragma warning(push)
#pragma warning(disable : 4806)
template< class _Elem1, class _Elem2, bool 
#line 5434
 = ((sizeof(_Elem1) == sizeof(_Elem2)) && is_integral_v< _Elem1> ) && is_integral_v< _Elem2> > constexpr bool 
#line 5435
_Can_memcmp_elements = (is_same_v< _Elem1, bool>  || is_same_v< _Elem2, bool> ) || ((static_cast< _Elem1>(-1)) == (static_cast< _Elem2>(-1))); 
#line 5437
#pragma warning(pop)
#line 5449
template< class _Ty1, class _Ty2> constexpr bool 
#line 5450
_Can_memcmp_elements< _Ty1 *, _Ty2 *, false>  = _Is_pointer_address_comparable< _Ty1, _Ty2> ; 
#line 5452
template< class _Elem1, class _Elem2> constexpr bool 
#line 5453
_Can_memcmp_elements< _Elem1, _Elem2, false>  = false; 
#line 5458
template< class _Elem1, class _Elem2, class _Pr> constexpr bool 
#line 5459
_Can_memcmp_elements_with_pred = false; 
#line 5463
template< class _Elem1, class _Elem2, class _Elem3> constexpr bool 
#line 5464
_Can_memcmp_elements_with_pred< _Elem1, _Elem2, equal_to< _Elem3> >  = (_Iter_copy_cat< _Elem1 *, _Elem3 *> ::_Bitcopy_constructible && _Iter_copy_cat< _Elem2 *, _Elem3 *> ::_Bitcopy_constructible) && _Can_memcmp_elements< remove_cv_t< _Elem3> , remove_cv_t< _Elem3> , ((sizeof(remove_cv_t< _Elem3> ) == sizeof(remove_cv_t< _Elem3> )) && is_integral_v< remove_cv_t< _Elem3> > ) && is_integral_v< remove_cv_t< _Elem3> > > ; 
#line 5469
template< class _Elem1, class _Elem2> constexpr bool 
#line 5470
_Can_memcmp_elements_with_pred< _Elem1, _Elem2, equal_to<> >  = _Can_memcmp_elements< _Elem1, _Elem2, ((sizeof(_Elem1) == sizeof(_Elem2)) && is_integral_v< _Elem1> ) && is_integral_v< _Elem2> > ; 
#line 5481 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class _Iter1, class _Iter2, class _Pr> constexpr bool 
#line 5482
_Equal_memcmp_is_safe_helper = ((_Iterators_are_contiguous< _Iter1, _Iter2>  && (!_Iterator_is_volatile< _Iter1> )) && (!_Iterator_is_volatile< _Iter2> )) && _Can_memcmp_elements_with_pred< _Iter_value_t< _Iter1> , _Iter_value_t< _Iter2> , _Pr> ; 
#line 5486
template< class _Iter1, class _Iter2, class _Pr> constexpr bool 
#line 5487
_Equal_memcmp_is_safe = _Equal_memcmp_is_safe_helper< remove_const_t< _Iter1> , remove_const_t< _Iter2> , remove_const_t< _Pr> > ; 
#line 5491
template< class _It1, class _It2, class _Pr> constexpr bool 
#line 5492
_Vector_alg_in_search_is_safe = _Equal_memcmp_is_safe< _It1, _It2, _Pr>  && (sizeof(_Iter_value_t< _It1> ) <= (2)); 
#line 5495
template < class _CtgIt1, class _CtgIt2 >
[ [ nodiscard ] ] int _Memcmp_count ( _CtgIt1 _First1, _CtgIt2 _First2, const size_t _Count ) {
    ;
    const auto _First1_ch = reinterpret_cast < const char * > ( :: std :: _To_address ( _First1 ) );
    const auto _First2_ch = reinterpret_cast < const char * > ( :: std :: _To_address ( _First2 ) );
    return :: memcmp ( _First1_ch, _First2_ch, _Count * sizeof ( _Iter_value_t < _CtgIt1 > ) );
}
#line 5503
template < class _InIt1, class _InIt2, class _Pr >
[ [ nodiscard ] ] inline bool equal ( const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred ) {

    :: std :: _Adl_verify_range ( _First1, _Last1 );
    auto _UFirst1 = :: std :: _Get_unwrapped ( _First1 );
    const auto _ULast1 = :: std :: _Get_unwrapped ( _Last1 );
    auto _UFirst2 = :: std :: _Get_unwrapped_n ( _First2, :: std :: _Idl_distance < _InIt1 > ( _UFirst1, _ULast1 ) );
    if constexpr ( _Equal_memcmp_is_safe < decltype ( _UFirst1 ), decltype ( _UFirst2 ), _Pr > ) {



        {
            ;

            const auto _First1_ch = reinterpret_cast < const char * > ( :: std :: _To_address ( _UFirst1 ) );
            const auto _Size = reinterpret_cast < const char * > ( :: std :: _To_address ( _ULast1 ) ) - _First1_ch;
            return :: memcmp ( _First1_ch, :: std :: _To_address ( _UFirst2 ), static_cast < size_t > ( _Size ) ) == 0;
        }
    }

    for (; _UFirst1 != _ULast1; ++ _UFirst1, ( void ) ++ _UFirst2 ) {
        if ( ! _Pred ( * _UFirst1, * _UFirst2 ) ) {
            return false;
        }
    }

    return true;
}
#line 5538 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _InIt1, class _InIt2 >
[ [ nodiscard ] ] inline bool equal ( const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2 ) {

    return :: std :: equal ( _First1, _Last1, _First2, equal_to < > { } );
}
#line 5553 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _InIt1, class _InIt2, class _Pr >
[ [ nodiscard ] ] inline bool equal (
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred ) {

    :: std :: _Adl_verify_range ( _First1, _Last1 );
    :: std :: _Adl_verify_range ( _First2, _Last2 );
    auto _UFirst1 = :: std :: _Get_unwrapped ( _First1 );
    const auto _ULast1 = :: std :: _Get_unwrapped ( _Last1 );
    auto _UFirst2 = :: std :: _Get_unwrapped ( _First2 );
    const auto _ULast2 = :: std :: _Get_unwrapped ( _Last2 );
    if constexpr ( _Is_ranges_random_iter_v < _InIt1 > && _Is_ranges_random_iter_v < _InIt2 > ) {
        if ( _ULast1 - _UFirst1 != _ULast2 - _UFirst2 ) {
            return false;
        }

        return :: std :: equal ( _UFirst1, _ULast1, _UFirst2, :: std :: _Pass_fn ( _Pred ) );
    } else {
        for (;; ) {
            if ( _UFirst1 == _ULast1 ) {
                return _UFirst2 == _ULast2;
            }

            if ( _UFirst2 == _ULast2 ) {
                return false;
            }

            if ( ! _Pred ( * _UFirst1, * _UFirst2 ) ) {
                return false;
            }

            ++ _UFirst1;
            ++ _UFirst2;
        }
    }
}
#line 5595 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _InIt1, class _InIt2 >
[ [ nodiscard ] ] inline bool equal (
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2 ) {

    return :: std :: equal ( _First1, _Last1, _First2, _Last2, equal_to < > { } );
}
#line 5760 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class _Elem1, class _Elem2> constexpr bool 
#line 5761
_Lex_compare_memcmp_classify_elements = ((is_integral_v< _Elem1>  && is_integral_v< _Elem2> ) && (sizeof(_Elem1) == sizeof(_Elem2))) && (is_unsigned_v< _Elem1>  == is_unsigned_v< _Elem2> ); 
#line 5775 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class _Elem1, class _Elem2, class _Pr> 
#line 5776
struct _Lex_compare_memcmp_classify_pred { 
#line 5777
using _Pred = void; 
#line 5778
}; 
#line 5780
template< class _Elem1, class _Elem2, class _Elem3> 
#line 5781
struct _Lex_compare_memcmp_classify_pred< _Elem1, _Elem2, less< _Elem3> >  { 
#line 5782
using _Pred = conditional_t< (_Lex_compare_memcmp_classify_elements< _Elem3, _Elem3>  && _Iter_copy_cat< _Elem1 *, _Elem3 *> ::_Bitcopy_constructible) && _Iter_copy_cat< _Elem2 *, _Elem3 *> ::_Bitcopy_constructible, less< int> , void> ; 
#line 5786
}; 
#line 5788
template< class _Elem1, class _Elem2> 
#line 5789
struct _Lex_compare_memcmp_classify_pred< _Elem1, _Elem2, less<> >  { 
#line 5790
using _Pred = conditional_t< _Lex_compare_memcmp_classify_elements< _Elem1, _Elem2> , less< int> , void> ; 
#line 5791
}; 
#line 5793
template< class _Elem1, class _Elem2, class _Elem3> 
#line 5794
struct _Lex_compare_memcmp_classify_pred< _Elem1, _Elem2, greater< _Elem3> >  { 
#line 5795
using _Pred = conditional_t< (_Lex_compare_memcmp_classify_elements< _Elem3, _Elem3>  && _Iter_copy_cat< _Elem1 *, _Elem3 *> ::_Bitcopy_constructible) && _Iter_copy_cat< _Elem2 *, _Elem3 *> ::_Bitcopy_constructible, greater< int> , void> ; 
#line 5799
}; 
#line 5801
template< class _Elem1, class _Elem2> 
#line 5802
struct _Lex_compare_memcmp_classify_pred< _Elem1, _Elem2, greater<> >  { 
#line 5803
using _Pred = conditional_t< _Lex_compare_memcmp_classify_elements< _Elem1, _Elem2> , greater< int> , void> ; 
#line 5804
}; 
#line 5818 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class _It1, class _It2, class _Pr> using _Lex_compare_memcmp_classify = conditional_t< (_Iterators_are_contiguous< _It1, _It2>  && (!_Iterator_is_volatile< _It1> )) && (!_Iterator_is_volatile< _It2> ), typename _Lex_compare_memcmp_classify_pred< _Iter_value_t< _It1> , _Iter_value_t< _It2> , _Pr> ::_Pred, void> ; 
#line 5823
template < class _InIt1, class _InIt2, class _Pr >
[ [ nodiscard ] ] inline bool lexicographical_compare (
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred ) {

    :: std :: _Adl_verify_range ( _First1, _Last1 );
    :: std :: _Adl_verify_range ( _First2, _Last2 );
    auto _UFirst1 = :: std :: _Get_unwrapped ( _First1 );
    const auto _ULast1 = :: std :: _Get_unwrapped ( _Last1 );
    auto _UFirst2 = :: std :: _Get_unwrapped ( _First2 );
    const auto _ULast2 = :: std :: _Get_unwrapped ( _Last2 );

    using _Memcmp_pred = _Lex_compare_memcmp_classify < decltype ( _UFirst1 ), decltype ( _UFirst2 ), _Pr >;
    if constexpr ( ! is_void_v < _Memcmp_pred > ) {



        {
            const auto _Num1 = static_cast < size_t > ( _ULast1 - _UFirst1 );
            const auto _Num2 = static_cast < size_t > ( _ULast2 - _UFirst2 );
            const size_t _Num = ( :: std :: min ) ( _Num1, _Num2 );

            const auto _First1_ptr = :: std :: _To_address ( _UFirst1 );
            const auto _First2_ptr = :: std :: _To_address ( _UFirst2 );
            const size_t _Pos = _Mismatch_vectorized < sizeof ( * _First1_ptr ) > ( _First1_ptr, _First2_ptr, _Num );
            if ( _Pos == _Num2 ) {
                return false;
            } else if ( _Pos == _Num1 ) {
                return true;
            } else {
                return _Pred ( _First1_ptr [ _Pos ], _First2_ptr [ _Pos ] );
            }




        }
    }

    for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++ _UFirst1, ( void ) ++ _UFirst2 ) {
        if ( static_cast < bool > ( _Pred ( * _UFirst1, * _UFirst2 ) ) ) {
            return true;
        } else if ( _Pred ( * _UFirst2, * _UFirst1 ) ) {
            return false;
        }
    }

    return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;
}
#line 5872 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _InIt1, class _InIt2 >
[ [ nodiscard ] ] inline bool lexicographical_compare (
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2 ) {

    return :: std :: lexicographical_compare ( _First1, _Last1, _First2, _Last2, less < > { } );
}
#line 6018 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class _Ty, class _Elem> 
#line 6019
struct _Vector_alg_in_find_is_safe_object_pointers : public false_type { }; 
#line 6020
template< class _Ty1, class _Ty2> 
#line 6021
struct _Vector_alg_in_find_is_safe_object_pointers< _Ty1 *, _Ty2 *>  : public conjunction< disjunction< is_object< _Ty1> , is_void< _Ty1> > , disjunction< is_object< _Ty2> , is_void< _Ty2> > , disjunction< is_same< remove_cv_t< _Ty1> , remove_cv_t< _Ty2> > , is_void< _Ty1> , is_void< _Ty2> > >  { 
#line 6028
}; 
#line 6031
template< class _Ty, class _Elem> constexpr bool 
#line 6032
_Vector_alg_in_find_is_safe_elem = disjunction_v< conjunction< is_integral< _Ty> , is_integral< _Elem> > , conjunction< is_pointer< _Ty> , is_same< _Ty, _Elem> > , conjunction< is_same< _Ty, std::nullptr_t> , is_pointer< _Elem> > , _Vector_alg_in_find_is_safe_object_pointers< _Ty, _Elem> > ; 
#line 6050
template< class _Iter, class _Ty> constexpr bool 
#line 6051
_Vector_alg_in_find_is_safe = (_Iterator_is_contiguous< _Iter>  && (!_Iterator_is_volatile< _Iter> )) && _Vector_alg_in_find_is_safe_elem< _Ty, _Iter_value_t< _Iter> > ; 
#line 6059
template < class _InIt, class _Ty >
[ [ nodiscard ] ] constexpr bool _Could_compare_equal_to_value_type ( const _Ty & _Val ) {

    ;

    if constexpr ( disjunction_v <



                      is_same < _Ty, bool >, is_pointer < _Ty >, is_same < _Ty, nullptr_t >> ) {
        return true;
    } else {
        using _Elem = _Iter_value_t < _InIt >;
        ;

        if constexpr ( is_same_v < _Elem, bool > ) {
            return _Val == true || _Val == false;
        } else if constexpr ( is_signed_v < _Elem > ) {
            constexpr _Elem _Min = :: std :: _Min_limit < _Elem > ( );
            constexpr _Elem _Max = :: std :: _Max_limit < _Elem > ( );

            if constexpr ( is_signed_v < _Ty > ) {

                return _Min <= _Val && _Val <= _Max;
            } else {

                if constexpr ( _Elem { - 1 } == static_cast < _Ty > ( - 1 ) ) {

                    return _Val <= _Max || static_cast < _Ty > ( _Min ) <= _Val;
                } else {

                    return _Val <= _Max;
                }
            }
        } else {
            constexpr _Elem _Max = :: std :: _Max_limit < _Elem > ( );

            if constexpr ( is_unsigned_v < _Ty > ) {

                return _Val <= _Max;
            } else {

                if constexpr ( _Ty { - 1 } == static_cast < _Elem > ( - 1 ) ) {

                    return _Val <= _Max;
                } else {

                    return 0 <= _Val && _Val <= _Max;
                }
            }
        }
    }
}
#line 6113
template < class _InIt, class _Ty >
[ [ nodiscard ] ] inline _InIt _Find_unchecked ( _InIt _First, const _InIt _Last, const _Ty & _Val ) {


    if constexpr ( _Vector_alg_in_find_is_safe < _InIt, _Ty > ) {



        {
            if ( ! :: std :: _Could_compare_equal_to_value_type < _InIt > ( _Val ) ) {
                return _Last;
            }

            const auto _First_ptr = :: std :: _To_address ( _First );
            const auto _Result = :: std :: _Find_vectorized ( _First_ptr, :: std :: _To_address ( _Last ), _Val );
            if constexpr ( is_pointer_v < _InIt > ) {
                return _Result;
            } else {
                return _First + ( _Result - _First_ptr );
            }























        }
    }

    for (; _First != _Last; ++ _First ) {
        if ( * _First == _Val ) {
            break;
        }
    }

    return _First;
}
#line 6168 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _InIt, class _Ty >
[ [ nodiscard ] ] inline _InIt find ( _InIt _First, const _InIt _Last, const _Ty & _Val ) {
    :: std :: _Adl_verify_range ( _First, _Last );
    if constexpr ( _Is_vb_iterator < _InIt > && is_same_v < _Ty, bool > ) {
        return :: std :: _Find_vbool ( _First, _Last, _Val );
    } else {
        :: std :: _Seek_wrapped ( _First, :: std :: _Find_unchecked ( :: std :: _Get_unwrapped ( _First ), :: std :: _Get_unwrapped ( _Last ), _Val ) );
        return _First;
    }
}
#line 6295 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _InIt, class _Ty >
[ [ nodiscard ] ] inline _Iter_diff_t < _InIt > count ( const _InIt _First, const _InIt _Last, const _Ty & _Val ) {

    :: std :: _Adl_verify_range ( _First, _Last );
    if constexpr ( _Is_vb_iterator < _InIt > && is_same_v < _Ty, bool > ) {
        return :: std :: _Count_vbool ( _First, _Last, _Val );
    } else {
        auto _UFirst = :: std :: _Get_unwrapped ( _First );
        const auto _ULast = :: std :: _Get_unwrapped ( _Last );


        if constexpr ( _Vector_alg_in_find_is_safe < decltype ( _UFirst ), _Ty > ) {



            {
                if ( ! :: std :: _Could_compare_equal_to_value_type < decltype ( _UFirst ) > ( _Val ) ) {
                    return 0;
                }

                return static_cast < _Iter_diff_t < _InIt >> (
                    :: std :: _Count_vectorized ( :: std :: _To_address ( _UFirst ), :: std :: _To_address ( _ULast ), _Val ) );
            }
        }


        _Iter_diff_t < _InIt > _Count = 0;

        for (; _UFirst != _ULast; ++ _UFirst ) {
            if ( * _UFirst == _Val ) {
                ++ _Count;
            }
        }

        return _Count;
    }
}
#line 6339 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _InIt, class _Ty, class _Pr >
[ [ nodiscard ] ] constexpr _InIt _Find_pr ( _InIt _First, const _InIt _Last, const _Ty & _Val, _Pr _Pred ) {
    for (; _First != _Last; ++ _First ) {
        if ( _Pred ( * _First, _Val ) ) {
            break;
        }
    }

    return _First;
}
#line 6350
template < class _InIt, class _Ty, class _Pr >
[ [ nodiscard ] ] constexpr _Iter_diff_t < _InIt > _Count_pr ( _InIt _First, const _InIt _Last, const _Ty & _Val, _Pr _Pred ) {
    _Iter_diff_t < _InIt > _Count = 0;

    for (; _First != _Last; ++ _First ) {
        if ( _Pred ( * _First, _Val ) ) {
            ++ _Count;
        }
    }

    return _Count;
}
#line 6363
enum class _TrimResult: unsigned char { _KeepTrimming, _HaveWorkAfterTrimming, _ReturnFalse, _ReturnTrue}; 
#line 6365
template < class _BidIt1, class _BidIt2, class _Pr >
[ [ nodiscard ] ] inline _TrimResult _Trim_equal (
    _BidIt1 & _First1, _BidIt1 & _Back1, _BidIt2 & _First2, _BidIt2 & _Back2, _Pr _Pred ) {


    ;
    ;
    if ( _Pred ( * _First1, * _First2 ) ) {
        do {
            ++ _First1;
            ++ _First2;
            if ( _First1 == _Back1 ) {

                return _Pred ( * _First1, * _First2 ) ? _TrimResult :: _ReturnTrue : _TrimResult :: _ReturnFalse;
            }
        } while ( _Pred ( * _First1, * _First2 ) );
    } else {
        if ( ! _Pred ( * _Back1, * _Back2 ) ) {

            return _TrimResult :: _HaveWorkAfterTrimming;
        }
        -- _Back1;
        -- _Back2;
    }

    for (;; ) {
        if ( _First1 == _Back1 ) {

            return _TrimResult :: _ReturnFalse;
        }

        if ( ! _Pred ( * _Back1, * _Back2 ) ) {
            return _TrimResult :: _KeepTrimming;
        }
        -- _Back1;
        -- _Back2;
    }
}
#line 6404
template < class _BidIt1, class _BidIt2, class _Pr >
[ [ nodiscard ] ] inline _TrimResult _Trim_reversed (
    _BidIt1 & _First1, _BidIt1 & _Back1, _BidIt2 & _First2, _BidIt2 & _Back2, _Pr _Pred ) {


    ;
    ;
    if ( _Pred ( * _First1, * _Back2 ) ) {
        do {
            ++ _First1;
            -- _Back2;
            if ( _First1 == _Back1 ) {

                return _Pred ( * _First1, * _First2 ) ? _TrimResult :: _ReturnTrue : _TrimResult :: _ReturnFalse;
            }
        } while ( _Pred ( * _First1, * _Back2 ) );
    } else {
        if ( ! _Pred ( * _Back1, * _First2 ) ) {

            return _TrimResult :: _HaveWorkAfterTrimming;
        }
        -- _Back1;
        ++ _First2;
    }

    for (;; ) {
        if ( _First1 == _Back1 ) {

            return _TrimResult :: _ReturnFalse;
        }

        if ( ! _Pred ( * _Back1, * _First2 ) ) {
            return _TrimResult :: _KeepTrimming;
        }
        -- _Back1;
        ++ _First2;
    }
}
#line 6443
template < class _BidIt1, class _BidIt2, class _Pr >
[ [ nodiscard ] ] inline _TrimResult _Trim_completely (
    _BidIt1 & _First1, _BidIt1 & _Back1, _BidIt2 & _First2, _BidIt2 & _Back2, _Pr _Pred ) {

    _TrimResult _Res = _TrimResult :: _KeepTrimming;

    for ( bool _Check_reversed = true; _Res == _TrimResult :: _KeepTrimming; _Check_reversed = ! _Check_reversed ) {
        if ( _Check_reversed ) {
            _Res = :: std :: _Trim_reversed ( _First1, _Back1, _First2, _Back2, _Pred );
        } else {
            _Res = :: std :: _Trim_equal ( _First1, _Back1, _First2, _Back2, _Pred );
        }
    }

    return _Res;
}
#line 6460
template < class _FwdIt1, class _FwdIt2, class _Pr >
[ [ nodiscard ] ] inline bool _Check_match_counts (
    _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred ) {

    ;
    ;
    if constexpr ( _Is_ranges_bidi_iter_v < _FwdIt1 > && _Is_ranges_bidi_iter_v < _FwdIt2 > ) {
        do {
            -- _Last1;
            -- _Last2;
        } while ( _Pred ( * _Last1, * _Last2 ) );

        if ( _First1 == _Last1 ) {
            return false;
        }

        const _TrimResult _Res = :: std :: _Trim_completely ( _First1, _Last1, _First2, _Last2, _Pred );

        if ( _Res != _TrimResult :: _HaveWorkAfterTrimming ) {
            return _Res == _TrimResult :: _ReturnTrue;
        }

        ++ _Last1;
        ++ _Last2;
    }

    for ( _FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++ _Next1 ) {
        if ( _Next1 == :: std :: _Find_pr ( _First1, _Next1, * _Next1, _Pred ) ) {
            _Iter_diff_t < _FwdIt2 > _Count2 = :: std :: _Count_pr ( _First2, _Last2, * _Next1, _Pred );
            if ( _Count2 == 0 ) {
                return false;
            }

            _FwdIt1 _Skip1 = :: std :: _Next_iter ( _Next1 );
            _Iter_diff_t < _FwdIt1 > _Count1 = :: std :: _Count_pr ( _Skip1, _Last1, * _Next1, _Pred ) + 1;
            if ( _Count2 != _Count1 ) {
                return false;
            }
        }
    }

    return true;
}
#line 6504
template < class _BidIt >
inline void reverse ( const _BidIt _First, const _BidIt _Last ) {
    :: std :: _Adl_verify_range ( _First, _Last );
    auto _UFirst = :: std :: _Get_unwrapped ( _First );
    auto _ULast = :: std :: _Get_unwrapped ( _Last );

    using _Elem = remove_reference_t < _Iter_ref_t < decltype ( _UFirst ) >>;
    constexpr bool _Allow_vectorization = conjunction_v < bool_constant < _Iterator_is_contiguous < decltype ( _UFirst ) >>,
        _Is_trivially_swappable < _Elem >, negation < is_volatile < _Elem >> >;
    constexpr size_t _Nx = sizeof ( _Elem );

    if constexpr ( _Allow_vectorization && _Nx <= 8 && ( _Nx & ( _Nx - 1 ) ) == 0 ) {



        {
            :: std :: _Reverse_vectorized < _Nx > ( :: std :: _To_address ( _UFirst ), :: std :: _To_address ( _ULast ) );
            return;
        }
    }


    for (; _UFirst != _ULast && _UFirst != -- _ULast; ++ _UFirst ) {
        swap ( * _UFirst, * _ULast );
    }
}
#line 6541 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _BidIt >
constexpr pair < _BidIt, _BidIt > _Reverse_until_sentinel_unchecked ( _BidIt _First, _BidIt _Sentinel, _BidIt _Last ) {

    while ( _First != _Sentinel && _Last != _Sentinel ) {
        swap ( * _First, * -- _Last );
        ++ _First;
    }

    return pair < _BidIt, _BidIt > ( _First, _Last );
}
#line 6552
template < class _FwdIt >
inline _FwdIt rotate ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last ) {



    :: std :: _Adl_verify_range ( _First, _Mid );
    :: std :: _Adl_verify_range ( _Mid, _Last );
    auto _UFirst = :: std :: _Get_unwrapped ( _First );
    auto _UMid = :: std :: _Get_unwrapped ( _Mid );
    const auto _ULast = :: std :: _Get_unwrapped ( _Last );
    if ( _UFirst == _UMid ) {
        return _Last;
    }

    if ( _UMid == _ULast ) {
        return _First;
    }

    if constexpr ( _Is_cpp17_random_iter_v < _FwdIt > ) {
        :: std :: reverse ( _UFirst, _UMid );
        :: std :: reverse ( _UMid, _ULast );
        :: std :: reverse ( _UFirst, _ULast );
        :: std :: _Seek_wrapped ( _First, _UFirst + ( _ULast - _UMid ) );
    } else if constexpr ( _Is_cpp17_bidi_iter_v < _FwdIt > ) {
        :: std :: reverse ( _UFirst, _UMid );
        :: std :: reverse ( _UMid, _ULast );
        auto _Tmp = :: std :: _Reverse_until_sentinel_unchecked ( _UFirst, _UMid, _ULast );
        :: std :: reverse ( _Tmp . first, _Tmp . second );
        :: std :: _Seek_wrapped ( _First, _UMid != _Tmp . first ? _Tmp . first : _Tmp . second );
    } else {
        auto _UNext = _UMid;
        do {
            swap ( * _UFirst, * _UNext );
            ++ _UFirst;
            ++ _UNext;
            if ( _UFirst == _UMid ) {
                _UMid = _UNext;
            }
        } while ( _UNext != _ULast );
        :: std :: _Seek_wrapped ( _First, _UFirst );
        while ( _UMid != _ULast ) {
            _UNext = _UMid;
            do {
                swap ( * _UFirst, * _UNext );
                ++ _UFirst;
                ++ _UNext;
                if ( _UFirst == _UMid ) {
                    _UMid = _UNext;
                }
            } while ( _UNext != _ULast );
        }
    }

    return _First;
}
#line 6618 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _InIt, class _Pr >
[ [ nodiscard ] ] inline _InIt find_if ( _InIt _First, const _InIt _Last, _Pr _Pred ) {
    :: std :: _Adl_verify_range ( _First, _Last );
    auto _UFirst = :: std :: _Get_unwrapped ( _First );
    const auto _ULast = :: std :: _Get_unwrapped ( _Last );
    for (; _UFirst != _ULast; ++ _UFirst ) {
        if ( _Pred ( * _UFirst ) ) {
            break;
        }
    }

    :: std :: _Seek_wrapped ( _First, _UFirst );
    return _First;
}
#line 6954 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class _Iter, class _Pr, class _Elem = _Iter_value_t< _Iter> > constexpr bool 
#line 6955
_Is_min_max_optimization_safe = (_Iterator_is_contiguous< _Iter>  && (!_Iterator_is_volatile< _Iter> )) && conjunction_v< disjunction< is_floating_point< _Elem> , is_integral< _Elem> , is_pointer< _Elem> > , disjunction< is_same< _Pr, less<> > , is_same< _Pr, less< _Elem> > > > ; 
#line 6984 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template< class _Iter, class _Pr, class _Elem = _Iter_value_t< _Iter> > constexpr bool 
#line 6985
_Is_min_max_value_optimization_safe = (!is_floating_point_v< _Elem> ) && _Is_min_max_optimization_safe< _Iter, _Pr, _Elem> ; 
#line 6991 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _FwdIt, class _Pr >
constexpr _FwdIt _Max_element_unchecked ( _FwdIt _First, _FwdIt _Last, _Pr _Pred ) {

    if constexpr ( _Is_min_max_optimization_safe < _FwdIt, _Pr > ) {
        if ( ! _Is_constant_evaluated ( ) ) {
            const auto _First_ptr = :: std :: _To_address ( _First );
            const auto _Result = :: std :: _Max_element_vectorized ( _First_ptr, :: std :: _To_address ( _Last ) );
            if constexpr ( is_pointer_v < _FwdIt > ) {
                return _Result;
            } else {
                return _First + ( _Result - _First_ptr );
            }
        }
    }


    _FwdIt _Found = _First;
    if ( _First != _Last ) {
        while ( ++ _First != _Last ) {
            if ( static_cast < bool > ( _Pred ( * _Found, * _First ) ) ) {
                _Found = _First;
            }
        }
    }

    return _Found;
}
#line 7019 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _FwdIt, class _Pr >
[ [ nodiscard ] ] constexpr _FwdIt max_element ( _FwdIt _First, _FwdIt _Last, _Pr _Pred ) {
    :: std :: _Adl_verify_range ( _First, _Last );
    :: std :: _Seek_wrapped ( _First,
        :: std :: _Max_element_unchecked ( :: std :: _Get_unwrapped ( _First ), :: std :: _Get_unwrapped ( _Last ), :: std :: _Pass_fn ( _Pred ) ) );
    return _First;
}
#line 7027
template < class _FwdIt >
[ [ nodiscard ] ] constexpr _FwdIt max_element ( _FwdIt _First, _FwdIt _Last ) {
    return :: std :: max_element ( _First, _Last, less < > { } );
}
#line 7115 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Ty, class _Pr >
[ [ nodiscard ] ] constexpr _Ty ( max ) ( initializer_list < _Ty > _Ilist, _Pr _Pred ) {

    ;


    if constexpr ( _Is_min_max_value_optimization_safe < const _Ty *, _Pr > ) {
        if ( ! _Is_constant_evaluated ( ) ) {
            return static_cast < _Ty > ( :: std :: _Max_vectorized ( _Ilist . begin ( ), _Ilist . end ( ) ) );
        }
    }

    const _Ty * _Res = :: std :: _Max_element_unchecked ( _Ilist . begin ( ), _Ilist . end ( ), :: std :: _Pass_fn ( _Pred ) );
    return * _Res;
}
#line 7131 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Ty >
[ [ nodiscard ] ] constexpr _Ty ( max ) ( initializer_list < _Ty > _Ilist ) {

    return ( :: std :: max ) ( _Ilist, less < > { } );
}
#line 7215 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _FwdIt, class _Pr >
constexpr _FwdIt _Min_element_unchecked ( _FwdIt _First, _FwdIt _Last, _Pr _Pred ) {

    if constexpr ( _Is_min_max_optimization_safe < _FwdIt, _Pr > ) {
        if ( ! _Is_constant_evaluated ( ) ) {
            const auto _First_ptr = :: std :: _To_address ( _First );
            const auto _Result = :: std :: _Min_element_vectorized ( _First_ptr, :: std :: _To_address ( _Last ) );
            if constexpr ( is_pointer_v < _FwdIt > ) {
                return _Result;
            } else {
                return _First + ( _Result - _First_ptr );
            }
        }
    }


    _FwdIt _Found = _First;
    if ( _First != _Last ) {
        while ( ++ _First != _Last ) {
            if ( static_cast < bool > ( _Pred ( * _First, * _Found ) ) ) {
                _Found = _First;
            }
        }
    }

    return _Found;
}
#line 7243 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _FwdIt, class _Pr >
[ [ nodiscard ] ] constexpr _FwdIt min_element ( _FwdIt _First, _FwdIt _Last, _Pr _Pred ) {
    :: std :: _Adl_verify_range ( _First, _Last );
    :: std :: _Seek_wrapped ( _First,
        :: std :: _Min_element_unchecked ( :: std :: _Get_unwrapped ( _First ), :: std :: _Get_unwrapped ( _Last ), :: std :: _Pass_fn ( _Pred ) ) );
    return _First;
}
#line 7251
template < class _FwdIt >
[ [ nodiscard ] ] constexpr _FwdIt min_element ( _FwdIt _First, _FwdIt _Last ) {
    return :: std :: min_element ( _First, _Last, less < > { } );
}
#line 7339 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Ty, class _Pr >
[ [ nodiscard ] ] constexpr _Ty ( min ) ( initializer_list < _Ty > _Ilist, _Pr _Pred ) {

    ;


    if constexpr ( _Is_min_max_value_optimization_safe < const _Ty *, _Pr > ) {
        if ( ! _Is_constant_evaluated ( ) ) {
            return static_cast < _Ty > ( :: std :: _Min_vectorized ( _Ilist . begin ( ), _Ilist . end ( ) ) );
        }
    }

    const _Ty * _Res = :: std :: _Min_element_unchecked ( _Ilist . begin ( ), _Ilist . end ( ), :: std :: _Pass_fn ( _Pred ) );
    return * _Res;
}
#line 7355 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _Ty >
[ [ nodiscard ] ] constexpr _Ty ( min ) ( initializer_list < _Ty > _Ilist ) {

    return ( :: std :: min ) ( _Ilist, less < > { } );
}
#line 7433 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template < class _FwdIt, class _Ty, class _Pr >
[ [ nodiscard ] ] inline _FwdIt lower_bound ( _FwdIt _First, const _FwdIt _Last, const _Ty & _Val, _Pr _Pred ) {

    :: std :: _Adl_verify_range ( _First, _Last );
    auto _UFirst = :: std :: _Get_unwrapped ( _First );
    _Iter_diff_t < _FwdIt > _Count = :: std :: distance ( _UFirst, :: std :: _Get_unwrapped ( _Last ) );

    while ( 0 < _Count ) {
        const _Iter_diff_t < _FwdIt > _Count2 = _Count / 2;
        const auto _UMid = :: std :: next ( _UFirst, _Count2 );
        if ( _Pred ( * _UMid, _Val ) ) {
            _UFirst = :: std :: _Next_iter ( _UMid );
            _Count -= _Count2 + 1;
        } else {
            _Count = _Count2;
        }
    }

    :: std :: _Seek_wrapped ( _First, _UFirst );
    return _First;
}
#line 7455
template < class _FwdIt, class _Ty >
[ [ nodiscard ] ] inline _FwdIt lower_bound ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val ) {

    return :: std :: lower_bound ( _First, _Last, _Val, less < > { } );
}
#line 7461
template < class _FwdIt, class _Ty, class _Pr >
[ [ nodiscard ] ] inline _FwdIt upper_bound ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val, _Pr _Pred ) {

    :: std :: _Adl_verify_range ( _First, _Last );
    auto _UFirst = :: std :: _Get_unwrapped ( _First );
    _Iter_diff_t < _FwdIt > _Count = :: std :: distance ( _UFirst, :: std :: _Get_unwrapped ( _Last ) );

    while ( 0 < _Count ) {
        _Iter_diff_t < _FwdIt > _Count2 = _Count / 2;
        const auto _UMid = :: std :: next ( _UFirst, _Count2 );
        if ( _Pred ( _Val, * _UMid ) ) {
            _Count = _Count2;
        } else {
            _UFirst = :: std :: _Next_iter ( _UMid );
            _Count -= _Count2 + 1;
        }
    }

    :: std :: _Seek_wrapped ( _First, _UFirst );
    return _First;
}
#line 7483
template < class _FwdIt, class _Ty >
[ [ nodiscard ] ] inline _FwdIt upper_bound ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val ) {

    return :: std :: upper_bound ( _First, _Last, _Val, less < > { } );
}
#line 7489
template < class _FwdIt1, class _FwdIt2 >
inline _FwdIt2 _Swap_ranges_unchecked ( _FwdIt1 _First1, const _FwdIt1 _Last1, _FwdIt2 _First2 ) {



    using _Elem1 = remove_reference_t < _Iter_ref_t < _FwdIt1 >>;
    using _Elem2 = remove_reference_t < _Iter_ref_t < _FwdIt2 >>;
    if constexpr ( is_same_v < _Elem1, _Elem2 > && _Is_trivially_swappable_v < _Elem1 >
                  && _Iterators_are_contiguous < _FwdIt1, _FwdIt2 > ) {



        {
            :: __std_swap_ranges_trivially_swappable_noalias (
                :: std :: _To_address ( _First1 ), :: std :: _To_address ( _Last1 ), :: std :: _To_address ( _First2 ) );
            return _First2 + ( _Last1 - _First1 );
        }
    }


    for (; _First1 != _Last1; ++ _First1, ( void ) ++ _First2 ) {
        swap ( * _First1, * _First2 );
    }

    return _First2;
}
#line 7516 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
[[noreturn]] void __cdecl _Xbad_alloc(); 
#line 7517
[[noreturn]] void __cdecl _Xinvalid_argument(const char *); 
#line 7518
[[noreturn]] void __cdecl _Xlength_error(const char *); 
#line 7519
[[noreturn]] void __cdecl _Xout_of_range(const char *); 
#line 7520
[[noreturn]] void __cdecl _Xoverflow_error(const char *); 
#line 7521
[[noreturn]] void __cdecl _Xruntime_error(const char *); 
#line 7522
[[noreturn]] void __cdecl _XGetLastError(); 
#line 7524
template< class _Category, class _Ty, class _Diff = ptrdiff_t, class _Pointer = _Ty *, class 
#line 7525
_Reference = _Ty &> 
#line 7526
struct iterator { 
#line 7527
using iterator_category = _Category; 
#line 7528
using value_type = _Ty; 
#line 7529
using difference_type = _Diff; 
#line 7530
using pointer = _Pointer; 
#line 7531
using reference = _Reference; 
#line 7532
}; 
#line 7618 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
}
#line 7627
#pragma warning(pop)
#pragma pack ( pop )
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iterator"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 20
namespace std { 
#line 21
template < class _Container >
class back_insert_iterator {
public :
    using iterator_category = output_iterator_tag;
    using value_type = void;
    using pointer = void;
    using reference = void;

    using container_type = _Container;




    using difference_type = void;


    inline explicit back_insert_iterator ( _Container & _Cont ) noexcept
        : container ( :: std :: addressof ( _Cont ) ) { }

    inline back_insert_iterator & operator = ( const typename _Container :: value_type & _Val ) {
        container -> push_back ( _Val );
        return * this;
    }

    inline back_insert_iterator & operator = ( typename _Container :: value_type && _Val ) {
        container -> push_back ( :: std :: move ( _Val ) );
        return * this;
    }

    [ [ nodiscard ] ] inline back_insert_iterator & operator * ( ) noexcept {
        return * this;
    }

    inline back_insert_iterator & operator ++ ( ) noexcept {
        return * this;
    }

    inline back_insert_iterator operator ++ ( int ) noexcept {
        return * this;
    }

protected :
    _Container * container;
};
#line 66 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iterator"
template < class _Container >
[ [ nodiscard ] ] inline back_insert_iterator < _Container > back_inserter ( _Container & _Cont ) noexcept {

    return back_insert_iterator < _Container > ( _Cont );
}
#line 72
template < class _Container >
class front_insert_iterator {
public :
    using iterator_category = output_iterator_tag;
    using value_type = void;
    using pointer = void;
    using reference = void;

    using container_type = _Container;




    using difference_type = void;


    inline explicit front_insert_iterator ( _Container & _Cont ) : container ( :: std :: addressof ( _Cont ) ) { }

    inline front_insert_iterator & operator = ( const typename _Container :: value_type & _Val ) {

        container -> push_front ( _Val );
        return * this;
    }

    inline front_insert_iterator & operator = ( typename _Container :: value_type && _Val ) {
        container -> push_front ( :: std :: move ( _Val ) );
        return * this;
    }

    [ [ nodiscard ] ] inline front_insert_iterator & operator * ( ) {
        return * this;
    }

    inline front_insert_iterator & operator ++ ( ) {
        return * this;
    }

    inline front_insert_iterator operator ++ ( int ) {
        return * this;
    }

protected :
    _Container * container;
};
#line 117 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iterator"
template < class _Container >
[ [ nodiscard ] ] inline front_insert_iterator < _Container > front_inserter ( _Container & _Cont ) {
    return front_insert_iterator < _Container > ( _Cont );
}
#line 122
template < class _Container >
class insert_iterator {
public :
    using iterator_category = output_iterator_tag;
    using value_type = void;
    using pointer = void;
    using reference = void;

    using container_type = _Container;




    using difference_type = void;
    using _Wrapped_iter = typename _Container :: iterator;


    inline insert_iterator ( _Container & _Cont, _Wrapped_iter _Where )
        : container ( :: std :: addressof ( _Cont ) ), iter ( :: std :: move ( _Where ) ) { }

    inline insert_iterator & operator = ( const typename _Container :: value_type & _Val ) {

        iter = container -> insert ( iter, _Val );
        ++ iter;
        return * this;
    }

    inline insert_iterator & operator = ( typename _Container :: value_type && _Val ) {
        iter = container -> insert ( iter, :: std :: move ( _Val ) );
        ++ iter;
        return * this;
    }

    [ [ nodiscard ] ] inline insert_iterator & operator * ( ) {
        return * this;
    }

    inline insert_iterator & operator ++ ( ) {
        return * this;
    }

    inline insert_iterator & operator ++ ( int ) {
        return * this;
    }

protected :
    _Container * container;
    _Wrapped_iter iter;
};
#line 173 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iterator"
template < class _Container >
[ [ nodiscard ] ] inline insert_iterator < _Container > inserter ( _Container & _Cont, typename _Container :: iterator _Where ) {
    return insert_iterator < _Container > ( _Cont, _Where );
}
#line 233 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iterator"
template < class _Ty, class _Elem = char, class _Traits = char_traits < _Elem >, class _Diff = ptrdiff_t >
class istream_iterator {
public :
    using iterator_category = input_iterator_tag;
    using value_type = _Ty;
    using difference_type = _Diff;
    using pointer = const _Ty *;
    using reference = const _Ty &;
    using char_type = _Elem;
    using traits_type = _Traits;
    using istream_type = basic_istream < _Elem, _Traits >;

    static_assert ( conjunction_v < is_default_constructible < _Ty >, is_copy_constructible < _Ty >, is_copy_assignable < _Ty >>,
        "istream_iterator<T> requires T to be default constructible, copy constructible, and copy assignable. (N4950 [istream.iterator]/2" ")"
                                      );

    constexpr istream_iterator ( ) noexcept ( is_nothrow_default_constructible_v < _Ty > ) { }






    istream_iterator ( istream_type & _Istr ) : _Myistr ( :: std :: addressof ( _Istr ) ) {
        _Getval ( );
    }

    [ [ nodiscard ] ] const _Ty & operator * ( ) const noexcept {
        ;
        return _Myval;
    }

    [ [ nodiscard ] ] const _Ty * operator -> ( ) const noexcept {
        ;
        return :: std :: addressof ( _Myval );
    }

    istream_iterator & operator ++ ( ) {
        _Getval ( );
        return * this;
    }

    istream_iterator operator ++ ( int ) {
        istream_iterator _Tmp = * this;
        _Getval ( );
        return _Tmp;
    }

    [ [ nodiscard ] ] bool _Equal ( const istream_iterator & _Right ) const noexcept {
        return _Myistr == _Right . _Myistr;
    }







private :
    void _Getval ( ) {
        ;
        if ( ! ( * _Myistr >> _Myval ) ) {
            _Myistr = nullptr;
        }
    }

    istream_type * _Myistr { nullptr };
    _Ty _Myval { };
};
#line 303 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iterator"
template < class _Ty, class _Elem, class _Traits, class _Diff >
[ [ nodiscard ] ] bool operator == ( const istream_iterator < _Ty, _Elem, _Traits, _Diff > & _Left,
    const istream_iterator < _Ty, _Elem, _Traits, _Diff > & _Right ) noexcept {
    return _Left . _Equal ( _Right );
}
#line 310
template < class _Ty, class _Elem, class _Traits, class _Diff >
[ [ nodiscard ] ] bool operator != ( const istream_iterator < _Ty, _Elem, _Traits, _Diff > & _Left,
    const istream_iterator < _Ty, _Elem, _Traits, _Diff > & _Right ) noexcept {
    return ! ( _Left == _Right );
}
#line 317 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iterator"
template < class _Ty, class _Elem = char, class _Traits = char_traits < _Elem > >
class ostream_iterator {
public :
    using iterator_category = output_iterator_tag;
    using value_type = void;



    using difference_type = void;

    using pointer = void;
    using reference = void;
    using char_type = _Elem;
    using traits_type = _Traits;
    using ostream_type = basic_ostream < _Elem, _Traits >;

    ostream_iterator ( ostream_type & _Ostr, const _Elem * const _Delim = nullptr ) noexcept
        : _Mydelim ( _Delim ), _Myostr ( :: std :: addressof ( _Ostr ) ) { }

    ostream_iterator & operator = ( const _Ty & _Val ) {
        * _Myostr << _Val;
        if ( _Mydelim ) {
            * _Myostr << _Mydelim;
        }

        return * this;
    }

    [ [ nodiscard ] ] ostream_iterator & operator * ( ) noexcept {
        return * this;
    }

    ostream_iterator & operator ++ ( ) noexcept {
        return * this;
    }

    ostream_iterator & operator ++ ( int ) noexcept {
        return * this;
    }

private :
    const _Elem * _Mydelim;
    ostream_type * _Myostr;
};
#line 362 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iterator"
template < class _Elem, class _Traits >
class istreambuf_iterator {
public :
    using iterator_category = input_iterator_tag;
    using value_type = _Elem;
    using difference_type = typename _Traits :: off_type;
    using pointer = const _Elem *;
    using reference = _Elem;
    using char_type = _Elem;
    using traits_type = _Traits;
    using int_type = typename traits_type :: int_type;
    using streambuf_type = basic_streambuf < _Elem, _Traits >;
    using istream_type = basic_istream < _Elem, _Traits >;

    constexpr istreambuf_iterator ( ) noexcept : _Strbuf ( nullptr ), _Got ( true ), _Val ( ) { }




    istreambuf_iterator ( istream_type & _Istr ) noexcept : _Strbuf ( _Istr . rdbuf ( ) ), _Got ( ! _Strbuf ), _Val ( ) { }

    istreambuf_iterator ( streambuf_type * _Sb ) noexcept : _Strbuf ( _Sb ), _Got ( ! _Sb ), _Val ( ) { }

private :
    class _Istreambuf_proxy {
    public :
        [ [ nodiscard ] ] _Elem operator * ( ) const noexcept ( is_nothrow_copy_constructible_v < _Elem > ) {
            return _Keep;
        }

    private :
        friend istreambuf_iterator;
        _Istreambuf_proxy ( streambuf_type * _Strbuf_, _Elem _Keep_ )
            noexcept ( is_nothrow_copy_constructible_v < _Elem > )
            : _Strbuf ( _Strbuf_ ), _Keep ( _Keep_ ) { }

        streambuf_type * _Strbuf;
        _Elem _Keep;
    };

public :
    istreambuf_iterator ( const _Istreambuf_proxy & _Px ) noexcept : _Strbuf ( _Px . _Strbuf ), _Got ( ! _Strbuf ), _Val ( ) { }

    [ [ nodiscard ] ] _Elem operator * ( ) const {
        if ( ! _Got ) {
            _Peek ( );
        }





        return _Val;
    }

    istreambuf_iterator & operator ++ ( ) {




        _Inc ( );
        return * this;
    }

    _Istreambuf_proxy operator ++ ( int ) {
        if ( ! _Got ) {
            _Peek ( );
        }

        _Istreambuf_proxy _Tmp { _Strbuf, _Val };
        ++ * this;
        return _Tmp;
    }

    [ [ nodiscard ] ] bool equal ( const istreambuf_iterator & _Right ) const {
        if ( ! _Got ) {
            _Peek ( );
        }

        if ( ! _Right . _Got ) {
            _Right . _Peek ( );
        }

        return ( ! _Strbuf && ! _Right . _Strbuf ) || ( _Strbuf && _Right . _Strbuf );
    }











private :
    void _Inc ( ) {
        if ( ! _Strbuf || traits_type :: eq_int_type ( traits_type :: eof ( ), _Strbuf -> sbumpc ( ) ) ) {
            _Strbuf = nullptr;
            _Got = true;
        } else {
            _Got = false;
        }
    }

    _Elem _Peek ( ) const {
        int_type _Meta;
        if ( ! _Strbuf || traits_type :: eq_int_type ( traits_type :: eof ( ), _Meta = _Strbuf -> sgetc ( ) ) ) {
            _Strbuf = nullptr;
        } else {
            _Val = traits_type :: to_char_type ( _Meta );
        }

        _Got = true;
        return _Val;
    }

    mutable streambuf_type * _Strbuf;
    mutable bool _Got;
    mutable _Elem _Val;
};
#line 485 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iterator"
template < class _Elem, class _Traits >
[ [ nodiscard ] ] bool operator == (
    const istreambuf_iterator < _Elem, _Traits > & _Left, const istreambuf_iterator < _Elem, _Traits > & _Right ) {
    return _Left . equal ( _Right );
}
#line 492
template < class _Elem, class _Traits >
[ [ nodiscard ] ] bool operator != (
    const istreambuf_iterator < _Elem, _Traits > & _Left, const istreambuf_iterator < _Elem, _Traits > & _Right ) {
    return ! ( _Left == _Right );
}
#line 504 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iterator"
template < class _Elem, class _Traits >
class ostreambuf_iterator {
public :
    using iterator_category = output_iterator_tag;
    using value_type = void;



    using difference_type = void;

    using pointer = void;
    using reference = void;
    using char_type = _Elem;
    using traits_type = _Traits;
    using streambuf_type = basic_streambuf < _Elem, _Traits >;
    using ostream_type = basic_ostream < _Elem, _Traits >;

    ostreambuf_iterator ( streambuf_type * _Sb ) noexcept : _Strbuf ( _Sb ) { }

    ostreambuf_iterator ( ostream_type & _Ostr ) noexcept : _Strbuf ( _Ostr . rdbuf ( ) ) { }

    ostreambuf_iterator & operator = ( _Elem _Right ) {
        if ( ! _Strbuf || traits_type :: eq_int_type ( _Traits :: eof ( ), _Strbuf -> sputc ( _Right ) ) ) {
            _Failed = true;
        }

        return * this;
    }

    [ [ nodiscard ] ] ostreambuf_iterator & operator * ( ) noexcept {
        return * this;
    }

    ostreambuf_iterator & operator ++ ( ) noexcept {
        return * this;
    }

    ostreambuf_iterator & operator ++ ( int ) noexcept {
        return * this;
    }

    [ [ nodiscard ] ] bool failed ( ) const noexcept {
        return _Failed;
    }

private :
    bool _Failed = false;
    streambuf_type * _Strbuf;
};
#line 1468 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iterator"
}
#line 1481
namespace stdext { 
#line 1482
template < class _Ptr >
class [ [ deprecated ( "warning STL4043: stdext::checked_array_iterator, stdext::unchecked_array_iterator, and related factory functions are non-Standar" "d extensions and will be removed in the future. std::span (since C++20) and gsl::span can be used instead. You can define _SILEN" "CE_STDEXT_ARR_ITERS_DEPRECATION_WARNING or _SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS to suppress this warning." ) ] ] checked_array_iterator {
private :
    using _Pointee_type = :: std :: remove_pointer_t < _Ptr >;
    static_assert ( :: std :: is_pointer_v < _Ptr > && :: std :: is_object_v < _Pointee_type >,
        "checked_array_iterator requires pointers to objects" );

public :
    using iterator_category = :: std :: random_access_iterator_tag;
    using value_type = :: std :: remove_cv_t < _Pointee_type >;
    using difference_type = :: std :: ptrdiff_t;
    using pointer = _Ptr;
    using reference = _Pointee_type &;




    constexpr checked_array_iterator ( ) = default;

    constexpr checked_array_iterator ( const _Ptr _Array, const size_t _Size, const size_t _Index = 0 ) noexcept
        : _Myarray ( _Array ), _Mysize ( _Size ), _Myindex ( _Index ) {
        if ( ! ( _Index <= _Size ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };
    }

    __pragma(warning(push))                            __pragma(warning(disable : 4996))
    template < class _Ty = _Pointee_type, :: std :: enable_if_t < ! :: std :: is_const_v < _Ty >, int > = 0 >
    constexpr operator checked_array_iterator < const _Ty * > ( ) const noexcept {
        return checked_array_iterator < const _Ty * > { _Myarray, _Mysize, _Myindex };
    }
    __pragma(warning(pop))

    [ [ nodiscard ] ] constexpr _Ptr base ( ) const noexcept {
        return _Myarray + _Myindex;
    }

    [ [ nodiscard ] ] constexpr reference operator * ( ) const noexcept {
        return * operator -> ( );
    }

    [ [ nodiscard ] ] constexpr pointer operator -> ( ) const noexcept {
        if ( ! ( _Myarray ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };
        if ( ! ( _Myindex < _Mysize ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };
        return _Myarray + _Myindex;
    }

    constexpr checked_array_iterator & operator ++ ( ) noexcept {
        if ( ! ( _Myarray ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };
        if ( ! ( _Myindex < _Mysize ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };
        ++ _Myindex;
        return * this;
    }

    constexpr checked_array_iterator operator ++ ( int ) noexcept {
        checked_array_iterator _Tmp = * this;
        ++ * this;
        return _Tmp;
    }

    constexpr checked_array_iterator & operator -- ( ) noexcept {
        if ( ! ( _Myarray ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };
        if ( ! ( _Myindex != 0 ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };
        -- _Myindex;
        return * this;
    }

    constexpr checked_array_iterator operator -- ( int ) noexcept {
        checked_array_iterator _Tmp = * this;
        -- * this;
        return _Tmp;
    }

    constexpr checked_array_iterator & operator += ( const difference_type _Off ) noexcept {
        if ( _Off != 0 ) {
            if ( ! ( _Myarray ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };
        }

        if ( _Off < 0 ) {
            if ( ! ( _Myindex >= size_t { 0 } - static_cast < size_t > ( _Off ) ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };

        }

        if ( _Off > 0 ) {
            if ( ! ( _Mysize - _Myindex >= static_cast < size_t > ( _Off ) ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };

        }

        _Myindex += _Off;
        return * this;
    }

    [ [ nodiscard ] ] constexpr checked_array_iterator operator + ( const difference_type _Off ) const noexcept {
        checked_array_iterator _Tmp = * this;
        _Tmp += _Off;
        return _Tmp;
    }

    [ [ nodiscard ] ] friend constexpr checked_array_iterator operator + (
        const difference_type _Off, const checked_array_iterator < _Ptr > & _Next ) noexcept {
        return _Next + _Off;
    }

    constexpr checked_array_iterator & operator -= ( const difference_type _Off ) noexcept {
        if ( _Off != 0 ) {
            if ( ! ( _Myarray ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };
        }

        if ( _Off > 0 ) {
            if ( ! ( _Myindex >= static_cast < size_t > ( _Off ) ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };
        }

        if ( _Off < 0 ) {
            if ( ! ( _Mysize - _Myindex >= size_t { 0 } - static_cast < size_t > ( _Off ) ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };

        }

        _Myindex -= _Off;
        return * this;
    }

    [ [ nodiscard ] ] constexpr checked_array_iterator operator - ( const difference_type _Off ) const noexcept {
        checked_array_iterator _Tmp = * this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [ [ nodiscard ] ] constexpr difference_type operator - ( const checked_array_iterator & _Right ) const noexcept {
        if ( ! ( _Myarray == _Right . _Myarray && _Mysize == _Right . _Mysize ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };

        return static_cast < difference_type > ( _Myindex - _Right . _Myindex );
    }

    [ [ nodiscard ] ] constexpr reference operator [ ] ( const difference_type _Off ) const noexcept {
        return * ( * this + _Off );
    }

    [ [ nodiscard ] ] constexpr bool operator == ( const checked_array_iterator & _Right ) const noexcept {
        if ( ! ( _Myarray == _Right . _Myarray && _Mysize == _Right . _Mysize ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };

        return _Myindex == _Right . _Myindex;
    }








    [ [ nodiscard ] ] constexpr bool operator != ( const checked_array_iterator & _Right ) const noexcept {
        return ! ( * this == _Right );
    }

    [ [ nodiscard ] ] constexpr bool operator < ( const checked_array_iterator & _Right ) const noexcept {
        if ( ! ( _Myarray == _Right . _Myarray && _Mysize == _Right . _Mysize ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };

        return _Myindex < _Right . _Myindex;
    }

    [ [ nodiscard ] ] constexpr bool operator > ( const checked_array_iterator & _Right ) const noexcept {
        return _Right < * this;
    }

    [ [ nodiscard ] ] constexpr bool operator <= ( const checked_array_iterator & _Right ) const noexcept {
        return ! ( _Right < * this );
    }

    [ [ nodiscard ] ] constexpr bool operator >= ( const checked_array_iterator & _Right ) const noexcept {
        return ! ( * this < _Right );
    }


    friend constexpr void _Verify_range (
        const checked_array_iterator & _First, const checked_array_iterator & _Last ) noexcept {
        if ( ! ( _First . _Myarray == _Last . _Myarray && _First . _Mysize == _Last . _Mysize ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };

        if ( ! ( _First . _Myindex <= _Last . _Myindex ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };
    }

    constexpr void _Verify_offset ( const difference_type _Off ) const noexcept {
        if ( _Off < 0 ) {
            if ( ! ( _Myindex >= size_t { 0 } - static_cast < size_t > ( _Off ) ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };

        }

        if ( _Off > 0 ) {
            if ( ! ( _Mysize - _Myindex >= static_cast < size_t > ( _Off ) ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };

        }
    }

    using _Prevent_inheriting_unwrap = checked_array_iterator;

    [ [ nodiscard ] ] constexpr _Ptr _Unwrapped ( ) const noexcept {
        return _Myarray + _Myindex;
    }

    constexpr void _Seek_to ( _Ptr _It ) noexcept {
        _Myindex = static_cast < size_t > ( _It - _Myarray );
    }

private :
    _Ptr _Myarray = nullptr;
    size_t _Mysize = 0;
    size_t _Myindex = 0;
};
#line 1688 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iterator"
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 1689
template < class _Ptr >
[ [ deprecated ( "warning STL4043: stdext::checked_array_iterator, stdext::unchecked_array_iterator, and related factory functions are non-Standar" "d extensions and will be removed in the future. std::span (since C++20) and gsl::span can be used instead. You can define _SILEN" "CE_STDEXT_ARR_ITERS_DEPRECATION_WARNING or _SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS to suppress this warning." ) ] ] [ [ nodiscard ] ] constexpr checked_array_iterator < _Ptr > make_checked_array_iterator (
    const _Ptr _Array, const size_t _Size, const size_t _Index = 0 ) noexcept {
    return checked_array_iterator < _Ptr > ( _Array, _Size, _Index );
}
#line 1694
__pragma( warning(pop)) 
#line 1696
template < class _Ptr >
class [ [ deprecated ( "warning STL4043: stdext::checked_array_iterator, stdext::unchecked_array_iterator, and related factory functions are non-Standar" "d extensions and will be removed in the future. std::span (since C++20) and gsl::span can be used instead. You can define _SILEN" "CE_STDEXT_ARR_ITERS_DEPRECATION_WARNING or _SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS to suppress this warning." ) ] ] unchecked_array_iterator {
private :
    using _Pointee_type = :: std :: remove_pointer_t < _Ptr >;
    static_assert ( :: std :: is_pointer_v < _Ptr > && :: std :: is_object_v < _Pointee_type >,
        "unchecked_array_iterator requires pointers to objects" );

public :
    using iterator_category = :: std :: random_access_iterator_tag;
    using value_type = :: std :: remove_cv_t < _Pointee_type >;
    using difference_type = :: std :: ptrdiff_t;
    using pointer = _Ptr;
    using reference = _Pointee_type &;




    constexpr unchecked_array_iterator ( ) = default;

    constexpr explicit unchecked_array_iterator ( const _Ptr _Src ) noexcept : _Myptr ( _Src ) { }

    __pragma(warning(push))                            __pragma(warning(disable : 4996))
    template < class _Ty = _Pointee_type, :: std :: enable_if_t < ! :: std :: is_const_v < _Ty >, int > = 0 >
    constexpr operator unchecked_array_iterator < const _Ty * > ( ) const noexcept {
        return unchecked_array_iterator < const _Ty * > { _Myptr };
    }
    __pragma(warning(pop))

    [ [ nodiscard ] ] constexpr _Ptr base ( ) const noexcept {
        return _Myptr;
    }

    [ [ nodiscard ] ] constexpr reference operator * ( ) const noexcept {
        return * _Myptr;
    }

    [ [ nodiscard ] ] constexpr pointer operator -> ( ) const noexcept {
        return _Myptr;
    }

    constexpr unchecked_array_iterator & operator ++ ( ) noexcept {
        ++ _Myptr;
        return * this;
    }

    constexpr unchecked_array_iterator operator ++ ( int ) noexcept {
        unchecked_array_iterator _Tmp = * this;
        ++ _Myptr;
        return _Tmp;
    }

    constexpr unchecked_array_iterator & operator -- ( ) noexcept {
        -- _Myptr;
        return * this;
    }

    constexpr unchecked_array_iterator operator -- ( int ) noexcept {
        unchecked_array_iterator _Tmp = * this;
        -- _Myptr;
        return _Tmp;
    }

    constexpr unchecked_array_iterator & operator += ( const difference_type _Off ) noexcept {
        _Myptr += _Off;
        return * this;
    }

    [ [ nodiscard ] ] constexpr unchecked_array_iterator operator + ( const difference_type _Off ) const noexcept {
        unchecked_array_iterator _Tmp = * this;
        _Tmp += _Off;
        return _Tmp;
    }

    [ [ nodiscard ] ] friend constexpr unchecked_array_iterator operator + (
        const difference_type _Off, const unchecked_array_iterator & _Next ) noexcept {
        return _Next + _Off;
    }

    constexpr unchecked_array_iterator & operator -= ( const difference_type _Off ) noexcept {
        return * this += - _Off;
    }

    [ [ nodiscard ] ] constexpr unchecked_array_iterator operator - ( const difference_type _Off ) const noexcept {
        unchecked_array_iterator _Tmp = * this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [ [ nodiscard ] ] constexpr difference_type operator - ( const unchecked_array_iterator & _Right ) const noexcept {
        return _Myptr - _Right . _Myptr;
    }

    [ [ nodiscard ] ] constexpr reference operator [ ] ( const difference_type _Off ) const noexcept {
        return * ( * this + _Off );
    }

    [ [ nodiscard ] ] constexpr bool operator == ( const unchecked_array_iterator & _Right ) const noexcept {
        return _Myptr == _Right . _Myptr;
    }






    [ [ nodiscard ] ] constexpr bool operator != ( const unchecked_array_iterator & _Right ) const noexcept {
        return ! ( * this == _Right );
    }

    [ [ nodiscard ] ] constexpr bool operator < ( const unchecked_array_iterator & _Right ) const noexcept {
        return _Myptr < _Right . _Myptr;
    }

    [ [ nodiscard ] ] constexpr bool operator > ( const unchecked_array_iterator & _Right ) const noexcept {
        return _Right < * this;
    }

    [ [ nodiscard ] ] constexpr bool operator <= ( const unchecked_array_iterator & _Right ) const noexcept {
        return ! ( _Right < * this );
    }

    [ [ nodiscard ] ] constexpr bool operator >= ( const unchecked_array_iterator & _Right ) const noexcept {
        return ! ( * this < _Right );
    }









    using _Prevent_inheriting_unwrap = unchecked_array_iterator;

    static constexpr bool _Unwrap_when_unverified = true;

    [ [ nodiscard ] ] constexpr _Ptr _Unwrapped ( ) const noexcept {
        return _Myptr;
    }

    constexpr void _Seek_to ( _Ptr _It ) noexcept {
        _Myptr = _It;
    }

private :
    _Ptr _Myptr = nullptr;
};
#line 1845 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iterator"
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 1846
template < class _Ptr >
[ [ deprecated ( "warning STL4043: stdext::checked_array_iterator, stdext::unchecked_array_iterator, and related factory functions are non-Standar" "d extensions and will be removed in the future. std::span (since C++20) and gsl::span can be used instead. You can define _SILEN" "CE_STDEXT_ARR_ITERS_DEPRECATION_WARNING or _SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS to suppress this warning." ) ] ] [ [ nodiscard ] ] unchecked_array_iterator < _Ptr > make_unchecked_array_iterator (
    const _Ptr _It ) noexcept {
    return unchecked_array_iterator < _Ptr > ( _It );
}
#line 1851
__pragma( warning(pop)) 
#line 1852
}
#line 1879 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iterator"
#pragma warning(pop)
#pragma pack ( pop )
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_system_error_abi.hpp"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 25 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_system_error_abi.hpp"
extern "C" {
#line 26
[[nodiscard]] size_t __stdcall __std_get_string_size_without_trailing_whitespace(const char * _Str, size_t _Size) noexcept; 
#line 29
[[nodiscard]] size_t __stdcall __std_system_error_allocate_message(unsigned long _Message_id, char ** _Ptr_str) noexcept; 
#line 31
void __stdcall __std_system_error_deallocate_message(char * _Str) noexcept; 
#line 32
}
#line 36
#pragma warning(pop)
#pragma pack ( pop )
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 21
namespace std { 
#line 24
[[nodiscard]] bool __cdecl 
#line 25
uncaught_exception() noexcept; 
#line 27 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"
[[nodiscard]] int __cdecl uncaught_exceptions() noexcept; 
#line 29
}
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_terminate.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 18
__pragma( pack ( push, 8 )) extern "C" {
#line 22
typedef void (__cdecl *terminate_handler)(void); 
#line 23
typedef void (__cdecl *terminate_function)(void); 
#line 32
__declspec(noreturn) void __cdecl abort(); 
#line 33
__declspec(noreturn) void __cdecl terminate() throw(); 
#line 37
terminate_handler __cdecl set_terminate(terminate_handler _NewTerminateHandler) throw(); 
#line 41
terminate_handler __cdecl _get_terminate(); 
#line 47 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_terminate.h"
}__pragma( pack ( pop )) 
#line 51 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\corecrt_terminate.h"
#pragma warning(pop)
#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\eh.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 22
__pragma( pack ( push, 8 )) extern "C" {
#line 25
typedef void (__cdecl *unexpected_handler)(void); 
#line 33
__declspec(noreturn) void __cdecl unexpected() noexcept(false); 
#line 36
unexpected_handler __cdecl set_unexpected(unexpected_handler _NewUnexpectedHandler) noexcept; 
#line 39
unexpected_handler __cdecl _get_unexpected() noexcept; 
#line 44 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\eh.h"
struct _EXCEPTION_POINTERS; 
#line 48
typedef void (__cdecl *_se_translator_function)(unsigned, _EXCEPTION_POINTERS *); 
#line 50
_se_translator_function __cdecl _set_se_translator(_se_translator_function _NewSETranslator); 
#line 55 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\eh.h"
extern "C++" {
#line 56
class type_info; 
#line 57
}
#line 59
int __cdecl _is_exception_typeof(const type_info & _Type, _EXCEPTION_POINTERS * _ExceptionPtr); 
#line 64
bool __cdecl __uncaught_exception(); 
#line 65
int __cdecl __uncaught_exceptions(); 
#line 68 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\eh.h"
}__pragma( pack ( pop )) 
#line 70
#pragma warning(pop)
#line 18 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_exception.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#pragma warning(disable: 4577)
#pragma warning(disable: 4643)
#line 23
#pragma pack ( push, 8 )
#line 25
__pragma( pack ( push, 8 )) extern "C" {
#line 27
struct __std_exception_data { 
#line 29
const char *_What; 
#line 30
bool _DoFree; 
#line 31
}; 
#line 33
void __cdecl __std_exception_copy(const __std_exception_data * _From, __std_exception_data * _To); 
#line 38
void __cdecl __std_exception_destroy(__std_exception_data * _Data); 
#line 42
}__pragma( pack ( pop )) 
#line 45
extern "C++" {
#line 47
namespace std { 
#line 49
class [[nodiscard]] exception { 
#line 53
public: exception() noexcept : _Data() 
#line 55
{ 
#line 56
} 
#line 58
explicit exception(const char *const _Message) noexcept : _Data() 
#line 60
{ 
#line 61
__std_exception_data _InitData = {_Message, true}; 
#line 62
__std_exception_copy(&_InitData, &(_Data)); 
#line 63
} 
#line 65
exception(const char *const _Message, int) noexcept : _Data() 
#line 67
{ 
#line 68
((_Data)._What) = _Message; 
#line 69
} 
#line 71
exception(const exception &_Other) noexcept : _Data() 
#line 73
{ 
#line 74
__std_exception_copy(&(_Other._Data), &(_Data)); 
#line 75
} 
#line 77
exception &operator=(const exception &_Other) noexcept 
#line 78
{ 
#line 79
if (this == (&_Other)) 
#line 80
{ 
#line 81
return *this; 
#line 82
}  
#line 84
__std_exception_destroy(&(_Data)); 
#line 85
__std_exception_copy(&(_Other._Data), &(_Data)); 
#line 86
return *this; 
#line 87
} 
#line 89
virtual ~exception() noexcept 
#line 90
{ 
#line 91
__std_exception_destroy(&(_Data)); 
#line 92
} 
#line 94
[[nodiscard]] virtual const char *what() const 
#line 95
{ 
#line 96
return ((_Data)._What) ? (_Data)._What : ("Unknown exception"); 
#line 97
} 
#line 101
private: __std_exception_data _Data; 
#line 102
}; 
#line 104
class [[nodiscard]] bad_exception : public exception { 
#line 109
public: bad_exception() noexcept : exception("bad exception", 1) 
#line 111
{ 
#line 112
} 
#line 113
}; 
#line 115
class [[nodiscard]] bad_array_new_length; 
#line 117
class [[nodiscard]] bad_alloc : public exception { 
#line 122
public: bad_alloc() noexcept : exception("bad allocation", 1) 
#line 124
{ 
#line 125
} 
#line 129
friend class bad_array_new_length; 
#line 131
private: bad_alloc(const char *const _Message) noexcept : exception(_Message, 1) 
#line 133
{ 
#line 134
} 
#line 135
}; 
#line 137
class [[nodiscard]] bad_array_new_length : public bad_alloc { 
#line 142
public: bad_array_new_length() noexcept : bad_alloc("bad array new length") 
#line 144
{ 
#line 145
} 
#line 146
}; 
#line 148
}
#line 150
}
#line 152
#pragma pack ( pop )
#line 154
#pragma warning(pop)
#line 36 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"
namespace std { 
#line 38
using ::terminate;
#line 41
using ::set_terminate;
#line 42
using ::terminate_handler;
#line 44
[[nodiscard]] inline terminate_handler __cdecl get_terminate() noexcept { 
#line 46
return _get_terminate(); 
#line 47
} 
#line 51 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"
using ::unexpected;
#line 54
using ::set_unexpected;
#line 55
using ::unexpected_handler;
#line 57
[[nodiscard]] inline unexpected_handler __cdecl get_unexpected() noexcept { 
#line 59
return _get_unexpected(); 
#line 60
} 
#line 64 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"
}
#line 210 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"
void __cdecl __ExceptionPtrCreate(void *) noexcept; 
#line 211
void __cdecl __ExceptionPtrDestroy(void *) noexcept; 
#line 212
void __cdecl __ExceptionPtrCopy(void *, const void *) noexcept; 
#line 213
void __cdecl __ExceptionPtrAssign(void *, const void *) noexcept; 
#line 214
bool __cdecl __ExceptionPtrCompare(const void *, const void *) noexcept; 
#line 216
bool __cdecl __ExceptionPtrToBool(const void *) noexcept; 
#line 217
void __cdecl __ExceptionPtrSwap(void *, void *) noexcept; 
#line 218
void __cdecl __ExceptionPtrCurrentException(void *) noexcept; 
#line 219
[[noreturn]] void __cdecl __ExceptionPtrRethrow(const void *); 
#line 220
void __cdecl __ExceptionPtrCopyException(void *, const void *, const void *) noexcept; 
#line 223
namespace std { 
#line 225
class exception_ptr { 
#line 227
public: exception_ptr() noexcept { 
#line 228
__ExceptionPtrCreate(this); 
#line 229
} 
#line 231
exception_ptr(nullptr_t) noexcept { 
#line 232
__ExceptionPtrCreate(this); 
#line 233
} 
#line 235
~exception_ptr() noexcept { 
#line 236
__ExceptionPtrDestroy(this); 
#line 243 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"
} 
#line 245
exception_ptr(const exception_ptr &_Rhs) noexcept { 
#line 246
__ExceptionPtrCopy(this, &_Rhs); 
#line 247
} 
#line 249
exception_ptr &operator=(const exception_ptr &_Rhs) noexcept { 
#line 250
__ExceptionPtrAssign(this, &_Rhs); 
#line 251
return *this; 
#line 252
} 
#line 254
exception_ptr &operator=(nullptr_t) noexcept { 
#line 255
exception_ptr _Ptr; 
#line 256
__ExceptionPtrAssign(this, &_Ptr); 
#line 257
return *this; 
#line 258
} 
#line 260
explicit operator bool() const noexcept { 
#line 261
return __ExceptionPtrToBool(this); 
#line 262
} 
#line 264
static exception_ptr _Copy_exception(void *_Except, const void *_Ptr) { 
#line 265
exception_ptr _Retval; 
#line 266
if (!_Ptr) { 
#line 268
return _Retval; 
#line 269
}  
#line 270
__ExceptionPtrCopyException(&_Retval, _Except, _Ptr); 
#line 271
return _Retval; 
#line 272
} 
#line 274
friend inline void swap(exception_ptr &_Lhs, exception_ptr &_Rhs) noexcept { 
#line 275
__ExceptionPtrSwap(&_Lhs, &_Rhs); 
#line 276
} 
#line 278
[[nodiscard]] friend inline bool operator==(const exception_ptr &_Lhs, const exception_ptr &_Rhs) noexcept { 
#line 279
return __ExceptionPtrCompare(&_Lhs, &_Rhs); 
#line 280
} 
#line 282
[[nodiscard]] friend inline bool operator==(const exception_ptr &_Lhs, std::nullptr_t) noexcept { 
#line 283
return !_Lhs; 
#line 284
} 
#line 287
[[nodiscard]] friend inline bool operator==(std::nullptr_t, const exception_ptr &_Rhs) noexcept { 
#line 288
return !_Rhs; 
#line 289
} 
#line 291
[[nodiscard]] friend inline bool operator!=(const exception_ptr &_Lhs, const exception_ptr &_Rhs) noexcept { 
#line 292
return !(_Lhs == _Rhs); 
#line 293
} 
#line 295
[[nodiscard]] friend inline bool operator!=(const exception_ptr &_Lhs, std::nullptr_t) noexcept { 
#line 296
return !(_Lhs == (nullptr)); 
#line 297
} 
#line 299
[[nodiscard]] friend inline bool operator!=(std::nullptr_t, const exception_ptr &_Rhs) noexcept { 
#line 300
return !((nullptr) == _Rhs); 
#line 301
} 
#line 309 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"
private: void *_Data1{((void *)0i64)}; 
#line 310
void *_Data2{((void *)0i64)}; 
#line 314
}; 
#line 316
[[nodiscard]] inline exception_ptr current_exception() noexcept { 
#line 317
exception_ptr _Retval; 
#line 318
__ExceptionPtrCurrentException(&_Retval); 
#line 319
return _Retval; 
#line 320
} 
#line 322
[[noreturn]] inline void rethrow_exception(exception_ptr _Ptr) { 
#line 323
__ExceptionPtrRethrow(&_Ptr); 
#line 324
} 
#line 326
template< class _Ex> void *__GetExceptionInfo(_Ex); 
#line 329
template < class _Ex >
[ [ nodiscard ( "This function constructs an object wrapped by a smart pointer and has no other effects; it is not useful to call this function a" "nd discard the return value." ) ] ] exception_ptr make_exception_ptr ( _Ex _Except ) noexcept {
    return exception_ptr :: _Copy_exception ( :: std :: addressof ( _Except ), __GetExceptionInfo ( _Except ) );
}
#line 334
class nested_exception { 
#line 336
public: nested_exception() noexcept : _Exc(::std::current_exception()) { } 
#line 338
nested_exception(const nested_exception &) noexcept = default;
#line 339
nested_exception &operator=(const nested_exception &) noexcept = default;
#line 340
virtual ~nested_exception() noexcept { } 
#line 342
[[noreturn]] void rethrow_nested() const { 
#line 343
if ((_Exc)) { 
#line 344
::std::rethrow_exception(_Exc); 
#line 345
} else { 
#line 346
::std::terminate(); 
#line 347
}  
#line 348
} 
#line 350
[[nodiscard]] exception_ptr nested_ptr() const noexcept { 
#line 351
return _Exc; 
#line 352
} 
#line 355
private: exception_ptr _Exc; 
#line 356
}; 
#line 358
template< class _Uty> 
#line 359
struct _With_nested_v2 : public _Uty, public nested_exception { 
#line 360
template < class _Ty >
    explicit _With_nested_v2 ( _Ty && _Arg )
        : _Uty ( :: std :: forward < _Ty > ( _Arg ) ), nested_exception ( ) { }
#line 363
}; 
#line 365
template < class _Ty >
[ [ noreturn ] ] void throw_with_nested ( _Ty && _Arg ) {

    using _Uty = decay_t < _Ty >;

    if constexpr ( is_class_v < _Uty > && ! is_base_of_v < nested_exception, _Uty > && ! is_final_v < _Uty > ) {

        throw ( _With_nested_v2 < _Uty > ( :: std :: forward < _Ty > ( _Arg ) ) );
    } else {

        throw ( :: std :: forward < _Ty > ( _Arg ) );
    }
}
#line 380
template < class _Ty >
void rethrow_if_nested ( const _Ty & _Arg ) {

    constexpr bool _Can_use_dynamic_cast =
        is_polymorphic_v < _Ty > && ( ! is_base_of_v < nested_exception, _Ty > || is_convertible_v < _Ty *, nested_exception * > );

    if constexpr ( _Can_use_dynamic_cast ) {
        const auto _Nested = dynamic_cast < const nested_exception * > ( :: std :: addressof ( _Arg ) );

        if ( _Nested ) {
            _Nested -> rethrow_nested ( );
        }
    }
}
#line 399 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"
class [[nodiscard]] bad_variant_access : public exception { 
#line 402
public: bad_variant_access() noexcept = default;
#line 404
[[nodiscard]] virtual const char *what() const noexcept override { 
#line 405
return "bad variant access"; 
#line 406
} 
#line 414 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"
}; 
#line 416
[[noreturn]] inline void _Throw_bad_variant_access() { 
#line 417
throw bad_variant_access{}; 
#line 418
} 
#line 420
}
#line 424
#pragma warning(pop)
#pragma pack ( pop )
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_sanitizer_annotate_container.hpp"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 102 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_sanitizer_annotate_container.hpp"
#pragma detect_mismatch("annotate_string", "0")
#line 105 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_sanitizer_annotate_container.hpp"
#pragma detect_mismatch("annotate_vector", "0")
#line 120 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_sanitizer_annotate_container.hpp"
extern "C" {
#line 128
}
#line 173 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_sanitizer_annotate_container.hpp"
#pragma warning(pop)
#pragma pack ( pop )
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_string_view.hpp"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 23
extern "C" {
#line 32
__declspec(noalias) size_t __stdcall __std_find_first_of_trivial_pos_1(const void * _Haystack, size_t _Haystack_length, const void * _Needle, size_t _Needle_length) noexcept; 
#line 34
__declspec(noalias) size_t __stdcall __std_find_first_of_trivial_pos_2(const void * _Haystack, size_t _Haystack_length, const void * _Needle, size_t _Needle_length) noexcept; 
#line 36
__declspec(noalias) size_t __stdcall __std_find_first_of_trivial_pos_4(const void * _Haystack, size_t _Haystack_length, const void * _Needle, size_t _Needle_length) noexcept; 
#line 38
__declspec(noalias) size_t __stdcall __std_find_first_of_trivial_pos_8(const void * _Haystack, size_t _Haystack_length, const void * _Needle, size_t _Needle_length) noexcept; 
#line 41
__declspec(noalias) size_t __stdcall __std_find_last_of_trivial_pos_1(const void * _Haystack, size_t _Haystack_length, const void * _Needle, size_t _Needle_length) noexcept; 
#line 43
__declspec(noalias) size_t __stdcall __std_find_last_of_trivial_pos_2(const void * _Haystack, size_t _Haystack_length, const void * _Needle, size_t _Needle_length) noexcept; 
#line 46
}
#line 48
namespace std { 
#line 50
template < class _Ty1, class _Ty2 >
size_t _Find_first_of_pos_vectorized ( const _Ty1 * const _Haystack, const size_t _Haystack_length,
    const _Ty2 * const _Needle, const size_t _Needle_length ) noexcept {
    ;
    if constexpr ( sizeof ( _Ty1 ) == 1 ) {
        return :: __std_find_first_of_trivial_pos_1 ( _Haystack, _Haystack_length, _Needle, _Needle_length );
    } else if constexpr ( sizeof ( _Ty1 ) == 2 ) {
        return :: __std_find_first_of_trivial_pos_2 ( _Haystack, _Haystack_length, _Needle, _Needle_length );
    } else if constexpr ( sizeof ( _Ty1 ) == 4 ) {
        return :: __std_find_first_of_trivial_pos_4 ( _Haystack, _Haystack_length, _Needle, _Needle_length );
    } else if constexpr ( sizeof ( _Ty1 ) == 8 ) {
        return :: __std_find_first_of_trivial_pos_8 ( _Haystack, _Haystack_length, _Needle, _Needle_length );
    } else {
        ;
    }
}
#line 67
template < class _Ty1, class _Ty2 >
size_t _Find_last_of_pos_vectorized ( const _Ty1 * const _Haystack, const size_t _Haystack_length,
    const _Ty2 * const _Needle, const size_t _Needle_length ) noexcept {
    ;
    if constexpr ( sizeof ( _Ty1 ) == 1 ) {
        return :: __std_find_last_of_trivial_pos_1 ( _Haystack, _Haystack_length, _Needle, _Needle_length );
    } else if constexpr ( sizeof ( _Ty1 ) == 2 ) {
        return :: __std_find_last_of_trivial_pos_2 ( _Haystack, _Haystack_length, _Needle, _Needle_length );
    } else {
        ;
    }
}
#line 80
}
#line 84 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_string_view.hpp"
namespace std { 
#line 91 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_string_view.hpp"
template < class _Elem, class _Int_type >
struct _Char_traits {
    using char_type = _Elem;
    using int_type = _Int_type;
    using pos_type = streampos;
    using off_type = streamoff;
    using state_type = _Mbstatet;






    static inline _Elem * copy ( _Elem * const _First1,
          const _Elem * const _First2, const size_t _Count ) noexcept {















        :: memcpy ( _First1, _First2, _Count * sizeof ( _Elem ) );


        return _First1;
    }

      static inline _Elem * _Copy_s (
                                                                                 _Elem * const _First1,
        const size_t _Dest_size, const _Elem * const _First2, const size_t _Count ) noexcept {

        if ( ! ( _Count <= _Dest_size ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };
        return copy ( _First1, _First2, _Count );
    }

    static inline _Elem * move ( _Elem * const _First1,
          const _Elem * const _First2, const size_t _Count ) noexcept {





































        :: memmove ( _First1, _First2, _Count * sizeof ( _Elem ) );


        return _First1;
    }




    [ [ nodiscard ] ] static inline int compare ( const _Elem * _First1,
          const _Elem * _First2, size_t _Count ) noexcept {

        for (; 0 < _Count; -- _Count, ++ _First1, ++ _First2 ) {
            if ( * _First1 != * _First2 ) {
                return * _First1 < * _First2 ? - 1 : + 1;
            }
        }

        return 0;
    }

    [ [ nodiscard ] ] static inline size_t length ( const _Elem * _First ) noexcept {

        size_t _Count = 0;
        while ( * _First != _Elem ( ) ) {
            ++ _Count;
            ++ _First;
        }

        return _Count;
    }

    [ [ nodiscard ] ] static inline const _Elem * find (
          const _Elem * _First, size_t _Count, const _Elem & _Ch ) noexcept {

        for (; 0 < _Count; -- _Count, ++ _First ) {
            if ( * _First == _Ch ) {
                return _First;
            }
        }

        return nullptr;
    }

    static inline _Elem * assign (
          _Elem * const _First, size_t _Count, const _Elem _Ch ) noexcept {

        for ( _Elem * _Next = _First; _Count > 0; -- _Count, ++ _Next ) {
            * _Next = _Ch;
        }

        return _First;
    }

    static inline void assign ( _Elem & _Left, const _Elem & _Right ) noexcept {
        _Left = _Right;
    }

    [ [ nodiscard ] ] static constexpr bool eq ( const _Elem _Left, const _Elem _Right ) noexcept {
        return _Left == _Right;
    }

    [ [ nodiscard ] ] static constexpr bool lt ( const _Elem _Left, const _Elem _Right ) noexcept {
        return _Left < _Right;
    }

    [ [ nodiscard ] ] static constexpr _Elem to_char_type ( const int_type _Meta ) noexcept {
        return static_cast < _Elem > ( _Meta );
    }

    [ [ nodiscard ] ] static constexpr int_type to_int_type ( const _Elem _Ch ) noexcept {
        return static_cast < int_type > ( _Ch );
    }

    [ [ nodiscard ] ] static constexpr bool eq_int_type ( const int_type _Left, const int_type _Right ) noexcept {
        return _Left == _Right;
    }

    [ [ nodiscard ] ] static constexpr int_type not_eof ( const int_type _Meta ) noexcept {
        return _Meta != eof ( ) ? _Meta : ! eof ( );
    }

    [ [ nodiscard ] ] static constexpr int_type eof ( ) noexcept {
        return static_cast < int_type > ( ( - 1 ) );
    }
};
#line 261 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_string_view.hpp"
template < class _Elem >
struct _WChar_traits : private _Char_traits < _Elem, unsigned short > {

private :
    using _Primary_char_traits = _Char_traits < _Elem, unsigned short >;

public :
    using char_type = _Elem;
    using int_type = unsigned short;
    using pos_type = streampos;
    using off_type = streamoff;
    using state_type = mbstate_t;




    using _Primary_char_traits :: _Copy_s;
    using _Primary_char_traits :: copy;
    using _Primary_char_traits :: move;

    [ [ nodiscard ] ] static inline int compare ( const _Elem * const _First1,
          const _Elem * const _First2, const size_t _Count ) noexcept {











        return :: wmemcmp (
            reinterpret_cast < const wchar_t * > ( _First1 ), reinterpret_cast < const wchar_t * > ( _First2 ), _Count );
    }

    [ [ nodiscard ] ] static inline size_t length ( const _Elem * _First ) noexcept {











        return :: wcslen ( reinterpret_cast < const wchar_t * > ( _First ) );
    }

    [ [ nodiscard ] ] static inline const _Elem * find (
          const _Elem * _First, const size_t _Count, const _Elem & _Ch ) noexcept {











        return reinterpret_cast < const _Elem * > ( :: wmemchr ( reinterpret_cast < const wchar_t * > ( _First ), _Ch, _Count ) );
    }

    static inline _Elem * assign (
          _Elem * const _First, size_t _Count, const _Elem _Ch ) noexcept {







        return reinterpret_cast < _Elem * > ( :: wmemset ( reinterpret_cast < wchar_t * > ( _First ), _Ch, _Count ) );
    }

    static inline void assign ( _Elem & _Left, const _Elem & _Right ) noexcept {





        _Left = _Right;
    }

    [ [ nodiscard ] ] static constexpr bool eq ( const _Elem _Left, const _Elem _Right ) noexcept {
        return _Left == _Right;
    }

    [ [ nodiscard ] ] static constexpr bool lt ( const _Elem _Left, const _Elem _Right ) noexcept {
        return _Left < _Right;
    }

    [ [ nodiscard ] ] static constexpr _Elem to_char_type ( const int_type _Meta ) noexcept {
        return _Meta;
    }

    [ [ nodiscard ] ] static constexpr int_type to_int_type ( const _Elem _Ch ) noexcept {
        return _Ch;
    }

    [ [ nodiscard ] ] static constexpr bool eq_int_type ( const int_type _Left, const int_type _Right ) noexcept {
        return _Left == _Right;
    }

    [ [ nodiscard ] ] static constexpr int_type not_eof ( const int_type _Meta ) noexcept {
        return _Meta != eof ( ) ? _Meta : static_cast < int_type > ( ! eof ( ) );
    }

    [ [ nodiscard ] ] static constexpr int_type eof ( ) noexcept {
        return ( ( wint_t ) ( 65535 ) );
    }
};
#line 379 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_string_view.hpp"
template< class _Elem> 
#line 380
struct char_traits : public _Char_traits< _Elem, long>  { }; 
#line 383
template<> struct char_traits< char16_t>  : public _WChar_traits< char16_t>  { }; 
#line 386
template<> struct char_traits< char32_t>  : public _Char_traits< char32_t, unsigned>  { }; 
#line 389
template<> struct char_traits< __wchar_t>  : public _WChar_traits< __wchar_t>  { }; 
#line 398
template< class _Ty> constexpr bool 
#line 399
_Is_implementation_handled_char_like_type = is_arithmetic_v< _Ty>  || is_null_pointer_v< _Ty> ; 
#line 401
template< class > constexpr bool 
#line 402
_Is_implementation_handled_char_traits = false; 
#line 403
template< class _Elem> constexpr bool 
#line 404
_Is_implementation_handled_char_traits< char_traits< _Elem> >  = _Is_implementation_handled_char_like_type< _Elem> ; 
#line 413 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_string_view.hpp"
template < class _Elem, class _Int_type >
struct _Narrow_char_traits : private _Char_traits < _Elem, _Int_type > {

private :
    using _Primary_char_traits = _Char_traits < _Elem, _Int_type >;

public :
    using char_type = _Elem;
    using int_type = _Int_type;
    using pos_type = streampos;
    using off_type = streamoff;
    using state_type = mbstate_t;




    using _Primary_char_traits :: _Copy_s;
    using _Primary_char_traits :: copy;
    using _Primary_char_traits :: move;

    [ [ nodiscard ] ] static inline int compare ( const _Elem * const _First1,
          const _Elem * const _First2, const size_t _Count ) noexcept {




        return :: memcmp ( _First1, _First2, _Count );

    }

    [ [ nodiscard ] ] static inline size_t length ( const _Elem * const _First ) noexcept {















        return :: strlen ( reinterpret_cast < const char * > ( _First ) );

    }

    [ [ nodiscard ] ] static inline const _Elem * find ( const _Elem * const _First, const size_t _Count,
        const _Elem & _Ch ) noexcept {















        return static_cast < const _Elem * > ( :: memchr ( _First, _Ch, _Count ) );

    }

    static inline _Elem * assign (
          _Elem * const _First, size_t _Count, const _Elem _Ch ) noexcept {







        return static_cast < _Elem * > ( :: memset ( _First, _Ch, _Count ) );
    }

    static inline void assign ( _Elem & _Left, const _Elem & _Right ) noexcept {





        _Left = _Right;
    }

    [ [ nodiscard ] ] static constexpr bool eq ( const _Elem _Left, const _Elem _Right ) noexcept {
        return _Left == _Right;
    }

    [ [ nodiscard ] ] static constexpr bool lt ( const _Elem _Left, const _Elem _Right ) noexcept {
        return static_cast < unsigned char > ( _Left ) < static_cast < unsigned char > ( _Right );
    }

    [ [ nodiscard ] ] static constexpr _Elem to_char_type ( const int_type _Meta ) noexcept {
        return static_cast < _Elem > ( _Meta );
    }

    [ [ nodiscard ] ] static constexpr int_type to_int_type ( const _Elem _Ch ) noexcept {
        return static_cast < unsigned char > ( _Ch );
    }

    [ [ nodiscard ] ] static constexpr bool eq_int_type ( const int_type _Left, const int_type _Right ) noexcept {
        return _Left == _Right;
    }

    [ [ nodiscard ] ] static constexpr int_type not_eof ( const int_type _Meta ) noexcept {
        return _Meta != eof ( ) ? _Meta : ! eof ( );
    }

    [ [ nodiscard ] ] static constexpr int_type eof ( ) noexcept {
        return static_cast < int_type > ( ( - 1 ) );
    }
};
#line 538 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_string_view.hpp"
template<> struct char_traits< char>  : public _Narrow_char_traits< char, int>  { }; 
#line 545
template < class _Elem, class _Traits, class _SizeT >
basic_ostream < _Elem, _Traits > & _Insert_string (
    basic_ostream < _Elem, _Traits > & _Ostr, const _Elem * const _Data, const _SizeT _Size ) {

    using _Ostr_t = basic_ostream < _Elem, _Traits >;
    typename _Ostr_t :: iostate _State = _Ostr_t :: goodbit;

    _SizeT _Pad;
    if ( _Ostr . width ( ) <= 0 || static_cast < _SizeT > ( _Ostr . width ( ) ) <= _Size ) {
        _Pad = 0;
    } else {
        _Pad = static_cast < _SizeT > ( _Ostr . width ( ) ) - _Size;
    }

    const typename _Ostr_t :: sentry _Ok ( _Ostr );

    if ( ! _Ok ) {
        _State |= _Ostr_t :: badbit;
    } else {
        try {
        if ( ( _Ostr . flags ( ) & _Ostr_t :: adjustfield ) != _Ostr_t :: left ) {
            for (; 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= _Ostr_t :: badbit;
                    break;
                }
            }
        }

        if ( _State == _Ostr_t :: goodbit
            && _Ostr . rdbuf ( ) -> sputn ( _Data, static_cast < streamsize > ( _Size ) ) != static_cast < streamsize > ( _Size ) ) {
            _State |= _Ostr_t :: badbit;
        } else {
            for (; 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= _Ostr_t :: badbit;
                    break;
                }
            }
        }

        _Ostr . width ( 0 );
        } catch ( ... ) { ( _Ostr ) . setstate ( _Ostr_t :: badbit, true ); }
    }

    _Ostr . setstate ( _State );
    return _Ostr;
}
#line 594
template< class _Traits> using _Traits_ch_t = typename _Traits::char_type; 
#line 597
template< class _Traits> using _Traits_ptr_t = const typename _Traits::char_type *; 
#line 600
template < class _Traits >
constexpr bool _Traits_equal ( const _Traits_ptr_t < _Traits > _Left, const size_t _Left_size,
      const _Traits_ptr_t < _Traits > _Right, const size_t _Right_size ) noexcept {

    if ( _Left_size != _Right_size ) {
        return false;
    }

    if ( _Left_size == 0U ) {
        return true;
    }

    return _Traits :: compare ( _Left, _Right, _Left_size ) == 0;
}
#line 615
template < class _Traits >
constexpr int _Traits_compare ( const _Traits_ptr_t < _Traits > _Left, const size_t _Left_size,
      const _Traits_ptr_t < _Traits > _Right, const size_t _Right_size ) noexcept {

    const int _Ans = _Traits :: compare ( _Left, _Right, ( :: std :: min ) ( _Left_size, _Right_size ) );

    if ( _Ans != 0 ) {
        return _Ans;
    }

    if ( _Left_size < _Right_size ) {
        return - 1;
    }

    if ( _Left_size > _Right_size ) {
        return 1;
    }

    return 0;
}
#line 636
template < class _Traits >
constexpr size_t _Traits_find ( const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ptr_t < _Traits > _Needle,
    const size_t _Needle_size ) noexcept {

    if ( _Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size ) {








        return static_cast < size_t > ( - 1 );
    }

    if ( _Needle_size == 0 ) {
        return _Start_at;
    }


    if constexpr ( _Is_implementation_handled_char_traits < _Traits > && sizeof ( typename _Traits :: char_type ) <= 2 ) {
        if ( ! :: std :: _Is_constant_evaluated ( ) ) {
            const auto _End = _Haystack + _Hay_size;
            const auto _Ptr = :: std :: _Search_vectorized ( _Haystack + _Start_at, _End, _Needle, _Needle_size );

            if ( _Ptr != _End ) {
                return static_cast < size_t > ( _Ptr - _Haystack );
            } else {
                return static_cast < size_t > ( - 1 );
            }
        }
    }


    const auto _Possible_matches_end = _Haystack + ( _Hay_size - _Needle_size ) + 1;
    for ( auto _Match_try = _Haystack + _Start_at;; ++ _Match_try ) {
        _Match_try = _Traits :: find ( _Match_try, static_cast < size_t > ( _Possible_matches_end - _Match_try ), * _Needle );
        if ( ! _Match_try ) {
            return static_cast < size_t > ( - 1 );
        }

        if ( _Traits :: compare ( _Match_try, _Needle, _Needle_size ) == 0 ) {
            return static_cast < size_t > ( _Match_try - _Haystack );
        }
    }
}
#line 685 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_string_view.hpp"
template < class _Traits >
constexpr size_t _Traits_find_ch ( const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ch_t < _Traits > _Ch ) noexcept {

    if ( _Start_at >= _Hay_size ) {
        return static_cast < size_t > ( - 1 );
    }


    if constexpr ( _Is_implementation_handled_char_traits < _Traits > ) {
        if ( ! :: std :: _Is_constant_evaluated ( ) ) {
            const auto _End = _Haystack + _Hay_size;
            const auto _Ptr = :: std :: _Find_vectorized ( _Haystack + _Start_at, _End, _Ch );

            if ( _Ptr != _End ) {
                return static_cast < size_t > ( _Ptr - _Haystack );
            } else {
                return static_cast < size_t > ( - 1 );
            }
        }
    }


    const auto _Found_at = _Traits :: find ( _Haystack + _Start_at, _Hay_size - _Start_at, _Ch );
    if ( _Found_at ) {
        return static_cast < size_t > ( _Found_at - _Haystack );
    }

    return static_cast < size_t > ( - 1 );
}
#line 716 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_string_view.hpp"
template < class _Traits >
constexpr size_t _Traits_rfind ( const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ptr_t < _Traits > _Needle,
    const size_t _Needle_size ) noexcept {

    if ( _Needle_size == 0 ) {
        return ( :: std :: min ) ( _Start_at, _Hay_size );
    }

    if ( _Needle_size > _Hay_size ) {
        return static_cast < size_t > ( - 1 );
    }

    const size_t _Actual_start_at = ( :: std :: min ) ( _Start_at, _Hay_size - _Needle_size );


    if constexpr ( _Is_implementation_handled_char_traits < _Traits > && sizeof ( typename _Traits :: char_type ) <= 2 ) {
        if ( ! :: std :: _Is_constant_evaluated ( ) ) {




            const auto _End = _Haystack + _Actual_start_at + _Needle_size;
            const auto _Ptr = :: std :: _Find_end_vectorized ( _Haystack, _End, _Needle, _Needle_size );

            if ( _Ptr != _End ) {
                return static_cast < size_t > ( _Ptr - _Haystack );
            } else {
                return static_cast < size_t > ( - 1 );
            }
        }
    }


    for ( auto _Match_try = _Haystack + _Actual_start_at;; -- _Match_try ) {
        if ( _Traits :: eq ( * _Match_try, * _Needle ) && _Traits :: compare ( _Match_try, _Needle, _Needle_size ) == 0 ) {
            return static_cast < size_t > ( _Match_try - _Haystack );
        }

        if ( _Match_try == _Haystack ) {
            return static_cast < size_t > ( - 1 );
        }
    }
}
#line 761 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_string_view.hpp"
template < class _Traits >
constexpr size_t _Traits_rfind_ch ( const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ch_t < _Traits > _Ch ) noexcept {


    if ( _Hay_size == 0 ) {
        return static_cast < size_t > ( - 1 );
    }

    const size_t _Actual_start_at = ( :: std :: min ) ( _Start_at, _Hay_size - 1 );


    if constexpr ( _Is_implementation_handled_char_traits < _Traits > ) {
        if ( ! :: std :: _Is_constant_evaluated ( ) ) {
            const auto _End = _Haystack + _Actual_start_at + 1;
            const auto _Ptr = :: std :: _Find_last_vectorized ( _Haystack, _End, _Ch );

            if ( _Ptr != _End ) {
                return static_cast < size_t > ( _Ptr - _Haystack );
            } else {
                return static_cast < size_t > ( - 1 );
            }
        }
    }


    for ( auto _Match_try = _Haystack + _Actual_start_at;; -- _Match_try ) {
        if ( _Traits :: eq ( * _Match_try, _Ch ) ) {
            return static_cast < size_t > ( _Match_try - _Haystack );
        }

        if ( _Match_try == _Haystack ) {
            return static_cast < size_t > ( - 1 );
        }
    }
}
#line 798 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_string_view.hpp"
template < class _Elem, bool = _Is_character < _Elem > :: value >
class _String_bitmap {
public :
    constexpr bool _Mark ( const _Elem * _First, const _Elem * const _Last ) noexcept {


        for (; _First != _Last; ++ _First ) {
            _Matches [ static_cast < unsigned char > ( * _First ) ] = true;
        }

        return true;
    }

    constexpr bool _Match ( const _Elem _Ch ) const noexcept {

        return _Matches [ static_cast < unsigned char > ( _Ch ) ];
    }

private :
    bool _Matches [ 256 ] = { };
};
#line 820
template < class _Elem >
class _String_bitmap < _Elem, false > {
public :
    static_assert ( is_unsigned_v < _Elem >, "Standard char_traits is only provided for char, wchar_t, char8_t, char16_t, and char32_t. See N4988 [char.traits]. Visual C++ ac" "cepts other unsigned integral types as an extension."

                                                                                                           );

    constexpr bool _Mark ( const _Elem * _First, const _Elem * const _Last ) noexcept {


        for (; _First != _Last; ++ _First ) {
            const auto _Ch = * _First;
            if ( _Ch >= 256U ) {
                return false;
            }

            _Matches [ static_cast < unsigned char > ( _Ch ) ] = true;
        }

        return true;
    }

    constexpr bool _Match ( const _Elem _Ch ) const noexcept {
        return _Ch < 256U && _Matches [ _Ch ];
    }

private :
    bool _Matches [ 256 ] = { };
};
#line 850
template < class _Traits >
constexpr size_t _Traits_find_first_of ( const _Traits_ptr_t < _Traits > _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t < _Traits > _Needle,
    const size_t _Needle_size ) noexcept {

    if ( _Needle_size == 0 || _Start_at >= _Hay_size ) {
        return static_cast < size_t > ( - 1 );
    }

    const auto _Hay_start = _Haystack + _Start_at;
    const auto _Hay_end = _Haystack + _Hay_size;

    if constexpr ( _Is_implementation_handled_char_traits < _Traits > ) {

        if ( ! :: std :: _Is_constant_evaluated ( ) ) {
            const size_t _Remaining_size = _Hay_size - _Start_at;
            if ( _Remaining_size + _Needle_size >= _Threshold_find_first_of ) {
                size_t _Pos = _Find_first_of_pos_vectorized ( _Hay_start, _Remaining_size, _Needle, _Needle_size );
                if ( _Pos != static_cast < size_t > ( - 1 ) ) {
                    _Pos += _Start_at;
                }
                return _Pos;
            }
        }


        _String_bitmap < typename _Traits :: char_type > _Matches;

        if ( _Matches . _Mark ( _Needle, _Needle + _Needle_size ) ) {
            for ( auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++ _Match_try ) {
                if ( _Matches . _Match ( * _Match_try ) ) {
                    return static_cast < size_t > ( _Match_try - _Haystack );
                }
            }
            return static_cast < size_t > ( - 1 );
        }


    }

    for ( auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++ _Match_try ) {
        if ( _Traits :: find ( _Needle, _Needle_size, * _Match_try ) ) {
            return static_cast < size_t > ( _Match_try - _Haystack );
        }
    }

    return static_cast < size_t > ( - 1 );
}
#line 899 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_string_view.hpp"
template < class _Traits >
constexpr size_t _Traits_find_last_of ( const _Traits_ptr_t < _Traits > _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t < _Traits > _Needle,
    const size_t _Needle_size ) noexcept {

    if ( _Needle_size == 0 || _Hay_size == 0 ) {
        return static_cast < size_t > ( - 1 );
    }

    const auto _Hay_start = ( :: std :: min ) ( _Start_at, _Hay_size - 1 );

    if constexpr ( _Is_implementation_handled_char_traits < _Traits > ) {
        using _Elem = typename _Traits :: char_type;

        if constexpr ( sizeof ( _Elem ) <= 2 ) {
            if ( ! :: std :: _Is_constant_evaluated ( ) ) {
                const size_t _Remaining_size = _Hay_start + 1;
                if ( _Remaining_size + _Needle_size >= _Threshold_find_first_of ) {
                    return _Find_last_of_pos_vectorized ( _Haystack, _Remaining_size, _Needle, _Needle_size );
                }
            }
        }


        _String_bitmap < _Elem > _Matches;
        if ( _Matches . _Mark ( _Needle, _Needle + _Needle_size ) ) {
            for ( auto _Match_try = _Haystack + _Hay_start;; -- _Match_try ) {
                if ( _Matches . _Match ( * _Match_try ) ) {
                    return static_cast < size_t > ( _Match_try - _Haystack );
                }

                if ( _Match_try == _Haystack ) {
                    return static_cast < size_t > ( - 1 );
                }
            }
        }


    }

    for ( auto _Match_try = _Haystack + _Hay_start;; -- _Match_try ) {
        if ( _Traits :: find ( _Needle, _Needle_size, * _Match_try ) ) {
            return static_cast < size_t > ( _Match_try - _Haystack );
        }

        if ( _Match_try == _Haystack ) {
            return static_cast < size_t > ( - 1 );
        }
    }
}
#line 950 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_string_view.hpp"
template < class _Traits >
constexpr size_t _Traits_find_first_not_of ( const _Traits_ptr_t < _Traits > _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t < _Traits > _Needle,
    const size_t _Needle_size ) noexcept {

    if ( _Start_at >= _Hay_size ) {
        return static_cast < size_t > ( - 1 );
    }

    const auto _Hay_start = _Haystack + _Start_at;
    const auto _Hay_end = _Haystack + _Hay_size;

    if constexpr ( _Is_implementation_handled_char_traits < _Traits > ) {
        using _Elem = typename _Traits :: char_type;
        _String_bitmap < _Elem > _Matches;
        if ( _Matches . _Mark ( _Needle, _Needle + _Needle_size ) ) {
            for ( auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++ _Match_try ) {
                if ( ! _Matches . _Match ( * _Match_try ) ) {
                    return static_cast < size_t > ( _Match_try - _Haystack );
                }
            }
            return static_cast < size_t > ( - 1 );
        }


    }

    for ( auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++ _Match_try ) {
        if ( ! _Traits :: find ( _Needle, _Needle_size, * _Match_try ) ) {
            return static_cast < size_t > ( _Match_try - _Haystack );
        }
    }

    return static_cast < size_t > ( - 1 );
}
#line 986
template < class _Traits >
constexpr size_t _Traits_find_not_ch ( const _Traits_ptr_t < _Traits > _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t < _Traits > _Ch ) noexcept {

    if ( _Start_at < _Hay_size ) {
        const auto _End = _Haystack + _Hay_size;
        for ( auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++ _Match_try ) {
            if ( ! _Traits :: eq ( * _Match_try, _Ch ) ) {
                return static_cast < size_t > ( _Match_try - _Haystack );
            }
        }
    }

    return static_cast < size_t > ( - 1 );
}
#line 1002
template < class _Traits >
constexpr size_t _Traits_find_last_not_of ( const _Traits_ptr_t < _Traits > _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t < _Traits > _Needle,
    const size_t _Needle_size ) noexcept {

    if ( _Hay_size == 0 ) {
        return static_cast < size_t > ( - 1 );
    }

    const auto _Hay_start = ( :: std :: min ) ( _Start_at, _Hay_size - 1 );

    if constexpr ( _Is_implementation_handled_char_traits < _Traits > ) {
        using _Elem = typename _Traits :: char_type;
        _String_bitmap < _Elem > _Matches;
        if ( _Matches . _Mark ( _Needle, _Needle + _Needle_size ) ) {
            for ( auto _Match_try = _Haystack + _Hay_start;; -- _Match_try ) {
                if ( ! _Matches . _Match ( * _Match_try ) ) {
                    return static_cast < size_t > ( _Match_try - _Haystack );
                }

                if ( _Match_try == _Haystack ) {
                    return static_cast < size_t > ( - 1 );
                }
            }
        }


    }

    for ( auto _Match_try = _Haystack + _Hay_start;; -- _Match_try ) {
        if ( ! _Traits :: find ( _Needle, _Needle_size, * _Match_try ) ) {
            return static_cast < size_t > ( _Match_try - _Haystack );
        }

        if ( _Match_try == _Haystack ) {
            return static_cast < size_t > ( - 1 );
        }
    }
}
#line 1042
template < class _Traits >
constexpr size_t _Traits_rfind_not_ch ( const _Traits_ptr_t < _Traits > _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t < _Traits > _Ch ) noexcept {

    if ( _Hay_size == 0 ) {
        return static_cast < size_t > ( - 1 );
    }

    for ( auto _Match_try = _Haystack + ( :: std :: min ) ( _Start_at, _Hay_size - 1 );; -- _Match_try ) {
        if ( ! _Traits :: eq ( * _Match_try, _Ch ) ) {
            return static_cast < size_t > ( _Match_try - _Haystack );
        }

        if ( _Match_try == _Haystack ) {
            return static_cast < size_t > ( - 1 );
        }
    }
}
#line 1061
template< class _Ty> constexpr bool 
#line 1062
_Is_EcharT = _Is_any_of_v< _Ty, char, __wchar_t, char16_t, char32_t> ; 
#line 2008 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_string_view.hpp"
}
#line 2012
#pragma warning(pop)
#pragma pack ( pop )
#line 17 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\limits"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 24
namespace std { 
#line 26
enum float_denorm_style { 
#line 27
denorm_indeterminate = (-1), 
#line 28
denorm_absent = 0, 
#line 29
denorm_present
#line 30
}; 
#line 32
enum float_round_style { 
#line 33
round_indeterminate = (-1), 
#line 34
round_toward_zero = 0, 
#line 35
round_to_nearest, 
#line 36
round_toward_infinity, 
#line 37
round_toward_neg_infinity
#line 38
}; 
#line 40
struct _Num_base { 
#line 41
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 42
static constexpr float_denorm_style has_denorm = denorm_absent; 
#line 43
static constexpr bool has_denorm_loss = false; 
#line 44
__pragma( warning(pop)) 
#line 46
static constexpr bool has_infinity = false; 
#line 47
static constexpr bool has_quiet_NaN = false; 
#line 48
static constexpr bool has_signaling_NaN = false; 
#line 49
static constexpr bool is_bounded = false; 
#line 50
static constexpr bool is_exact = false; 
#line 51
static constexpr bool is_iec559 = false; 
#line 52
static constexpr bool is_integer = false; 
#line 53
static constexpr bool is_modulo = false; 
#line 54
static constexpr bool is_signed = false; 
#line 55
static constexpr bool is_specialized = false; 
#line 56
static constexpr bool tinyness_before = false; 
#line 57
static constexpr bool traps = false; 
#line 58
static constexpr float_round_style round_style = round_toward_zero; 
#line 59
static constexpr int digits = 0; 
#line 60
static constexpr int digits10 = 0; 
#line 61
static constexpr int max_digits10 = 0; 
#line 62
static constexpr int max_exponent = 0; 
#line 63
static constexpr int max_exponent10 = 0; 
#line 64
static constexpr int min_exponent = 0; 
#line 65
static constexpr int min_exponent10 = 0; 
#line 66
static constexpr int radix = 0; 
#line 67
}; 
#line 69
template < class _Ty >
class numeric_limits : public _Num_base {
public :
    [ [ nodiscard ] ] static constexpr _Ty ( min ) ( ) noexcept {
        return _Ty ( );
    }

    [ [ nodiscard ] ] static constexpr _Ty ( max ) ( ) noexcept {
        return _Ty ( );
    }

    [ [ nodiscard ] ] static constexpr _Ty lowest ( ) noexcept {
        return _Ty ( );
    }

    [ [ nodiscard ] ] static constexpr _Ty epsilon ( ) noexcept {
        return _Ty ( );
    }

    [ [ nodiscard ] ] static constexpr _Ty round_error ( ) noexcept {
        return _Ty ( );
    }

    [ [ nodiscard ] ] static constexpr _Ty denorm_min ( ) noexcept {
        return _Ty ( );
    }

    [ [ nodiscard ] ] static constexpr _Ty infinity ( ) noexcept {
        return _Ty ( );
    }

    [ [ nodiscard ] ] static constexpr _Ty quiet_NaN ( ) noexcept {
        return _Ty ( );
    }

    [ [ nodiscard ] ] static constexpr _Ty signaling_NaN ( ) noexcept {
        return _Ty ( );
    }
};
#line 109
template< class _Ty> 
#line 110
class numeric_limits< const _Ty>  : public std::numeric_limits< _Ty>  { }; 
#line 112
template< class _Ty> 
#line 113
class numeric_limits< volatile _Ty>  : public std::numeric_limits< _Ty>  { }; 
#line 115
template< class _Ty> 
#line 116
class numeric_limits< const volatile _Ty>  : public std::numeric_limits< _Ty>  { }; 
#line 118
struct _Num_int_base : public _Num_base { 
#line 119
static constexpr bool is_bounded = true; 
#line 120
static constexpr bool is_exact = true; 
#line 121
static constexpr bool is_integer = true; 
#line 122
static constexpr bool is_specialized = true; 
#line 123
static constexpr int radix = 2; 
#line 124
}; 
#line 126
struct _Num_float_base : public _Num_base { 
#line 127
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 128
static constexpr float_denorm_style has_denorm = denorm_present; 
#line 129
__pragma( warning(pop)) 
#line 131
static constexpr bool has_infinity = true; 
#line 132
static constexpr bool has_quiet_NaN = true; 
#line 133
static constexpr bool has_signaling_NaN = true; 
#line 134
static constexpr bool is_bounded = true; 
#line 135
static constexpr bool is_iec559 = true; 
#line 136
static constexpr bool is_signed = true; 
#line 137
static constexpr bool is_specialized = true; 
#line 138
static constexpr float_round_style round_style = round_to_nearest; 
#line 139
static constexpr int radix = 2; 
#line 140
}; 
#line 143
template<> class numeric_limits< bool>  : public _Num_int_base { 
#line 145
public: [[nodiscard]] static constexpr bool min() noexcept { 
#line 146
return false; 
#line 147
} 
#line 149
[[nodiscard]] static constexpr bool max() noexcept { 
#line 150
return true; 
#line 151
} 
#line 153
[[nodiscard]] static constexpr bool lowest() noexcept { 
#line 154
return min(); 
#line 155
} 
#line 157
[[nodiscard]] static constexpr bool epsilon() noexcept { 
#line 158
return 0; 
#line 159
} 
#line 161
[[nodiscard]] static constexpr bool round_error() noexcept { 
#line 162
return 0; 
#line 163
} 
#line 165
[[nodiscard]] static constexpr bool denorm_min() noexcept { 
#line 166
return 0; 
#line 167
} 
#line 169
[[nodiscard]] static constexpr bool infinity() noexcept { 
#line 170
return 0; 
#line 171
} 
#line 173
[[nodiscard]] static constexpr bool quiet_NaN() noexcept { 
#line 174
return 0; 
#line 175
} 
#line 177
[[nodiscard]] static constexpr bool signaling_NaN() noexcept { 
#line 178
return 0; 
#line 179
} 
#line 181
static constexpr int digits = 1; 
#line 182
}; 
#line 185
template<> class numeric_limits< char>  : public _Num_int_base { 
#line 187
public: [[nodiscard]] static constexpr char min() noexcept { 
#line 188
return (-128); 
#line 189
} 
#line 191
[[nodiscard]] static constexpr char max() noexcept { 
#line 192
return 127; 
#line 193
} 
#line 195
[[nodiscard]] static constexpr char lowest() noexcept { 
#line 196
return min(); 
#line 197
} 
#line 199
[[nodiscard]] static constexpr char epsilon() noexcept { 
#line 200
return 0; 
#line 201
} 
#line 203
[[nodiscard]] static constexpr char round_error() noexcept { 
#line 204
return 0; 
#line 205
} 
#line 207
[[nodiscard]] static constexpr char denorm_min() noexcept { 
#line 208
return 0; 
#line 209
} 
#line 211
[[nodiscard]] static constexpr char infinity() noexcept { 
#line 212
return 0; 
#line 213
} 
#line 215
[[nodiscard]] static constexpr char quiet_NaN() noexcept { 
#line 216
return 0; 
#line 217
} 
#line 219
[[nodiscard]] static constexpr char signaling_NaN() noexcept { 
#line 220
return 0; 
#line 221
} 
#line 223
static constexpr bool is_signed = ((-128) != 0); 
#line 224
static constexpr bool is_modulo = ((-128) == 0); 
#line 225
static constexpr int digits = (8 - ((-128) != 0)); 
#line 226
static constexpr int digits10 = 2; 
#line 227
}; 
#line 230
template<> class numeric_limits< signed char>  : public _Num_int_base { 
#line 232
public: [[nodiscard]] static constexpr signed char min() noexcept { 
#line 233
return (-128); 
#line 234
} 
#line 236
[[nodiscard]] static constexpr signed char max() noexcept { 
#line 237
return 127; 
#line 238
} 
#line 240
[[nodiscard]] static constexpr signed char lowest() noexcept { 
#line 241
return min(); 
#line 242
} 
#line 244
[[nodiscard]] static constexpr signed char epsilon() noexcept { 
#line 245
return 0; 
#line 246
} 
#line 248
[[nodiscard]] static constexpr signed char round_error() noexcept { 
#line 249
return 0; 
#line 250
} 
#line 252
[[nodiscard]] static constexpr signed char denorm_min() noexcept { 
#line 253
return 0; 
#line 254
} 
#line 256
[[nodiscard]] static constexpr signed char infinity() noexcept { 
#line 257
return 0; 
#line 258
} 
#line 260
[[nodiscard]] static constexpr signed char quiet_NaN() noexcept { 
#line 261
return 0; 
#line 262
} 
#line 264
[[nodiscard]] static constexpr signed char signaling_NaN() noexcept { 
#line 265
return 0; 
#line 266
} 
#line 268
static constexpr bool is_signed = true; 
#line 269
static constexpr int digits = 7; 
#line 270
static constexpr int digits10 = 2; 
#line 271
}; 
#line 274
template<> class numeric_limits< unsigned char>  : public _Num_int_base { 
#line 276
public: [[nodiscard]] static constexpr unsigned char min() noexcept { 
#line 277
return 0; 
#line 278
} 
#line 280
[[nodiscard]] static constexpr unsigned char max() noexcept { 
#line 281
return 255; 
#line 282
} 
#line 284
[[nodiscard]] static constexpr unsigned char lowest() noexcept { 
#line 285
return min(); 
#line 286
} 
#line 288
[[nodiscard]] static constexpr unsigned char epsilon() noexcept { 
#line 289
return 0; 
#line 290
} 
#line 292
[[nodiscard]] static constexpr unsigned char round_error() noexcept { 
#line 293
return 0; 
#line 294
} 
#line 296
[[nodiscard]] static constexpr unsigned char denorm_min() noexcept { 
#line 297
return 0; 
#line 298
} 
#line 300
[[nodiscard]] static constexpr unsigned char infinity() noexcept { 
#line 301
return 0; 
#line 302
} 
#line 304
[[nodiscard]] static constexpr unsigned char quiet_NaN() noexcept { 
#line 305
return 0; 
#line 306
} 
#line 308
[[nodiscard]] static constexpr unsigned char signaling_NaN() noexcept { 
#line 309
return 0; 
#line 310
} 
#line 312
static constexpr bool is_modulo = true; 
#line 313
static constexpr int digits = 8; 
#line 314
static constexpr int digits10 = 2; 
#line 315
}; 
#line 364
template<> class numeric_limits< char16_t>  : public _Num_int_base { 
#line 366
public: [[nodiscard]] static constexpr char16_t min() noexcept { 
#line 367
return 0; 
#line 368
} 
#line 370
[[nodiscard]] static constexpr char16_t max() noexcept { 
#line 371
return 65535; 
#line 372
} 
#line 374
[[nodiscard]] static constexpr char16_t lowest() noexcept { 
#line 375
return min(); 
#line 376
} 
#line 378
[[nodiscard]] static constexpr char16_t epsilon() noexcept { 
#line 379
return 0; 
#line 380
} 
#line 382
[[nodiscard]] static constexpr char16_t round_error() noexcept { 
#line 383
return 0; 
#line 384
} 
#line 386
[[nodiscard]] static constexpr char16_t denorm_min() noexcept { 
#line 387
return 0; 
#line 388
} 
#line 390
[[nodiscard]] static constexpr char16_t infinity() noexcept { 
#line 391
return 0; 
#line 392
} 
#line 394
[[nodiscard]] static constexpr char16_t quiet_NaN() noexcept { 
#line 395
return 0; 
#line 396
} 
#line 398
[[nodiscard]] static constexpr char16_t signaling_NaN() noexcept { 
#line 399
return 0; 
#line 400
} 
#line 402
static constexpr bool is_modulo = true; 
#line 403
static constexpr int digits = 16; 
#line 404
static constexpr int digits10 = 4; 
#line 405
}; 
#line 408
template<> class numeric_limits< char32_t>  : public _Num_int_base { 
#line 410
public: [[nodiscard]] static constexpr char32_t min() noexcept { 
#line 411
return 0; 
#line 412
} 
#line 414
[[nodiscard]] static constexpr char32_t max() noexcept { 
#line 415
return 4294967295U; 
#line 416
} 
#line 418
[[nodiscard]] static constexpr char32_t lowest() noexcept { 
#line 419
return min(); 
#line 420
} 
#line 422
[[nodiscard]] static constexpr char32_t epsilon() noexcept { 
#line 423
return 0; 
#line 424
} 
#line 426
[[nodiscard]] static constexpr char32_t round_error() noexcept { 
#line 427
return 0; 
#line 428
} 
#line 430
[[nodiscard]] static constexpr char32_t denorm_min() noexcept { 
#line 431
return 0; 
#line 432
} 
#line 434
[[nodiscard]] static constexpr char32_t infinity() noexcept { 
#line 435
return 0; 
#line 436
} 
#line 438
[[nodiscard]] static constexpr char32_t quiet_NaN() noexcept { 
#line 439
return 0; 
#line 440
} 
#line 442
[[nodiscard]] static constexpr char32_t signaling_NaN() noexcept { 
#line 443
return 0; 
#line 444
} 
#line 446
static constexpr bool is_modulo = true; 
#line 447
static constexpr int digits = 32; 
#line 448
static constexpr int digits10 = 9; 
#line 449
}; 
#line 452
template<> class numeric_limits< __wchar_t>  : public _Num_int_base { 
#line 454
public: [[nodiscard]] static constexpr __wchar_t min() noexcept { 
#line 455
return 0; 
#line 456
} 
#line 458
[[nodiscard]] static constexpr __wchar_t max() noexcept { 
#line 459
return 65535; 
#line 460
} 
#line 462
[[nodiscard]] static constexpr __wchar_t lowest() noexcept { 
#line 463
return min(); 
#line 464
} 
#line 466
[[nodiscard]] static constexpr __wchar_t epsilon() noexcept { 
#line 467
return 0; 
#line 468
} 
#line 470
[[nodiscard]] static constexpr __wchar_t round_error() noexcept { 
#line 471
return 0; 
#line 472
} 
#line 474
[[nodiscard]] static constexpr __wchar_t denorm_min() noexcept { 
#line 475
return 0; 
#line 476
} 
#line 478
[[nodiscard]] static constexpr __wchar_t infinity() noexcept { 
#line 479
return 0; 
#line 480
} 
#line 482
[[nodiscard]] static constexpr __wchar_t quiet_NaN() noexcept { 
#line 483
return 0; 
#line 484
} 
#line 486
[[nodiscard]] static constexpr __wchar_t signaling_NaN() noexcept { 
#line 487
return 0; 
#line 488
} 
#line 490
static constexpr bool is_modulo = true; 
#line 491
static constexpr int digits = 16; 
#line 492
static constexpr int digits10 = 4; 
#line 493
}; 
#line 496
template<> class numeric_limits< short>  : public _Num_int_base { 
#line 498
public: [[nodiscard]] static constexpr short min() noexcept { 
#line 499
return (-32768); 
#line 500
} 
#line 502
[[nodiscard]] static constexpr short max() noexcept { 
#line 503
return 32767; 
#line 504
} 
#line 506
[[nodiscard]] static constexpr short lowest() noexcept { 
#line 507
return min(); 
#line 508
} 
#line 510
[[nodiscard]] static constexpr short epsilon() noexcept { 
#line 511
return 0; 
#line 512
} 
#line 514
[[nodiscard]] static constexpr short round_error() noexcept { 
#line 515
return 0; 
#line 516
} 
#line 518
[[nodiscard]] static constexpr short denorm_min() noexcept { 
#line 519
return 0; 
#line 520
} 
#line 522
[[nodiscard]] static constexpr short infinity() noexcept { 
#line 523
return 0; 
#line 524
} 
#line 526
[[nodiscard]] static constexpr short quiet_NaN() noexcept { 
#line 527
return 0; 
#line 528
} 
#line 530
[[nodiscard]] static constexpr short signaling_NaN() noexcept { 
#line 531
return 0; 
#line 532
} 
#line 534
static constexpr bool is_signed = true; 
#line 535
static constexpr int digits = 15; 
#line 536
static constexpr int digits10 = 4; 
#line 537
}; 
#line 540
template<> class numeric_limits< int>  : public _Num_int_base { 
#line 542
public: [[nodiscard]] static constexpr int min() noexcept { 
#line 543
return ((-2147483647) - 1); 
#line 544
} 
#line 546
[[nodiscard]] static constexpr int max() noexcept { 
#line 547
return 2147483647; 
#line 548
} 
#line 550
[[nodiscard]] static constexpr int lowest() noexcept { 
#line 551
return min(); 
#line 552
} 
#line 554
[[nodiscard]] static constexpr int epsilon() noexcept { 
#line 555
return 0; 
#line 556
} 
#line 558
[[nodiscard]] static constexpr int round_error() noexcept { 
#line 559
return 0; 
#line 560
} 
#line 562
[[nodiscard]] static constexpr int denorm_min() noexcept { 
#line 563
return 0; 
#line 564
} 
#line 566
[[nodiscard]] static constexpr int infinity() noexcept { 
#line 567
return 0; 
#line 568
} 
#line 570
[[nodiscard]] static constexpr int quiet_NaN() noexcept { 
#line 571
return 0; 
#line 572
} 
#line 574
[[nodiscard]] static constexpr int signaling_NaN() noexcept { 
#line 575
return 0; 
#line 576
} 
#line 578
static constexpr bool is_signed = true; 
#line 579
static constexpr int digits = 31; 
#line 580
static constexpr int digits10 = 9; 
#line 581
}; 
#line 584
template<> class numeric_limits< long>  : public _Num_int_base { 
#line 586
public: [[nodiscard]] static constexpr long min() noexcept { 
#line 587
return ((-2147483647L) - (1)); 
#line 588
} 
#line 590
[[nodiscard]] static constexpr long max() noexcept { 
#line 591
return 2147483647L; 
#line 592
} 
#line 594
[[nodiscard]] static constexpr long lowest() noexcept { 
#line 595
return min(); 
#line 596
} 
#line 598
[[nodiscard]] static constexpr long epsilon() noexcept { 
#line 599
return 0; 
#line 600
} 
#line 602
[[nodiscard]] static constexpr long round_error() noexcept { 
#line 603
return 0; 
#line 604
} 
#line 606
[[nodiscard]] static constexpr long denorm_min() noexcept { 
#line 607
return 0; 
#line 608
} 
#line 610
[[nodiscard]] static constexpr long infinity() noexcept { 
#line 611
return 0; 
#line 612
} 
#line 614
[[nodiscard]] static constexpr long quiet_NaN() noexcept { 
#line 615
return 0; 
#line 616
} 
#line 618
[[nodiscard]] static constexpr long signaling_NaN() noexcept { 
#line 619
return 0; 
#line 620
} 
#line 622
static_assert((sizeof(int) == sizeof(long)), "LLP64 assumption");
#line 623
static constexpr bool is_signed = true; 
#line 624
static constexpr int digits = 31; 
#line 625
static constexpr int digits10 = 9; 
#line 626
}; 
#line 629
template<> class numeric_limits< __int64>  : public _Num_int_base { 
#line 631
public: [[nodiscard]] static constexpr __int64 min() noexcept { 
#line 632
return ((-9223372036854775807i64) - (1)); 
#line 633
} 
#line 635
[[nodiscard]] static constexpr __int64 max() noexcept { 
#line 636
return 9223372036854775807i64; 
#line 637
} 
#line 639
[[nodiscard]] static constexpr __int64 lowest() noexcept { 
#line 640
return min(); 
#line 641
} 
#line 643
[[nodiscard]] static constexpr __int64 epsilon() noexcept { 
#line 644
return 0; 
#line 645
} 
#line 647
[[nodiscard]] static constexpr __int64 round_error() noexcept { 
#line 648
return 0; 
#line 649
} 
#line 651
[[nodiscard]] static constexpr __int64 denorm_min() noexcept { 
#line 652
return 0; 
#line 653
} 
#line 655
[[nodiscard]] static constexpr __int64 infinity() noexcept { 
#line 656
return 0; 
#line 657
} 
#line 659
[[nodiscard]] static constexpr __int64 quiet_NaN() noexcept { 
#line 660
return 0; 
#line 661
} 
#line 663
[[nodiscard]] static constexpr __int64 signaling_NaN() noexcept { 
#line 664
return 0; 
#line 665
} 
#line 667
static constexpr bool is_signed = true; 
#line 668
static constexpr int digits = 63; 
#line 669
static constexpr int digits10 = 18; 
#line 670
}; 
#line 674
template<> class numeric_limits< unsigned short>  : public _Num_int_base { 
#line 676
public: [[nodiscard]] static constexpr unsigned short min() noexcept { 
#line 677
return 0; 
#line 678
} 
#line 680
[[nodiscard]] static constexpr unsigned short max() noexcept { 
#line 681
return 65535; 
#line 682
} 
#line 684
[[nodiscard]] static constexpr unsigned short lowest() noexcept { 
#line 685
return min(); 
#line 686
} 
#line 688
[[nodiscard]] static constexpr unsigned short epsilon() noexcept { 
#line 689
return 0; 
#line 690
} 
#line 692
[[nodiscard]] static constexpr unsigned short round_error() noexcept { 
#line 693
return 0; 
#line 694
} 
#line 696
[[nodiscard]] static constexpr unsigned short denorm_min() noexcept { 
#line 697
return 0; 
#line 698
} 
#line 700
[[nodiscard]] static constexpr unsigned short infinity() noexcept { 
#line 701
return 0; 
#line 702
} 
#line 704
[[nodiscard]] static constexpr unsigned short quiet_NaN() noexcept { 
#line 705
return 0; 
#line 706
} 
#line 708
[[nodiscard]] static constexpr unsigned short signaling_NaN() noexcept { 
#line 709
return 0; 
#line 710
} 
#line 712
static constexpr bool is_modulo = true; 
#line 713
static constexpr int digits = 16; 
#line 714
static constexpr int digits10 = 4; 
#line 715
}; 
#line 719 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\limits"
template<> class numeric_limits< unsigned>  : public _Num_int_base { 
#line 721
public: [[nodiscard]] static constexpr unsigned min() noexcept { 
#line 722
return 0; 
#line 723
} 
#line 725
[[nodiscard]] static constexpr unsigned max() noexcept { 
#line 726
return 4294967295U; 
#line 727
} 
#line 729
[[nodiscard]] static constexpr unsigned lowest() noexcept { 
#line 730
return min(); 
#line 731
} 
#line 733
[[nodiscard]] static constexpr unsigned epsilon() noexcept { 
#line 734
return 0; 
#line 735
} 
#line 737
[[nodiscard]] static constexpr unsigned round_error() noexcept { 
#line 738
return 0; 
#line 739
} 
#line 741
[[nodiscard]] static constexpr unsigned denorm_min() noexcept { 
#line 742
return 0; 
#line 743
} 
#line 745
[[nodiscard]] static constexpr unsigned infinity() noexcept { 
#line 746
return 0; 
#line 747
} 
#line 749
[[nodiscard]] static constexpr unsigned quiet_NaN() noexcept { 
#line 750
return 0; 
#line 751
} 
#line 753
[[nodiscard]] static constexpr unsigned signaling_NaN() noexcept { 
#line 754
return 0; 
#line 755
} 
#line 757
static constexpr bool is_modulo = true; 
#line 758
static constexpr int digits = 32; 
#line 759
static constexpr int digits10 = 9; 
#line 760
}; 
#line 763
template<> class numeric_limits< unsigned long>  : public _Num_int_base { 
#line 765
public: [[nodiscard]] static constexpr unsigned long min() noexcept { 
#line 766
return 0; 
#line 767
} 
#line 769
[[nodiscard]] static constexpr unsigned long max() noexcept { 
#line 770
return 4294967295UL; 
#line 771
} 
#line 773
[[nodiscard]] static constexpr unsigned long lowest() noexcept { 
#line 774
return min(); 
#line 775
} 
#line 777
[[nodiscard]] static constexpr unsigned long epsilon() noexcept { 
#line 778
return 0; 
#line 779
} 
#line 781
[[nodiscard]] static constexpr unsigned long round_error() noexcept { 
#line 782
return 0; 
#line 783
} 
#line 785
[[nodiscard]] static constexpr unsigned long denorm_min() noexcept { 
#line 786
return 0; 
#line 787
} 
#line 789
[[nodiscard]] static constexpr unsigned long infinity() noexcept { 
#line 790
return 0; 
#line 791
} 
#line 793
[[nodiscard]] static constexpr unsigned long quiet_NaN() noexcept { 
#line 794
return 0; 
#line 795
} 
#line 797
[[nodiscard]] static constexpr unsigned long signaling_NaN() noexcept { 
#line 798
return 0; 
#line 799
} 
#line 801
static_assert((sizeof(unsigned) == sizeof(unsigned long)), "LLP64 assumption");
#line 802
static constexpr bool is_modulo = true; 
#line 803
static constexpr int digits = 32; 
#line 804
static constexpr int digits10 = 9; 
#line 805
}; 
#line 808
template<> class numeric_limits< unsigned __int64>  : public _Num_int_base { 
#line 810
public: [[nodiscard]] static constexpr unsigned __int64 min() noexcept { 
#line 811
return 0; 
#line 812
} 
#line 814
[[nodiscard]] static constexpr unsigned __int64 max() noexcept { 
#line 815
return 18446744073709551615Ui64; 
#line 816
} 
#line 818
[[nodiscard]] static constexpr unsigned __int64 lowest() noexcept { 
#line 819
return min(); 
#line 820
} 
#line 822
[[nodiscard]] static constexpr unsigned __int64 epsilon() noexcept { 
#line 823
return 0; 
#line 824
} 
#line 826
[[nodiscard]] static constexpr unsigned __int64 round_error() noexcept { 
#line 827
return 0; 
#line 828
} 
#line 830
[[nodiscard]] static constexpr unsigned __int64 denorm_min() noexcept { 
#line 831
return 0; 
#line 832
} 
#line 834
[[nodiscard]] static constexpr unsigned __int64 infinity() noexcept { 
#line 835
return 0; 
#line 836
} 
#line 838
[[nodiscard]] static constexpr unsigned __int64 quiet_NaN() noexcept { 
#line 839
return 0; 
#line 840
} 
#line 842
[[nodiscard]] static constexpr unsigned __int64 signaling_NaN() noexcept { 
#line 843
return 0; 
#line 844
} 
#line 846
static constexpr bool is_modulo = true; 
#line 847
static constexpr int digits = 64; 
#line 848
static constexpr int digits10 = 19; 
#line 849
}; 
#line 852
template<> class numeric_limits< float>  : public _Num_float_base { 
#line 854
public: [[nodiscard]] static constexpr float min() noexcept { 
#line 855
return (1.175494351e-38F); 
#line 856
} 
#line 858
[[nodiscard]] static constexpr float max() noexcept { 
#line 859
return (3.402823466e+38F); 
#line 860
} 
#line 862
[[nodiscard]] static constexpr float lowest() noexcept { 
#line 863
return -max(); 
#line 864
} 
#line 866
[[nodiscard]] static constexpr float epsilon() noexcept { 
#line 867
return (1.192092896e-07F); 
#line 868
} 
#line 870
[[nodiscard]] static constexpr float round_error() noexcept { 
#line 871
return (0.5F); 
#line 872
} 
#line 874
[[nodiscard]] static constexpr float denorm_min() noexcept { 
#line 875
return (1.401298464e-45F); 
#line 876
} 
#line 879
[[nodiscard]] static constexpr float infinity() noexcept { 
#line 880
return __builtin_huge_valf(); 
#line 881
} 
#line 883
[[nodiscard]] static constexpr float quiet_NaN() noexcept { 
#line 884
return __builtin_nanf("0"); 
#line 885
} 
#line 887
[[nodiscard]] static constexpr float signaling_NaN() noexcept { 
#line 888
return __builtin_nansf("1"); 
#line 889
} 
#line 892
static constexpr int digits = 24; 
#line 893
static constexpr int digits10 = 6; 
#line 894
static constexpr int max_digits10 = 9; 
#line 895
static constexpr int max_exponent = 128; 
#line 896
static constexpr int max_exponent10 = 38; 
#line 897
static constexpr int min_exponent = (-125); 
#line 898
static constexpr int min_exponent10 = (-37); 
#line 899
}; 
#line 902
template<> class numeric_limits< double>  : public _Num_float_base { 
#line 904
public: [[nodiscard]] static constexpr double min() noexcept { 
#line 905
return (2.225073858507201383e-308); 
#line 906
} 
#line 908
[[nodiscard]] static constexpr double max() noexcept { 
#line 909
return (1.797693134862315708e+308); 
#line 910
} 
#line 912
[[nodiscard]] static constexpr double lowest() noexcept { 
#line 913
return -max(); 
#line 914
} 
#line 916
[[nodiscard]] static constexpr double epsilon() noexcept { 
#line 917
return (2.220446049250313081e-16); 
#line 918
} 
#line 920
[[nodiscard]] static constexpr double round_error() noexcept { 
#line 921
return (0.5); 
#line 922
} 
#line 924
[[nodiscard]] static constexpr double denorm_min() noexcept { 
#line 925
return (4.940656458412465442e-324); 
#line 926
} 
#line 929
[[nodiscard]] static constexpr double infinity() noexcept { 
#line 930
return __builtin_huge_val(); 
#line 931
} 
#line 933
[[nodiscard]] static constexpr double quiet_NaN() noexcept { 
#line 934
return __builtin_nan("0"); 
#line 935
} 
#line 937
[[nodiscard]] static constexpr double signaling_NaN() noexcept { 
#line 938
return __builtin_nans("1"); 
#line 939
} 
#line 942
static constexpr int digits = 53; 
#line 943
static constexpr int digits10 = 15; 
#line 944
static constexpr int max_digits10 = 17; 
#line 945
static constexpr int max_exponent = 1024; 
#line 946
static constexpr int max_exponent10 = 308; 
#line 947
static constexpr int min_exponent = (-1021); 
#line 948
static constexpr int min_exponent10 = (-307); 
#line 949
}; 
#line 952
template<> class numeric_limits< long double>  : public _Num_float_base { 
#line 954
public: [[nodiscard]] static constexpr long double min() noexcept { 
#line 955
return (2.225073858507201383e-308); 
#line 956
} 
#line 958
[[nodiscard]] static constexpr long double max() noexcept { 
#line 959
return (1.797693134862315708e+308); 
#line 960
} 
#line 962
[[nodiscard]] static constexpr long double lowest() noexcept { 
#line 963
return -max(); 
#line 964
} 
#line 966
[[nodiscard]] static constexpr long double epsilon() noexcept { 
#line 967
return (2.220446049250313081e-16); 
#line 968
} 
#line 970
[[nodiscard]] static constexpr long double round_error() noexcept { 
#line 971
return (0.5L); 
#line 972
} 
#line 974
[[nodiscard]] static constexpr long double denorm_min() noexcept { 
#line 975
return (4.940656458412465442e-324); 
#line 976
} 
#line 979
[[nodiscard]] static constexpr long double infinity() noexcept { 
#line 980
return __builtin_huge_val(); 
#line 981
} 
#line 983
[[nodiscard]] static constexpr long double quiet_NaN() noexcept { 
#line 984
return __builtin_nan("0"); 
#line 985
} 
#line 987
[[nodiscard]] static constexpr long double signaling_NaN() noexcept { 
#line 988
return __builtin_nans("1"); 
#line 989
} 
#line 992
static constexpr int digits = 53; 
#line 993
static constexpr int digits10 = 15; 
#line 994
static constexpr int max_digits10 = ((2) + (((53) * 301L) / (1000))); 
#line 995
static constexpr int max_exponent = 1024; 
#line 996
static constexpr int max_exponent10 = 308; 
#line 997
static constexpr int min_exponent = (-1021); 
#line 998
static constexpr int min_exponent10 = (-307); 
#line 999
}; 
#line 1001
}
#line 1004
#pragma warning(pop)
#pragma pack ( pop )
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\new"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 20
namespace std { 
#line 49 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\new"
using new_handler = void (__cdecl *)(void); 
#line 51
new_handler __cdecl set_new_handler(new_handler) noexcept; 
#line 52
[[nodiscard]] new_handler __cdecl get_new_handler() noexcept; 
#line 53
}
#line 57
#pragma warning(pop)
#pragma pack ( pop )
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xatomic.h"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 73 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xatomic.h"
namespace std { 
#line 99 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xatomic.h"
enum memory_order { 
#line 100
memory_order_relaxed, 
#line 101
memory_order_consume, 
#line 102
memory_order_acquire, 
#line 103
memory_order_release, 
#line 104
memory_order_acq_rel, 
#line 105
memory_order_seq_cst
#line 106
}; 
#line 109 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xatomic.h"
using _Atomic_counter_t = unsigned long; 
#line 111
template < class _Integral, class _Ty >
[ [ nodiscard ] ] volatile _Integral * _Atomic_address_as ( _Ty & _Source ) noexcept {

    static_assert ( is_integral_v < _Integral >, "Tried to reinterpret memory as non-integral" );
    return & reinterpret_cast < volatile _Integral & > ( _Source );
}
#line 118
template < class _Integral, class _Ty >
[ [ nodiscard ] ] const volatile _Integral * _Atomic_address_as ( const _Ty & _Source ) noexcept {

    static_assert ( is_integral_v < _Integral >, "Tried to reinterpret memory as non-integral" );
    return & reinterpret_cast < const volatile _Integral & > ( _Source );
}
#line 125
}
#line 129
#pragma warning(pop)
#pragma pack ( pop )
#line 21 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 29
extern "C" {
#line 30
void *__stdcall __std_remove_1(void * _First, void * _Last, uint8_t _Val) noexcept; 
#line 31
void *__stdcall __std_remove_2(void * _First, void * _Last, uint16_t _Val) noexcept; 
#line 32
void *__stdcall __std_remove_4(void * _First, void * _Last, uint32_t _Val) noexcept; 
#line 33
void *__stdcall __std_remove_8(void * _First, void * _Last, uint64_t _Val) noexcept; 
#line 34
}
#line 36
namespace std { 
#line 37
template < class _Ty, class _TVal >
_Ty * _Remove_vectorized ( _Ty * const _First, _Ty * const _Last, const _TVal _Val ) noexcept {
    if constexpr ( is_pointer_v < _Ty > ) {

        return reinterpret_cast < _Ty * > ( :: __std_remove_8 ( _First, _Last, reinterpret_cast < uint64_t > ( _Val ) ) );



    } else if constexpr ( sizeof ( _Ty ) == 1 ) {
        return reinterpret_cast < _Ty * > ( :: __std_remove_1 ( _First, _Last, static_cast < uint8_t > ( _Val ) ) );
    } else if constexpr ( sizeof ( _Ty ) == 2 ) {
        return reinterpret_cast < _Ty * > ( :: __std_remove_2 ( _First, _Last, static_cast < uint16_t > ( _Val ) ) );
    } else if constexpr ( sizeof ( _Ty ) == 4 ) {
        return reinterpret_cast < _Ty * > ( :: __std_remove_4 ( _First, _Last, static_cast < uint32_t > ( _Val ) ) );
    } else if constexpr ( sizeof ( _Ty ) == 8 ) {
        return reinterpret_cast < _Ty * > ( :: __std_remove_8 ( _First, _Last, static_cast < uint64_t > ( _Val ) ) );
    } else {
        ;
    }
}
#line 57 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
}
#line 61 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
namespace std { 
#line 62
template < class _Ptrty >
[ [ nodiscard ] ] constexpr auto _Unfancy ( _Ptrty _Ptr ) noexcept {
    return :: std :: addressof ( * _Ptr );
}
#line 67
template < class _Ty >
[ [ nodiscard ] ] constexpr _Ty * _Unfancy ( _Ty * _Ptr ) noexcept {
    return _Ptr;
}
#line 72
template < class _Ptrty >
constexpr auto _Unfancy_maybe_null ( _Ptrty _Ptr ) noexcept {

    return _Ptr ? :: std :: addressof ( * _Ptr ) : nullptr;
}
#line 78
template < class _Ty >
constexpr _Ty * _Unfancy_maybe_null ( _Ty * _Ptr ) noexcept {
    return _Ptr;
}
#line 83
template < class _Ty >
struct [ [ nodiscard ] ] _Tidy_guard {
    _Ty * _Target;
    inline ~ _Tidy_guard ( ) {
        if ( _Target ) {
            _Target -> _Tidy ( );
        }
    }
};
#line 93
template < class _Ty >
struct [ [ nodiscard ] ] _Tidy_deallocate_guard {
    _Ty * _Target;
    inline ~ _Tidy_deallocate_guard ( ) {
        if ( _Target ) {
            _Target -> _Tidy_deallocate ( );
        }
    }
};
#line 103
template< class _Keycmp, class _Lhs, class _Rhs> constexpr bool 
#line 104
_Nothrow_compare = noexcept((static_cast< bool>(std::declval< const _Keycmp &> ()(std::declval< const _Lhs &> (), std::declval< const _Rhs &> ())))); 
#line 107
[[noreturn]] inline void _Throw_bad_array_new_length() { 
#line 108
throw bad_array_new_length{}; 
#line 109
} 
#line 111
template < size_t _Ty_size >
[ [ nodiscard ] ] constexpr size_t _Get_size_of_n ( const size_t _Count ) {
    constexpr bool _Overflow_is_possible = _Ty_size > 1;

    if constexpr ( _Overflow_is_possible ) {
        constexpr size_t _Max_possible = static_cast < size_t > ( - 1 ) / _Ty_size;
        if ( _Count > _Max_possible ) {
            _Throw_bad_array_new_length ( );
        }
    }

    return _Count * _Ty_size;
}
#line 125
template< class _Ty> constexpr size_t 
#line 126
_New_alignof = (::std::max)(__alignof(_Ty), 16Ui64); 
#line 134 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
struct _Default_allocate_traits { 
#line 135
__declspec(allocator) static void *_Allocate(const size_t _Bytes) { 
#line 136
return ::operator new(_Bytes); 
#line 137
} 
#line 151
}; 
#line 155
constexpr bool _Is_pow_2(const size_t _Value) noexcept { 
#line 156
return (_Value != (0)) && ((_Value & (_Value - (1))) == (0)); 
#line 157
} 
#line 160
constexpr size_t _Big_allocation_threshold = (4096); 
#line 161
constexpr size_t _Big_allocation_alignment = (32); 
#line 172
constexpr size_t _Non_user_size = ((sizeof(void *) + _Big_allocation_alignment) - (1)); 
#line 176 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
constexpr size_t _Big_allocation_sentinel = 18085043209519168250Ui64; 
#line 181 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template < class _Traits >
__declspec ( allocator ) void * _Allocate_manually_vector_aligned ( const size_t _Bytes ) {

    const size_t _Block_size = _Non_user_size + _Bytes;
    if ( _Block_size <= _Bytes ) {
        _Throw_bad_array_new_length ( );
    }

    const uintptr_t _Ptr_container = reinterpret_cast < uintptr_t > ( _Traits :: _Allocate ( _Block_size ) );
    if ( ! ( _Ptr_container != 0 ) ) {; :: _invoke_watson ( nullptr, nullptr, nullptr, 0, 0 ); };
    void * const _Ptr = reinterpret_cast < void * > ( ( _Ptr_container + _Non_user_size ) & ~ ( _Big_allocation_alignment - 1 ) );
    static_cast < uintptr_t * > ( _Ptr ) [ - 1 ] = _Ptr_container;




    return _Ptr;
}
#line 200
inline void _Adjust_manually_vector_aligned(void *&_Ptr, size_t &_Bytes) { 
#line 202
_Bytes += _Non_user_size; 
#line 204
const uintptr_t *const _Ptr_user = static_cast< uintptr_t *>(_Ptr); 
#line 205
const uintptr_t _Ptr_container = _Ptr_user[-1]; 
#line 209
; 
#line 216
constexpr uintptr_t _Min_back_shift = sizeof(void *); 
#line 218 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
const uintptr_t _Back_shift = (reinterpret_cast< uintptr_t>(_Ptr)) - _Ptr_container; 
#line 219
if (!((_Back_shift >= _Min_back_shift) && (_Back_shift <= _Non_user_size))) { ; ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); }  ; 
#line 220
_Ptr = (reinterpret_cast< void *>(_Ptr_container)); 
#line 221
} 
#line 224 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template < size_t _Align, class _Traits = _Default_allocate_traits >
__declspec ( allocator ) inline void * _Allocate ( const size_t _Bytes ) {

    if ( _Bytes == 0 ) {
        return nullptr;
    }



















    {

        if ( _Bytes >= _Big_allocation_threshold ) {

            return _Allocate_manually_vector_aligned < _Traits > ( _Bytes );
        }

        return _Traits :: _Allocate ( _Bytes );
    }
}
#line 260 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template < size_t _Align >
inline void _Deallocate ( void * _Ptr, size_t _Bytes ) noexcept {




















    {

        if ( _Bytes >= _Big_allocation_threshold ) {

            _Adjust_manually_vector_aligned ( _Ptr, _Bytes );
        }

        :: operator delete ( _Ptr, _Bytes );
    }
}
#line 293 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template< class _Ptr, class _Ty> using _Rebind_pointer_t = typename pointer_traits< _Ptr> ::template rebind< _Ty> ; 
#line 296
template < class _Pointer, enable_if_t < ! is_pointer_v < _Pointer >, int > = 0 >
inline _Pointer _Refancy ( typename pointer_traits < _Pointer > :: element_type * _Ptr ) noexcept {
    return pointer_traits < _Pointer > :: pointer_to ( * _Ptr );
}
#line 301
template < class _Pointer, enable_if_t < is_pointer_v < _Pointer >, int > = 0 >
inline _Pointer _Refancy ( _Pointer _Ptr ) noexcept {
    return _Ptr;
}
#line 306
template < class _Pointer, enable_if_t < ! is_pointer_v < _Pointer >, int > = 0 >
inline _Pointer _Refancy_maybe_null ( typename pointer_traits < _Pointer > :: element_type * _Ptr ) noexcept {
    return _Ptr == nullptr ? _Pointer ( ) : pointer_traits < _Pointer > :: pointer_to ( * _Ptr );
}
#line 311
template < class _Pointer, enable_if_t < is_pointer_v < _Pointer >, int > = 0 >
inline _Pointer _Refancy_maybe_null ( _Pointer _Ptr ) noexcept {
    return _Ptr;
}
#line 316
template < class _NoThrowFwdIt, class _NoThrowSentinel >
inline void _Destroy_range ( _NoThrowFwdIt _First, _NoThrowSentinel _Last ) noexcept;
#line 319
template < class _Ty >
inline void _Destroy_in_place ( _Ty & _Obj ) noexcept {
    if constexpr ( is_array_v < _Ty > ) {
        :: std :: _Destroy_range ( _Obj, _Obj + extent_v < _Ty > );
    } else {
        _Obj . ~ _Ty ( );
    }
}
#line 342 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template < class _Ptrty >
auto _Const_cast ( _Ptrty _Ptr ) noexcept {
    using _Elem = typename pointer_traits < _Ptrty > :: element_type;
    using _Modifiable = remove_const_t < _Elem >;
    using _Dest = typename pointer_traits < _Ptrty > :: template rebind < _Modifiable >;

    return pointer_traits < _Dest > :: pointer_to ( const_cast < _Modifiable & > ( * _Ptr ) );
}
#line 351
template < class _Ty >
auto _Const_cast ( _Ty * _Ptr ) noexcept {
    return const_cast < remove_const_t < _Ty > * > ( _Ptr );
}
#line 356
template< class _Ty, class  = void> 
#line 357
struct _Get_pointer_type { 
#line 358
using type = typename _Ty::value_type *; 
#line 359
}; 
#line 361
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 362
template< class _Ty> 
#line 363
struct _Get_pointer_type< _Ty, void_t< typename _Ty::pointer> >  { 
#line 364
using type = typename _Ty::pointer; 
#line 365
}; 
#line 366
__pragma( warning(pop)) 
#line 368
template< class _Ty, class  = void> 
#line 369
struct _Get_const_pointer_type { 
#line 370
using _Ptrty = typename _Get_pointer_type< _Ty> ::type; 
#line 371
using _Valty = typename _Ty::value_type; 
#line 372
using type = typename pointer_traits< _Ptrty> ::template rebind< const _Valty> ; 
#line 373
}; 
#line 375
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 376
template< class _Ty> 
#line 377
struct _Get_const_pointer_type< _Ty, void_t< typename _Ty::const_pointer> >  { 
#line 378
using type = typename _Ty::const_pointer; 
#line 379
}; 
#line 380
__pragma( warning(pop)) 
#line 382
template< class _Ty, class  = void> 
#line 383
struct _Get_void_pointer_type { 
#line 384
using _Ptrty = typename _Get_pointer_type< _Ty> ::type; 
#line 385
using type = typename pointer_traits< _Ptrty> ::template rebind< void> ; 
#line 386
}; 
#line 388
template< class _Ty> 
#line 389
struct _Get_void_pointer_type< _Ty, void_t< typename _Ty::void_pointer> >  { 
#line 390
using type = typename _Ty::void_pointer; 
#line 391
}; 
#line 393
template< class _Ty, class  = void> 
#line 394
struct _Get_const_void_pointer_type { 
#line 395
using _Ptrty = typename _Get_pointer_type< _Ty> ::type; 
#line 396
using type = typename pointer_traits< _Ptrty> ::template rebind< const void> ; 
#line 397
}; 
#line 399
template< class _Ty> 
#line 400
struct _Get_const_void_pointer_type< _Ty, void_t< typename _Ty::const_void_pointer> >  { 
#line 401
using type = typename _Ty::const_void_pointer; 
#line 402
}; 
#line 404
template< class _Ty, class  = void> 
#line 405
struct _Get_difference_type { 
#line 406
using _Ptrty = typename _Get_pointer_type< _Ty> ::type; 
#line 407
using type = typename pointer_traits< _Ptrty> ::difference_type; 
#line 408
}; 
#line 410
template< class _Ty> 
#line 411
struct _Get_difference_type< _Ty, void_t< typename _Ty::difference_type> >  { 
#line 412
using type = typename _Ty::difference_type; 
#line 413
}; 
#line 415
template< class _Ty, class  = void> 
#line 416
struct _Get_size_type { 
#line 417
using type = make_unsigned_t< typename _Get_difference_type< _Ty> ::type> ; 
#line 418
}; 
#line 420
template< class _Ty> 
#line 421
struct _Get_size_type< _Ty, void_t< typename _Ty::size_type> >  { 
#line 422
using type = typename _Ty::size_type; 
#line 423
}; 
#line 425
template< class _Ty, class  = void> 
#line 426
struct _Get_propagate_on_container_copy { 
#line 427
using type = false_type; 
#line 428
}; 
#line 430
template< class _Ty> 
#line 431
struct _Get_propagate_on_container_copy< _Ty, void_t< typename _Ty::propagate_on_container_copy_assignment> >  { 
#line 432
using type = typename _Ty::propagate_on_container_copy_assignment; 
#line 433
}; 
#line 435
template< class _Ty, class  = void> 
#line 436
struct _Get_propagate_on_container_move { 
#line 437
using type = false_type; 
#line 438
}; 
#line 440
template< class _Ty> 
#line 441
struct _Get_propagate_on_container_move< _Ty, void_t< typename _Ty::propagate_on_container_move_assignment> >  { 
#line 442
using type = typename _Ty::propagate_on_container_move_assignment; 
#line 443
}; 
#line 445
template< class _Ty, class  = void> 
#line 446
struct _Get_propagate_on_container_swap { 
#line 447
using type = false_type; 
#line 448
}; 
#line 450
template< class _Ty> 
#line 451
struct _Get_propagate_on_container_swap< _Ty, void_t< typename _Ty::propagate_on_container_swap> >  { 
#line 452
using type = typename _Ty::propagate_on_container_swap; 
#line 453
}; 
#line 455
template< class _Ty, class  = void> 
#line 456
struct _Get_is_always_equal { 
#line 457
using type = bool_constant< is_empty_v< _Ty> > ; 
#line 458
}; 
#line 460
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 461
template< class _Ty> 
#line 462
struct _Get_is_always_equal< _Ty, void_t< typename _Ty::is_always_equal> >  { 
#line 463
using type = typename _Ty::is_always_equal; 
#line 464
}; 
#line 465
__pragma( warning(pop)) 
#line 467
template< class _Ty, class _Other, class  = void> 
#line 468
struct _Get_rebind_type { 
#line 469
using type = typename _Replace_first_parameter< _Other, _Ty> ::type; 
#line 470
}; 
#line 472
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 473
template< class _Ty, class _Other> 
#line 474
struct _Get_rebind_type< _Ty, _Other, void_t< typename _Ty::template rebind< _Other> ::other> >  { 
#line 475
using type = typename _Ty::template rebind< _Other> ::other; 
#line 476
}; 
#line 477
__pragma( warning(pop)) 
#line 479
template< class _Ty> class allocator; 
#line 482
template< class _Alloc, class  = void> 
#line 483
struct _Is_default_allocator : public false_type { }; 
#line 485
template< class _Ty> 
#line 486
struct _Is_default_allocator< allocator< _Ty> , void_t< typename allocator< _Ty> ::_From_primary> >  : public is_same< typename allocator< _Ty> ::_From_primary, allocator< _Ty> > ::type { 
#line 487
}; 
#line 494 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template< class _Void, class ..._Types> 
#line 495
struct _Has_no_allocator_construct : public true_type { }; 
#line 497
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 498
template< class _Alloc, class _Ptr, class ..._Args> 
#line 499
struct _Has_no_allocator_construct< void_t< decltype(std::declval< _Alloc &> ().construct(std::declval< _Ptr> (), std::declval< _Args> ()...))> , _Alloc, _Ptr, _Args...>  : public false_type { 
#line 501
}; 
#line 502
__pragma( warning(pop)) 
#line 504
template< class _Alloc, class _Ptr, class ..._Args> using _Uses_default_construct = disjunction< _Is_default_allocator< _Alloc> , _Has_no_allocator_construct< void, _Alloc, _Ptr, _Args...> > ; 
#line 508
template< class _Alloc, class _Ptr, class  = void> 
#line 509
struct _Has_no_alloc_destroy : public true_type { }; 
#line 511
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 512
template< class _Alloc, class _Ptr> 
#line 513
struct _Has_no_alloc_destroy< _Alloc, _Ptr, void_t< decltype(std::declval< _Alloc &> ().destroy(std::declval< _Ptr> ()))> >  : public false_type { 
#line 514
}; 
#line 515
__pragma( warning(pop)) 
#line 517
template< class _Alloc, class _Ptr> using _Uses_default_destroy = disjunction< _Is_default_allocator< _Alloc> , _Has_no_alloc_destroy< _Alloc, _Ptr> > ; 
#line 520
template< class _Alloc, class _Size_type, class _Const_void_pointer, class  = void> 
#line 521
struct _Has_allocate_hint : public false_type { }; 
#line 523
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 524
template< class _Alloc, class _Size_type, class _Const_void_pointer> 
#line 525
struct _Has_allocate_hint< _Alloc, _Size_type, _Const_void_pointer, void_t< decltype(std::declval< _Alloc &> ().allocate(std::declval< const _Size_type &> (), std::declval< const _Const_void_pointer &> ()))> >  : public true_type { 
#line 527
}; 
#line 528
__pragma( warning(pop)) 
#line 530
template< class _Alloc, class  = void> 
#line 531
struct _Has_max_size : public false_type { }; 
#line 533
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 534
template< class _Alloc> 
#line 535
struct _Has_max_size< _Alloc, void_t< decltype(std::declval< const _Alloc &> ().max_size())> >  : public true_type { }; 
#line 536
__pragma( warning(pop)) 
#line 538
template< class _Alloc, class  = void> 
#line 539
struct _Has_select_on_container_copy_construction : public false_type { }; 
#line 541
template< class _Alloc> 
#line 542
struct _Has_select_on_container_copy_construction< _Alloc, void_t< decltype(std::declval< const _Alloc &> ().select_on_container_copy_construction())> >  : public true_type { 
#line 543
}; 
#line 553 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template< class _Alloc> struct allocator_traits; 
#line 556
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 557
template < class _Alloc >
struct _Normal_allocator_traits {
    using allocator_type = _Alloc;
    using value_type = typename _Alloc :: value_type;

    using pointer = typename _Get_pointer_type < _Alloc > :: type;
    using const_pointer = typename _Get_const_pointer_type < _Alloc > :: type;
    using void_pointer = typename _Get_void_pointer_type < _Alloc > :: type;
    using const_void_pointer = typename _Get_const_void_pointer_type < _Alloc > :: type;

    using size_type = typename _Get_size_type < _Alloc > :: type;
    using difference_type = typename _Get_difference_type < _Alloc > :: type;

    using propagate_on_container_copy_assignment = typename _Get_propagate_on_container_copy < _Alloc > :: type;
    using propagate_on_container_move_assignment = typename _Get_propagate_on_container_move < _Alloc > :: type;
    using propagate_on_container_swap = typename _Get_propagate_on_container_swap < _Alloc > :: type;
    using is_always_equal = typename _Get_is_always_equal < _Alloc > :: type;

    template < class _Other >
    using rebind_alloc = typename _Get_rebind_type < _Alloc, _Other > :: type;

    template < class _Other >
    using rebind_traits = allocator_traits < rebind_alloc < _Other >>;

    [ [ nodiscard ( "This function allocates memory and returns a raw pointer. Discarding the return value will cause a memory leak." ) ] ] static inline __declspec ( allocator ) pointer allocate (
        _Alloc & _Al, const size_type _Count ) {
        return _Al . allocate ( _Count );
    }

    [ [ nodiscard ( "This function allocates memory and returns a raw pointer. Discarding the return value will cause a memory leak." ) ] ] static inline __declspec ( allocator ) pointer allocate (
        _Alloc & _Al, const size_type _Count, const const_void_pointer _Hint ) {
        if constexpr ( _Has_allocate_hint < _Alloc, size_type, const_void_pointer > :: value ) {
            return _Al . allocate ( _Count, _Hint );
        } else {
            return _Al . allocate ( _Count );
        }
    }












    static inline void deallocate ( _Alloc & _Al, pointer _Ptr, size_type _Count ) {
        _Al . deallocate ( _Ptr, _Count );
    }

    template < class _Ty, class ... _Types >
    static inline void construct ( _Alloc & _Al, _Ty * _Ptr, _Types && ... _Args ) {
        if constexpr ( _Uses_default_construct < _Alloc, _Ty *, _Types ... > :: value ) {



            :: new ( static_cast < void * > ( _Ptr ) ) _Ty ( :: std :: forward < _Types > ( _Args ) ... );

        } else {
            _Al . construct ( _Ptr, :: std :: forward < _Types > ( _Args ) ... );
        }
    }

    template < class _Ty >
    static inline void destroy ( _Alloc & _Al, _Ty * _Ptr ) {
        if constexpr ( _Uses_default_destroy < _Alloc, _Ty * > :: value ) {



            _Ptr -> ~ _Ty ( );

        } else {
            _Al . destroy ( _Ptr );
        }
    }

    [ [ nodiscard ] ] static inline size_type max_size ( const _Alloc & _Al ) noexcept {
        if constexpr ( _Has_max_size < _Alloc > :: value ) {
            return _Al . max_size ( );
        } else {
            return :: std :: _Max_limit < size_type > ( ) / sizeof ( value_type );
        }
    }

    [ [ nodiscard ] ] static inline _Alloc select_on_container_copy_construction ( const _Alloc & _Al ) {
        if constexpr ( _Has_select_on_container_copy_construction < _Alloc > :: value ) {
            return _Al . select_on_container_copy_construction ( );
        } else {
            return _Al;
        }
    }
};
#line 652 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
__pragma( warning(pop)) 
#line 654
template < class _Alloc >
struct _Default_allocator_traits {
    using allocator_type = _Alloc;
    using value_type = typename _Alloc :: value_type;

    using pointer = value_type *;
    using const_pointer = const value_type *;
    using void_pointer = void *;
    using const_void_pointer = const void *;

    using size_type = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_copy_assignment = false_type;
    using propagate_on_container_move_assignment = true_type;
    using propagate_on_container_swap = false_type;
    using is_always_equal = true_type;

    template < class _Other >
    using rebind_alloc = allocator < _Other >;

    template < class _Other >
    using rebind_traits = allocator_traits < allocator < _Other >>;

    [ [ nodiscard ( "This function allocates memory and returns a raw pointer. Discarding the return value will cause a memory leak." ) ] ] static inline __declspec ( allocator ) pointer allocate (
        _Alloc & _Al, const size_type _Count ) {





        {
            ( void ) _Al;
            return static_cast < pointer > (
                _Allocate < _New_alignof < value_type >> ( _Get_size_of_n < sizeof ( value_type ) > ( _Count ) ) );
        }
    }

    [ [ nodiscard ( "This function allocates memory and returns a raw pointer. Discarding the return value will cause a memory leak." ) ] ] static inline __declspec ( allocator ) pointer allocate (
        _Alloc & _Al, const size_type _Count, const_void_pointer ) {





        {
            ( void ) _Al;
            return static_cast < pointer > (
                _Allocate < _New_alignof < value_type >> ( _Get_size_of_n < sizeof ( value_type ) > ( _Count ) ) );
        }
    }








    static inline void deallocate ( _Alloc & _Al, const pointer _Ptr, const size_type _Count ) noexcept
     {






        {
            ( void ) _Al;
            :: std :: _Deallocate < _New_alignof < value_type >> ( _Ptr, sizeof ( value_type ) * _Count );
        }
    }

    template < class _Objty, class ... _Types >
    static inline void construct ( _Alloc &, _Objty * const _Ptr, _Types && ... _Args ) {



        :: new ( const_cast < void * > ( static_cast < const volatile void * > ( _Ptr ) ) ) _Objty ( :: std :: forward < _Types > ( _Args ) ... );

    }

    template < class _Uty >
    static inline void destroy ( _Alloc &, _Uty * const _Ptr ) {



        _Ptr -> ~ _Uty ( );

    }

    [ [ nodiscard ] ] static inline size_type max_size ( const _Alloc & ) noexcept {
        return static_cast < size_t > ( - 1 ) / sizeof ( value_type );
    }

    [ [ nodiscard ] ] static inline _Alloc select_on_container_copy_construction ( const _Alloc & _Al ) {
        return _Al;
    }
};
#line 754 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template< class _Alloc> 
#line 755
struct allocator_traits : public conditional_t< _Is_default_allocator< _Alloc> ::value, _Default_allocator_traits< _Alloc> , _Normal_allocator_traits< _Alloc> >  { 
#line 756
}; 
#line 760
template< class _Alloc> constexpr bool 
#line 761
_Choose_pocca_v = (allocator_traits< _Alloc> ::propagate_on_container_copy_assignment::value && (!allocator_traits< _Alloc> ::is_always_equal::value)); 
#line 764
enum class _Pocma_values { 
#line 765
_Equal_allocators, 
#line 766
_Propagate_allocators, 
#line 767
_No_propagate_allocators
#line 768
}; 
#line 770
template< class _Alloc> constexpr _Pocma_values 
#line 771
_Choose_pocma_v = ((allocator_traits< _Alloc> ::is_always_equal::value) ? _Pocma_values::_Equal_allocators : ((allocator_traits< _Alloc> ::propagate_on_container_move_assignment::value) ? _Pocma_values::_Propagate_allocators : _Pocma_values::_No_propagate_allocators)); 
#line 777
template< class _Alloc, class _Value_type> using _Rebind_alloc_t = typename allocator_traits< _Alloc> ::template rebind_alloc< _Value_type> ; 
#line 782
template< class _Alloc, class _Value_type> using _Maybe_rebind_alloc_t = typename _Select< is_same_v< typename _Alloc::value_type, _Value_type> > ::template _Apply< _Alloc &, _Rebind_alloc_t< _Alloc, _Value_type> > ; 
#line 787
template< class _Alloc> constexpr bool 
#line 788
_Is_simple_alloc_v = ((is_same_v< typename allocator_traits< _Alloc> ::size_type, unsigned __int64>  && is_same_v< typename allocator_traits< _Alloc> ::difference_type, __int64> ) && is_same_v< typename allocator_traits< _Alloc> ::pointer, typename _Alloc::value_type *> ) && is_same_v< typename allocator_traits< _Alloc> ::const_pointer, const typename _Alloc::value_type *> ; 
#line 794
template< class _Value_type> 
#line 795
struct _Simple_types { 
#line 797
using value_type = _Value_type; 
#line 798
using size_type = size_t; 
#line 799
using difference_type = ptrdiff_t; 
#line 800
using pointer = value_type *; 
#line 801
using const_pointer = const value_type *; 
#line 802
}; 
#line 805
constexpr size_t _Asan_granularity = (8); 
#line 806
constexpr size_t _Asan_granularity_mask = (_Asan_granularity - (1)); 
#line 809
template< class > constexpr bool 
#line 810
_Disable_ASan_container_annotations_for_allocator = false; 
#line 812
struct _Asan_aligned_pointers { 
#line 813
const void *_First; 
#line 814
const void *_End; 
#line 816
[[nodiscard]] constexpr const void *_Clamp_to_end(const void *_Mid) const noexcept { 
#line 817
; 
#line 818
if (_Mid > (_End)) { 
#line 819
return _End; 
#line 820
} else { 
#line 821
return _Mid; 
#line 822
}  
#line 823
} 
#line 824
}; 
#line 906
[[nodiscard]] inline _Asan_aligned_pointers _Get_asan_aligned_first_end(const void *const 
#line 907
_First, const void *const _End) noexcept { 
#line 908
return {reinterpret_cast< const void *>((reinterpret_cast< uintptr_t>(_First)) & (~_Asan_granularity_mask)), reinterpret_cast< const void *>((reinterpret_cast< uintptr_t>(_End)) & (~_Asan_granularity_mask))}; 
#line 912
} 
#line 917
[[nodiscard]] inline const void *_Get_asan_aligned_after(const void *const _End) noexcept { 
#line 918
return reinterpret_cast< const void *>(((reinterpret_cast< uintptr_t>(_End)) + _Asan_granularity_mask) & (~_Asan_granularity_mask)); 
#line 920
} 
#line 922
template< class _Container, class  = void> constexpr size_t 
#line 923
_Container_allocation_minimum_asan_alignment = __alignof(typename _Container::value_type); 
#line 925
template< class _Container> constexpr size_t 
#line 926
_Container_allocation_minimum_asan_alignment< _Container, void_t< decltype(_Container::allocator_type::_Minimum_asan_allocation_alignment)> >  = (std::max)(__alignof(typename _Container::value_type), _Container::allocator_type::_Minimum_asan_allocation_alignment); 
#line 931
template < class _Ty >
class allocator {
public :
    static_assert ( ! is_const_v < _Ty >, "The C++ Standard forbids containers of const elements because allocator<const T> is ill-formed."
                                                                               );
    static_assert ( ! is_function_v < _Ty >, "The C++ Standard forbids allocators for function elements because of [allocator.requirements]."
                                                                             );
    static_assert ( ! is_reference_v < _Ty >, "The C++ Standard forbids allocators for reference elements because of [allocator.requirements]."
                                                                              );

    using _From_primary = allocator;

    using value_type = _Ty;


    using pointer = _Ty *;
    using const_pointer = const _Ty *;

    using reference = _Ty &;
    using const_reference = const _Ty &;


    using size_type = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_move_assignment = true_type;
    using is_always_equal = true_type;


    template < class _Other >
    struct rebind {
        using other = allocator < _Other >;
    };

     [ [ nodiscard ] ] _Ty * address ( _Ty & _Val ) const noexcept {
        return :: std :: addressof ( _Val );
    }

     [ [ nodiscard ] ] const _Ty * address ( const _Ty & _Val ) const noexcept {
        return :: std :: addressof ( _Val );
    }


    constexpr allocator ( ) noexcept { }

    constexpr allocator ( const allocator & ) noexcept = default;
    template < class _Other >
    constexpr allocator ( const allocator < _Other > & ) noexcept { }
    inline ~ allocator ( ) = default;
    inline allocator & operator = ( const allocator & ) = default;

    inline void deallocate ( _Ty * const _Ptr, const size_t _Count ) noexcept {
        ;

        :: std :: _Deallocate < _New_alignof < _Ty >> ( _Ptr, sizeof ( _Ty ) * _Count );
    }

    [ [ nodiscard ( "This function allocates memory and returns a raw pointer. Discarding the return value will cause a memory leak." ) ] ] inline __declspec ( allocator ) _Ty * allocate ( const size_t _Count ) {
        static_assert ( sizeof ( value_type ) > 0, "value_type must be complete before calling allocate." );
        return static_cast < _Ty * > ( :: std :: _Allocate < _New_alignof < _Ty >> ( _Get_size_of_n < sizeof ( _Ty ) > ( _Count ) ) );
    }









     [ [ nodiscard ( "This function allocates memory and returns a raw pointer. Discarding the return value will cause a memory leak." ) ] ] __declspec ( allocator )
    _Ty * allocate ( const size_t _Count, const void * ) {
        return allocate ( _Count );
    }

    template < class _Objty, class ... _Types >
     void construct ( _Objty * const _Ptr, _Types && ... _Args ) {
        :: new ( const_cast < void * > ( static_cast < const volatile void * > ( _Ptr ) ) ) _Objty ( :: std :: forward < _Types > ( _Args ) ... );
    }

    template < class _Uty >
     void destroy ( _Uty * const _Ptr ) {
        _Ptr -> ~ _Uty ( );
    }

     [ [ nodiscard ] ] size_t max_size ( ) const noexcept {
        return static_cast < size_t > ( - 1 ) / sizeof ( _Ty );
    }


    static constexpr size_t _Minimum_asan_allocation_alignment = _Asan_granularity;
};
#line 1026 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
#pragma pack(8)
template<> 
#line 1026
class allocator< void>  { 
#line 1028
public: using value_type = void; 
#line 1030
using pointer = void *; 
#line 1031
using const_pointer = const void *; 
#line 1033
template< class _Other> 
#line 1034
struct rebind { 
#line 1035
using other = std::allocator< _Other> ; 
#line 1036
}; 
#line 1046 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
}; 
#pragma pack()
#line 1049 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template < class _Ty, class _Other >
[ [ nodiscard ] ] inline bool operator == ( const allocator < _Ty > &, const allocator < _Other > & ) noexcept {
    return true;
}
#line 1055
template < class _Ty, class _Other >
[ [ nodiscard ] ] bool operator != ( const allocator < _Ty > &, const allocator < _Other > & ) noexcept {
    return false;
}
#line 1068 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template< class _Alloc> using _Alloc_ptr_t = typename allocator_traits< _Alloc> ::pointer; 
#line 1071
template< class _Alloc> using _Alloc_size_t = typename allocator_traits< _Alloc> ::size_type; 
#line 1074
template < class _Alloc >
inline void _Pocca ( _Alloc & _Left, const _Alloc & _Right ) noexcept {
    if constexpr ( allocator_traits < _Alloc > :: propagate_on_container_copy_assignment :: value ) {
        _Left = _Right;
    }
}
#line 1081
template < class _Alloc >
inline void _Pocma ( _Alloc & _Left, _Alloc & _Right ) noexcept {
    if constexpr ( allocator_traits < _Alloc > :: propagate_on_container_move_assignment :: value ) {
        _Left = :: std :: move ( _Right );
    }
}
#line 1088
template < class _Alloc >
inline void _Pocs ( _Alloc & _Left, _Alloc & _Right ) noexcept {
    if constexpr ( allocator_traits < _Alloc > :: propagate_on_container_swap :: value ) {
        swap ( _Left, _Right );
    } else {
        ;
    }
}
#line 1097
template < class _Alloc >
inline void _Destroy_range ( _Alloc_ptr_t < _Alloc > _First, const _Alloc_ptr_t < _Alloc > _Last, _Alloc & _Al ) noexcept {

    using _Ty = typename _Alloc :: value_type;
    if constexpr ( ! conjunction_v < is_trivially_destructible < _Ty >, _Uses_default_destroy < _Alloc, _Ty * >> ) {
        for (; _First != _Last; ++ _First ) {
            allocator_traits < _Alloc > :: destroy ( _Al, :: std :: _Unfancy ( _First ) );
        }
    }
}
#line 1108
template < class _NoThrowFwdIt, class _NoThrowSentinel >
inline void _Destroy_range ( _NoThrowFwdIt _First, const _NoThrowSentinel _Last ) noexcept {

    if constexpr ( ! is_trivially_destructible_v < _Iter_value_t < _NoThrowFwdIt >> ) {
        for (; _First != _Last; ++ _First ) {
            :: std :: _Destroy_in_place ( * _First );
        }
    }
}
#line 1118
template < class _Size_type, class _Unsigned_type >
[ [ nodiscard ] ] constexpr _Size_type _Convert_size ( const _Unsigned_type _Len )
    noexcept ( sizeof ( _Unsigned_type ) <= sizeof ( _Size_type ) ) {

    ;
    ;

    if constexpr ( sizeof ( _Unsigned_type ) > sizeof ( _Size_type ) ) {
        if ( _Len > :: std :: _Max_limit < _Size_type > ( ) ) {
            _Xlength_error ( "size is too long for _Size_type" );
        }
    }

    return static_cast < _Size_type > ( _Len );
}
#line 1134
template < class _Alloc >
inline void _Deallocate_plain ( _Alloc & _Al, typename _Alloc :: value_type * const _Ptr ) noexcept {

    using _Alloc_traits = allocator_traits < _Alloc >;
    if constexpr ( is_same_v < _Alloc_ptr_t < _Alloc >, typename _Alloc :: value_type * > ) {
        _Alloc_traits :: deallocate ( _Al, _Ptr, 1 );
    } else {
        using _Ptr_traits = pointer_traits < _Alloc_ptr_t < _Alloc >>;
        _Alloc_traits :: deallocate ( _Al, _Ptr_traits :: pointer_to ( * _Ptr ), 1 );
    }
}
#line 1146
template < class _Alloc >
inline void _Delete_plain_internal ( _Alloc & _Al, typename _Alloc :: value_type * const _Ptr ) noexcept {

    using _Ty = typename _Alloc :: value_type;
    _Ptr -> ~ _Ty ( );
    :: std :: _Deallocate_plain ( _Al, _Ptr );
}
#line 1154
template < class _Alloc >
struct _Alloc_construct_ptr {
    using pointer = _Alloc_ptr_t < _Alloc >;
    _Alloc & _Al;
    pointer _Ptr;

    inline explicit _Alloc_construct_ptr ( _Alloc & _Al_ ) : _Al ( _Al_ ), _Ptr ( nullptr ) { }

    [ [ nodiscard ] ] inline pointer _Release ( ) noexcept {
        return :: std :: exchange ( _Ptr, nullptr );
    }

    inline void _Allocate ( ) {
        _Ptr = nullptr;
        _Ptr = _Al . allocate ( 1 );
    }

    inline ~ _Alloc_construct_ptr ( ) {
        if ( _Ptr ) {
            _Al . deallocate ( _Ptr, 1 );
        }
    }

    _Alloc_construct_ptr ( const _Alloc_construct_ptr & ) = delete;
    _Alloc_construct_ptr & operator = ( const _Alloc_construct_ptr & ) = delete;
};
#line 1181
struct _Fake_allocator { }; 
#line 1183
struct _Container_base0 { 
#line 1184
void _Orphan_all() noexcept { } 
#line 1185
void _Swap_proxy_and_iterators(_Container_base0 &) noexcept { } 
#line 1186
void _Alloc_proxy(const _Fake_allocator &) noexcept { } 
#line 1187
void _Reload_proxy(const _Fake_allocator &, const _Fake_allocator &) noexcept { } 
#line 1188
}; 
#line 1190
struct _Iterator_base0 { 
#line 1191
void _Adopt(const void *) noexcept { } 
#line 1192
const _Container_base0 *_Getcont() const noexcept { 
#line 1193
return nullptr; 
#line 1194
} 
#line 1196
static constexpr bool _Unwrap_when_unverified = true; 
#line 1197
}; 
#line 1199
struct _Container_base12; 
#line 1200
struct _Container_proxy { 
#line 1201
_Container_proxy() noexcept = default;
#line 1202
_Container_proxy(_Container_base12 *_Mycont_) noexcept : _Mycont(_Mycont_) { } 
#line 1204
const _Container_base12 *_Mycont = (nullptr); 
#line 1205
mutable _Iterator_base12 *_Myfirstiter = (nullptr); 
#line 1206
}; 
#line 1208
struct _Container_base12 { 
#line 1210
_Container_base12() noexcept = default;
#line 1212
_Container_base12(const _Container_base12 &) = delete;
#line 1213
_Container_base12 &operator=(const _Container_base12 &) = delete;
#line 1215
inline void _Orphan_all() noexcept; 
#line 1216
inline void _Swap_proxy_and_iterators(_Container_base12 &) noexcept; 
#line 1218
template < class _Alloc >
    inline void _Alloc_proxy ( _Alloc && _Al ) {
        _Container_proxy * const _New_proxy = _Unfancy ( _Al . allocate ( 1 ) );
        _Construct_in_place ( * _New_proxy, this );
        _Myproxy = _New_proxy;
        _New_proxy -> _Mycont = this;
    }
#line 1226
template < class _Alloc >
    inline void _Reload_proxy ( _Alloc && _Old_alloc, _Alloc && _New_alloc ) {

        _Container_proxy * const _New_proxy = _Unfancy ( _New_alloc . allocate ( 1 ) );
        _Construct_in_place ( * _New_proxy, this );
        _New_proxy -> _Mycont = this;
        _Delete_plain_internal ( _Old_alloc, :: std :: exchange ( _Myproxy, _New_proxy ) );
    }
#line 1235
_Container_proxy *_Myproxy = (nullptr); 
#line 1238
private: inline void _Orphan_all_unlocked_v3() noexcept; 
#line 1239
inline void _Swap_proxy_and_iterators_unlocked(_Container_base12 &) noexcept; 
#line 1241
void _Orphan_all_locked_v3() noexcept { 
#line 1242
_Lockit _Lock(3); 
#line 1243
this->_Orphan_all_unlocked_v3(); 
#line 1244
} 
#line 1246
void _Swap_proxy_and_iterators_locked(_Container_base12 &_Right) noexcept { 
#line 1247
_Lockit _Lock(3); 
#line 1248
this->_Swap_proxy_and_iterators_unlocked(_Right); 
#line 1249
} 
#line 1250
}; 
#line 1252
struct _Iterator_base12 { 
#line 1254
_Iterator_base12() noexcept = default;
#line 1256
_Iterator_base12(const _Iterator_base12 &_Right) noexcept { 
#line 1257
((*this) = _Right); 
#line 1258
} 
#line 1260
_Iterator_base12 &operator=(const _Iterator_base12 &_Right) noexcept { 
#line 1271 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
(_Myproxy) = (_Right._Myproxy); 
#line 1273 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
return *this; 
#line 1274
} 
#line 1299 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
void _Adopt(const _Container_base12 *_Parent) noexcept { 
#line 1300
if (_Parent) { 
#line 1301
(_Myproxy) = (_Parent->_Myproxy); 
#line 1302
} else { 
#line 1303
(_Myproxy) = (nullptr); 
#line 1304
}  
#line 1305
} 
#line 1308 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
const _Container_base12 *_Getcont() const noexcept { 
#line 1309
return (_Myproxy) ? (_Myproxy)->_Mycont : (nullptr); 
#line 1310
} 
#line 1312
static constexpr bool _Unwrap_when_unverified = (0 == 0); 
#line 1314
mutable _Container_proxy *_Myproxy = (nullptr); 
#line 1315
mutable _Iterator_base12 *_Mynextiter = (nullptr); 
#line 1379 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
}; 
#line 1381
inline void _Container_base12::_Orphan_all_unlocked_v3() noexcept { 
#line 1382
if (!(_Myproxy)) { 
#line 1383
return; 
#line 1384
}  
#line 1387
for (auto _Pnext = ::std::exchange((_Myproxy)->_Myfirstiter, nullptr); _Pnext; _Pnext = (_Pnext->_Mynextiter)) { 
#line 1388
(_Pnext->_Myproxy) = (nullptr); 
#line 1389
}  
#line 1390
} 
#line 1392
inline void _Container_base12::_Orphan_all() noexcept { 
#line 1403 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
} 
#line 1405
inline void _Container_base12::_Swap_proxy_and_iterators_unlocked(_Container_base12 &_Right) noexcept { 
#line 1406
_Container_proxy *_Temp = _Myproxy; 
#line 1407
(_Myproxy) = (_Right._Myproxy); 
#line 1408
(_Right._Myproxy) = _Temp; 
#line 1410
if (_Myproxy) { 
#line 1411
((_Myproxy)->_Mycont) = this; 
#line 1412
}  
#line 1414
if (_Right._Myproxy) { 
#line 1415
((_Right._Myproxy)->_Mycont) = (&_Right); 
#line 1416
}  
#line 1417
} 
#line 1419
inline void _Container_base12::_Swap_proxy_and_iterators(_Container_base12 &_Right) noexcept { 
#line 1430 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
this->_Swap_proxy_and_iterators_unlocked(_Right); 
#line 1432 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
} 
#line 1435
using _Container_base = _Container_base0; 
#line 1436
using _Iterator_base = _Iterator_base0; 
#line 1442 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
struct _Leave_proxy_unbound { 
#line 1443
explicit _Leave_proxy_unbound() = default;
#line 1444
}; 
#line 1446
struct _Fake_proxy_ptr_impl { 
#line 1447
_Fake_proxy_ptr_impl(const _Fake_proxy_ptr_impl &) = delete;
#line 1448
_Fake_proxy_ptr_impl &operator=(const _Fake_proxy_ptr_impl &) = delete;
#line 1449
_Fake_proxy_ptr_impl(const _Fake_allocator &, _Leave_proxy_unbound) noexcept { } 
#line 1450
_Fake_proxy_ptr_impl(const _Fake_allocator &, const _Container_base0 &) noexcept { } 
#line 1452
void _Bind(const _Fake_allocator &, _Container_base0 *) noexcept { } 
#line 1453
void _Release() noexcept { } 
#line 1454
}; 
#line 1456
struct _Basic_container_proxy_ptr12 { 
#line 1458
_Container_proxy *_Ptr = (nullptr); 
#line 1460
constexpr void _Release() noexcept { 
#line 1461
(_Ptr) = (nullptr); 
#line 1462
} 
#line 1465
protected: _Basic_container_proxy_ptr12() = default;
#line 1466
_Basic_container_proxy_ptr12(const _Basic_container_proxy_ptr12 &) = delete;
#line 1467
_Basic_container_proxy_ptr12(_Basic_container_proxy_ptr12 &&) = delete;
#line 1468
}; 
#line 1470
template < class _Alloc >
struct _Container_proxy_ptr12 : _Basic_container_proxy_ptr12 {

    _Alloc & _Al;

    inline _Container_proxy_ptr12 ( _Alloc & _Al_, _Leave_proxy_unbound ) : _Al ( _Al_ ) {

        _Ptr = _Unfancy ( _Al_ . allocate ( 1 ) );
        _Construct_in_place ( * _Ptr );
    }

    inline _Container_proxy_ptr12 ( _Alloc & _Al_, _Container_base12 & _Mycont ) : _Al ( _Al_ ) {

        _Ptr = _Unfancy ( _Al_ . allocate ( 1 ) );
        _Construct_in_place ( * _Ptr, :: std :: addressof ( _Mycont ) );
        _Mycont . _Myproxy = _Ptr;
    }

    inline void _Bind ( _Alloc & _Old_alloc, _Container_base12 * _Mycont ) noexcept {


        _Ptr -> _Mycont = _Mycont;
        _Delete_plain_internal ( _Old_alloc, :: std :: exchange ( _Mycont -> _Myproxy, :: std :: exchange ( _Ptr, nullptr ) ) );
    }

    inline ~ _Container_proxy_ptr12 ( ) {
        if ( _Ptr ) {
            _Delete_plain_internal ( _Al, _Ptr );
        }
    }
};
#line 1505
template< class _Alloc> using _Container_proxy_ptr = _Fake_proxy_ptr_impl; 
#line 1513 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
struct _Zero_then_variadic_args_t { 
#line 1514
explicit _Zero_then_variadic_args_t() = default;
#line 1515
}; 
#line 1517
struct _One_then_variadic_args_t { 
#line 1518
explicit _One_then_variadic_args_t() = default;
#line 1519
}; 
#line 1521
template < class _Ty1, class _Ty2, bool = is_empty_v < _Ty1 > && ! is_final_v < _Ty1 > >
class _Compressed_pair final : private _Ty1 {
public :
    _Ty2 _Myval2;

    using _Mybase = _Ty1;

    template < class ... _Other2 >
    constexpr explicit _Compressed_pair ( _Zero_then_variadic_args_t, _Other2 && ... _Val2 )
        noexcept ( conjunction_v < is_nothrow_default_constructible < _Ty1 >, is_nothrow_constructible < _Ty2, _Other2 ... >> )
        : _Ty1 ( ), _Myval2 ( :: std :: forward < _Other2 > ( _Val2 ) ... ) { }

    template < class _Other1, class ... _Other2 >
    constexpr _Compressed_pair ( _One_then_variadic_args_t, _Other1 && _Val1, _Other2 && ... _Val2 )
        noexcept ( conjunction_v < is_nothrow_constructible < _Ty1, _Other1 >, is_nothrow_constructible < _Ty2, _Other2 ... >> )
        : _Ty1 ( :: std :: forward < _Other1 > ( _Val1 ) ), _Myval2 ( :: std :: forward < _Other2 > ( _Val2 ) ... ) { }

    constexpr _Ty1 & _Get_first ( ) noexcept {
        return * this;
    }

    constexpr const _Ty1 & _Get_first ( ) const noexcept {
        return * this;
    }
};
#line 1547
template < class _Ty1, class _Ty2 >
class _Compressed_pair < _Ty1, _Ty2, false > final {
public :
    _Ty1 _Myval1;
    _Ty2 _Myval2;

    template < class ... _Other2 >
    constexpr explicit _Compressed_pair ( _Zero_then_variadic_args_t, _Other2 && ... _Val2 )
        noexcept ( conjunction_v < is_nothrow_default_constructible < _Ty1 >, is_nothrow_constructible < _Ty2, _Other2 ... >> )
        : _Myval1 ( ), _Myval2 ( :: std :: forward < _Other2 > ( _Val2 ) ... ) { }

    template < class _Other1, class ... _Other2 >
    constexpr _Compressed_pair ( _One_then_variadic_args_t, _Other1 && _Val1, _Other2 && ... _Val2 )
        noexcept ( conjunction_v < is_nothrow_constructible < _Ty1, _Other1 >, is_nothrow_constructible < _Ty2, _Other2 ... >> )
        : _Myval1 ( :: std :: forward < _Other1 > ( _Val1 ) ), _Myval2 ( :: std :: forward < _Other2 > ( _Val2 ) ... ) { }

    constexpr _Ty1 & _Get_first ( ) noexcept {
        return _Myval1;
    }

    constexpr const _Ty1 & _Get_first ( ) const noexcept {
        return _Myval1;
    }
};
#line 1572
template < class _Ty >
pair < _Ty *, ptrdiff_t > _Get_temporary_buffer ( ptrdiff_t _Count ) noexcept {
    if ( static_cast < size_t > ( _Count ) <= static_cast < size_t > ( - 1 ) / sizeof ( _Ty ) ) {
        for (; 0 < _Count; _Count /= 2 ) {
            const auto _Size = static_cast < size_t > ( _Count ) * sizeof ( _Ty );
            void * _Pbuf;





            {
                _Pbuf = :: operator new ( _Size, nothrow );
            }

            if ( _Pbuf ) {
                return { static_cast < _Ty * > ( _Pbuf ), _Count };
            }
        }
    }

    return { nullptr, 0 };
}
#line 1596
template < class _Ty >
void _Return_temporary_buffer ( _Ty * const _Pbuf ) noexcept {





    {
        :: operator delete ( _Pbuf );
    }
}
#line 1608
template < class _Ty, class _InIt >
void _Construct_in_place_by_deref ( _Ty & _Val, _InIt & _Iter )
    noexcept ( noexcept ( :: new ( static_cast < void * > ( :: std :: addressof ( _Val ) ) ) _Ty ( * _Iter ) ) ) {
    :: new ( static_cast < void * > ( :: std :: addressof ( _Val ) ) ) _Ty ( * _Iter );
}
#line 1614
template < class _NoThrowFwdIt >
struct [ [ nodiscard ] ] _Uninitialized_backout {

    _NoThrowFwdIt _First;
    _NoThrowFwdIt _Last;

    constexpr explicit _Uninitialized_backout ( _NoThrowFwdIt _Dest ) : _First ( _Dest ), _Last ( _Dest ) { }

    constexpr _Uninitialized_backout ( _NoThrowFwdIt _First_, _NoThrowFwdIt _Last_ ) : _First ( _First_ ), _Last ( _Last_ ) { }

    _Uninitialized_backout ( const _Uninitialized_backout & ) = delete;
    _Uninitialized_backout & operator = ( const _Uninitialized_backout & ) = delete;

    inline ~ _Uninitialized_backout ( ) {
        :: std :: _Destroy_range ( _First, _Last );
    }

    template < class ... _Types >
    inline void _Emplace_back ( _Types && ... _Vals ) {

        :: std :: _Construct_in_place ( * _Last, :: std :: forward < _Types > ( _Vals ) ... );
        ++ _Last;
    }

    template < class _InIt >
    void _Emplace_back_deref ( _InIt & _Iter ) {

        :: std :: _Construct_in_place_by_deref ( * _Last, _Iter );
        ++ _Last;
    }

    template < class _InIt >
    void _Emplace_back_deref_move ( _InIt & _Iter ) {


        if constexpr ( is_lvalue_reference_v < decltype ( * _Iter ) > ) {
            :: std :: _Construct_in_place ( * _Last, :: std :: move ( * _Iter ) );
        } else {
            :: std :: _Construct_in_place_by_deref ( * _Last, _Iter );
        }
        ++ _Last;
    }

    constexpr _NoThrowFwdIt _Release ( ) {
        _First = _Last;
        return _Last;
    }
};
#line 1663
template < class _InIt, class _NoThrowFwdIt >
_NoThrowFwdIt _Uninitialized_move_unchecked ( _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest ) {

    if constexpr ( _Iter_move_cat < _InIt, _NoThrowFwdIt > :: _Bitcopy_constructible ) {



        {
            return :: std :: _Copy_memmove ( _First, _Last, _Dest );
        }
    }
    _Uninitialized_backout < _NoThrowFwdIt > _Backout { _Dest };
    for (; _First != _Last; ++ _First ) {
        _Backout . _Emplace_back_deref_move ( _First );
    }

    return _Backout . _Release ( );
}
#line 1826 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template < class _Alloc >
class [ [ nodiscard ] ] _Uninitialized_backout_al {

private :
    using pointer = _Alloc_ptr_t < _Alloc >;

public :
    inline _Uninitialized_backout_al ( pointer _Dest, _Alloc & _Al_ ) : _First ( _Dest ), _Last ( _Dest ), _Al ( _Al_ ) { }

    _Uninitialized_backout_al ( const _Uninitialized_backout_al & ) = delete;
    _Uninitialized_backout_al & operator = ( const _Uninitialized_backout_al & ) = delete;

    inline ~ _Uninitialized_backout_al ( ) {
        :: std :: _Destroy_range ( _First, _Last, _Al );
    }

    template < class ... _Types >
    inline void _Emplace_back ( _Types && ... _Vals ) {
        allocator_traits < _Alloc > :: construct ( _Al, :: std :: _Unfancy ( _Last ), :: std :: forward < _Types > ( _Vals ) ... );
        ++ _Last;
    }

    constexpr pointer _Release ( ) {
        _First = _Last;
        return _Last;
    }

private :
    pointer _First;
    pointer _Last;
    _Alloc & _Al;
};
#line 1859
template < class _InIt, class _Se, class _Alloc >
inline _Alloc_ptr_t < _Alloc > _Uninitialized_copy (
    _InIt _First, _Se _Last, _Alloc_ptr_t < _Alloc > _Dest, _Alloc & _Al ) {


    using _Ptrval = typename _Alloc :: value_type *;











    auto _UFirst = :: std :: _Get_unwrapped ( :: std :: move ( _First ) );
    auto _ULast = :: std :: _Get_unwrapped ( :: std :: move ( _Last ) );


    constexpr bool _Can_memmove = _Sent_copy_cat < decltype ( _UFirst ), decltype ( _ULast ), _Ptrval > :: _Bitcopy_constructible
                               && _Uses_default_construct < _Alloc, _Ptrval, decltype ( * _UFirst ) > :: value;

    if constexpr ( _Can_memmove ) {



        {
            if constexpr ( is_same_v < decltype ( _UFirst ), decltype ( _ULast ) > ) {
                :: std :: _Copy_memmove ( :: std :: _To_address ( _UFirst ), :: std :: _To_address ( _ULast ), :: std :: _Unfancy ( _Dest ) );
                _Dest += _ULast - _UFirst;
            } else {
                const auto _Count = static_cast < size_t > ( _ULast - _UFirst );
                :: std :: _Copy_memmove_n ( :: std :: _To_address ( _UFirst ), _Count, :: std :: _Unfancy ( _Dest ) );
                _Dest += _Count;
            }
            return _Dest;
        }
    }

    _Uninitialized_backout_al < _Alloc > _Backout { _Dest, _Al };
    for (; _UFirst != _ULast; ++ _UFirst ) {
        _Backout . _Emplace_back ( * _UFirst );
    }

    return _Backout . _Release ( );
}
#line 1908 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template < class _InIt, class _Alloc >
inline _Alloc_ptr_t < _Alloc > _Uninitialized_copy_n (
    _InIt _First, size_t _Count, _Alloc_ptr_t < _Alloc > _Dest, _Alloc & _Al ) {


    using _Ptrval = typename _Alloc :: value_type *;




    auto _UFirst = :: std :: _Get_unwrapped ( :: std :: move ( _First ) );


    constexpr bool _Can_memmove =
        conjunction_v < bool_constant < _Iter_copy_cat < decltype ( _UFirst ), _Ptrval > :: _Bitcopy_constructible >,
            _Uses_default_construct < _Alloc, _Ptrval, decltype ( * _UFirst ) >>;

    if constexpr ( _Can_memmove ) {



        {
            :: std :: _Copy_memmove_n ( _UFirst, _Count, :: std :: _Unfancy ( _Dest ) );
            _Dest += _Count;
            return _Dest;
        }
    }

    _Uninitialized_backout_al < _Alloc > _Backout { _Dest, _Al };
    for (; _Count != 0; ++ _UFirst, ( void ) -- _Count ) {
        _Backout . _Emplace_back ( * _UFirst );
    }

    return _Backout . _Release ( );
}
#line 1944 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template < class _InIt, class _NoThrowFwdIt >
_NoThrowFwdIt _Uninitialized_copy_unchecked ( _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest ) {

    if constexpr ( _Iter_copy_cat < _InIt, _NoThrowFwdIt > :: _Bitcopy_constructible ) {



        {
            return :: std :: _Copy_memmove ( _First, _Last, _Dest );
        }
    }

    _Uninitialized_backout < _NoThrowFwdIt > _Backout { _Dest };
    for (; _First != _Last; ++ _First ) {
        _Backout . _Emplace_back_deref ( _First );
    }

    return _Backout . _Release ( );
}
#line 1964 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template < class _InIt, class _NoThrowFwdIt >
_NoThrowFwdIt uninitialized_copy ( const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest ) {

    :: std :: _Adl_verify_range ( _First, _Last );
    auto _UFirst = :: std :: _Get_unwrapped ( _First );
    const auto _ULast = :: std :: _Get_unwrapped ( _Last );
    auto _UDest = :: std :: _Get_unwrapped_n ( _Dest, :: std :: _Idl_distance < _InIt > ( _UFirst, _ULast ) );
    :: std :: _Seek_wrapped ( _Dest, :: std :: _Uninitialized_copy_unchecked ( _UFirst, _ULast, _UDest ) );
    return _Dest;
}
#line 1975
template < class _InIt, class _Alloc >
inline _Alloc_ptr_t < _Alloc > _Uninitialized_move (
    const _InIt _First, const _InIt _Last, _Alloc_ptr_t < _Alloc > _Dest, _Alloc & _Al ) {





    using _Ptrval = typename _Alloc :: value_type *;
    auto _UFirst = :: std :: _Get_unwrapped ( _First );
    const auto _ULast = :: std :: _Get_unwrapped ( _Last );
    if constexpr ( conjunction_v < bool_constant < _Iter_move_cat < decltype ( _UFirst ), _Ptrval > :: _Bitcopy_constructible >,
                      _Uses_default_construct < _Alloc, _Ptrval, decltype ( :: std :: move ( * _UFirst ) ) >> ) {



        {
            :: std :: _Copy_memmove ( _UFirst, _ULast, :: std :: _Unfancy ( _Dest ) );
            return _Dest + ( _ULast - _UFirst );
        }
    }

    _Uninitialized_backout_al < _Alloc > _Backout { _Dest, _Al };
    for (; _UFirst != _ULast; ++ _UFirst ) {
        _Backout . _Emplace_back ( :: std :: move ( * _UFirst ) );
    }

    return _Backout . _Release ( );
}
#line 2005 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template < class _Alloc >
inline _Alloc_ptr_t < _Alloc > _Uninitialized_fill_n (
    _Alloc_ptr_t < _Alloc > _First, _Alloc_size_t < _Alloc > _Count, const typename _Alloc :: value_type & _Val, _Alloc & _Al ) {

    using _Ty = typename _Alloc :: value_type;
    if constexpr ( _Fill_memset_is_safe < _Ty *, _Ty > && _Uses_default_construct < _Alloc, _Ty *, _Ty > :: value ) {



        {
            _Fill_memset ( _Unfancy ( _First ), _Val, static_cast < size_t > ( _Count ) );
            return _First + _Count;
        }
    } else if constexpr ( _Fill_zero_memset_is_safe < _Ty *, _Ty > && _Uses_default_construct < _Alloc, _Ty *, _Ty > :: value ) {



        {
            if ( _Is_all_bits_zero ( _Val ) ) {
                _Fill_zero_memset ( _Unfancy ( _First ), static_cast < size_t > ( _Count ) );
                return _First + _Count;
            }
        }
    }

    _Uninitialized_backout_al < _Alloc > _Backout { _First, _Al };
    for (; 0 < _Count; -- _Count ) {
        _Backout . _Emplace_back ( _Val );
    }

    return _Backout . _Release ( );
}
#line 2038 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template < class _NoThrowFwdIt, class _Tval >
void uninitialized_fill ( const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval & _Val ) {

    :: std :: _Adl_verify_range ( _First, _Last );
    auto _UFirst = :: std :: _Get_unwrapped ( _First );
    const auto _ULast = :: std :: _Get_unwrapped ( _Last );
    if constexpr ( _Fill_memset_is_safe < _Unwrapped_t < const _NoThrowFwdIt & >, _Tval > ) {
        :: std :: _Fill_memset ( _UFirst, _Val, static_cast < size_t > ( _ULast - _UFirst ) );
    } else {
        if constexpr ( _Fill_zero_memset_is_safe < _Unwrapped_t < const _NoThrowFwdIt & >, _Tval > ) {
            if ( :: std :: _Is_all_bits_zero ( _Val ) ) {
                :: std :: _Fill_zero_memset ( _UFirst, static_cast < size_t > ( _ULast - _UFirst ) );
                return;
            }
        }

        _Uninitialized_backout < _Unwrapped_t < const _NoThrowFwdIt & >> _Backout { _UFirst };
        while ( _Backout . _Last != _ULast ) {
            _Backout . _Emplace_back ( _Val );
        }

        _Backout . _Release ( );
    }
}
#line 2063
template< class _NoThrowFwdIt> constexpr bool 
#line 2064
_Use_memset_value_construct_v = conjunction_v< bool_constant< _Iterator_is_contiguous< _NoThrowFwdIt> > , is_scalar< _Iter_value_t< _NoThrowFwdIt> > , negation< is_volatile< remove_reference_t< _Iter_ref_t< _NoThrowFwdIt> > > > , negation< is_member_pointer< _Iter_value_t< _NoThrowFwdIt> > > > ; 
#line 2068
template < class _Ptr >
_Ptr _Zero_range ( const _Ptr _First, const _Ptr _Last ) {
    char * const _First_ch = reinterpret_cast < char * > ( :: std :: _To_address ( _First ) );
    char * const _Last_ch = reinterpret_cast < char * > ( :: std :: _To_address ( _Last ) );
    :: memset ( _First_ch, 0, static_cast < size_t > ( _Last_ch - _First_ch ) );
    return _Last;
}
#line 2076
template < class _Alloc >
inline _Alloc_ptr_t < _Alloc > _Uninitialized_value_construct_n (
    _Alloc_ptr_t < _Alloc > _First, _Alloc_size_t < _Alloc > _Count, _Alloc & _Al ) {

    using _Ptrty = typename _Alloc :: value_type *;
    if constexpr ( _Use_memset_value_construct_v < _Ptrty > && _Uses_default_construct < _Alloc, _Ptrty > :: value ) {



        {
            auto _PFirst = _Unfancy ( _First );
            _Zero_range ( _PFirst, _PFirst + _Count );
            return _First + _Count;
        }
    }

    _Uninitialized_backout_al < _Alloc > _Backout { _First, _Al };
    for (; 0 < _Count; -- _Count ) {
        _Backout . _Emplace_back ( );
    }

    return _Backout . _Release ( );
}
#line 2100 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template < class _NoThrowFwdIt, class _Diff >
_NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1 ( _NoThrowFwdIt _UFirst, _Diff _Count ) {

    ;
    if constexpr ( _Use_memset_value_construct_v < _NoThrowFwdIt > ) {
        return :: std :: _Zero_range ( _UFirst, _UFirst + _Count );
    } else {
        _Uninitialized_backout < _NoThrowFwdIt > _Backout { _UFirst };
        for (; 0 < _Count; -- _Count ) {
            _Backout . _Emplace_back ( );
        }

        return _Backout . _Release ( );
    }
}
#line 2117
template < class _Ty >
 [ [ nodiscard ] ] pair < _Ty *, ptrdiff_t > get_temporary_buffer ( ptrdiff_t _Count ) noexcept {
    return _Get_temporary_buffer < _Ty > ( _Count );
}
#line 2122
template < class _Ty >
 void return_temporary_buffer ( _Ty * _Pbuf ) {
    _Return_temporary_buffer ( _Pbuf );
}
#line 2132 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template< class _Ty> using _Remove_const_ref_t = remove_const_t< remove_reference_t< _Ty> > ; 
#line 2136
template< class _Key, class ..._Args> 
#line 2137
struct _In_place_key_extract_set_impl { 
#line 2139
static constexpr bool _Extractable = false; 
#line 2140
}; 
#line 2142
template < class _Key >
struct _In_place_key_extract_set_impl < _Key, _Key > {

    static constexpr bool _Extractable = true;
    static const _Key & _Extract ( const _Key & _Val ) noexcept {
        return _Val;
    }
};
#line 2151
template< class ..._Valtys> using _In_place_key_extract_set = _In_place_key_extract_set_impl< _Remove_const_ref_t< _Valtys> ...> ; 
#line 2155
template< class _Key, class ..._Args> 
#line 2156
struct _In_place_key_extract_map_impl { 
#line 2158
static constexpr bool _Extractable = false; 
#line 2159
}; 
#line 2161
template < class _Key, class _Second >
struct _In_place_key_extract_map_impl < _Key, _Key, _Second > {

    static constexpr bool _Extractable = true;
    static const _Key & _Extract ( const _Key & _Val, const _Second & ) noexcept {
        return _Val;
    }
};
#line 2170
template < class _Key, class _First, class _Second >
struct _In_place_key_extract_map_impl < _Key, pair < _First, _Second > > {

    static constexpr bool _Extractable = is_same_v < _Key, _Remove_const_ref_t < _First >>;
    static const _Key & _Extract ( const pair < _First, _Second > & _Val ) noexcept {
        return _Val . first;
    }
};
#line 2200 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template < class _Key, class _First, class ... _RestTypes >
struct _In_place_key_extract_map_impl < _Key, piecewise_construct_t, tuple < _First >, tuple < _RestTypes ... > > {


    static constexpr bool _Extractable = is_same_v < _Key, _Remove_const_ref_t < _First >>;
    static const _Key & _Extract (
        const piecewise_construct_t &, const tuple < _First > & _Tup_val, const tuple < _RestTypes ... > & ) noexcept {
        return :: std :: get < 0 > ( _Tup_val );
    }
};
#line 2211
template< class ..._Valtys> using _In_place_key_extract_map = _In_place_key_extract_map_impl< _Remove_const_ref_t< _Valtys> ...> ; 
#line 2214
#pragma warning(push)
#pragma warning(disable : 4624)
template< class _Ty> 
#line 2217
struct _Wrap { 
#line 2218
_Ty _Value; 
#line 2219
}; 
#pragma warning(pop)
#line 2222
template < class _Alloc >
struct _Alloc_temporary2 {
    using value_type = typename _Alloc :: value_type;
    using _Traits = allocator_traits < _Alloc >;

    _Alloc & _Al;














    union {
        value_type _Value;
    };

    [ [ nodiscard ] ] inline value_type & _Get_value ( ) noexcept {
        return _Value;
    }

    [ [ nodiscard ] ] inline const value_type & _Get_value ( ) const noexcept {
        return _Value;
    }


    template < class ... _Args >
    inline explicit _Alloc_temporary2 ( _Alloc & _Al_, _Args && ... _Vals )
        noexcept ( noexcept ( _Traits :: construct ( _Al_, :: std :: addressof ( _Get_value ( ) ), :: std :: forward < _Args > ( _Vals ) ... ) ) )
        : _Al ( _Al_ ) {
        _Traits :: construct ( _Al, :: std :: addressof ( _Get_value ( ) ), :: std :: forward < _Args > ( _Vals ) ... );
    }

    _Alloc_temporary2 ( const _Alloc_temporary2 & ) = delete;
    _Alloc_temporary2 & operator = ( const _Alloc_temporary2 & ) = delete;

    inline ~ _Alloc_temporary2 ( ) {
        _Traits :: destroy ( _Al, :: std :: addressof ( _Get_value ( ) ) );
    }
};
#line 2270 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template < class _Alloc >
[ [ nodiscard ] ] constexpr bool _Allocators_equal ( const _Alloc & _Lhs, const _Alloc & _Rhs ) noexcept {
    if constexpr ( allocator_traits < _Alloc > :: is_always_equal :: value ) {
        return true;
    } else {
        return _Lhs == _Rhs;
    }
}
#line 2292 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template < class _Alloc >
[ [ nodiscard ( "This function allocates memory and returns a raw pointer. Discarding the return value will cause a memory leak." ) ] ] inline typename allocator_traits < _Alloc > :: pointer _Allocate_at_least_helper (
    _Alloc & _Al, typename allocator_traits < _Alloc > :: size_type & _Count ) {







    {
        return _Al . allocate ( _Count );
    }
}
#line 2307 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template < class _FwdIt, class _Ty >
[ [ nodiscard ( "The \'remove\' and \'remove_if\' algorithms return the iterator past the last element that should be kept. You need to call cont" "ainer.erase(result, container.end()) afterwards. In C++20, \'std::erase\' and \'std::erase_if\' are simpler replacements for the" "se two steps." ) ] ] inline _FwdIt remove ( _FwdIt _First, const _FwdIt _Last, const _Ty & _Val ) {

    :: std :: _Adl_verify_range ( _First, _Last );
    auto _UFirst = :: std :: _Get_unwrapped ( _First );
    const auto _ULast = :: std :: _Get_unwrapped ( _Last );
    _UFirst = :: std :: _Find_unchecked ( _UFirst, _ULast, _Val );
    auto _UNext = _UFirst;
    if ( _UFirst != _ULast ) {

        if constexpr ( _Vector_alg_in_find_is_safe < decltype ( _UFirst ), _Ty > ) {



            {
                const auto _First_ptr = :: std :: _To_address ( _UFirst );
                const auto _Result = :: std :: _Remove_vectorized ( _First_ptr, :: std :: _To_address ( _ULast ), _Val );

                if constexpr ( is_pointer_v < decltype ( _UNext ) > ) {
                    _UNext = _Result;
                } else {
                    _UNext += _Result - _First_ptr;
                }

                :: std :: _Seek_wrapped ( _First, _UNext );
                return _First;
            }
        }


        while ( ++ _UFirst != _ULast ) {
            if ( ! ( * _UFirst == _Val ) ) {
                * _UNext = :: std :: move ( * _UFirst );
                ++ _UNext;
            }
        }
    }

    :: std :: _Seek_wrapped ( _First, _UNext );
    return _First;
}
#line 2349 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template < class _FwdIt, class _Pr >
[ [ nodiscard ( "The \'remove\' and \'remove_if\' algorithms return the iterator past the last element that should be kept. You need to call cont" "ainer.erase(result, container.end()) afterwards. In C++20, \'std::erase\' and \'std::erase_if\' are simpler replacements for the" "se two steps." ) ] ] inline _FwdIt remove_if ( _FwdIt _First, const _FwdIt _Last, _Pr _Pred ) {

    :: std :: _Adl_verify_range ( _First, _Last );
    auto _UFirst = :: std :: _Get_unwrapped ( _First );
    const auto _ULast = :: std :: _Get_unwrapped ( _Last );
    _UFirst = :: std :: find_if ( _UFirst, _ULast, :: std :: _Pass_fn ( _Pred ) );
    auto _UNext = _UFirst;
    if ( _UFirst != _ULast ) {
        while ( ++ _UFirst != _ULast ) {
            if ( ! _Pred ( * _UFirst ) ) {
                * _UNext = :: std :: move ( * _UFirst );
                ++ _UNext;
            }
        }
    }

    :: std :: _Seek_wrapped ( _First, _UNext );
    return _First;
}
#line 2370
template < class _Container, class _Uty >
inline typename _Container :: size_type _Erase_remove ( _Container & _Cont, const _Uty & _Val ) {

    auto _First = _Cont . begin ( );
    const auto _Last = _Cont . end ( );
    const auto _Old_size = _Cont . size ( );
    :: std :: _Seek_wrapped ( _First, :: std :: remove ( :: std :: _Get_unwrapped ( _First ), :: std :: _Get_unwrapped ( _Last ), _Val ) );
    _Cont . erase ( _First, _Last );
    return _Old_size - _Cont . size ( );
}
#line 2381
template < class _Container, class _Pr >
inline typename _Container :: size_type _Erase_remove_if ( _Container & _Cont, _Pr _Pred ) {

    auto _First = _Cont . begin ( );
    const auto _Last = _Cont . end ( );
    const auto _Old_size = _Cont . size ( );
    :: std :: _Seek_wrapped ( _First, :: std :: remove_if ( :: std :: _Get_unwrapped ( _First ), :: std :: _Get_unwrapped ( _Last ), _Pred ) );
    _Cont . erase ( _First, _Last );
    return _Old_size - _Cont . size ( );
}
#line 2392
template < class _Container, class _Pr >
typename _Container :: size_type _Erase_nodes_if ( _Container & _Cont, _Pr _Pred ) {

    auto _First = _Cont . begin ( );
    const auto _Last = _Cont . end ( );
    const auto _Old_size = _Cont . size ( );
    while ( _First != _Last ) {
        if ( _Pred ( * _First ) ) {
            _First = _Cont . erase ( _First );
        } else {
            ++ _First;
        }
    }
    return _Old_size - _Cont . size ( );
}
#line 2408
template< class _Ty1, class _Ty2> void _Deduce_as_pair(const pair< _Ty1, _Ty2>  &); 
#line 2411
template< class _Ty, class  = void> constexpr bool 
#line 2412
_Is_deducible_as_pair = false; 
#line 2414
template< class _Ty> constexpr bool 
#line 2415
_Is_deducible_as_pair< _Ty, decltype(std::_Deduce_as_pair(std::declval< _Ty> ()))>  = true; 
#line 2417
template< class _Ty> constexpr bool 
#line 2418
_Is_cv_pair = _Is_specialization_v< remove_cv_t< _Ty> , pair> ; 
#line 2420
template< class _Ty> const _Ty &_Normally_bind(_Identity_t< const _Ty &> ); 
#line 2423
template< class _Ty> _Ty &&_Normally_bind(_Identity_t< _Ty &&> ); 
#line 2426
template< class _Ty, class _Uty> using _Normally_bound_ref = decltype(std::_Normally_bind< _Ty> (std::declval< _Uty> ())); 
#line 2429
template< class _Ty, class _Uty, class  = void> constexpr bool 
#line 2430
_Is_normally_bindable = false; 
#line 2432
template< class _Ty, class _Uty> constexpr bool 
#line 2433
_Is_normally_bindable< _Ty, _Uty, void_t< _Normally_bound_ref< _Ty, _Uty> > >  = true; 
#line 2661 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template < class _Ty,
    bool = is_empty_v < _Ty > && ! is_final_v < _Ty > >
class _Ebco_base : private _Ty {
private :
    using _Mybase = _Ty;

protected :
    template < class _Other, enable_if_t < ! is_same_v < _Remove_cvref_t < _Other >, _Ebco_base >, int > = 0 >
    constexpr explicit _Ebco_base ( _Other && _Val ) noexcept ( is_nothrow_constructible_v < _Ty, _Other > )
        : _Ty ( :: std :: forward < _Other > ( _Val ) ) { }

    constexpr _Ty & _Get_val ( ) noexcept {
        return * this;
    }

    constexpr const _Ty & _Get_val ( ) const noexcept {
        return * this;
    }
};
#line 2681
template < class _Ty >
class _Ebco_base < _Ty, false > {
private :
    _Ty _Myval;

protected :
    template < class _Other, enable_if_t < ! is_same_v < _Remove_cvref_t < _Other >, _Ebco_base >, int > = 0 >
    constexpr explicit _Ebco_base ( _Other && _Val ) noexcept ( is_nothrow_constructible_v < _Ty, _Other > )
        : _Myval ( :: std :: forward < _Other > ( _Val ) ) { }

    constexpr _Ty & _Get_val ( ) noexcept {
        return _Myval;
    }

    constexpr const _Ty & _Get_val ( ) const noexcept {
        return _Myval;
    }
};
#line 2700
inline void *align(size_t _Bound, size_t _Size, void *&_Ptr, size_t &_Space) noexcept { 
#line 2702
size_t _Off = static_cast< size_t>((reinterpret_cast< uintptr_t>(_Ptr)) & (_Bound - (1))); 
#line 2703
if (_Off != (0)) { 
#line 2704
_Off = (_Bound - _Off); 
#line 2705
}  
#line 2707
if ((_Space < _Off) || ((_Space - _Off) < _Size)) { 
#line 2708
return nullptr; 
#line 2709
}  
#line 2712
_Ptr = ((static_cast< char *>(_Ptr)) + _Off); 
#line 2713
_Space -= _Off; 
#line 2714
return _Ptr; 
#line 2715
} 
#line 2717
template< class _Ty, class  = void> constexpr bool 
#line 2718
_Is_transparent_v = false; 
#line 2720
template< class _Ty> constexpr bool 
#line 2721
_Is_transparent_v< _Ty, void_t< typename _Ty::is_transparent> >  = true; 
#line 2723
template< class _Ty> 
#line 2724
struct _Is_transparent : public bool_constant< _Is_transparent_v< _Ty, void> >  { }; 
#line 2753 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
template < class _Elem, class _UTy >
[ [ nodiscard ] ] _Elem * _UIntegral_to_buff ( _Elem * _RNext, _UTy _UVal ) {

    static_assert ( is_unsigned_v < _UTy >, "_UTy must be unsigned" );


    auto _UVal_trunc = _UVal;


















    do {
        * -- _RNext = static_cast < _Elem > ( '0' + _UVal_trunc % 10 );
        _UVal_trunc /= 10;
    } while ( _UVal_trunc != 0 );
    return _RNext;
}
#line 2784 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
}
#line 2806 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
#pragma warning(pop)
#pragma pack ( pop )
#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xstring"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 26
namespace std { 
#line 27
template < class _Mystr >
class _String_const_iterator : public _Iterator_base {
public :



    using iterator_category = random_access_iterator_tag;
    using value_type = typename _Mystr :: value_type;
    using difference_type = typename _Mystr :: difference_type;
    using pointer = typename _Mystr :: const_pointer;
    using reference = const value_type &;

    inline _String_const_iterator ( ) noexcept : _Ptr ( ) { }

    inline _String_const_iterator ( pointer _Parg, const _Container_base * _Pstring ) noexcept : _Ptr ( _Parg ) {
        this -> _Adopt ( _Pstring );
    }

    [ [ nodiscard ] ] inline reference operator * ( ) const noexcept {











        ;
        return * _Ptr;
    }

    [ [ nodiscard ] ] inline pointer operator -> ( ) const noexcept {
        return pointer_traits < pointer > :: pointer_to ( * * this );
    }

    inline _String_const_iterator & operator ++ ( ) noexcept {








        ++ _Ptr;
        return * this;
    }

    inline _String_const_iterator operator ++ ( int ) noexcept {
        _String_const_iterator _Tmp = * this;
        ++ * this;
        return _Tmp;
    }

    inline _String_const_iterator & operator -- ( ) noexcept {








        -- _Ptr;
        return * this;
    }

    inline _String_const_iterator operator -- ( int ) noexcept {
        _String_const_iterator _Tmp = * this;
        -- * this;
        return _Tmp;
    }

    inline void _Verify_offset ( const difference_type _Off ) const noexcept {






















        ( void ) _Off;

    }

    inline _String_const_iterator & operator += ( const difference_type _Off ) noexcept {



        _Ptr += _Off;
        return * this;
    }

    [ [ nodiscard ] ] inline _String_const_iterator operator + ( const difference_type _Off ) const noexcept {
        _String_const_iterator _Tmp = * this;
        _Tmp += _Off;
        return _Tmp;
    }

    [ [ nodiscard ] ] friend inline _String_const_iterator operator + (
        const difference_type _Off, _String_const_iterator _Next ) noexcept {
        _Next += _Off;
        return _Next;
    }

    inline _String_const_iterator & operator -= ( const difference_type _Off ) noexcept {
        return * this += - _Off;
    }

    [ [ nodiscard ] ] inline _String_const_iterator operator - ( const difference_type _Off ) const noexcept {
        _String_const_iterator _Tmp = * this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [ [ nodiscard ] ] inline difference_type operator - ( const _String_const_iterator & _Right ) const noexcept {
        _Compat ( _Right );
        return static_cast < difference_type > ( _Ptr - _Right . _Ptr );
    }

    [ [ nodiscard ] ] inline reference operator [ ] ( const difference_type _Off ) const noexcept {
        return * ( * this + _Off );
    }

    [ [ nodiscard ] ] inline bool operator == ( const _String_const_iterator & _Right ) const noexcept {
        _Compat ( _Right );
        return _Ptr == _Right . _Ptr;
    }







    [ [ nodiscard ] ] bool operator != ( const _String_const_iterator & _Right ) const noexcept {
        return ! ( * this == _Right );
    }

    [ [ nodiscard ] ] bool operator < ( const _String_const_iterator & _Right ) const noexcept {
        _Compat ( _Right );
        return _Ptr < _Right . _Ptr;
    }

    [ [ nodiscard ] ] bool operator > ( const _String_const_iterator & _Right ) const noexcept {
        return _Right < * this;
    }

    [ [ nodiscard ] ] bool operator <= ( const _String_const_iterator & _Right ) const noexcept {
        return ! ( _Right < * this );
    }

    [ [ nodiscard ] ] bool operator >= ( const _String_const_iterator & _Right ) const noexcept {
        return ! ( * this < _Right );
    }


    inline void _Compat ( const _String_const_iterator & _Right ) const noexcept {





        ( void ) _Right;

    }









    using _Prevent_inheriting_unwrap = _String_const_iterator;

    [ [ nodiscard ] ] inline const value_type * _Unwrapped ( ) const noexcept {
        return :: std :: _Unfancy_maybe_null ( _Ptr );
    }

    inline void _Seek_to ( const value_type * _It ) noexcept {
        _Ptr = :: std :: _Refancy_maybe_null < pointer > ( const_cast < value_type * > ( _It ) );
    }

    pointer _Ptr;
};
#line 264 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xstring"
template < class _Mystr >
class _String_iterator : public _String_const_iterator < _Mystr > {
public :
    using _Mybase = _String_const_iterator < _Mystr >;




    using iterator_category = random_access_iterator_tag;
    using value_type = typename _Mystr :: value_type;
    using difference_type = typename _Mystr :: difference_type;
    using pointer = typename _Mystr :: pointer;
    using reference = value_type &;

    using _Mybase :: _Mybase;

    [ [ nodiscard ] ] inline reference operator * ( ) const noexcept {
        return const_cast < reference > ( _Mybase :: operator * ( ) );
    }

    [ [ nodiscard ] ] inline pointer operator -> ( ) const noexcept {
        return pointer_traits < pointer > :: pointer_to ( * * this );
    }

    inline _String_iterator & operator ++ ( ) noexcept {
        _Mybase :: operator ++ ( );
        return * this;
    }

    inline _String_iterator operator ++ ( int ) noexcept {
        _String_iterator _Tmp = * this;
        _Mybase :: operator ++ ( );
        return _Tmp;
    }

    inline _String_iterator & operator -- ( ) noexcept {
        _Mybase :: operator -- ( );
        return * this;
    }

    inline _String_iterator operator -- ( int ) noexcept {
        _String_iterator _Tmp = * this;
        _Mybase :: operator -- ( );
        return _Tmp;
    }

    inline _String_iterator & operator += ( const difference_type _Off ) noexcept {
        _Mybase :: operator += ( _Off );
        return * this;
    }

    [ [ nodiscard ] ] inline _String_iterator operator + ( const difference_type _Off ) const noexcept {
        _String_iterator _Tmp = * this;
        _Tmp += _Off;
        return _Tmp;
    }

    [ [ nodiscard ] ] friend inline _String_iterator operator + (
        const difference_type _Off, _String_iterator _Next ) noexcept {
        _Next += _Off;
        return _Next;
    }

    inline _String_iterator & operator -= ( const difference_type _Off ) noexcept {
        _Mybase :: operator -= ( _Off );
        return * this;
    }

    using _Mybase :: operator -;

    [ [ nodiscard ] ] inline _String_iterator operator - ( const difference_type _Off ) const noexcept {
        _String_iterator _Tmp = * this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [ [ nodiscard ] ] inline reference operator [ ] ( const difference_type _Off ) const noexcept {
        return const_cast < reference > ( _Mybase :: operator [ ] ( _Off ) );
    }

    using _Prevent_inheriting_unwrap = _String_iterator;

    [ [ nodiscard ] ] inline value_type * _Unwrapped ( ) const noexcept {
        return const_cast < value_type * > ( :: std :: _Unfancy_maybe_null ( this -> _Ptr ) );
    }
};
#line 382 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xstring"
template< class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer> 
#line 383
struct _String_iter_types { 
#line 384
using value_type = _Value_type; 
#line 385
using size_type = _Size_type; 
#line 386
using difference_type = _Difference_type; 
#line 387
using pointer = _Pointer; 
#line 388
using const_pointer = _Const_pointer; 
#line 389
}; 
#line 391
template < class _Val_types >
class _String_val : public _Container_base {
public :
    using value_type = typename _Val_types :: value_type;
    using size_type = typename _Val_types :: size_type;
    using difference_type = typename _Val_types :: difference_type;
    using pointer = typename _Val_types :: pointer;
    using const_pointer = typename _Val_types :: const_pointer;
    using reference = value_type &;
    using const_reference = const value_type &;

    inline _String_val ( ) noexcept : _Bx ( ) { }





















    static constexpr size_type _BUF_SIZE = 16 / sizeof ( value_type ) < 1 ? 1 : 16 / sizeof ( value_type );

    static constexpr size_type _Alloc_mask = sizeof ( value_type ) <= 1 ? 15
                                           : sizeof ( value_type ) <= 2 ? 7
                                           : sizeof ( value_type ) <= 4 ? 3
                                           : sizeof ( value_type ) <= 8 ? 1
                                                                     : 0;

    static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;

    [ [ nodiscard ] ] inline value_type * _Myptr ( ) noexcept {
        value_type * _Result = _Bx . _Buf;
        if ( _Large_mode_engaged ( ) ) {
            _Result = _Unfancy ( _Bx . _Ptr );
        }

        return _Result;
    }

    [ [ nodiscard ] ] inline const value_type * _Myptr ( ) const noexcept {
        const value_type * _Result = _Bx . _Buf;
        if ( _Large_mode_engaged ( ) ) {
            _Result = _Unfancy ( _Bx . _Ptr );
        }

        return _Result;
    }

    [ [ nodiscard ] ] inline bool _Large_mode_engaged ( ) const noexcept {
        return _Myres > _Small_string_capacity;
    }

    inline void _Activate_SSO_buffer ( ) noexcept {








    }

    inline void _Check_offset ( const size_type _Off ) const {

        if ( _Mysize < _Off ) {
            _Xran ( );
        }
    }

    inline void _Check_offset_exclusive ( const size_type _Off ) const {

        if ( _Mysize <= _Off ) {
            _Xran ( );
        }
    }

    [ [ noreturn ] ] static void _Xran ( ) {
        _Xout_of_range ( "invalid string position" );
    }

    [ [ nodiscard ] ] inline size_type _Clamp_suffix_size ( const size_type _Off, const size_type _Size ) const noexcept {

        return ( :: std :: min ) ( _Size, _Mysize - _Off );
    }

    union _Bxty {


        inline _Bxty ( ) noexcept : _Buf ( ) { }
        inline ~ _Bxty ( ) noexcept { }

        value_type _Buf [ _BUF_SIZE ];
        pointer _Ptr;
        char _Alias [ _BUF_SIZE ];

        inline void _Switch_to_buf ( ) noexcept {
            :: std :: _Destroy_in_place ( _Ptr );









        }
    };
    _Bxty _Bx;



    size_type _Mysize = 0;
    size_type _Myres = 0;
};
#line 522 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xstring"
template< class _Ty> constexpr size_t 
#line 523
_Size_after_ebco_v = (is_empty_v< _Ty> ) ? 0 : sizeof(_Ty); 
#line 525
struct _String_constructor_concat_tag { 
#line 527
explicit _String_constructor_concat_tag() = default;
#line 528
}; 
#line 530
[[noreturn]] inline void _Xlen_string() { 
#line 531
_Xlength_error("string too long"); 
#line 532
} 
#line 540 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xstring"
template < class _Elem, class _Traits = char_traits < _Elem >, class _Alloc = allocator < _Elem > >
class basic_string {
private :
    friend _Tidy_deallocate_guard < basic_string >;
    friend basic_stringbuf < _Elem, _Traits, _Alloc >;

    using _Alty = _Rebind_alloc_t < _Alloc, _Elem >;
    using _Alty_traits = allocator_traits < _Alty >;

    using _Scary_val = _String_val < conditional_t < _Is_simple_alloc_v < _Alty >, _Simple_types < _Elem >,
        _String_iter_types < _Elem, typename _Alty_traits :: size_type, typename _Alty_traits :: difference_type,
            typename _Alty_traits :: pointer, typename _Alty_traits :: const_pointer >> >;

    static_assert ( ! 0 || is_same_v < _Elem, typename _Alloc :: value_type >,
        "basic_string<T, Traits, Allocator> requires that Allocator\'s value_type match T (See N4950 [container.alloc.reqmts]/5) Either f" "ix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0 to suppress this error." );

    static_assert ( is_same_v < _Elem, typename _Traits :: char_type >,
        "N4950 [string.require]/3 requires that the supplied char_traits character type match the string\'s character type."
                                                                       );

    static_assert ( ! is_array_v < _Elem > && is_trivially_copyable_v < _Elem > && is_trivially_default_constructible_v < _Elem >
                      && is_standard_layout_v < _Elem >,
        "The character type of basic_string must be a non-array trivially copyable standard-layout type T where is_trivially_default_cons" "tructible_v<T> is true. See N5001 [strings.general]/1."
                                                                                         );

public :
    using traits_type = _Traits;
    using allocator_type = _Alloc;

    using value_type = _Elem;
    using size_type = typename _Alty_traits :: size_type;
    using difference_type = typename _Alty_traits :: difference_type;
    using pointer = typename _Alty_traits :: pointer;
    using const_pointer = typename _Alty_traits :: const_pointer;
    using reference = value_type &;
    using const_reference = const value_type &;

    using iterator = _String_iterator < _Scary_val >;
    using const_iterator = _String_const_iterator < _Scary_val >;

    using reverse_iterator = :: std :: reverse_iterator < iterator >;
    using const_reverse_iterator = :: std :: reverse_iterator < const_iterator >;

private :
    static constexpr size_type _BUF_SIZE = _Scary_val :: _BUF_SIZE;
    static constexpr size_type _Alloc_mask = _Scary_val :: _Alloc_mask;
    static constexpr size_type _Small_string_capacity = _Scary_val :: _Small_string_capacity;


    static constexpr size_type _Least_allocation_size = _Small_string_capacity + 1 + 1;











    static constexpr bool _Can_memcpy_val =
        _Is_specialization_v < _Traits, char_traits > && is_trivially_copyable_v < pointer >;

    static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v < _Container_base >;
    static constexpr size_t _Memcpy_val_size = sizeof ( _Scary_val ) - _Memcpy_val_offset;

    template < class _Iter >


    using _Is_elem_cptr = bool_constant < _Is_any_of_v < _Iter, const _Elem * const, _Elem * const, const _Elem *, _Elem * >>;































































































public :
    inline
    basic_string ( ) noexcept ( is_nothrow_default_constructible_v < _Alty > ) : _Mypair ( _Zero_then_variadic_args_t { } ) {
        _Construct_empty ( );
    }

    inline explicit basic_string ( const _Alloc & _Al ) noexcept : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        _Construct_empty ( );
    }

    inline basic_string ( const basic_string & _Right )
        : _Mypair ( _One_then_variadic_args_t { }, _Alty_traits :: select_on_container_copy_construction ( _Right . _Getal ( ) ) ) {
        _Construct < _Construct_strategy :: _From_string > ( _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
    }

    inline basic_string ( const basic_string & _Right, const _Alloc & _Al )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        _Construct < _Construct_strategy :: _From_string > ( _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
    }

    inline basic_string ( const basic_string & _Right, const size_type _Roff, const _Alloc & _Al = _Alloc ( ) )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        _Right . _Mypair . _Myval2 . _Check_offset ( _Roff );
        _Construct < _Construct_strategy :: _From_ptr > (
            _Right . _Mypair . _Myval2 . _Myptr ( ) + _Roff, _Right . _Mypair . _Myval2 . _Clamp_suffix_size ( _Roff, npos ) );
    }

    inline basic_string (
        const basic_string & _Right, const size_type _Roff, const size_type _Count, const _Alloc & _Al = _Alloc ( ) )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        _Right . _Mypair . _Myval2 . _Check_offset ( _Roff );
        _Construct < _Construct_strategy :: _From_ptr > (
            _Right . _Mypair . _Myval2 . _Myptr ( ) + _Roff, _Right . _Mypair . _Myval2 . _Clamp_suffix_size ( _Roff, _Count ) );
    }














    inline basic_string ( const _Elem * const _Ptr, const size_type _Count )
        : _Mypair ( _Zero_then_variadic_args_t { } ) {
        _Construct < _Construct_strategy :: _From_ptr > ( _Ptr, _Count );
    }




    inline basic_string (
          const _Elem * const _Ptr, const size_type _Count, const _Alloc & _Al )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        _Construct < _Construct_strategy :: _From_ptr > ( _Ptr, _Count );
    }

    inline basic_string ( const _Elem * const _Ptr ) : _Mypair ( _Zero_then_variadic_args_t { } ) {
        _Construct < _Construct_strategy :: _From_ptr > ( _Ptr, _Convert_size < size_type > ( _Traits :: length ( _Ptr ) ) );
    }




    inline basic_string ( const _Elem * const _Ptr, const _Alloc & _Al )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        _Construct < _Construct_strategy :: _From_ptr > ( _Ptr, _Convert_size < size_type > ( _Traits :: length ( _Ptr ) ) );
    }





    inline basic_string ( const size_type _Count, const _Elem _Ch )
        : _Mypair ( _Zero_then_variadic_args_t { } ) {
        _Construct < _Construct_strategy :: _From_char > ( _Ch, _Count );
    }




    inline basic_string ( const size_type _Count, const _Elem _Ch, const _Alloc & _Al )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        _Construct < _Construct_strategy :: _From_char > ( _Ch, _Count );
    }

    template < class _Iter, enable_if_t < _Is_iterator_v < _Iter >, int > = 0 >
    inline basic_string ( _Iter _First, _Iter _Last, const _Alloc & _Al = _Alloc ( ) )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        :: std :: _Adl_verify_range ( _First, _Last );
        auto _UFirst = :: std :: _Get_unwrapped ( _First );
        auto _ULast = :: std :: _Get_unwrapped ( _Last );
        if ( _UFirst == _ULast ) {
            _Construct_empty ( );
        } else {
            if constexpr ( _Is_elem_cptr < decltype ( _UFirst ) > :: value ) {
                _Construct < _Construct_strategy :: _From_ptr > (
                    _UFirst, :: std :: _Convert_size < size_type > ( static_cast < size_t > ( _ULast - _UFirst ) ) );
            } else if constexpr ( _Is_cpp17_fwd_iter_v < decltype ( _UFirst ) > ) {
                const auto _Length = static_cast < size_t > ( :: std :: distance ( _UFirst, _ULast ) );
                const auto _Count = :: std :: _Convert_size < size_type > ( _Length );
                _Construct_from_iter ( :: std :: move ( _UFirst ), :: std :: move ( _ULast ), _Count );
            } else {
                _Construct_from_iter ( :: std :: move ( _UFirst ), :: std :: move ( _ULast ) );
            }
        }
    }

private :
    enum class _Allocation_policy { _At_least, _Exactly };

    template < _Allocation_policy _Policy = _Allocation_policy :: _At_least >
    [ [ nodiscard ] ] static inline pointer _Allocate_for_capacity ( _Alty & _Al, size_type & _Capacity ) {
        ;
        ++ _Capacity;

        pointer _Fancy_ptr = nullptr;
        if constexpr ( _Policy == _Allocation_policy :: _At_least ) {
            _Fancy_ptr = _Allocate_at_least_helper ( _Al, _Capacity );
        } else {
            ;
            _Fancy_ptr = _Al . allocate ( _Capacity );
        }











        -- _Capacity;
        return _Fancy_ptr;
    }

    static inline void _Deallocate_for_capacity (
        _Alty & _Al, const pointer _Old_ptr, const size_type _Capacity ) noexcept {
        ;
        _Al . deallocate ( _Old_ptr, _Capacity + 1 );
    }

    inline void _Construct_empty ( ) {
        auto & _My_data = _Mypair . _Myval2;
        _My_data . _Alloc_proxy ( _Fake_allocator { } );


        _My_data . _Mysize = 0;
        _My_data . _Myres = _Small_string_capacity;
        _My_data . _Activate_SSO_buffer ( );


        _Traits :: assign ( _My_data . _Bx . _Buf [ 0 ], _Elem ( ) );
    }

    enum class _Construct_strategy : uint8_t { _From_char, _From_ptr, _From_string };

    template < _Construct_strategy _Strat, class _Char_or_ptr >
    inline void _Construct ( const _Char_or_ptr _Arg, const size_type _Count ) {
        auto & _My_data = _Mypair . _Myval2;
        ;

        if constexpr ( _Strat == _Construct_strategy :: _From_char ) {
            ;
        } else {
            ;
        }

        if ( _Count > max_size ( ) ) {
            _Xlen_string ( );
        }

        auto & _Al = _Getal ( );
        auto && _Alproxy = _Fake_allocator { };
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _My_data );

        if ( _Count <= _Small_string_capacity ) {
            _My_data . _Mysize = _Count;
            _My_data . _Myres = _Small_string_capacity;

            if constexpr ( _Strat == _Construct_strategy :: _From_char ) {
                _Traits :: assign ( _My_data . _Bx . _Buf, _Count, _Arg );
                _Traits :: assign ( _My_data . _Bx . _Buf [ _Count ], _Elem ( ) );
            } else if constexpr ( _Strat == _Construct_strategy :: _From_ptr ) {
                _Traits :: copy ( _My_data . _Bx . _Buf, _Arg, _Count );
                _Traits :: assign ( _My_data . _Bx . _Buf [ _Count ], _Elem ( ) );
            } else {



                _Traits :: copy ( _My_data . _Bx . _Buf, _Arg, _BUF_SIZE );

            }

            _Proxy . _Release ( );
            return;
        }

        size_type _New_capacity = _Calculate_growth ( _Count, _Small_string_capacity, max_size ( ) );
        const pointer _New_ptr = _Allocate_for_capacity ( _Al, _New_capacity );
        _Construct_in_place ( _My_data . _Bx . _Ptr, _New_ptr );

        _My_data . _Mysize = _Count;
        _My_data . _Myres = _New_capacity;
        if constexpr ( _Strat == _Construct_strategy :: _From_char ) {
            _Traits :: assign ( _Unfancy ( _New_ptr ), _Count, _Arg );
            _Traits :: assign ( _Unfancy ( _New_ptr ) [ _Count ], _Elem ( ) );
        } else if constexpr ( _Strat == _Construct_strategy :: _From_ptr ) {
            _Traits :: copy ( _Unfancy ( _New_ptr ), _Arg, _Count );
            _Traits :: assign ( _Unfancy ( _New_ptr ) [ _Count ], _Elem ( ) );
        } else {
            _Traits :: copy ( _Unfancy ( _New_ptr ), _Arg, _Count + 1 );
        }

        ;
        _Proxy . _Release ( );
    }

    template < class _Iter, class _Sent, class _Size = nullptr_t >
    inline void _Construct_from_iter ( _Iter _First, const _Sent _Last, _Size _Count = { } ) {







        auto & _My_data = _Mypair . _Myval2;
        auto & _Al = _Getal ( );
        auto && _Alproxy = _Fake_allocator { };
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _My_data );

        _My_data . _Mysize = 0;
        _My_data . _Myres = _Small_string_capacity;

        if constexpr ( is_same_v < _Size, size_type > ) {
            if ( _Count > max_size ( ) ) {
                _Xlen_string ( );
            }

            if ( _Count > _Small_string_capacity ) {
                size_type _New_capacity = _Calculate_growth ( _Count );
                const pointer _New_ptr = _Allocate_for_capacity ( _Al, _New_capacity );
                _Construct_in_place ( _My_data . _Bx . _Ptr, _New_ptr );
                _My_data . _Myres = _New_capacity;
            }
        }

        _Tidy_deallocate_guard < basic_string > _Guard { this };

        constexpr bool _Can_construct_by_copy =
            _Is_specialization_v < _Traits, char_traits > && _Is_EcharT < _Elem > && is_same_v < _Size, size_type >;

        if constexpr ( _Can_construct_by_copy ) {
            const auto _Data = _My_data . _Myptr ( );
            :: std :: _Copy_n_unchecked4 ( :: std :: move ( _First ), _Count, _Data );
            _My_data . _Mysize = _Count;
            _Data [ _Count ] = _Elem ( );
        } else {
            for (; _First != _Last; ++ _First ) {
                if constexpr ( ! is_same_v < _Size, size_type > ) {
                    if ( _My_data . _Mysize == _My_data . _Myres ) {
                        if ( _My_data . _Mysize == max_size ( ) ) {
                            _Xlen_string ( );
                        }

                        _Elem * const _Old_ptr = _My_data . _Myptr ( );
                        size_type _New_capacity = _Calculate_growth ( _My_data . _Mysize + 1 );
                        const pointer _New_ptr = _Allocate_for_capacity ( _Al, _New_capacity );

                        _Traits :: copy ( _Unfancy ( _New_ptr ), _Old_ptr, _My_data . _Mysize );
                        if ( _My_data . _Large_mode_engaged ( ) ) {
                            _Deallocate_for_capacity ( _Al, _My_data . _Bx . _Ptr, _My_data . _Myres );
                            _My_data . _Bx . _Ptr = _New_ptr;
                        } else {
                            _Construct_in_place ( _My_data . _Bx . _Ptr, _New_ptr );
                        }
                        _My_data . _Myres = _New_capacity;
                    }
                }

                _Elem * const _Ptr = _My_data . _Myptr ( );
                _Traits :: assign ( _Ptr [ _My_data . _Mysize ], * _First );
                ++ _My_data . _Mysize;
            }

            _Elem * const _Ptr = _My_data . _Myptr ( );
            _Traits :: assign ( _Ptr [ _My_data . _Mysize ], _Elem ( ) );
        }

        ;
        _Guard . _Target = nullptr;
        _Proxy . _Release ( );
    }

public :


















    inline basic_string ( basic_string && _Right ) noexcept
        : _Mypair ( _One_then_variadic_args_t { }, :: std :: move ( _Right . _Getal ( ) ) ) {
        _Mypair . _Myval2 . _Alloc_proxy ( _Fake_allocator { } );
        _Take_contents ( _Right );
    }

    inline basic_string ( basic_string && _Right, const _Alloc & _Al )
        noexcept ( _Alty_traits :: is_always_equal :: value )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        if constexpr ( ! _Alty_traits :: is_always_equal :: value ) {
            if ( _Getal ( ) != _Right . _Getal ( ) ) {
                _Construct < _Construct_strategy :: _From_string > (
                    _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
                return;
            }
        }

        _Mypair . _Myval2 . _Alloc_proxy ( _Fake_allocator { } );
        _Take_contents ( _Right );
    }

    inline basic_string ( _String_constructor_concat_tag, const basic_string & _Source_of_al,
        const _Elem * const _Left_ptr, const size_type _Left_size, const _Elem * const _Right_ptr,
        const size_type _Right_size )
        : _Mypair ( _One_then_variadic_args_t { },
              _Alty_traits :: select_on_container_copy_construction ( _Source_of_al . _Getal ( ) ) ) {
        ;
        ;
        ;
        const auto _New_size = static_cast < size_type > ( _Left_size + _Right_size );
        size_type _New_capacity = _Small_string_capacity;
        auto & _My_data = _Mypair . _Myval2;
        _Elem * _Ptr = _My_data . _Bx . _Buf;
        auto && _Alproxy = _Fake_allocator { };
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _My_data );

        if ( _New_capacity < _New_size ) {
            _New_capacity = _Calculate_growth ( _New_size, _Small_string_capacity, max_size ( ) );
            const pointer _Fancyptr = _Allocate_for_capacity ( _Getal ( ), _New_capacity );
            _Ptr = _Unfancy ( _Fancyptr );
            _Construct_in_place ( _My_data . _Bx . _Ptr, _Fancyptr );
        }

        _My_data . _Mysize = _New_size;
        _My_data . _Myres = _New_capacity;
        _Traits :: copy ( _Ptr, _Left_ptr, _Left_size );
        _Traits :: copy ( _Ptr + static_cast < ptrdiff_t > ( _Left_size ), _Right_ptr, _Right_size );
        _Traits :: assign ( _Ptr [ _New_size ], _Elem ( ) );
        ;
        _Proxy . _Release ( );
    }

    inline basic_string ( _String_constructor_concat_tag, basic_string & _Left, basic_string & _Right )
        : _Mypair ( _One_then_variadic_args_t { }, _Left . _Getal ( ) ) {
        auto & _My_data = _Mypair . _Myval2;
        auto & _Left_data = _Left . _Mypair . _Myval2;
        auto & _Right_data = _Right . _Mypair . _Myval2;
        _Left_data . _Orphan_all ( );
        _Right_data . _Orphan_all ( );
        const auto _Left_size = _Left_data . _Mysize;
        const auto _Right_size = _Right_data . _Mysize;

        const auto _Left_capacity = _Left_data . _Myres;
        const auto _Right_capacity = _Right_data . _Myres;

        const auto _New_size = static_cast < size_type > ( _Left_size + _Right_size );
        const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;
        if ( _Fits_in_left && _Right_capacity <= _Left_capacity ) {

            _My_data . _Alloc_proxy ( _Fake_allocator { } );
            _Take_contents ( _Left );
            const auto _Ptr = _My_data . _Myptr ( );
            ;
            _Traits :: copy ( _Ptr + _Left_size, _Right_data . _Myptr ( ), _Right_size + 1 );
            _My_data . _Mysize = _New_size;
            return;
        }

        const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;
        if ( _Allocators_equal ( _Getal ( ), _Right . _Getal ( ) ) && _Fits_in_right ) {









            ;
            _My_data . _Alloc_proxy ( _Fake_allocator { } );
            _Take_contents ( _Right );
            const auto _Ptr = _Unfancy ( _My_data . _Bx . _Ptr );
            ;
            _Traits :: move ( _Ptr + _Left_size, _Ptr, _Right_size + 1 );
            _Traits :: copy ( _Ptr, _Left_data . _Myptr ( ), _Left_size );
            _My_data . _Mysize = _New_size;
            return;
        }


        const auto _Max = max_size ( );
        if ( _Max - _Left_size < _Right_size ) {
            _Xlen_string ( );
        }

        size_type _New_capacity = _Calculate_growth ( _New_size, _Small_string_capacity, _Max );
        auto && _Alproxy = _Fake_allocator { };
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _My_data );
        const pointer _Fancyptr = _Allocate_for_capacity ( _Getal ( ), _New_capacity );

        _Construct_in_place ( _My_data . _Bx . _Ptr, _Fancyptr );
        _My_data . _Mysize = _New_size;
        _My_data . _Myres = _New_capacity;
        const auto _Ptr = _Unfancy ( _Fancyptr );
        _Traits :: copy ( _Ptr, _Left_data . _Myptr ( ), _Left_size );
        _Traits :: copy ( _Ptr + _Left_size, _Right_data . _Myptr ( ), _Right_size + 1 );
        ;
        _Proxy . _Release ( );
    }













































































    inline basic_string & operator = ( basic_string && _Right )
        noexcept ( _Choose_pocma_v < _Alty > != _Pocma_values :: _No_propagate_allocators ) {
        if ( this == :: std :: addressof ( _Right ) ) {
            return * this;
        }

        auto & _Al = _Getal ( );
        auto & _Right_al = _Right . _Getal ( );
        constexpr auto _Pocma_val = _Choose_pocma_v < _Alty >;
        if constexpr ( _Pocma_val == _Pocma_values :: _Propagate_allocators ) {
            if ( _Al != _Right_al ) {

                _Mypair . _Myval2 . _Orphan_all ( );
                _Mypair . _Myval2 . _Reload_proxy ( _Fake_allocator { }, _Fake_allocator { } );
            }
        } else if constexpr ( _Pocma_val == _Pocma_values :: _No_propagate_allocators ) {
            if ( _Al != _Right_al ) {
                assign ( _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
                return * this;
            }
        }

        _Tidy_deallocate ( );
        _Pocma ( _Al, _Right_al );
        _Take_contents ( _Right );
        return * this;
    }

    inline basic_string & assign ( basic_string && _Right ) noexcept ( noexcept ( * this = :: std :: move ( _Right ) ) ) {
        * this = :: std :: move ( _Right );
        return * this;
    }

private :
    inline void _Take_contents ( basic_string & _Right ) noexcept {





        auto & _My_data = _Mypair . _Myval2;
        auto & _Right_data = _Right . _Mypair . _Myval2;


        if constexpr ( _Can_memcpy_val ) {



            {









                const auto _My_data_mem =
                    reinterpret_cast < unsigned char * > ( :: std :: addressof ( _Mypair . _Myval2 ) ) + _Memcpy_val_offset;
                const auto _Right_data_mem =
                    reinterpret_cast < const unsigned char * > ( :: std :: addressof ( _Right . _Mypair . _Myval2 ) ) + _Memcpy_val_offset;
                :: memcpy ( _My_data_mem, _Right_data_mem, _Memcpy_val_size );

                _Right_data . _Mysize = 0;
                _Right_data . _Myres = _Small_string_capacity;
                _Right_data . _Activate_SSO_buffer ( );
                _Traits :: assign ( _Right_data . _Bx . _Buf [ 0 ], _Elem ( ) );
                return;
            }
        }


        if ( _Right_data . _Large_mode_engaged ( ) ) {
            _Swap_proxy_and_iterators ( _Right );

            _Construct_in_place ( _My_data . _Bx . _Ptr, _Right_data . _Bx . _Ptr );
            _Right_data . _Bx . _Switch_to_buf ( );
        } else {
            _Right_data . _Orphan_all ( );

            _My_data . _Activate_SSO_buffer ( );
            _Traits :: copy ( _My_data . _Bx . _Buf, _Right_data . _Bx . _Buf, _Right_data . _Mysize + 1 );
        }

        _My_data . _Myres = _Right_data . _Myres;
        _My_data . _Mysize = _Right_data . _Mysize;

        _Right_data . _Mysize = 0;
        _Right_data . _Myres = _Small_string_capacity;
        _Traits :: assign ( _Right_data . _Bx . _Buf [ 0 ], _Elem ( ) );
    }























public :
    inline basic_string ( initializer_list < _Elem > _Ilist, const _Alloc & _Al = allocator_type ( ) )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        _Construct < _Construct_strategy :: _From_ptr > ( _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) );
    }

    inline basic_string & operator = ( initializer_list < _Elem > _Ilist ) {
        return assign ( _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) );
    }

    inline basic_string & operator += ( initializer_list < _Elem > _Ilist ) {
        return append ( _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) );
    }

    inline basic_string & assign ( initializer_list < _Elem > _Ilist ) {
        return assign ( _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) );
    }

    inline basic_string & append ( initializer_list < _Elem > _Ilist ) {
        return append ( _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) );
    }

    inline iterator insert ( const const_iterator _Where, const initializer_list < _Elem > _Ilist ) {



        const auto _Off = static_cast < size_type > ( _Unfancy ( _Where . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) );
        insert ( _Off, _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) );
        return begin ( ) + static_cast < difference_type > ( _Off );
    }

    inline basic_string & replace (
        const const_iterator _First, const const_iterator _Last, const initializer_list < _Elem > _Ilist ) {

        :: std :: _Adl_verify_range ( _First, _Last );



        const auto _Offset = static_cast < size_type > ( _Unfancy ( _First . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) );
        const auto _Length = static_cast < size_type > ( _Last . _Ptr - _First . _Ptr );
        return replace ( _Offset, _Length, _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) );
    }

    inline ~ basic_string ( ) noexcept {
        _Tidy_deallocate ( );






    }

    static constexpr auto npos { static_cast < size_type > ( - 1 ) };

    inline basic_string & operator = ( const basic_string & _Right ) {
        if ( this == :: std :: addressof ( _Right ) ) {
            return * this;
        }

        auto & _Al = _Getal ( );
        const auto & _Right_al = _Right . _Getal ( );
        if constexpr ( _Choose_pocca_v < _Alty > ) {
            if ( _Al != _Right_al ) {
                auto && _Alproxy = _Fake_allocator { };
                auto && _Right_alproxy = _Fake_allocator { };
                _Container_proxy_ptr < _Alty > _New_proxy ( _Right_alproxy, _Leave_proxy_unbound { } );

                const size_type _Right_size = _Right . _Mypair . _Myval2 . _Mysize;
                const _Elem * const _Right_ptr = _Right . _Mypair . _Myval2 . _Myptr ( );
                if ( _Right_size > _Small_string_capacity ) {
                    size_type _New_capacity = _Calculate_growth ( _Right_size, _Small_string_capacity, _Right . max_size ( ) );
                    auto _Right_al_non_const = _Right_al;
                    const pointer _New_ptr = _Allocate_for_capacity ( _Right_al_non_const, _New_capacity );
                    _Traits :: copy ( _Unfancy ( _New_ptr ), _Right_ptr, _Right_size + 1 );

                    _Tidy_deallocate ( );
                    _Construct_in_place ( _Mypair . _Myval2 . _Bx . _Ptr, _New_ptr );
                    _Mypair . _Myval2 . _Mysize = _Right_size;
                    _Mypair . _Myval2 . _Myres = _New_capacity;
                    ;
                } else {
                    _Tidy_deallocate ( );
                    _Traits :: copy ( _Mypair . _Myval2 . _Bx . _Buf, _Right_ptr, _Right_size + 1 );
                    _Mypair . _Myval2 . _Mysize = _Right_size;
                    _Mypair . _Myval2 . _Myres = _Small_string_capacity;
                }

                _Pocca ( _Al, _Right_al );
                _New_proxy . _Bind ( _Alproxy, :: std :: addressof ( _Mypair . _Myval2 ) );
                return * this;
            }
        }

        _Pocca ( _Al, _Right_al );
        assign ( _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
        return * this;
    }








    inline basic_string & operator = ( const _Elem * const _Ptr ) {
        return assign ( _Ptr );
    }





    inline basic_string & operator = ( const _Elem _Ch ) {
        ;
        _Mypair . _Myval2 . _Mysize = 1;
        _Elem * const _Ptr = _Mypair . _Myval2 . _Myptr ( );
        _Traits :: assign ( _Ptr [ 0 ], _Ch );
        _Traits :: assign ( _Ptr [ 1 ], _Elem ( ) );
        return * this;
    }

    inline basic_string & operator += ( const basic_string & _Right ) {
        return append ( _Right );
    }








    inline basic_string & operator += ( const _Elem * const _Ptr ) {
        return append ( _Ptr );
    }

    inline basic_string & operator += ( _Elem _Ch ) {
        push_back ( _Ch );
        return * this;
    }

    inline basic_string & append ( const basic_string & _Right ) {
        return append ( _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
    }

    inline basic_string & append ( const basic_string & _Right, const size_type _Roff, size_type _Count = npos ) {

        _Right . _Mypair . _Myval2 . _Check_offset ( _Roff );
        _Count = _Right . _Mypair . _Myval2 . _Clamp_suffix_size ( _Roff, _Count );
        return append ( _Right . _Mypair . _Myval2 . _Myptr ( ) + _Roff, _Count );
    }

















    inline basic_string & append (
          const _Elem * const _Ptr, const size_type _Count ) {

        const size_type _Old_size = _Mypair . _Myval2 . _Mysize;
        if ( _Count <= _Mypair . _Myval2 . _Myres - _Old_size ) {
            ;
            _Mypair . _Myval2 . _Mysize = _Old_size + _Count;
            _Elem * const _Old_ptr = _Mypair . _Myval2 . _Myptr ( );
            _Traits :: move ( _Old_ptr + _Old_size, _Ptr, _Count );
            _Traits :: assign ( _Old_ptr [ _Old_size + _Count ], _Elem ( ) );
            return * this;
        }

        return _Reallocate_grow_by (
            _Count,
            [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size, const _Elem * const _Ptr,
                const size_type _Count ) {
                _Traits :: copy ( _New_ptr, _Old_ptr, _Old_size );
                _Traits :: copy ( _New_ptr + _Old_size, _Ptr, _Count );
                _Traits :: assign ( _New_ptr [ _Old_size + _Count ], _Elem ( ) );
            },
            _Ptr, _Count );
    }

    inline basic_string & append ( const _Elem * const _Ptr ) {
        return append ( _Ptr, _Convert_size < size_type > ( _Traits :: length ( _Ptr ) ) );
    }

    inline basic_string & append ( const size_type _Count, const _Elem _Ch ) {

        const size_type _Old_size = _Mypair . _Myval2 . _Mysize;
        if ( _Count <= _Mypair . _Myval2 . _Myres - _Old_size ) {
            ;
            _Mypair . _Myval2 . _Mysize = _Old_size + _Count;
            _Elem * const _Old_ptr = _Mypair . _Myval2 . _Myptr ( );
            _Traits :: assign ( _Old_ptr + _Old_size, _Count, _Ch );
            _Traits :: assign ( _Old_ptr [ _Old_size + _Count ], _Elem ( ) );
            return * this;
        }

        return _Reallocate_grow_by (
            _Count,
            [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size, const size_type _Count,
                const _Elem _Ch ) {
                _Traits :: copy ( _New_ptr, _Old_ptr, _Old_size );
                _Traits :: assign ( _New_ptr + _Old_size, _Count, _Ch );
                _Traits :: assign ( _New_ptr [ _Old_size + _Count ], _Elem ( ) );
            },
            _Count, _Ch );
    }

    template < class _Iter, enable_if_t < _Is_iterator_v < _Iter >, int > = 0 >
    inline basic_string & append ( const _Iter _First, const _Iter _Last ) {

        :: std :: _Adl_verify_range ( _First, _Last );
        const auto _UFirst = :: std :: _Get_unwrapped ( _First );
        const auto _ULast = :: std :: _Get_unwrapped ( _Last );
        if constexpr ( _Is_elem_cptr < decltype ( _UFirst ) > :: value ) {
            return append ( _UFirst, :: std :: _Convert_size < size_type > ( static_cast < size_t > ( _ULast - _UFirst ) ) );
        } else {
            const basic_string _Right ( _UFirst, _ULast, get_allocator ( ) );
            return append ( _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
        }
    }














    inline basic_string & assign ( const basic_string & _Right ) {
        * this = _Right;
        return * this;
    }

    inline basic_string & assign ( const basic_string & _Right, const size_type _Roff, size_type _Count = npos ) {

        _Right . _Mypair . _Myval2 . _Check_offset ( _Roff );
        _Count = _Right . _Mypair . _Myval2 . _Clamp_suffix_size ( _Roff, _Count );
        return assign ( _Right . _Mypair . _Myval2 . _Myptr ( ) + _Roff, _Count );
    }

















    inline basic_string & assign (
          const _Elem * const _Ptr, const size_type _Count ) {

        if ( _Count <= _Mypair . _Myval2 . _Myres ) {
            ;
            _Elem * const _Old_ptr = _Mypair . _Myval2 . _Myptr ( );
            _Mypair . _Myval2 . _Mysize = _Count;
            _Traits :: move ( _Old_ptr, _Ptr, _Count );
            _Traits :: assign ( _Old_ptr [ _Count ], _Elem ( ) );
            ;
            return * this;
        }

        return _Reallocate_for (
            _Count,
            [ ] ( _Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr ) {
                _Traits :: copy ( _New_ptr, _Ptr, _Count );
                _Traits :: assign ( _New_ptr [ _Count ], _Elem ( ) );
            },
            _Ptr );
    }

    inline basic_string & assign ( const _Elem * const _Ptr ) {
        return assign ( _Ptr, _Convert_size < size_type > ( _Traits :: length ( _Ptr ) ) );
    }

    inline basic_string & assign ( const size_type _Count, const _Elem _Ch ) {

        if ( _Count <= _Mypair . _Myval2 . _Myres ) {
            ;
            _Elem * const _Old_ptr = _Mypair . _Myval2 . _Myptr ( );
            _Mypair . _Myval2 . _Mysize = _Count;
            _Traits :: assign ( _Old_ptr, _Count, _Ch );
            _Traits :: assign ( _Old_ptr [ _Count ], _Elem ( ) );
            return * this;
        }

        return _Reallocate_for (
            _Count,
            [ ] ( _Elem * const _New_ptr, const size_type _Count, const _Elem _Ch ) {
                _Traits :: assign ( _New_ptr, _Count, _Ch );
                _Traits :: assign ( _New_ptr [ _Count ], _Elem ( ) );
            },
            _Ch );
    }

    template < class _Iter, enable_if_t < _Is_iterator_v < _Iter >, int > = 0 >
    inline basic_string & assign ( const _Iter _First, const _Iter _Last ) {
        :: std :: _Adl_verify_range ( _First, _Last );
        const auto _UFirst = :: std :: _Get_unwrapped ( _First );
        const auto _ULast = :: std :: _Get_unwrapped ( _Last );
        if constexpr ( _Is_elem_cptr < decltype ( _UFirst ) > :: value ) {
            return assign ( _UFirst, :: std :: _Convert_size < size_type > ( static_cast < size_t > ( _ULast - _UFirst ) ) );
        } else {
            basic_string _Right ( _UFirst, _ULast, get_allocator ( ) );
            if ( _Mypair . _Myval2 . _Myres < _Right . _Mypair . _Myval2 . _Myres ) {
                _Mypair . _Myval2 . _Orphan_all ( );
                _Swap_data ( _Right );
                return * this;
            } else {
                return assign ( _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
            }
        }
    }




















    inline basic_string & insert ( const size_type _Off, const basic_string & _Right ) {

        return insert ( _Off, _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
    }

    inline basic_string & insert (
        const size_type _Off, const basic_string & _Right, const size_type _Roff, size_type _Count = npos ) {

        _Right . _Mypair . _Myval2 . _Check_offset ( _Roff );
        _Count = _Right . _Mypair . _Myval2 . _Clamp_suffix_size ( _Roff, _Count );
        return insert ( _Off, _Right . _Mypair . _Myval2 . _Myptr ( ) + _Roff, _Count );
    }


















    inline basic_string & insert (
        const size_type _Off, const _Elem * const _Ptr, const size_type _Count ) {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        const size_type _Old_size = _Mypair . _Myval2 . _Mysize;






        const bool _Check_overlap = _Count <= _Mypair . _Myval2 . _Myres - _Old_size;


        if ( _Check_overlap ) {
            ;
            _Mypair . _Myval2 . _Mysize = _Old_size + _Count;
            _Elem * const _Old_ptr = _Mypair . _Myval2 . _Myptr ( );
            _Elem * const _Insert_at = _Old_ptr + _Off;


            size_type _Ptr_shifted_after;
            if ( _Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size ) {

                _Ptr_shifted_after = _Count;
            } else if ( _Insert_at <= _Ptr ) {
                _Ptr_shifted_after = 0;
            } else {
                _Ptr_shifted_after = static_cast < size_type > ( _Insert_at - _Ptr );
            }

            _Traits :: move ( _Insert_at + _Count, _Insert_at, _Old_size - _Off + 1 );
            _Traits :: copy ( _Insert_at, _Ptr, _Ptr_shifted_after );
            _Traits :: copy (
                _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after );
            return * this;
        }

        return _Reallocate_grow_by (
            _Count,
            [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const _Elem * const _Ptr, const size_type _Count ) {
                _Traits :: copy ( _New_ptr, _Old_ptr, _Off );
                _Traits :: copy ( _New_ptr + _Off, _Ptr, _Count );
                _Traits :: copy ( _New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1 );
            },
            _Off, _Ptr, _Count );
    }

    inline basic_string & insert ( const size_type _Off, const _Elem * const _Ptr ) {

        return insert ( _Off, _Ptr, _Convert_size < size_type > ( _Traits :: length ( _Ptr ) ) );
    }

    inline basic_string & insert (
        const size_type _Off, const size_type _Count, const _Elem _Ch ) {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        const size_type _Old_size = _Mypair . _Myval2 . _Mysize;
        if ( _Count <= _Mypair . _Myval2 . _Myres - _Old_size ) {
            ;
            _Mypair . _Myval2 . _Mysize = _Old_size + _Count;
            _Elem * const _Old_ptr = _Mypair . _Myval2 . _Myptr ( );
            _Elem * const _Insert_at = _Old_ptr + _Off;
            _Traits :: move ( _Insert_at + _Count, _Insert_at, _Old_size - _Off + 1 );
            _Traits :: assign ( _Insert_at, _Count, _Ch );
            return * this;
        }

        return _Reallocate_grow_by (
            _Count,
            [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Count, const _Elem _Ch ) {
                _Traits :: copy ( _New_ptr, _Old_ptr, _Off );
                _Traits :: assign ( _New_ptr + _Off, _Count, _Ch );
                _Traits :: copy ( _New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1 );
            },
            _Off, _Count, _Ch );
    }

    inline iterator insert ( const const_iterator _Where, const _Elem _Ch ) {



        const auto _Off = static_cast < size_type > ( _Unfancy ( _Where . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) );
        insert ( _Off, 1, _Ch );
        return begin ( ) + static_cast < difference_type > ( _Off );
    }

    inline iterator insert (
        const const_iterator _Where, const size_type _Count, const _Elem _Ch ) {




        const auto _Off = static_cast < size_type > ( _Unfancy ( _Where . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) );
        insert ( _Off, _Count, _Ch );
        return begin ( ) + static_cast < difference_type > ( _Off );
    }

    template < class _Iter, enable_if_t < _Is_iterator_v < _Iter >, int > = 0 >
    inline iterator insert ( const const_iterator _Where, const _Iter _First, const _Iter _Last ) {




        const auto _Off = static_cast < size_type > ( _Unfancy ( _Where . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) );
        :: std :: _Adl_verify_range ( _First, _Last );
        const auto _UFirst = :: std :: _Get_unwrapped ( _First );
        const auto _ULast = :: std :: _Get_unwrapped ( _Last );
        if constexpr ( _Is_elem_cptr < decltype ( _UFirst ) > :: value ) {
            insert ( _Off, _UFirst, :: std :: _Convert_size < size_type > ( static_cast < size_t > ( _ULast - _UFirst ) ) );
        } else {
            const basic_string _Right ( _UFirst, _ULast, get_allocator ( ) );
            insert ( _Off, _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
        }

        return begin ( ) + static_cast < difference_type > ( _Off );
    }





















    inline basic_string & erase ( const size_type _Off = 0 ) {
        _Mypair . _Myval2 . _Check_offset ( _Off );
        _Eos ( _Off );
        return * this;
    }

private :
    inline basic_string & _Erase_noexcept ( const size_type _Off, size_type _Count ) noexcept {
        _Count = _Mypair . _Myval2 . _Clamp_suffix_size ( _Off, _Count );
        const size_type _Old_size = _Mypair . _Myval2 . _Mysize;
        _Elem * const _My_ptr = _Mypair . _Myval2 . _Myptr ( );
        _Elem * const _Erase_at = _My_ptr + _Off;
        const size_type _New_size = _Old_size - _Count;
        _Traits :: move ( _Erase_at, _Erase_at + _Count, _New_size - _Off + 1 );
        ;
        _Mypair . _Myval2 . _Mysize = _New_size;
        return * this;
    }

public :
    inline basic_string & erase ( const size_type _Off, const size_type _Count ) {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        return _Erase_noexcept ( _Off, _Count );
    }

    inline iterator erase ( const const_iterator _Where ) noexcept {



        const auto _Off = static_cast < size_type > ( _Unfancy ( _Where . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) );
        _Erase_noexcept ( _Off, 1 );
        return begin ( ) + static_cast < difference_type > ( _Off );
    }

    inline iterator erase ( const const_iterator _First, const const_iterator _Last ) noexcept
     {
        :: std :: _Adl_verify_range ( _First, _Last );



        const auto _Off = static_cast < size_type > ( _Unfancy ( _First . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) );
        _Erase_noexcept ( _Off, static_cast < size_type > ( _Last . _Ptr - _First . _Ptr ) );
        return begin ( ) + static_cast < difference_type > ( _Off );
    }

    inline void clear ( ) noexcept {
        _Eos ( 0 );
    }

    inline basic_string & replace ( const size_type _Off, const size_type _Nx, const basic_string & _Right ) {

        return replace ( _Off, _Nx, _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
    }

    inline basic_string & replace ( const size_type _Off, size_type _Nx, const basic_string & _Right,
        const size_type _Roff, size_type _Count = npos ) {

        _Right . _Mypair . _Myval2 . _Check_offset ( _Roff );
        _Count = _Right . _Mypair . _Myval2 . _Clamp_suffix_size ( _Roff, _Count );
        return replace ( _Off, _Nx, _Right . _Mypair . _Myval2 . _Myptr ( ) + _Roff, _Count );
    }


















    inline basic_string & replace (
        const size_type _Off, size_type _Nx, const _Elem * const _Ptr, const size_type _Count ) {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        _Nx = _Mypair . _Myval2 . _Clamp_suffix_size ( _Off, _Nx );
        if ( _Nx == _Count ) {
            _Traits :: move ( _Mypair . _Myval2 . _Myptr ( ) + _Off, _Ptr, _Count );
            return * this;
        }

        const size_type _Old_size = _Mypair . _Myval2 . _Mysize;
        const size_type _Suffix_size = _Old_size - _Nx - _Off + 1;
        if ( _Count < _Nx ) {
            _Elem * const _Old_ptr = _Mypair . _Myval2 . _Myptr ( );
            _Elem * const _Insert_at = _Old_ptr + _Off;
            _Traits :: move ( _Insert_at, _Ptr, _Count );
            _Traits :: move ( _Insert_at + _Count, _Insert_at + _Nx, _Suffix_size );

            const auto _New_size = _Old_size - ( _Nx - _Count );
            ;
            _Mypair . _Myval2 . _Mysize = _New_size;
            return * this;
        }

        const size_type _Growth = static_cast < size_type > ( _Count - _Nx );






        {
            if ( _Growth <= _Mypair . _Myval2 . _Myres - _Old_size ) {
                ;
                _Mypair . _Myval2 . _Mysize = _Old_size + _Growth;
                _Elem * const _Old_ptr = _Mypair . _Myval2 . _Myptr ( );
                _Elem * const _Insert_at = _Old_ptr + _Off;
                _Elem * const _Suffix_at = _Insert_at + _Nx;

                size_type _Ptr_shifted_after;
                if ( _Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size ) {
                    _Ptr_shifted_after = _Count;
                } else if ( _Suffix_at <= _Ptr ) {
                    _Ptr_shifted_after = 0;
                } else {
                    _Ptr_shifted_after = static_cast < size_type > ( _Suffix_at - _Ptr );
                }

                _Traits :: move ( _Suffix_at + _Growth, _Suffix_at, _Suffix_size );



                _Traits :: move ( _Insert_at, _Ptr, _Ptr_shifted_after );


                _Traits :: copy (
                    _Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after, _Count - _Ptr_shifted_after );
                return * this;
            }
        }

        return _Reallocate_grow_by (
            _Growth,
            [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Nx, const _Elem * const _Ptr, const size_type _Count ) {
                _Traits :: copy ( _New_ptr, _Old_ptr, _Off );
                _Traits :: copy ( _New_ptr + _Off, _Ptr, _Count );
                _Traits :: copy ( _New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1 );
            },
            _Off, _Nx, _Ptr, _Count );
    }

    inline basic_string & replace ( const size_type _Off, const size_type _Nx, const _Elem * const _Ptr ) {

        return replace ( _Off, _Nx, _Ptr, _Convert_size < size_type > ( _Traits :: length ( _Ptr ) ) );
    }

    inline basic_string & replace ( const size_type _Off, size_type _Nx, const size_type _Count, const _Elem _Ch ) {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        _Nx = _Mypair . _Myval2 . _Clamp_suffix_size ( _Off, _Nx );
        if ( _Count == _Nx ) {
            _Traits :: assign ( _Mypair . _Myval2 . _Myptr ( ) + _Off, _Count, _Ch );
            return * this;
        }

        const size_type _Old_size = _Mypair . _Myval2 . _Mysize;
        if ( _Count < _Nx || _Count - _Nx <= _Mypair . _Myval2 . _Myres - _Old_size ) {


            const auto _New_size = _Old_size + _Count - _Nx;
            ;
            _Mypair . _Myval2 . _Mysize = _New_size;
            _Elem * const _Old_ptr = _Mypair . _Myval2 . _Myptr ( );
            _Elem * const _Insert_at = _Old_ptr + _Off;
            _Traits :: move ( _Insert_at + _Count, _Insert_at + _Nx, _Old_size - _Nx - _Off + 1 );
            _Traits :: assign ( _Insert_at, _Count, _Ch );
            ;
            return * this;
        }

        return _Reallocate_grow_by (
            _Count - _Nx,
            [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Nx, const size_type _Count, const _Elem _Ch ) {
                _Traits :: copy ( _New_ptr, _Old_ptr, _Off );
                _Traits :: assign ( _New_ptr + _Off, _Count, _Ch );
                _Traits :: copy ( _New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1 );
            },
            _Off, _Nx, _Count, _Ch );
    }

    inline basic_string & replace (
        const const_iterator _First, const const_iterator _Last, const basic_string & _Right ) {

        :: std :: _Adl_verify_range ( _First, _Last );



        return replace ( static_cast < size_type > ( _Unfancy ( _First . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) ),
            static_cast < size_type > ( _Last . _Ptr - _First . _Ptr ), _Right );
    }















    inline basic_string & replace ( const const_iterator _First, const const_iterator _Last,
          const _Elem * const _Ptr, const size_type _Count ) {

        :: std :: _Adl_verify_range ( _First, _Last );



        return replace ( static_cast < size_type > ( _Unfancy ( _First . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) ),
            static_cast < size_type > ( _Last . _Ptr - _First . _Ptr ), _Ptr, _Count );
    }

    inline basic_string & replace (
        const const_iterator _First, const const_iterator _Last, const _Elem * const _Ptr ) {

        :: std :: _Adl_verify_range ( _First, _Last );



        return replace ( static_cast < size_type > ( _Unfancy ( _First . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) ),
            static_cast < size_type > ( _Last . _Ptr - _First . _Ptr ), _Ptr );
    }

    inline basic_string & replace (
        const const_iterator _First, const const_iterator _Last, const size_type _Count, const _Elem _Ch ) {

        :: std :: _Adl_verify_range ( _First, _Last );



        return replace ( static_cast < size_type > ( _Unfancy ( _First . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) ),
            static_cast < size_type > ( _Last . _Ptr - _First . _Ptr ), _Count, _Ch );
    }

    template < class _Iter, enable_if_t < _Is_iterator_v < _Iter >, int > = 0 >
    inline basic_string & replace (
        const const_iterator _First, const const_iterator _Last, const _Iter _First2, const _Iter _Last2 ) {

        :: std :: _Adl_verify_range ( _First, _Last );



        const auto _Off = static_cast < size_type > ( :: std :: _Unfancy ( _First . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) );
        const auto _Length = static_cast < size_type > ( _Last . _Ptr - _First . _Ptr );
        :: std :: _Adl_verify_range ( _First2, _Last2 );
        const auto _UFirst2 = :: std :: _Get_unwrapped ( _First2 );
        const auto _ULast2 = :: std :: _Get_unwrapped ( _Last2 );
        if constexpr ( _Is_elem_cptr < decltype ( _UFirst2 ) > :: value ) {
            return replace (
                _Off, _Length, _UFirst2, :: std :: _Convert_size < size_type > ( static_cast < size_t > ( _ULast2 - _UFirst2 ) ) );
        } else {
            const basic_string _Right ( _UFirst2, _ULast2, get_allocator ( ) );
            return replace ( _Off, _Length, _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
        }
    }





















    [ [ nodiscard ] ] inline iterator begin ( ) noexcept {
        return iterator ( _Refancy < pointer > ( _Mypair . _Myval2 . _Myptr ( ) ), :: std :: addressof ( _Mypair . _Myval2 ) );
    }

    [ [ nodiscard ] ] inline const_iterator begin ( ) const noexcept {
        return const_iterator ( _Refancy < const_pointer > ( _Mypair . _Myval2 . _Myptr ( ) ), :: std :: addressof ( _Mypair . _Myval2 ) );
    }

    [ [ nodiscard ] ] inline iterator end ( ) noexcept {
        return iterator (
            _Refancy < pointer > ( _Mypair . _Myval2 . _Myptr ( ) ) + static_cast < difference_type > ( _Mypair . _Myval2 . _Mysize ),
            :: std :: addressof ( _Mypair . _Myval2 ) );
    }

    [ [ nodiscard ] ] inline const_iterator end ( ) const noexcept {
        return const_iterator (
            _Refancy < const_pointer > ( _Mypair . _Myval2 . _Myptr ( ) ) + static_cast < difference_type > ( _Mypair . _Myval2 . _Mysize ),
            :: std :: addressof ( _Mypair . _Myval2 ) );
    }

    [ [ nodiscard ] ] inline _Elem * _Unchecked_begin ( ) noexcept {
        return _Mypair . _Myval2 . _Myptr ( );
    }

    [ [ nodiscard ] ] inline const _Elem * _Unchecked_begin ( ) const noexcept {
        return _Mypair . _Myval2 . _Myptr ( );
    }

    [ [ nodiscard ] ] inline _Elem * _Unchecked_end ( ) noexcept {
        return _Mypair . _Myval2 . _Myptr ( ) + _Mypair . _Myval2 . _Mysize;
    }

    [ [ nodiscard ] ] inline const _Elem * _Unchecked_end ( ) const noexcept {
        return _Mypair . _Myval2 . _Myptr ( ) + _Mypair . _Myval2 . _Mysize;
    }

    [ [ nodiscard ] ] inline reverse_iterator rbegin ( ) noexcept {
        return reverse_iterator ( end ( ) );
    }

    [ [ nodiscard ] ] inline const_reverse_iterator rbegin ( ) const noexcept {
        return const_reverse_iterator ( end ( ) );
    }

    [ [ nodiscard ] ] inline reverse_iterator rend ( ) noexcept {
        return reverse_iterator ( begin ( ) );
    }

    [ [ nodiscard ] ] inline const_reverse_iterator rend ( ) const noexcept {
        return const_reverse_iterator ( begin ( ) );
    }

    [ [ nodiscard ] ] inline const_iterator cbegin ( ) const noexcept {
        return begin ( );
    }

    [ [ nodiscard ] ] inline const_iterator cend ( ) const noexcept {
        return end ( );
    }

    [ [ nodiscard ] ] inline const_reverse_iterator crbegin ( ) const noexcept {
        return rbegin ( );
    }

    [ [ nodiscard ] ] inline const_reverse_iterator crend ( ) const noexcept {
        return rend ( );
    }

    inline void shrink_to_fit ( ) {
        auto & _My_data = _Mypair . _Myval2;

        if ( ! _My_data . _Large_mode_engaged ( ) ) {
            return;
        }

        if ( _My_data . _Mysize <= _Small_string_capacity ) {
            _Become_small ( );
            return;
        }

        size_type _Target_capacity = ( :: std :: min ) ( _My_data . _Mysize | _Alloc_mask, max_size ( ) );
        if ( _Target_capacity < _My_data . _Myres ) {
            auto & _Al = _Getal ( );
            const pointer _New_ptr =
                _Allocate_for_capacity < _Allocation_policy :: _Exactly > ( _Al, _Target_capacity );
            ;

            _My_data . _Orphan_all ( );
            _Traits :: copy ( _Unfancy ( _New_ptr ), _Unfancy ( _My_data . _Bx . _Ptr ), _My_data . _Mysize + 1 );
            _Deallocate_for_capacity ( _Al, _My_data . _Bx . _Ptr, _My_data . _Myres );
            _My_data . _Bx . _Ptr = _New_ptr;
            _My_data . _Myres = _Target_capacity;
            ;
        }
    }

    [ [ nodiscard ] ] inline reference at ( const size_type _Off ) {
        _Mypair . _Myval2 . _Check_offset_exclusive ( _Off );
        return _Mypair . _Myval2 . _Myptr ( ) [ _Off ];
    }

    [ [ nodiscard ] ] inline const_reference at ( const size_type _Off ) const {
        _Mypair . _Myval2 . _Check_offset_exclusive ( _Off );
        return _Mypair . _Myval2 . _Myptr ( ) [ _Off ];
    }

    [ [ nodiscard ] ] inline reference operator [ ] ( const size_type _Off ) noexcept {




        return _Mypair . _Myval2 . _Myptr ( ) [ _Off ];
    }

    [ [ nodiscard ] ] inline const_reference operator [ ] ( const size_type _Off ) const noexcept
     {




        return _Mypair . _Myval2 . _Myptr ( ) [ _Off ];
    }








    inline void push_back ( const _Elem _Ch ) {
        const size_type _Old_size = _Mypair . _Myval2 . _Mysize;
        if ( _Old_size < _Mypair . _Myval2 . _Myres ) {
            ;
            _Mypair . _Myval2 . _Mysize = _Old_size + 1;
            _Elem * const _Ptr = _Mypair . _Myval2 . _Myptr ( );
            _Traits :: assign ( _Ptr [ _Old_size ], _Ch );
            _Traits :: assign ( _Ptr [ _Old_size + 1 ], _Elem ( ) );
            return;
        }

        _Reallocate_grow_by (
            1,
            [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size, const _Elem _Ch )
                 {
                    _Traits :: copy ( _New_ptr, _Old_ptr, _Old_size );
                    _Traits :: assign ( _New_ptr [ _Old_size ], _Ch );
                    _Traits :: assign ( _New_ptr [ _Old_size + 1 ], _Elem ( ) );
                },
            _Ch );
    }

    inline void pop_back ( ) noexcept {
        const size_type _Old_size = _Mypair . _Myval2 . _Mysize;





        _Eos ( _Old_size - 1 );
    }

    [ [ nodiscard ] ] inline reference front ( ) noexcept {




        return _Mypair . _Myval2 . _Myptr ( ) [ 0 ];
    }

    [ [ nodiscard ] ] inline const_reference front ( ) const noexcept {




        return _Mypair . _Myval2 . _Myptr ( ) [ 0 ];
    }

    [ [ nodiscard ] ] inline reference back ( ) noexcept {




        return _Mypair . _Myval2 . _Myptr ( ) [ _Mypair . _Myval2 . _Mysize - 1 ];
    }

    [ [ nodiscard ] ] inline const_reference back ( ) const noexcept {




        return _Mypair . _Myval2 . _Myptr ( ) [ _Mypair . _Myval2 . _Mysize - 1 ];
    }

    [ [ nodiscard ] ] inline const _Elem * c_str ( ) const noexcept {
        return _Mypair . _Myval2 . _Myptr ( );
    }

    [ [ nodiscard ] ] inline const _Elem * data ( ) const noexcept {
        return _Mypair . _Myval2 . _Myptr ( );
    }







    [ [ nodiscard ] ] inline size_type length ( ) const noexcept {
        return _Mypair . _Myval2 . _Mysize;
    }

    [ [ nodiscard ] ] inline size_type size ( ) const noexcept {
        return _Mypair . _Myval2 . _Mysize;
    }

    [ [ nodiscard ] ] inline size_type max_size ( ) const noexcept {
        const size_type _Alloc_max = _Alty_traits :: max_size ( _Getal ( ) );
        const size_type _Storage_max =
            ( :: std :: max ) ( _Alloc_max, static_cast < size_type > ( _BUF_SIZE ) );
        return ( :: std :: min ) ( static_cast < size_type > ( :: std :: _Max_limit < difference_type > ( ) ),
            _Storage_max - 1
        );
    }

    inline void resize ( const size_type _New_size, const _Elem _Ch = _Elem ( ) ) {

        const size_type _Old_size = size ( );
        if ( _New_size <= _Old_size ) {
            _Eos ( _New_size );
        } else {
            append ( _New_size - _Old_size, _Ch );
        }
    }

    template < class _Operation >
    constexpr void



        _Resize_and_overwrite

        ( const size_type _New_size, _Operation _Op ) {
        if ( _Mypair . _Myval2 . _Myres < _New_size ) {
            _Reallocate_grow_by ( _New_size - _Mypair . _Myval2 . _Mysize,
                [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size )
                     { _Traits :: copy ( _New_ptr, _Old_ptr, _Old_size + 1 ); } );
        } else {
            ;
            _Mypair . _Myval2 . _Mysize = _New_size;
        }

        auto _Arg_ptr = _Mypair . _Myval2 . _Myptr ( );
        auto _Arg_size = _New_size;
        const auto _Result_size = :: std :: move ( _Op ) ( _Arg_ptr, _Arg_size );
        const auto _Result_as_size_type = static_cast < size_type > ( _Result_size );




        _Eos ( _Result_as_size_type );
    }








    [ [ nodiscard ] ] inline size_type capacity ( ) const noexcept {
        return _Mypair . _Myval2 . _Myres;
    }


























    void reserve ( const size_type _Newcap = 0 ) {
        if ( _Mypair . _Myval2 . _Mysize > _Newcap ) {
            return;
        }

        if ( _Mypair . _Myval2 . _Myres == _Newcap ) {
            return;
        }

        if ( _Mypair . _Myval2 . _Myres < _Newcap ) {
            const size_type _Old_size = _Mypair . _Myval2 . _Mysize;
            _Reallocate_grow_by ( _Newcap - _Old_size,
                [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size )
                     { _Traits :: copy ( _New_ptr, _Old_ptr, _Old_size + 1 ); } );




            ;
            _Mypair . _Myval2 . _Mysize = _Old_size;
            return;
        }

        if ( _Newcap <= _Small_string_capacity && _Mypair . _Myval2 . _Large_mode_engaged ( ) ) {

            _Become_small ( );
            return;
        }


    }


    [ [ nodiscard ( "This member function returns a bool indicating whether the collection is empty and has no other effects. It is not useful to cal" "l this member function and discard the return value. Use the \'clear()\' member function if you want to erase all elements." ) ] ] inline bool empty ( ) const noexcept {
        return _Mypair . _Myval2 . _Mysize == 0;
    }

    inline size_type copy (
          _Elem * const _Ptr, size_type _Count, const size_type _Off = 0 ) const {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        _Count = _Mypair . _Myval2 . _Clamp_suffix_size ( _Off, _Count );
        _Traits :: copy ( _Ptr, _Mypair . _Myval2 . _Myptr ( ) + _Off, _Count );
        return _Count;
    }

    inline size_type
        _Copy_s ( _Elem * const _Dest, const size_type _Dest_size, size_type _Count,
            const size_type _Off = 0 ) const {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        _Count = _Mypair . _Myval2 . _Clamp_suffix_size ( _Off, _Count );
        _Traits :: _Copy_s ( _Dest, _Dest_size, _Mypair . _Myval2 . _Myptr ( ) + _Off, _Count );
        return _Count;
    }

    static inline void _Swap_bx_large_with_small ( _Scary_val & _Starts_large, _Scary_val & _Starts_small ) noexcept {

        const pointer _Ptr = _Starts_large . _Bx . _Ptr;
        _Starts_large . _Bx . _Switch_to_buf ( );
        _Traits :: copy ( _Starts_large . _Bx . _Buf, _Starts_small . _Bx . _Buf, _BUF_SIZE );

        _Construct_in_place ( _Starts_small . _Bx . _Ptr, _Ptr );
    }

    inline void _Swap_data ( basic_string & _Right ) noexcept {
        using :: std :: swap;

        auto & _My_data = _Mypair . _Myval2;
        auto & _Right_data = _Right . _Mypair . _Myval2;


        if constexpr ( _Can_memcpy_val ) {



            {
                const auto _My_data_mem =
                    reinterpret_cast < unsigned char * > ( :: std :: addressof ( _My_data ) ) + _Memcpy_val_offset;
                const auto _Right_data_mem =
                    reinterpret_cast < unsigned char * > ( :: std :: addressof ( _Right_data ) ) + _Memcpy_val_offset;
                unsigned char _Temp_mem [ _Memcpy_val_size ];
                :: memcpy ( _Temp_mem, _My_data_mem, _Memcpy_val_size );
                :: memcpy ( _My_data_mem, _Right_data_mem, _Memcpy_val_size );
                :: memcpy ( _Right_data_mem, _Temp_mem, _Memcpy_val_size );

                return;
            }
        }


        const bool _My_large = _My_data . _Large_mode_engaged ( );
        const bool _Right_large = _Right_data . _Large_mode_engaged ( );

        if ( _My_large && _Right_large ) {
            swap ( _My_data . _Bx . _Ptr, _Right_data . _Bx . _Ptr );
        } else if ( _My_large ) {
            _Swap_bx_large_with_small ( _My_data, _Right_data );
        } else if ( _Right_large ) {
            _Swap_bx_large_with_small ( _Right_data, _My_data );
        } else {
            _Elem _Temp_buf [ _BUF_SIZE ];
            _Traits :: copy ( _Temp_buf, _My_data . _Bx . _Buf, _My_data . _Mysize + 1 );
            _Traits :: copy ( _My_data . _Bx . _Buf, _Right_data . _Bx . _Buf, _Right_data . _Mysize + 1 );
            _Traits :: copy ( _Right_data . _Bx . _Buf, _Temp_buf, _My_data . _Mysize + 1 );
        }

        :: std :: swap ( _My_data . _Mysize, _Right_data . _Mysize );
        :: std :: swap ( _My_data . _Myres, _Right_data . _Myres );
    }

    inline void swap ( basic_string & _Right ) noexcept {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Pocs ( _Getal ( ), _Right . _Getal ( ) );
















            _Swap_data ( _Right );
        }
    }












    [ [ nodiscard ] ] inline size_type find ( const basic_string & _Right, const size_type _Off = 0 ) const noexcept {

        return static_cast < size_type > ( _Traits_find < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off,
            _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize ) );
    }

    [ [ nodiscard ] ] inline size_type find ( const _Elem * const _Ptr, const size_type _Off,
        const size_type _Count ) const noexcept {

        return static_cast < size_type > (
            _Traits_find < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ptr, _Count ) );
    }

    [ [ nodiscard ] ] inline size_type find ( const _Elem * const _Ptr, const size_type _Off = 0 ) const noexcept
     {

        return static_cast < size_type > ( _Traits_find < _Traits > (
            _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ptr, _Traits :: length ( _Ptr ) ) );
    }

    [ [ nodiscard ] ] inline size_type find ( const _Elem _Ch, const size_type _Off = 0 ) const noexcept {

        return static_cast < size_type > (
            _Traits_find_ch < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ch ) );
    }












    [ [ nodiscard ] ] inline size_type rfind ( const basic_string & _Right, const size_type _Off = npos ) const noexcept {

        return static_cast < size_type > ( _Traits_rfind < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off,
            _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize ) );
    }

    [ [ nodiscard ] ] inline size_type rfind ( const _Elem * const _Ptr, const size_type _Off,
        const size_type _Count ) const noexcept {

        return static_cast < size_type > (
            _Traits_rfind < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ptr, _Count ) );
    }

    [ [ nodiscard ] ] inline size_type rfind ( const _Elem * const _Ptr, const size_type _Off = npos ) const noexcept
     {

        return static_cast < size_type > ( _Traits_rfind < _Traits > (
            _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ptr, _Traits :: length ( _Ptr ) ) );
    }

    [ [ nodiscard ] ] inline size_type rfind ( const _Elem _Ch, const size_type _Off = npos ) const noexcept {

        return static_cast < size_type > (
            _Traits_rfind_ch < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ch ) );
    }












    [ [ nodiscard ] ] inline size_type find_first_of (
        const basic_string & _Right, const size_type _Off = 0 ) const noexcept {

        return static_cast < size_type > ( _Traits_find_first_of < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize,
            _Off, _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize ) );
    }

    [ [ nodiscard ] ] inline size_type find_first_of ( const _Elem * const _Ptr, const size_type _Off,
        const size_type _Count ) const noexcept {

        return static_cast < size_type > (
            _Traits_find_first_of < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ptr, _Count ) );
    }

    [ [ nodiscard ] ] inline size_type find_first_of (
          const _Elem * const _Ptr, const size_type _Off = 0 ) const noexcept
     {

        return static_cast < size_type > ( _Traits_find_first_of < _Traits > (
            _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ptr, _Traits :: length ( _Ptr ) ) );
    }

    [ [ nodiscard ] ] inline size_type find_first_of ( const _Elem _Ch, const size_type _Off = 0 ) const noexcept {

        return static_cast < size_type > (
            _Traits_find_ch < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ch ) );
    }












    [ [ nodiscard ] ] inline size_type find_last_of ( const basic_string & _Right, size_type _Off = npos ) const noexcept {

        return static_cast < size_type > ( _Traits_find_last_of < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize,
            _Off, _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize ) );
    }

    [ [ nodiscard ] ] inline size_type find_last_of ( const _Elem * const _Ptr, const size_type _Off,
        const size_type _Count ) const noexcept {

        return static_cast < size_type > (
            _Traits_find_last_of < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ptr, _Count ) );
    }

    [ [ nodiscard ] ] inline size_type find_last_of (
          const _Elem * const _Ptr, const size_type _Off = npos ) const noexcept {

        return static_cast < size_type > ( _Traits_find_last_of < _Traits > (
            _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ptr, _Traits :: length ( _Ptr ) ) );
    }

    [ [ nodiscard ] ] inline size_type find_last_of ( const _Elem _Ch, const size_type _Off = npos ) const noexcept {

        return static_cast < size_type > (
            _Traits_rfind_ch < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ch ) );
    }












    [ [ nodiscard ] ] inline size_type find_first_not_of (
        const basic_string & _Right, const size_type _Off = 0 ) const noexcept {

        return static_cast < size_type > ( _Traits_find_first_not_of < _Traits > ( _Mypair . _Myval2 . _Myptr ( ),
            _Mypair . _Myval2 . _Mysize, _Off, _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize ) );
    }

    [ [ nodiscard ] ] inline size_type find_first_not_of ( const _Elem * const _Ptr,
        const size_type _Off, const size_type _Count ) const noexcept {

        return static_cast < size_type > (
            _Traits_find_first_not_of < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ptr, _Count ) );
    }

    [ [ nodiscard ] ] inline size_type find_first_not_of (
          const _Elem * const _Ptr, size_type _Off = 0 ) const noexcept
     {

        return static_cast < size_type > ( _Traits_find_first_not_of < _Traits > (
            _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ptr, _Traits :: length ( _Ptr ) ) );
    }

    [ [ nodiscard ] ] inline size_type find_first_not_of ( const _Elem _Ch, const size_type _Off = 0 ) const noexcept {

        return static_cast < size_type > (
            _Traits_find_not_ch < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ch ) );
    }












    [ [ nodiscard ] ] inline size_type find_last_not_of (
        const basic_string & _Right, const size_type _Off = npos ) const noexcept {

        return static_cast < size_type > ( _Traits_find_last_not_of < _Traits > ( _Mypair . _Myval2 . _Myptr ( ),
            _Mypair . _Myval2 . _Mysize, _Off, _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize ) );
    }

    [ [ nodiscard ] ] inline size_type find_last_not_of ( const _Elem * const _Ptr, const size_type _Off,
        const size_type _Count ) const noexcept {

        return static_cast < size_type > (
            _Traits_find_last_not_of < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ptr, _Count ) );
    }

    [ [ nodiscard ] ] inline size_type find_last_not_of (
          const _Elem * const _Ptr, const size_type _Off = npos ) const noexcept {

        return static_cast < size_type > ( _Traits_find_last_not_of < _Traits > (
            _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ptr, _Traits :: length ( _Ptr ) ) );
    }

    [ [ nodiscard ] ] inline size_type find_last_not_of ( const _Elem _Ch, const size_type _Off = npos ) const noexcept {

        return static_cast < size_type > (
            _Traits_rfind_not_ch < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ch ) );
    }








    [ [ nodiscard ] ] inline basic_string substr ( const size_type _Off = 0, const size_type _Count = npos )



        const

    {

        return basic_string { * this, _Off, _Count };
    }








    inline bool _Equal ( const basic_string & _Right ) const noexcept {

        return _Traits_equal < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize,
            _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
    }

    inline bool _Equal ( const _Elem * const _Ptr ) const noexcept {

        return _Traits_equal < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Ptr, _Traits :: length ( _Ptr ) );
    }
































    [ [ nodiscard ] ] inline int compare ( const basic_string & _Right ) const noexcept {

        return _Traits_compare < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize,
            _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
    }

    [ [ nodiscard ] ] inline int compare ( size_type _Off, size_type _Nx, const basic_string & _Right ) const {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        return _Traits_compare < _Traits > ( _Mypair . _Myval2 . _Myptr ( ) + _Off, _Mypair . _Myval2 . _Clamp_suffix_size ( _Off, _Nx ),
            _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
    }

    [ [ nodiscard ] ] inline int compare ( const size_type _Off, const size_type _Nx, const basic_string & _Right,
        const size_type _Roff, const size_type _Count = npos ) const {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        _Right . _Mypair . _Myval2 . _Check_offset ( _Roff );
        return _Traits_compare < _Traits > ( _Mypair . _Myval2 . _Myptr ( ) + _Off, _Mypair . _Myval2 . _Clamp_suffix_size ( _Off, _Nx ),
            _Right . _Mypair . _Myval2 . _Myptr ( ) + _Roff, _Right . _Mypair . _Myval2 . _Clamp_suffix_size ( _Roff, _Count ) );
    }

    [ [ nodiscard ] ] inline int compare ( const _Elem * const _Ptr ) const noexcept {

        return _Traits_compare < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Ptr, _Traits :: length ( _Ptr ) );
    }

    [ [ nodiscard ] ] inline int compare (
        const size_type _Off, const size_type _Nx, const _Elem * const _Ptr ) const {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        return _Traits_compare < _Traits > ( _Mypair . _Myval2 . _Myptr ( ) + _Off, _Mypair . _Myval2 . _Clamp_suffix_size ( _Off, _Nx ),
            _Ptr, _Traits :: length ( _Ptr ) );
    }

    [ [ nodiscard ] ] inline int compare ( const size_type _Off, const size_type _Nx,
          const _Elem * const _Ptr, const size_type _Count ) const {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        return _Traits_compare < _Traits > (
            _Mypair . _Myval2 . _Myptr ( ) + _Off, _Mypair . _Myval2 . _Clamp_suffix_size ( _Off, _Nx ), _Ptr, _Count );
    }









































    [ [ nodiscard ] ] inline allocator_type get_allocator ( ) const noexcept {
        return static_cast < allocator_type > ( _Getal ( ) );
    }

private :
    [ [ nodiscard ] ] static inline size_type _Calculate_growth (
        const size_type _Requested, const size_type _Old, const size_type _Max ) noexcept {
        const size_type _Masked = _Requested | _Alloc_mask;
        if ( _Masked > _Max ) {
            return _Max;
        }

        if ( _Old > _Max - _Old / 2 ) {
            return _Max;
        }

        return ( :: std :: max ) ( _Masked, _Old + _Old / 2 );
    }

    [ [ nodiscard ] ] inline size_type _Calculate_growth ( const size_type _Requested ) const noexcept {
        return _Calculate_growth ( _Requested, _Mypair . _Myval2 . _Myres, max_size ( ) );
    }

    template < class _Fty, class ... _ArgTys >
    inline basic_string & _Reallocate_for ( const size_type _New_size, _Fty _Fn, _ArgTys ... _Args ) {


        if ( _New_size > max_size ( ) ) {
            _Xlen_string ( );
        }

        const size_type _Old_capacity = _Mypair . _Myval2 . _Myres;
        size_type _New_capacity = _Calculate_growth ( _New_size );
        auto & _Al = _Getal ( );
        const pointer _New_ptr = _Allocate_for_capacity ( _Al, _New_capacity );

        _Mypair . _Myval2 . _Orphan_all ( );
        ;
        _Mypair . _Myval2 . _Mysize = _New_size;
        _Mypair . _Myval2 . _Myres = _New_capacity;
        _Fn ( _Unfancy ( _New_ptr ), _New_size, _Args ... );
        if ( _Old_capacity > _Small_string_capacity ) {
            _Deallocate_for_capacity ( _Al, _Mypair . _Myval2 . _Bx . _Ptr, _Old_capacity );
            _Mypair . _Myval2 . _Bx . _Ptr = _New_ptr;
        } else {
            _Construct_in_place ( _Mypair . _Myval2 . _Bx . _Ptr, _New_ptr );
        }

        ;
        return * this;
    }

    template < class _Fty, class ... _ArgTys >
    inline basic_string & _Reallocate_grow_by ( const size_type _Size_increase, _Fty _Fn, _ArgTys ... _Args ) {


        auto & _My_data = _Mypair . _Myval2;
        const size_type _Old_size = _My_data . _Mysize;
        if ( max_size ( ) - _Old_size < _Size_increase ) {
            _Xlen_string ( );
        }

        const size_type _New_size = _Old_size + _Size_increase;
        const size_type _Old_capacity = _My_data . _Myres;
        size_type _New_capacity = _Calculate_growth ( _New_size );
        auto & _Al = _Getal ( );
        const pointer _New_ptr = _Allocate_for_capacity ( _Al, _New_capacity );

        _My_data . _Orphan_all ( );
        ;
        _My_data . _Mysize = _New_size;
        _My_data . _Myres = _New_capacity;
        _Elem * const _Raw_new = _Unfancy ( _New_ptr );
        if ( _Old_capacity > _Small_string_capacity ) {
            const pointer _Old_ptr = _My_data . _Bx . _Ptr;
            _Fn ( _Raw_new, _Unfancy ( _Old_ptr ), _Old_size, _Args ... );
            _Deallocate_for_capacity ( _Al, _Old_ptr, _Old_capacity );
            _My_data . _Bx . _Ptr = _New_ptr;
        } else {
            _Fn ( _Raw_new, _My_data . _Bx . _Buf, _Old_size, _Args ... );
            _Construct_in_place ( _My_data . _Bx . _Ptr, _New_ptr );
        }

        ;
        return * this;
    }

    inline void _Become_small ( ) noexcept {

        auto & _My_data = _Mypair . _Myval2;
        ;
        ;

        _My_data . _Orphan_all ( );
        ;
        const pointer _Ptr = _My_data . _Bx . _Ptr;
        _My_data . _Bx . _Switch_to_buf ( );
        _Traits :: copy ( _My_data . _Bx . _Buf, _Unfancy ( _Ptr ), _My_data . _Mysize + 1 );
        auto & _Al = _Getal ( );
        _Deallocate_for_capacity ( _Al, _Ptr, _My_data . _Myres );
        _My_data . _Myres = _Small_string_capacity;
    }

    inline void _Eos ( const size_type _New_size ) noexcept {
        ;
        _Mypair . _Myval2 . _Mysize = _New_size;
        _Traits :: assign ( _Mypair . _Myval2 . _Myptr ( ) [ _New_size ], _Elem ( ) );
    }

    inline void _Tidy_deallocate ( ) noexcept {
        auto & _My_data = _Mypair . _Myval2;
        _My_data . _Orphan_all ( );
        if ( _My_data . _Large_mode_engaged ( ) ) {
            ;
            auto & _Al = _Getal ( );
            _Deallocate_for_capacity ( _Al, _My_data . _Bx . _Ptr, _My_data . _Myres );
            _My_data . _Bx . _Switch_to_buf ( );
        }

        _My_data . _Mysize = 0;
        _My_data . _Myres = _Small_string_capacity;

        _Traits :: assign ( _My_data . _Bx . _Buf [ 0 ], _Elem ( ) );
    }

public :
    inline void _Orphan_all ( ) noexcept {
        _Mypair . _Myval2 . _Orphan_all ( );
    }

private :
    inline void _Swap_proxy_and_iterators ( basic_string & _Right ) noexcept {
        _Mypair . _Myval2 . _Swap_proxy_and_iterators ( _Right . _Mypair . _Myval2 );
    }

    inline _Alty & _Getal ( ) noexcept {
        return _Mypair . _Get_first ( );
    }

    inline const _Alty & _Getal ( ) const noexcept {
        return _Mypair . _Get_first ( );
    }

    _Compressed_pair < _Alty, _Scary_val > _Mypair;
};
#line 3140 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xstring"
template < class _Elem, class _Traits, class _Alloc >
inline void swap ( basic_string < _Elem, _Traits, _Alloc > & _Left,
    basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept {
    _Left . swap ( _Right );
}
#line 3146
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) {
    const auto _Left_size = _Left . size ( );
    const auto _Right_size = _Right . size ( );
    if ( _Left . max_size ( ) - _Left_size < _Right_size ) {
        _Xlen_string ( );
    }

    return { _String_constructor_concat_tag { }, _Left, _Left . c_str ( ), _Left_size, _Right . c_str ( ), _Right_size };
}
#line 3158
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
      const _Elem * const _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) {
    using _Size_type = typename basic_string < _Elem, _Traits, _Alloc > :: size_type;
    const auto _Left_size = _Convert_size < _Size_type > ( _Traits :: length ( _Left ) );
    const auto _Right_size = _Right . size ( );
    if ( _Right . max_size ( ) - _Right_size < _Left_size ) {
        _Xlen_string ( );
    }

    return { _String_constructor_concat_tag { }, _Right, _Left, _Left_size, _Right . c_str ( ), _Right_size };
}
#line 3171
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
    const _Elem _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) {
    const auto _Right_size = _Right . size ( );
    if ( _Right_size == _Right . max_size ( ) ) {
        _Xlen_string ( );
    }

    return { _String_constructor_concat_tag { }, _Right, :: std :: addressof ( _Left ), 1, _Right . c_str ( ), _Right_size };
}
#line 3182
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, const _Elem * const _Right ) {
    using _Size_type = typename basic_string < _Elem, _Traits, _Alloc > :: size_type;
    const auto _Left_size = _Left . size ( );
    const auto _Right_size = _Convert_size < _Size_type > ( _Traits :: length ( _Right ) );
    if ( _Left . max_size ( ) - _Left_size < _Right_size ) {
        _Xlen_string ( );
    }

    return { _String_constructor_concat_tag { }, _Left, _Left . c_str ( ), _Left_size, _Right, _Right_size };
}
#line 3195
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, const _Elem _Right ) {
    const auto _Left_size = _Left . size ( );
    if ( _Left_size == _Left . max_size ( ) ) {
        _Xlen_string ( );
    }

    return { _String_constructor_concat_tag { }, _Left, _Left . c_str ( ), _Left_size, :: std :: addressof ( _Right ), 1 };
}
#line 3206
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, basic_string < _Elem, _Traits, _Alloc > && _Right ) {
    return :: std :: move ( _Right . insert ( 0, _Left ) );
}
#line 3212
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
    basic_string < _Elem, _Traits, _Alloc > && _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) {
    return :: std :: move ( _Left . append ( _Right ) );
}
#line 3218
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
    basic_string < _Elem, _Traits, _Alloc > && _Left, basic_string < _Elem, _Traits, _Alloc > && _Right ) {







    return { _String_constructor_concat_tag { }, _Left, _Right };
}
#line 3231 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xstring"
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
      const _Elem * const _Left, basic_string < _Elem, _Traits, _Alloc > && _Right ) {
    return :: std :: move ( _Right . insert ( 0, _Left ) );
}
#line 3237
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
    const _Elem _Left, basic_string < _Elem, _Traits, _Alloc > && _Right ) {
    return :: std :: move ( _Right . insert ( 0, 1, _Left ) );
}
#line 3243
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
    basic_string < _Elem, _Traits, _Alloc > && _Left, const _Elem * const _Right ) {
    return :: std :: move ( _Left . append ( _Right ) );
}
#line 3249
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
    basic_string < _Elem, _Traits, _Alloc > && _Left, const _Elem _Right ) {
    _Left . push_back ( _Right );
    return :: std :: move ( _Left );
}
#line 3256
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline bool operator == (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept {
    return _Left . _Equal ( _Right );
}
#line 3262
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline bool operator == (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, const _Elem * const _Right ) noexcept {
    return _Left . _Equal ( _Right );
}
#line 3281 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xstring"
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator == ( const _Elem * const _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept
 {
    return _Right . _Equal ( _Left );
}
#line 3287
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator != (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept {
    return ! ( _Left == _Right );
}
#line 3293
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator != ( const _Elem * const _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept
 {
    return ! ( _Left == _Right );
}
#line 3299
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator != ( const basic_string < _Elem, _Traits, _Alloc > & _Left, const _Elem * const _Right ) noexcept
 {
    return ! ( _Left == _Right );
}
#line 3305
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator < (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept {
    return _Left . compare ( _Right ) < 0;
}
#line 3311
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator < ( const _Elem * const _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept
 {
    return _Right . compare ( _Left ) > 0;
}
#line 3317
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator < ( const basic_string < _Elem, _Traits, _Alloc > & _Left, const _Elem * const _Right ) noexcept
 {
    return _Left . compare ( _Right ) < 0;
}
#line 3323
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator > (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept {
    return _Right < _Left;
}
#line 3329
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator > ( const _Elem * const _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept
 {
    return _Right < _Left;
}
#line 3335
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator > ( const basic_string < _Elem, _Traits, _Alloc > & _Left, const _Elem * const _Right ) noexcept
 {
    return _Right < _Left;
}
#line 3341
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator <= (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept {
    return ! ( _Right < _Left );
}
#line 3347
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator <= ( const _Elem * const _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept
 {
    return ! ( _Right < _Left );
}
#line 3353
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator <= ( const basic_string < _Elem, _Traits, _Alloc > & _Left, const _Elem * const _Right ) noexcept
 {
    return ! ( _Right < _Left );
}
#line 3359
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator >= (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept {
    return ! ( _Left < _Right );
}
#line 3365
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator >= ( const _Elem * const _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept
 {
    return ! ( _Left < _Right );
}
#line 3371
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator >= ( const basic_string < _Elem, _Traits, _Alloc > & _Left, const _Elem * const _Right ) noexcept
 {
    return ! ( _Left < _Right );
}
#line 3378 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xstring"
using string = basic_string< char, char_traits< char> , allocator< char> > ; 
#line 3379
using wstring = basic_string< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > ; 
#line 3383
using u16string = basic_string< char16_t, char_traits< char16_t> , allocator< char16_t> > ; 
#line 3384
using u32string = basic_string< char32_t, char_traits< char32_t> , allocator< char32_t> > ; 
#line 3386
template < class _Elem, class _Alloc >
struct hash < basic_string < _Elem, char_traits < _Elem >, _Alloc > >
    : _Conditionally_enabled_hash < basic_string < _Elem, char_traits < _Elem >, _Alloc >, _Is_EcharT < _Elem > > {
    [ [ nodiscard ] ] static size_t _Do_hash ( const basic_string < _Elem, char_traits < _Elem >, _Alloc > & _Keyval ) noexcept {
        return _Hash_array_representation ( _Keyval . c_str ( ), _Keyval . size ( ) );
    }
};
#line 3394
template < class _Elem, class _Traits, class _Alloc >
basic_istream < _Elem, _Traits > & operator >> (
    basic_istream < _Elem, _Traits > & _Istr, basic_string < _Elem, _Traits, _Alloc > & _Str ) {
    using _Myis = basic_istream < _Elem, _Traits >;
    using _Ctype = typename _Myis :: _Ctype;
    using _Mystr = basic_string < _Elem, _Traits, _Alloc >;
    using _Mysizt = typename _Mystr :: size_type;

    typename _Myis :: iostate _State = _Myis :: goodbit;
    bool _Changed = false;
    const typename _Myis :: sentry _Ok ( _Istr );

    if ( _Ok ) {
        const _Ctype & _Ctype_fac = :: std :: use_facet < _Ctype > ( _Istr . getloc ( ) );
        _Str . erase ( );

        try {
        _Mysizt _Size;
        if ( 0 < _Istr . width ( ) && static_cast < _Mysizt > ( _Istr . width ( ) ) < _Str . max_size ( ) ) {
            _Size = static_cast < _Mysizt > ( _Istr . width ( ) );
        } else {
            _Size = _Str . max_size ( );
        }

        typename _Traits :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );

        for (; 0 < _Size; -- _Size, _Meta = _Istr . rdbuf ( ) -> snextc ( ) ) {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                _State |= _Myis :: eofbit;
                break;
            } else if ( _Ctype_fac . is ( _Ctype :: space, _Traits :: to_char_type ( _Meta ) ) ) {
                break;
            } else {
                _Str . push_back ( _Traits :: to_char_type ( _Meta ) );
                _Changed = true;
            }
        }
        } catch ( ... ) { ( _Istr ) . setstate ( _Myis :: badbit, true ); }
    }

    _Istr . width ( 0 );
    if ( ! _Changed ) {
        _State |= _Myis :: failbit;
    }

    _Istr . setstate ( _State );
    return _Istr;
}
#line 3443
template < class _Elem, class _Traits, class _Alloc >
basic_ostream < _Elem, _Traits > & operator << (
    basic_ostream < _Elem, _Traits > & _Ostr, const basic_string < _Elem, _Traits, _Alloc > & _Str ) {
    return _Insert_string ( _Ostr, _Str . data ( ), _Str . size ( ) );
}
#line 3449
inline namespace literals { 
#line 3450
inline namespace string_literals { 
#line 3451
[[nodiscard]] inline string operator ""s(const char *_Str, size_t _Len) { 
#line 3452
return string{_Str, _Len}; 
#line 3453
} 
#line 3455
[[nodiscard]] inline wstring operator ""s(const __wchar_t *_Str, size_t _Len) { 
#line 3456
return wstring{_Str, _Len}; 
#line 3457
} 
#line 3465
[[nodiscard]] inline u16string operator ""s(const char16_t *_Str, size_t _Len) { 
#line 3466
return u16string{_Str, _Len}; 
#line 3467
} 
#line 3469
[[nodiscard]] inline u32string operator ""s(const char32_t *_Str, size_t _Len) { 
#line 3470
return u32string{_Str, _Len}; 
#line 3471
} 
#line 3472
}
#line 3473
}
#line 3503 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xstring"
}
#line 3512
#pragma warning(pop)
#pragma pack ( pop )
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\stdexcept"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 19
namespace std { 
#line 20
class [[nodiscard]] logic_error : public exception { 
#line 22
public: using _Mybase = exception; 
#line 24
explicit logic_error(const string &_Message) : _Mybase(_Message.c_str()) { } 
#line 26
explicit logic_error(const char *_Message) : _Mybase(_Message) { } 
#line 34 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\stdexcept"
}; 
#line 36
class [[nodiscard]] domain_error : public logic_error { 
#line 38
public: using _Mybase = logic_error; 
#line 40
explicit domain_error(const string &_Message) : _Mybase(_Message.c_str()) { } 
#line 42
explicit domain_error(const char *_Message) : _Mybase(_Message) { } 
#line 50 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\stdexcept"
}; 
#line 52
class [[nodiscard]] invalid_argument : public logic_error { 
#line 54
public: using _Mybase = logic_error; 
#line 56
explicit invalid_argument(const string &_Message) : _Mybase(_Message.c_str()) { } 
#line 58
explicit invalid_argument(const char *_Message) : _Mybase(_Message) { } 
#line 66 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\stdexcept"
}; 
#line 68
class [[nodiscard]] length_error : public logic_error { 
#line 70
public: using _Mybase = logic_error; 
#line 72
explicit length_error(const string &_Message) : _Mybase(_Message.c_str()) { } 
#line 74
explicit length_error(const char *_Message) : _Mybase(_Message) { } 
#line 82 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\stdexcept"
}; 
#line 84
class [[nodiscard]] out_of_range : public logic_error { 
#line 86
public: using _Mybase = logic_error; 
#line 88
explicit out_of_range(const string &_Message) : _Mybase(_Message.c_str()) { } 
#line 90
explicit out_of_range(const char *_Message) : _Mybase(_Message) { } 
#line 98 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\stdexcept"
}; 
#line 100
class [[nodiscard]] runtime_error : public exception { 
#line 102
public: using _Mybase = exception; 
#line 104
explicit runtime_error(const string &_Message) : _Mybase(_Message.c_str()) { } 
#line 106
explicit runtime_error(const char *_Message) : _Mybase(_Message) { } 
#line 114 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\stdexcept"
}; 
#line 116
class [[nodiscard]] overflow_error : public runtime_error { 
#line 118
public: using _Mybase = runtime_error; 
#line 120
explicit overflow_error(const string &_Message) : _Mybase(_Message.c_str()) { } 
#line 122
explicit overflow_error(const char *_Message) : _Mybase(_Message) { } 
#line 130 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\stdexcept"
}; 
#line 132
class [[nodiscard]] underflow_error : public runtime_error { 
#line 134
public: using _Mybase = runtime_error; 
#line 136
explicit underflow_error(const string &_Message) : _Mybase(_Message.c_str()) { } 
#line 138
explicit underflow_error(const char *_Message) : _Mybase(_Message) { } 
#line 146 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\stdexcept"
}; 
#line 148
class [[nodiscard]] range_error : public runtime_error { 
#line 150
public: using _Mybase = runtime_error; 
#line 152
explicit range_error(const string &_Message) : _Mybase(_Message.c_str()) { } 
#line 154
explicit range_error(const char *_Message) : _Mybase(_Message) { } 
#line 162 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\stdexcept"
}; 
#line 164
[[noreturn]] inline void _Throw_range_error(const char *const _Message) { 
#line 165
throw range_error{_Message}; 
#line 166
} 
#line 167
}
#line 170
#pragma warning(pop)
#pragma pack ( pop )
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xcall_once.h"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 21
namespace std { 
#line 22
struct once_flag { 
#line 23
constexpr once_flag() noexcept : _Opaque((nullptr)) { } 
#line 25
once_flag(const once_flag &) = delete;
#line 26
once_flag &operator=(const once_flag &) = delete;
#line 28
void *_Opaque; 
#line 29
}; 
#line 31
template < class _Ty >
union _Immortalizer_impl {
    constexpr _Immortalizer_impl ( ) noexcept : _Storage { } { }
    _Immortalizer_impl ( const _Immortalizer_impl & ) = delete;
    _Immortalizer_impl & operator = ( const _Immortalizer_impl & ) = delete;
    ~ _Immortalizer_impl ( ) {

    }

    _Ty _Storage;
};
#line 61 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xcall_once.h"
extern "C" [[nodiscard]] __declspec(dllimport) int __stdcall __std_init_once_begin_initialize(void ** _LpInitOnce, unsigned long _DwFlags, int * _FPending, void ** _LpContext) noexcept; 
#line 72
extern "C" [[nodiscard]] __declspec(dllimport) int __stdcall __std_init_once_complete(void ** _LpInitOnce, unsigned long _DwFlags, void * _LpContext) noexcept; 
#line 75
extern "C" [[noreturn]] void __stdcall __std_init_once_link_alternate_names_and_abort() noexcept; 
#line 79
constexpr unsigned long _Init_once_init_failed = 4UL; 
#line 81
struct _Init_once_completer { 
#line 82
once_flag &_Once; 
#line 83
unsigned long _DwFlags; 
#line 84
~_Init_once_completer() { 
#line 85
if (!(__std_init_once_complete(&((_Once)._Opaque), _DwFlags, nullptr))) { 
#line 86
__std_init_once_link_alternate_names_and_abort(); 
#line 87
}  
#line 88
} 
#line 89
}; 
#line 91
template < class _Fn, class ... _Args >
void ( call_once ) ( once_flag & _Once, _Fn && _Fx, _Args && ... _Ax )
    noexcept ( noexcept ( :: std :: invoke ( :: std :: forward < _Fn > ( _Fx ), :: std :: forward < _Args > ( _Ax ) ... ) ) ) {


    int _Pending;
    if ( ! __std_init_once_begin_initialize ( & _Once . _Opaque, 0, & _Pending, nullptr ) ) {
        :: abort ( );
    }

    if ( _Pending != 0 ) {
        _Init_once_completer _Op { _Once, _Init_once_init_failed };
        :: std :: invoke ( :: std :: forward < _Fn > ( _Fx ), :: std :: forward < _Args > ( _Ax ) ... );
        _Op . _DwFlags = 0;
    }
}
#line 110
}
#line 114
#pragma warning(pop)
#pragma pack ( pop )
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xerrc.h"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 18
namespace std { 
#line 19
enum class errc { 
#line 20
address_family_not_supported = 102, 
#line 21
address_in_use = 100, 
#line 22
address_not_available, 
#line 23
already_connected = 113, 
#line 24
argument_list_too_long = 7, 
#line 25
argument_out_of_domain = 33, 
#line 26
bad_address = 14, 
#line 27
bad_file_descriptor = 9, 
#line 28
bad_message = 104, 
#line 29
broken_pipe = 32, 
#line 30
connection_aborted = 106, 
#line 31
connection_already_in_progress = 103, 
#line 32
connection_refused = 107, 
#line 33
connection_reset, 
#line 34
cross_device_link = 18, 
#line 35
destination_address_required = 109, 
#line 36
device_or_resource_busy = 16, 
#line 37
directory_not_empty = 41, 
#line 38
executable_format_error = 8, 
#line 39
file_exists = 17, 
#line 40
file_too_large = 27, 
#line 41
filename_too_long = 38, 
#line 42
function_not_supported = 40, 
#line 43
host_unreachable = 110, 
#line 44
identifier_removed, 
#line 45
illegal_byte_sequence = 42, 
#line 46
inappropriate_io_control_operation = 25, 
#line 47
interrupted = 4, 
#line 48
invalid_argument = 22, 
#line 49
invalid_seek = 29, 
#line 50
io_error = 5, 
#line 51
is_a_directory = 21, 
#line 52
message_size = 115, 
#line 53
network_down, 
#line 54
network_reset, 
#line 55
network_unreachable, 
#line 56
no_buffer_space, 
#line 57
no_child_process = 10, 
#line 58
no_link = 121, 
#line 59
no_lock_available = 39, 
#line 60
no_message_available = 120, 
#line 61
no_message = 122, 
#line 62
no_protocol_option, 
#line 63
no_space_on_device = 28, 
#line 64
no_stream_resources = 124, 
#line 65
no_such_device_or_address = 6, 
#line 66
no_such_device = 19, 
#line 67
no_such_file_or_directory = 2, 
#line 68
no_such_process, 
#line 69
not_a_directory = 20, 
#line 70
not_a_socket = 128, 
#line 71
not_a_stream = 125, 
#line 72
not_connected, 
#line 73
not_enough_memory = 12, 
#line 74
not_supported = 129, 
#line 75
operation_canceled = 105, 
#line 76
operation_in_progress = 112, 
#line 77
operation_not_permitted = 1, 
#line 78
operation_not_supported = 130, 
#line 79
operation_would_block = 140, 
#line 80
owner_dead = 133, 
#line 81
permission_denied = 13, 
#line 82
protocol_error = 134, 
#line 83
protocol_not_supported, 
#line 84
read_only_file_system = 30, 
#line 85
resource_deadlock_would_occur = 36, 
#line 86
resource_unavailable_try_again = 11, 
#line 87
result_out_of_range = 34, 
#line 88
state_not_recoverable = 127, 
#line 89
stream_timeout = 137, 
#line 90
text_file_busy = 139, 
#line 91
timed_out = 138, 
#line 92
too_many_files_open_in_system = 23, 
#line 93
too_many_files_open, 
#line 94
too_many_links = 31, 
#line 95
too_many_symbolic_link_levels = 114, 
#line 96
value_too_large = 132, 
#line 97
wrong_protocol_type = 136
#line 98
}; 
#line 100
}
#line 104
#pragma warning(pop)
#pragma pack ( pop )
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_threads_core.hpp"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 19
extern "C" {
#line 20
using _Thrd_id_t = unsigned; 
#line 21
struct _Thrd_t { 
#line 22
void *_Hnd; 
#line 23
_Thrd_id_t _Id; 
#line 24
}; 
#line 26
using _Smtx_t = void *; 
#line 28
enum class _Thrd_result: int { _Success, _Nomem, _Timedout, _Busy, _Error}; 
#line 30
struct _Stl_critical_section { 
#line 31
void *_Unused = (nullptr); 
#line 32
_Smtx_t _M_srw_lock = (nullptr); 
#line 33
}; 
#line 35
struct _Mtx_internal_imp_t { 
#line 38
static constexpr size_t _Critical_section_size = (64); 
#line 43 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_threads_core.hpp"
int _Type{0}; 
#line 44
union { 
#line 45
_Stl_critical_section _Critical_section{}; 
#line 46
std::_Aligned_storage_t< _Critical_section_size, 8Ui64>  _Cs_storage; 
#line 47
}; 
#line 48
long _Thread_id{0L}; 
#line 49
int _Count{0}; 
#line 50
}; 
#line 52
using _Mtx_t = _Mtx_internal_imp_t *; 
#line 54
struct _Stl_condition_variable { 
#line 55
void *_Unused = (nullptr); 
#line 56
void *_Win_cv = (nullptr); 
#line 57
}; 
#line 59
#pragma warning(push)
#pragma warning(disable : 26495)
struct _Cnd_internal_imp_t { 
#line 64
static constexpr size_t _Cnd_internal_imp_size = (72); 
#line 69 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_threads_core.hpp"
union { 
#line 70
_Stl_condition_variable _Stl_cv{}; 
#line 71
std::_Aligned_storage_t< _Cnd_internal_imp_size, 8Ui64>  _Cv_storage; 
#line 72
}; 
#line 73
}; 
#pragma warning(pop)
#line 76
using _Cnd_t = _Cnd_internal_imp_t *; 
#line 77
}
#line 81
#pragma warning(pop)
#pragma pack ( pop )
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ctime"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 20
namespace std { 
#line 21
using ::clock_t;
#line 23
using ::time_t;
#line 25
using ::asctime;
#line 26
using ::clock;
#line 27
using ::strftime;
#line 79 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ctime"
using ::ctime;
#line 80
using ::difftime;
#line 81
using ::gmtime;
#line 82
using ::localtime;
#line 83
using ::mktime;
#line 84
using ::time;
#line 90 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ctime"
}
#line 94
#pragma warning(pop)
#pragma pack ( pop )
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xtimec.h"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 20
extern "C" {
#line 26
__int64 __cdecl _Xtime_get_ticks() noexcept; 
#line 33
__int64 __cdecl _Query_perf_counter() noexcept; 
#line 34
__int64 __cdecl _Query_perf_frequency() noexcept; 
#line 36
}
#line 40
#pragma warning(pop)
#pragma pack ( pop )
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xthreads.h"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 21
extern "C" {
#line 23
_Thrd_result __cdecl _Thrd_detach(_Thrd_t) noexcept; 
#line 24
_Thrd_result __cdecl _Thrd_join(_Thrd_t, int *) noexcept; 
#line 25
void __cdecl _Thrd_yield() noexcept; 
#line 26
unsigned __cdecl _Thrd_hardware_concurrency() noexcept; 
#line 27
_Thrd_id_t __cdecl _Thrd_id() noexcept; 
#line 28
void __stdcall _Thrd_sleep_for(unsigned long) noexcept; 
#line 31
enum { 
#line 32
_Mtx_plain = 1, 
#line 33
_Mtx_try, 
#line 34
_Mtx_timed = 4, 
#line 35
_Mtx_recursive = 256
#line 36
}; 
#line 41 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xthreads.h"
int __cdecl _Mtx_current_owns(_Mtx_t) noexcept; 
#line 42
_Thrd_result __cdecl _Mtx_lock(_Mtx_t) noexcept; 
#line 43
_Thrd_result __cdecl _Mtx_trylock(_Mtx_t) noexcept; 
#line 44
_Thrd_result __cdecl _Mtx_unlock(_Mtx_t) noexcept; 
#line 48
void __cdecl _Smtx_lock_exclusive(_Smtx_t *) noexcept; 
#line 49
void __cdecl _Smtx_lock_shared(_Smtx_t *) noexcept; 
#line 50
int __cdecl _Smtx_try_lock_exclusive(_Smtx_t *) noexcept; 
#line 51
int __cdecl _Smtx_try_lock_shared(_Smtx_t *) noexcept; 
#line 52
void __cdecl _Smtx_unlock_exclusive(_Smtx_t *) noexcept; 
#line 53
void __cdecl _Smtx_unlock_shared(_Smtx_t *) noexcept; 
#line 59
_Thrd_result __cdecl _Cnd_wait(_Cnd_t, _Mtx_t) noexcept; 
#line 60
_Thrd_result __cdecl _Cnd_broadcast(_Cnd_t) noexcept; 
#line 61
_Thrd_result __cdecl _Cnd_signal(_Cnd_t) noexcept; 
#line 62
void __cdecl _Cnd_register_at_thread_exit(_Cnd_t, _Mtx_t, int *) noexcept; 
#line 63
void __cdecl _Cnd_unregister_at_thread_exit(_Mtx_t) noexcept; 
#line 64
void __cdecl _Cnd_do_broadcast_at_thread_exit() noexcept; 
#line 66
_Thrd_result __stdcall _Cnd_timedwait_for_unchecked(_Cnd_t, _Mtx_t, unsigned) noexcept; 
#line 67
}
#line 69
namespace std { 
#line 70
enum { 
#line 71
_DEVICE_OR_RESOURCE_BUSY, 
#line 72
_INVALID_ARGUMENT, 
#line 73
_NO_SUCH_PROCESS, 
#line 74
_NOT_ENOUGH_MEMORY, 
#line 75
_OPERATION_NOT_PERMITTED, 
#line 76
_RESOURCE_DEADLOCK_WOULD_OCCUR, 
#line 77
_RESOURCE_UNAVAILABLE_TRY_AGAIN
#line 78
}; 
#line 80
[[noreturn]] void __cdecl _Throw_Cpp_error(int _Code); 
#line 81
}
#line 84
#pragma warning(pop)
#pragma pack ( pop )
#line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 78 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
extern "C" {
#line 79
enum { 
#line 80
_Atomic_memory_order_relaxed, 
#line 81
_Atomic_memory_order_consume, 
#line 82
_Atomic_memory_order_acquire, 
#line 83
_Atomic_memory_order_release, 
#line 84
_Atomic_memory_order_acq_rel, 
#line 85
_Atomic_memory_order_seq_cst
#line 86
}; 
#line 87
}
#line 97 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
extern "C" inline void _Check_memory_order(const unsigned _Order) noexcept { 
#line 98
if (_Order > (_Atomic_memory_order_seq_cst)) { 
#line 99
; 
#line 100
}  
#line 101
} 
#line 192 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
#pragma warning(push)
#pragma warning(disable : 6001)
#pragma warning(disable : 28113)
#line 196
extern "C" inline void _Atomic_thread_fence(const unsigned _Order) noexcept { 
#line 197
if (_Order == (_Atomic_memory_order_relaxed)) { 
#line 198
return; 
#line 199
}  
#line 202
__pragma( warning(push)) __pragma( warning(disable : 4996)) _ReadWriteBarrier(); __pragma( warning(pop)) 
#line 203
if (_Order == (_Atomic_memory_order_seq_cst)) { 
#line 204
volatile long _Guard; 
#line 209
(void)_InterlockedIncrement(&_Guard); 
#line 210
__pragma( warning(push)) __pragma( warning(disable : 4996)) _ReadWriteBarrier(); __pragma( warning(pop)) 
#line 211
}  
#line 221 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
} 
#pragma warning(pop)
#line 226
extern "C" {
#line 227
_Smtx_t *__stdcall __std_atomic_get_mutex(const void * _Key) noexcept; 
#line 228
}
#line 238 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
namespace std { 
#line 244 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template < class _Ty >
struct _Storage_for {

    alignas ( _Ty ) unsigned char _Storage [ sizeof ( _Ty ) ];

    _Storage_for ( ) = default;
    _Storage_for ( const _Storage_for & ) = delete;
    _Storage_for & operator = ( const _Storage_for & ) = delete;








    [ [ nodiscard ] ] _Ty & _Ref ( ) noexcept {
        return reinterpret_cast < _Ty & > ( _Storage );
    }

    [ [ nodiscard ] ] _Ty * _Ptr ( ) noexcept {
        return reinterpret_cast < _Ty * > ( & _Storage );
    }
};
#line 274 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
extern "C" inline void atomic_thread_fence(const memory_order _Order) noexcept { 
#line 275
::_Atomic_thread_fence(static_cast< unsigned>(_Order)); 
#line 276
} 
#line 278
extern "C" inline void atomic_signal_fence(const memory_order _Order) noexcept { 
#line 279
if (_Order != (memory_order_relaxed)) { 
#line 280
__pragma( warning(push)) __pragma( warning(disable : 4996)) _ReadWriteBarrier(); __pragma( warning(pop)) 
#line 281
}  
#line 282
} 
#line 284
template < class _Ty >
_Ty kill_dependency ( _Ty _Arg ) noexcept {
    return _Arg;
}
#line 289
inline void _Check_store_memory_order(const memory_order _Order) noexcept { 
#line 290
switch (_Order) { 
#line 291
case memory_order_relaxed:  
#line 292
case memory_order_release:  
#line 293
case memory_order_seq_cst:  
#line 295
break; 
#line 296
case memory_order_consume:  
#line 297
case memory_order_acquire:  
#line 298
case memory_order_acq_rel:  
#line 299
default:  
#line 300
; 
#line 301
break; 
#line 302
}  
#line 303
} 
#line 305
inline void _Check_load_memory_order(const memory_order _Order) noexcept { 
#line 306
switch (_Order) { 
#line 307
case memory_order_relaxed:  
#line 308
case memory_order_consume:  
#line 309
case memory_order_acquire:  
#line 310
case memory_order_seq_cst:  
#line 312
break; 
#line 313
case memory_order_release:  
#line 314
case memory_order_acq_rel:  
#line 315
default:  
#line 316
; 
#line 317
break; 
#line 318
}  
#line 319
} 
#line 321
[[nodiscard]] inline memory_order _Combine_cas_memory_orders(const memory_order 
#line 322
_Success, const memory_order _Failure) noexcept { 
#line 334
static constexpr memory_order _Combined_memory_orders[6][6] = {{memory_order_relaxed, memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel, memory_order_seq_cst}, {memory_order_consume, memory_order_consume, memory_order_acquire, memory_order_acq_rel, memory_order_acq_rel, memory_order_seq_cst}, {memory_order_acquire, memory_order_acquire, memory_order_acquire, memory_order_acq_rel, memory_order_acq_rel, memory_order_seq_cst}, {memory_order_release, memory_order_acq_rel, memory_order_acq_rel, memory_order_release, memory_order_acq_rel, memory_order_seq_cst}, {memory_order_acq_rel, memory_order_acq_rel, memory_order_acq_rel, memory_order_acq_rel, memory_order_acq_rel, memory_order_seq_cst}, {memory_order_seq_cst, memory_order_seq_cst, memory_order_seq_cst, memory_order_seq_cst, memory_order_seq_cst, memory_order_seq_cst}}; 
#line 348
_Check_memory_order(static_cast< unsigned>(_Success)); 
#line 349
_Check_load_memory_order(_Failure); 
#line 350
return (_Combined_memory_orders[static_cast< int>(_Success)])[static_cast< int>(_Failure)]; 
#line 351
} 
#line 353
template < class _Integral, class _Ty >
[ [ nodiscard ] ] _Integral _Atomic_reinterpret_as ( const _Ty & _Source ) noexcept {

    static_assert ( is_integral_v < _Integral >, "Tried to reinterpret memory as non-integral" );
    if constexpr ( is_integral_v < _Ty > && sizeof ( _Integral ) == sizeof ( _Ty ) ) {
        return static_cast < _Integral > ( _Source );
    } else if constexpr ( is_pointer_v < _Ty > && sizeof ( _Integral ) == sizeof ( _Ty ) ) {
        return reinterpret_cast < _Integral > ( _Source );
    } else {
        _Integral _Result { };
        :: memcpy ( & _Result, :: std :: addressof ( _Source ), sizeof ( _Source ) );
        return _Result;
    }
}
#line 369
template< class _Ty> 
#line 370
struct _Atomic_padded { 
#line 371
alignas(sizeof(_Ty)) mutable _Ty _Value; 
#line 372
}; 
#line 414 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template< class _Ty> 
#line 415
struct _Atomic_storage_types { 
#line 416
using _TStorage = _Atomic_padded< _Ty> ; 
#line 417
using _Spinlock = long; 
#line 418
}; 
#line 420
template< class _Ty> 
#line 421
struct _Atomic_storage_types< _Ty &>  { 
#line 422
using _TStorage = _Ty &; 
#line 423
using _Spinlock = _Smtx_t *; 
#line 424
}; 
#line 427
template < class _Ty, size_t = sizeof ( remove_reference_t < _Ty > ) >



struct _Atomic_storage;
#line 464 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
inline void _Atomic_lock_acquire(long &_Spinlock) noexcept { 
#line 469
int _Current_backoff = 1; 
#line 470
constexpr int _Max_backoff = 64; 
#line 471
while (_InterlockedExchange(&_Spinlock, 1) != (0)) { 
#line 472
while (__iso_volatile_load32(&(reinterpret_cast< int &>(_Spinlock))) != 0) { 
#line 473
for (int _Count_down = _Current_backoff; _Count_down != 0; --_Count_down) { 
#line 474
_mm_pause(); 
#line 475
}  
#line 476
_Current_backoff = ((_Current_backoff < _Max_backoff) ? _Current_backoff << 1 : _Max_backoff); 
#line 477
}  
#line 478
}  
#line 488 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
} 
#line 490
inline void _Atomic_lock_release(long &_Spinlock) noexcept { 
#line 491
__pragma( warning(push)) __pragma( warning(disable : 4996)) _ReadWriteBarrier(); __pragma( warning(pop)) __iso_volatile_store32(reinterpret_cast< int *>(&_Spinlock), 0); 
#line 492
} 
#line 494
inline void _Atomic_lock_acquire(_Smtx_t *_Spinlock) noexcept { 
#line 495
_Smtx_lock_exclusive(_Spinlock); 
#line 496
} 
#line 498
inline void _Atomic_lock_release(_Smtx_t *_Spinlock) noexcept { 
#line 499
_Smtx_unlock_exclusive(_Spinlock); 
#line 500
} 
#line 502
template < class _Spinlock_t >
class [ [ nodiscard ] ] _Atomic_lock_guard {
public :
    explicit _Atomic_lock_guard ( _Spinlock_t & _Spinlock_ ) noexcept : _Spinlock ( _Spinlock_ ) {
        _Atomic_lock_acquire ( _Spinlock );
    }

    ~ _Atomic_lock_guard ( ) {
        _Atomic_lock_release ( _Spinlock );
    }

    _Atomic_lock_guard ( const _Atomic_lock_guard & ) = delete;
    _Atomic_lock_guard & operator = ( const _Atomic_lock_guard & ) = delete;

private :
    _Spinlock_t & _Spinlock;
};
#line 546 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template < class _Ty, size_t >
struct _Atomic_storage {



    using _TVal = _Remove_cvref_t < _Ty >;
    using _Guard = _Atomic_lock_guard < typename _Atomic_storage_types < _Ty > :: _Spinlock >;

    _Atomic_storage ( ) = default;

     constexpr _Atomic_storage ( const _Ty & _Value ) noexcept : _Storage ( _Value ) {

    }

    void store ( const _TVal _Value, const memory_order _Order = memory_order_seq_cst ) noexcept {

        _Check_store_memory_order ( _Order );
        _Guard _Lock { _Spinlock };
        _Storage = _Value;
    }

    [ [ nodiscard ] ] _TVal load ( const memory_order _Order = memory_order_seq_cst ) const noexcept {

        _Check_load_memory_order ( _Order );
        _Guard _Lock { _Spinlock };
        _TVal _Local ( _Storage );
        return _Local;
    }

    _TVal exchange ( const _TVal _Value, const memory_order _Order = memory_order_seq_cst ) noexcept {

        _Check_memory_order ( static_cast < unsigned int > ( _Order ) );
        _Guard _Lock { _Spinlock };
        _TVal _Result ( _Storage );
        _Storage = _Value;
        return _Result;
    }

    bool compare_exchange_strong ( _TVal & _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst ) noexcept {
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) );
        const auto _Storage_ptr = :: std :: addressof ( _Storage );
        const auto _Expected_ptr = :: std :: addressof ( _Expected );
        bool _Result;



        _Guard _Lock { _Spinlock };











        _Result = :: memcmp ( _Storage_ptr, _Expected_ptr, sizeof ( _TVal ) ) == 0;

        if ( _Result ) {
            :: memcpy ( _Storage_ptr, :: std :: addressof ( _Desired ), sizeof ( _TVal ) );
        } else {
            :: memcpy ( _Expected_ptr, _Storage_ptr, sizeof ( _TVal ) );
        }

        return _Result;
    }
















































protected :
    void _Init_spinlock_for_ref ( ) noexcept {
        _Spinlock = :: __std_atomic_get_mutex ( :: std :: addressof ( _Storage ) );
    }

private :

    mutable typename _Atomic_storage_types < _Ty > :: _Spinlock _Spinlock { };

public :
    _Ty _Storage { };





};
#line 681 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template < class _Ty >
struct _Atomic_storage < _Ty, 1 > {
    using _TVal = _Remove_cvref_t < _Ty >;

    _Atomic_storage ( ) = default;

     constexpr _Atomic_storage ( const _Ty & _Value ) noexcept : _Storage { _Value } {

    }

    void store ( const _TVal _Value ) noexcept {
        const auto _Mem = :: std :: _Atomic_address_as < char > ( _Storage );
        const char _As_bytes = :: std :: _Atomic_reinterpret_as < char > ( _Value );
        ( void ) _InterlockedExchange8 ( ( ( _Mem ) ), ( ( _As_bytes ) ) );
    }

    void store ( const _TVal _Value, const memory_order _Order ) noexcept {
        const auto _Mem = :: std :: _Atomic_address_as < char > ( _Storage );
        const char _As_bytes = :: std :: _Atomic_reinterpret_as < char > ( _Value );

        _Check_store_memory_order ( _Order );

        if ( _Order == memory_order_relaxed ) {
            __iso_volatile_store8 ( _Mem, _As_bytes );
        } else if ( _Order == memory_order_release ) {
            __pragma(warning(push))                                    __pragma(warning(disable : 4996)) _ReadWriteBarrier ( )                                                                                          __pragma(warning(pop)); __iso_volatile_store8 ( ( _Mem ), ( _As_bytes ) );
        } else {
            store ( _Value );
        }
    }

    [ [ nodiscard ] ] _TVal load (
        const memory_order _Order = memory_order_seq_cst ) const noexcept {
        const auto _Mem = :: std :: _Atomic_address_as < char > ( _Storage );
        char _As_bytes;



        _As_bytes = __iso_volatile_load8 ( _Mem );
        _Check_load_memory_order ( _Order ); if ( _Order != memory_order_relaxed ) {                                                                                __pragma(warning(push))                                                                                                        __pragma(warning(disable : 4996)) _ReadWriteBarrier ( )                                                                                                                                                              __pragma(warning(pop)); }

        return reinterpret_cast < _TVal & > ( _As_bytes );
    }

    _TVal exchange ( const _TVal _Value, const memory_order _Order = memory_order_seq_cst ) noexcept {

        char _As_bytes;
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _As_bytes = _InterlockedExchange8 ( :: std :: _Atomic_address_as < char > ( _Storage ), :: std :: _Atomic_reinterpret_as < char > ( _Value ) );

        return reinterpret_cast < _TVal & > ( _As_bytes );
    }

    bool compare_exchange_strong ( _TVal & _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst ) noexcept {
        char _Expected_bytes = :: std :: _Atomic_reinterpret_as < char > ( _Expected );
        char _Prev_bytes;






















        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Prev_bytes = _InterlockedCompareExchange8 ( :: std :: _Atomic_address_as < char > ( _Storage ), :: std :: _Atomic_reinterpret_as < char > ( _Desired ), _Expected_bytes );

        if ( _Prev_bytes == _Expected_bytes ) {
            return true;
        }

        reinterpret_cast < char & > ( _Expected ) = _Prev_bytes;
        return false;
    }

















    typename _Atomic_storage_types < _Ty > :: _TStorage _Storage;
};
#line 788 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template < class _Ty >
struct _Atomic_storage < _Ty, 2 > {
    using _TVal = _Remove_cvref_t < _Ty >;

    _Atomic_storage ( ) = default;

     constexpr _Atomic_storage ( const _Ty & _Value ) noexcept : _Storage { _Value } {

    }

    void store ( const _TVal _Value ) noexcept {
        const auto _Mem = :: std :: _Atomic_address_as < short > ( _Storage );
        const short _As_bytes = :: std :: _Atomic_reinterpret_as < short > ( _Value );
        ( void ) _InterlockedExchange16 ( ( ( _Mem ) ), ( ( _As_bytes ) ) );
    }

    void store ( const _TVal _Value, const memory_order _Order ) noexcept {
        const auto _Mem = :: std :: _Atomic_address_as < short > ( _Storage );
        const short _As_bytes = :: std :: _Atomic_reinterpret_as < short > ( _Value );

        _Check_store_memory_order ( _Order );

        if ( _Order == memory_order_relaxed ) {
            __iso_volatile_store16 ( _Mem, _As_bytes );
        } else if ( _Order == memory_order_release ) {
            __pragma(warning(push))                                    __pragma(warning(disable : 4996)) _ReadWriteBarrier ( )                                                                                          __pragma(warning(pop)); __iso_volatile_store16 ( ( _Mem ), ( _As_bytes ) );
        } else {
            store ( _Value );
        }
    }

    [ [ nodiscard ] ] _TVal load (
        const memory_order _Order = memory_order_seq_cst ) const noexcept {
        const auto _Mem = :: std :: _Atomic_address_as < short > ( _Storage );
        short _As_bytes;



        _As_bytes = __iso_volatile_load16 ( _Mem );
        _Check_load_memory_order ( _Order ); if ( _Order != memory_order_relaxed ) {                                                                                __pragma(warning(push))                                                                                                        __pragma(warning(disable : 4996)) _ReadWriteBarrier ( )                                                                                                                                                              __pragma(warning(pop)); }

        return reinterpret_cast < _TVal & > ( _As_bytes );
    }

    _TVal exchange ( const _TVal _Value, const memory_order _Order = memory_order_seq_cst ) noexcept {

        short _As_bytes;
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _As_bytes = _InterlockedExchange16 ( :: std :: _Atomic_address_as < short > ( _Storage ), :: std :: _Atomic_reinterpret_as < short > ( _Value ) );

        return reinterpret_cast < _TVal & > ( _As_bytes );
    }

    bool compare_exchange_strong ( _TVal & _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst ) noexcept {
        short _Expected_bytes = :: std :: _Atomic_reinterpret_as < short > ( _Expected );
        short _Prev_bytes;





















        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Prev_bytes = _InterlockedCompareExchange16 ( :: std :: _Atomic_address_as < short > ( _Storage ), :: std :: _Atomic_reinterpret_as < short > ( _Desired ), _Expected_bytes );

        if ( _Prev_bytes == _Expected_bytes ) {
            return true;
        }

        :: memcpy ( :: std :: addressof ( _Expected ), & _Prev_bytes, sizeof ( _Ty ) );
        return false;
    }

















    typename _Atomic_storage_types < _Ty > :: _TStorage _Storage;
};
#line 894 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template < class _Ty >
struct _Atomic_storage < _Ty, 4 > {
    using _TVal = _Remove_cvref_t < _Ty >;

    _Atomic_storage ( ) = default;

     constexpr _Atomic_storage ( const _Ty & _Value ) noexcept : _Storage { _Value } {

    }

    void store ( const _TVal _Value ) noexcept {
        const auto _Mem = :: std :: _Atomic_address_as < int > ( _Storage );
        const int _As_bytes = :: std :: _Atomic_reinterpret_as < int > ( _Value );
        ( void ) _InterlockedExchange ( reinterpret_cast < volatile long * > ( ( _Mem ) ), static_cast < long > ( ( _As_bytes ) ) );
    }

    void store ( const _TVal _Value, const memory_order _Order ) noexcept {
        const auto _Mem = :: std :: _Atomic_address_as < int > ( _Storage );
        const int _As_bytes = :: std :: _Atomic_reinterpret_as < int > ( _Value );

        _Check_store_memory_order ( _Order );

        if ( _Order == memory_order_relaxed ) {
            __iso_volatile_store32 ( _Mem, _As_bytes );
        } else if ( _Order == memory_order_release ) {
            __pragma(warning(push))                                    __pragma(warning(disable : 4996)) _ReadWriteBarrier ( )                                                                                          __pragma(warning(pop)); __iso_volatile_store32 ( ( _Mem ), ( _As_bytes ) );
        } else {
            store ( _Value );
        }
    }

    [ [ nodiscard ] ] _TVal load (
        const memory_order _Order = memory_order_seq_cst ) const noexcept {
        const auto _Mem = :: std :: _Atomic_address_as < int > ( _Storage );
        int _As_bytes;



        _As_bytes = __iso_volatile_load32 ( _Mem );
        _Check_load_memory_order ( _Order ); if ( _Order != memory_order_relaxed ) {                                                                                __pragma(warning(push))                                                                                                        __pragma(warning(disable : 4996)) _ReadWriteBarrier ( )                                                                                                                                                              __pragma(warning(pop)); }

        return reinterpret_cast < _TVal & > ( _As_bytes );
    }

    _TVal exchange ( const _TVal _Value, const memory_order _Order = memory_order_seq_cst ) noexcept {

        long _As_bytes;
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _As_bytes = _InterlockedExchange ( :: std :: _Atomic_address_as < long > ( _Storage ), :: std :: _Atomic_reinterpret_as < long > ( _Value ) );

        return reinterpret_cast < _TVal & > ( _As_bytes );
    }

    bool compare_exchange_strong ( _TVal & _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst ) noexcept {
        long _Expected_bytes = :: std :: _Atomic_reinterpret_as < long > ( _Expected );
        long _Prev_bytes;





















        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Prev_bytes = _InterlockedCompareExchange ( :: std :: _Atomic_address_as < long > ( _Storage ), :: std :: _Atomic_reinterpret_as < long > ( _Desired ), _Expected_bytes );

        if ( _Prev_bytes == _Expected_bytes ) {
            return true;
        }

        :: memcpy ( :: std :: addressof ( _Expected ), & _Prev_bytes, sizeof ( _TVal ) );
        return false;
    }

















    typename _Atomic_storage_types < _Ty > :: _TStorage _Storage;
};
#line 1000 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template < class _Ty >
struct _Atomic_storage < _Ty, 8 > {
    using _TVal = _Remove_cvref_t < _Ty >;

    _Atomic_storage ( ) = default;

     constexpr _Atomic_storage ( const _Ty & _Value ) noexcept : _Storage { _Value } {

    }

    void store ( const _TVal _Value ) noexcept {
        const auto _Mem = :: std :: _Atomic_address_as < long long > ( _Storage );
        const long long _As_bytes = :: std :: _Atomic_reinterpret_as < long long > ( _Value );
        ( void ) _InterlockedExchange64 ( ( ( _Mem ) ), ( ( _As_bytes ) ) );;
    }

    void store ( const _TVal _Value, const memory_order _Order ) noexcept {
        const auto _Mem = :: std :: _Atomic_address_as < long long > ( _Storage );
        const long long _As_bytes = :: std :: _Atomic_reinterpret_as < long long > ( _Value );

        _Check_store_memory_order ( _Order );

        if ( _Order == memory_order_relaxed ) {
            __iso_volatile_store64 ( _Mem, _As_bytes );
        } else if ( _Order == memory_order_release ) {
            __pragma(warning(push))                                    __pragma(warning(disable : 4996)) _ReadWriteBarrier ( )                                                                                          __pragma(warning(pop)); __iso_volatile_store64 ( ( _Mem ), ( _As_bytes ) );
        } else {
            store ( _Value );
        }
    }

    [ [ nodiscard ] ] _TVal load (
        const memory_order _Order = memory_order_seq_cst ) const noexcept {
        const auto _Mem = :: std :: _Atomic_address_as < long long > ( _Storage );
        long long _As_bytes;







        _As_bytes = __iso_volatile_load64 ( _Mem );


        _Check_load_memory_order ( _Order ); if ( _Order != memory_order_relaxed ) {                                                                                __pragma(warning(push))                                                                                                        __pragma(warning(disable : 4996)) _ReadWriteBarrier ( )                                                                                                                                                              __pragma(warning(pop)); }

        return reinterpret_cast < _TVal & > ( _As_bytes );
    }











    _TVal exchange ( const _TVal _Value, const memory_order _Order = memory_order_seq_cst ) noexcept {

        long long _As_bytes;
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _As_bytes = _InterlockedExchange64 ( :: std :: _Atomic_address_as < long long > ( _Storage ), :: std :: _Atomic_reinterpret_as < long long > ( _Value ) );

        return reinterpret_cast < _TVal & > ( _As_bytes );
    }


    bool compare_exchange_strong ( _TVal & _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst ) noexcept {
        long long _Expected_bytes = :: std :: _Atomic_reinterpret_as < long long > ( _Expected );
        long long _Prev_bytes;






















        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Prev_bytes = _InterlockedCompareExchange64 ( :: std :: _Atomic_address_as < long long > ( _Storage ), :: std :: _Atomic_reinterpret_as < long long > ( _Desired ), _Expected_bytes );

        if ( _Prev_bytes == _Expected_bytes ) {
            return true;
        }

        :: memcpy ( :: std :: addressof ( _Expected ), & _Prev_bytes, sizeof ( _TVal ) );
        return false;
    }

















    typename _Atomic_storage_types < _Ty > :: _TStorage _Storage;
};
#line 1126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template < class _Ty >
struct _Atomic_storage < _Ty &, 16 > {

    using _TVal = _Remove_cvref_t < _Ty & >;

    _Atomic_storage ( ) = default;


     constexpr _Atomic_storage ( _Ty & _Value ) noexcept
        : _Storage { _Value } { }

    void store ( const _TVal _Value ) noexcept {
        ( void ) exchange ( _Value );
    }

    void store ( const _TVal _Value, const memory_order _Order ) noexcept {
        _Check_store_memory_order ( _Order );
        ( void ) exchange ( _Value, _Order );
    }

    [ [ nodiscard ] ] _TVal load ( ) const noexcept {
        long long * const _Storage_ptr = const_cast < long long * > ( :: std :: _Atomic_address_as < const long long > ( _Storage ) );
        _Int128 _Result { };
        ( void ) _InterlockedCompareExchange128 ( _Storage_ptr, 0, 0, & _Result . _Low );
        return reinterpret_cast < _TVal & > ( _Result );
    }

    [ [ nodiscard ] ] _TVal load ( const memory_order _Order ) const noexcept {























        _Check_load_memory_order ( _Order );
        return load ( );

    }

    _TVal exchange ( const _TVal _Value ) noexcept {
        _TVal _Result { _Value };
        while ( ! compare_exchange_strong ( _Result, _Value ) ) {
        }

        return _Result;
    }

    _TVal exchange ( const _TVal _Value, const memory_order _Order ) noexcept {
        _TVal _Result { _Value };
        while ( ! compare_exchange_strong ( _Result, _Value, _Order ) ) {
        }

        return _Result;
    }

    bool compare_exchange_strong ( _TVal & _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst ) noexcept {
        _Int128 _Desired_bytes { };
        :: memcpy ( & _Desired_bytes, :: std :: addressof ( _Desired ), sizeof ( _TVal ) );
        _Int128 _Expected_temp { };
        :: memcpy ( & _Expected_temp, :: std :: addressof ( _Expected ), sizeof ( _TVal ) );
        unsigned char _Result;








































        ( void ) _Order;
        _Result = _InterlockedCompareExchange128 ( & reinterpret_cast < volatile long long & > ( _Storage ), _Desired_bytes . _High,
            _Desired_bytes . _Low, & _Expected_temp . _Low );

        if ( _Result == 0 ) {
            :: memcpy ( :: std :: addressof ( _Expected ), & _Expected_temp, sizeof ( _TVal ) );
        }

        return _Result != 0;
    }











































    struct _Int128 {
        alignas ( 16 ) long long _Low;
        long long _High;
    };

    typename _Atomic_storage_types < _Ty & > :: _TStorage _Storage;
};
#line 1307 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template< class _Ty, size_t  = sizeof(_Ty)> struct _Atomic_integral; 
#line 1310
template < class _Ty >
struct _Atomic_integral < _Ty, 1 > : _Atomic_storage < _Ty > {
    using _Base = _Atomic_storage < _Ty >;
    using typename _Base :: _TVal;

    using _Base :: _Base;

    _TVal fetch_add ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        char _Result;
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Result = _InterlockedExchangeAdd8 ( :: std :: _Atomic_address_as < char > ( this -> _Storage ), static_cast < char > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_and ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        char _Result;
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Result = _InterlockedAnd8 ( :: std :: _Atomic_address_as < char > ( this -> _Storage ), static_cast < char > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_or ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        char _Result;
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Result = _InterlockedOr8 ( :: std :: _Atomic_address_as < char > ( this -> _Storage ), static_cast < char > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_xor ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        char _Result;
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Result = _InterlockedXor8 ( :: std :: _Atomic_address_as < char > ( this -> _Storage ), static_cast < char > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal operator ++ ( int ) noexcept {
        return static_cast < _TVal > ( _InterlockedExchangeAdd8 ( :: std :: _Atomic_address_as < char > ( this -> _Storage ), 1 ) );
    }

    _TVal operator ++ ( ) noexcept {
        unsigned char _Before =
            static_cast < unsigned char > ( _InterlockedExchangeAdd8 ( :: std :: _Atomic_address_as < char > ( this -> _Storage ), 1 ) );
        ++ _Before;
        return static_cast < _TVal > ( _Before );
    }

    _TVal operator -- ( int ) noexcept {
        return static_cast < _TVal > ( _InterlockedExchangeAdd8 ( :: std :: _Atomic_address_as < char > ( this -> _Storage ), - 1 ) );
    }

    _TVal operator -- ( ) noexcept {
        unsigned char _Before =
            static_cast < unsigned char > ( _InterlockedExchangeAdd8 ( :: std :: _Atomic_address_as < char > ( this -> _Storage ), - 1 ) );
        -- _Before;
        return static_cast < _TVal > ( _Before );
    }
};
#line 1368 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template < class _Ty >
struct _Atomic_integral < _Ty, 2 > : _Atomic_storage < _Ty > {
    using _Base = _Atomic_storage < _Ty >;
    using typename _Base :: _TVal;

    using _Base :: _Base;

    _TVal fetch_add ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        short _Result;
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Result = _InterlockedExchangeAdd16 ( :: std :: _Atomic_address_as < short > ( this -> _Storage ), static_cast < short > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_and ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        short _Result;
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Result = _InterlockedAnd16 ( :: std :: _Atomic_address_as < short > ( this -> _Storage ), static_cast < short > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_or ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        short _Result;
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Result = _InterlockedOr16 ( :: std :: _Atomic_address_as < short > ( this -> _Storage ), static_cast < short > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_xor ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        short _Result;
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Result = _InterlockedXor16 ( :: std :: _Atomic_address_as < short > ( this -> _Storage ), static_cast < short > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal operator ++ ( int ) noexcept {
        unsigned short _After =
            static_cast < unsigned short > ( _InterlockedIncrement16 ( :: std :: _Atomic_address_as < short > ( this -> _Storage ) ) );
        -- _After;
        return static_cast < _TVal > ( _After );
    }

    _TVal operator ++ ( ) noexcept {
        return static_cast < _TVal > ( _InterlockedIncrement16 ( :: std :: _Atomic_address_as < short > ( this -> _Storage ) ) );
    }

    _TVal operator -- ( int ) noexcept {
        unsigned short _After =
            static_cast < unsigned short > ( _InterlockedDecrement16 ( :: std :: _Atomic_address_as < short > ( this -> _Storage ) ) );
        ++ _After;
        return static_cast < _TVal > ( _After );
    }

    _TVal operator -- ( ) noexcept {
        return static_cast < _TVal > ( _InterlockedDecrement16 ( :: std :: _Atomic_address_as < short > ( this -> _Storage ) ) );
    }
};
#line 1426 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template < class _Ty >
struct _Atomic_integral < _Ty, 4 > : _Atomic_storage < _Ty > {
    using _Base = _Atomic_storage < _Ty >;
    using typename _Base :: _TVal;

    using _Base :: _Base;

    _TVal fetch_add ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        long _Result;
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Result = _InterlockedExchangeAdd ( :: std :: _Atomic_address_as < long > ( this -> _Storage ), static_cast < long > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_and ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        long _Result;
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Result = _InterlockedAnd ( :: std :: _Atomic_address_as < long > ( this -> _Storage ), static_cast < long > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_or ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        long _Result;
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Result = _InterlockedOr ( :: std :: _Atomic_address_as < long > ( this -> _Storage ), static_cast < long > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_xor ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        long _Result;
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Result = _InterlockedXor ( :: std :: _Atomic_address_as < long > ( this -> _Storage ), static_cast < long > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal operator ++ ( int ) noexcept {
        unsigned long _After =
            static_cast < unsigned long > ( _InterlockedIncrement ( :: std :: _Atomic_address_as < long > ( this -> _Storage ) ) );
        -- _After;
        return static_cast < _TVal > ( _After );
    }

    _TVal operator ++ ( ) noexcept {
        return static_cast < _TVal > ( _InterlockedIncrement ( :: std :: _Atomic_address_as < long > ( this -> _Storage ) ) );
    }

    _TVal operator -- ( int ) noexcept {
        unsigned long _After =
            static_cast < unsigned long > ( _InterlockedDecrement ( :: std :: _Atomic_address_as < long > ( this -> _Storage ) ) );
        ++ _After;
        return static_cast < _TVal > ( _After );
    }

    _TVal operator -- ( ) noexcept {
        return static_cast < _TVal > ( _InterlockedDecrement ( :: std :: _Atomic_address_as < long > ( this -> _Storage ) ) );
    }
};
#line 1484 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template < class _Ty >
struct _Atomic_integral < _Ty, 8 > : _Atomic_storage < _Ty > {
    using _Base = _Atomic_storage < _Ty >;
    using typename _Base :: _TVal;

    using _Base :: _Base;























































    _TVal fetch_add ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        long long _Result;
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Result = _InterlockedExchangeAdd64 ( :: std :: _Atomic_address_as < long long > ( this -> _Storage ), static_cast < long long > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_and ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        long long _Result;
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Result = _InterlockedAnd64 ( :: std :: _Atomic_address_as < long long > ( this -> _Storage ), static_cast < long long > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_or ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        long long _Result;
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Result = _InterlockedOr64 ( :: std :: _Atomic_address_as < long long > ( this -> _Storage ), static_cast < long long > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_xor ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        long long _Result;
        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Result = _InterlockedXor64 ( :: std :: _Atomic_address_as < long long > ( this -> _Storage ), static_cast < long long > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal operator ++ ( int ) noexcept {
        unsigned long long _After = static_cast < unsigned long long > (
            _InterlockedIncrement64 ( :: std :: _Atomic_address_as < long long > ( this -> _Storage ) ) );
        -- _After;
        return static_cast < _TVal > ( _After );
    }

    _TVal operator ++ ( ) noexcept {
        return static_cast < _TVal > ( _InterlockedIncrement64 ( :: std :: _Atomic_address_as < long long > ( this -> _Storage ) ) );
    }

    _TVal operator -- ( int ) noexcept {
        unsigned long long _After = static_cast < unsigned long long > (
            _InterlockedDecrement64 ( :: std :: _Atomic_address_as < long long > ( this -> _Storage ) ) );
        ++ _After;
        return static_cast < _TVal > ( _After );
    }

    _TVal operator -- ( ) noexcept {
        return static_cast < _TVal > ( _InterlockedDecrement64 ( :: std :: _Atomic_address_as < long long > ( this -> _Storage ) ) );
    }

};
#line 1598 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template< size_t _TypeSize> constexpr bool 
#line 1599
_Is_always_lock_free = ((_TypeSize <= (8)) && ((_TypeSize & (_TypeSize - (1))) == (0))); 
#line 1605 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template< class _Ty, bool _Is_lock_free = _Is_always_lock_free< sizeof(_Ty)> > constexpr bool 
#line 1606
_Deprecate_non_lock_free_volatile = true; 
#line 1608
template< class _Ty> constexpr bool 
#line 1609
_Deprecate_non_lock_free_volatile< _Ty, false>  = true; 
#line 1617 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template < class _Ty >
struct _Atomic_integral_facade : _Atomic_integral < _Ty > {

    ;
    ;

    using _Base = _Atomic_integral < _Ty >;
    using difference_type = _Ty;

    using _Base :: _Base;






    using _Base :: fetch_add;
    _Ty fetch_add ( const _Ty _Operand ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_add ( _Operand );
    }

    _Ty fetch_add ( const _Ty _Operand, const memory_order _Order ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_add ( _Operand, _Order );
    }

    [ [ nodiscard ] ] static _Ty _Negate ( const _Ty _Value ) noexcept {
        return static_cast < _Ty > ( 0U - static_cast < make_unsigned_t < _Ty >> ( _Value ) );
    }

    _Ty fetch_sub ( const _Ty _Operand ) noexcept {
        return fetch_add ( _Negate ( _Operand ) );
    }

    _Ty fetch_sub ( const _Ty _Operand ) volatile noexcept {
        return fetch_add ( _Negate ( _Operand ) );
    }

    _Ty fetch_sub ( const _Ty _Operand, const memory_order _Order ) noexcept {
        return fetch_add ( _Negate ( _Operand ), _Order );
    }

    _Ty fetch_sub ( const _Ty _Operand, const memory_order _Order ) volatile noexcept {
        return fetch_add ( _Negate ( _Operand ), _Order );
    }

    using _Base :: fetch_and;
    _Ty fetch_and ( const _Ty _Operand ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_and ( _Operand );
    }

    _Ty fetch_and ( const _Ty _Operand, const memory_order _Order ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_and ( _Operand, _Order );
    }

    using _Base :: fetch_or;
    _Ty fetch_or ( const _Ty _Operand ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_or ( _Operand );
    }

    _Ty fetch_or ( const _Ty _Operand, const memory_order _Order ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_or ( _Operand, _Order );
    }

    using _Base :: fetch_xor;
    _Ty fetch_xor ( const _Ty _Operand ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_xor ( _Operand );
    }

    _Ty fetch_xor ( const _Ty _Operand, const memory_order _Order ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_xor ( _Operand, _Order );
    }

    using _Base :: operator ++;
    _Ty operator ++ ( int ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: operator ++ ( 0 );
    }

    _Ty operator ++ ( ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: operator ++ ( );
    }

    using _Base :: operator --;
    _Ty operator -- ( int ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: operator -- ( 0 );
    }

    _Ty operator -- ( ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: operator -- ( );
    }

    _Ty operator += ( const _Ty _Operand ) noexcept {
        return static_cast < _Ty > ( this -> _Base :: fetch_add ( _Operand ) + _Operand );
    }

    _Ty operator += ( const _Ty _Operand ) volatile noexcept {
        return static_cast < _Ty > ( const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_add ( _Operand ) + _Operand );
    }

    _Ty operator -= ( const _Ty _Operand ) noexcept {
        return static_cast < _Ty > ( fetch_sub ( _Operand ) - _Operand );
    }

    _Ty operator -= ( const _Ty _Operand ) volatile noexcept {
        return static_cast < _Ty > ( const_cast < _Atomic_integral_facade * > ( this ) -> fetch_sub ( _Operand ) - _Operand );
    }

    _Ty operator &= ( const _Ty _Operand ) noexcept {
        return static_cast < _Ty > ( this -> _Base :: fetch_and ( _Operand ) & _Operand );
    }

    _Ty operator &= ( const _Ty _Operand ) volatile noexcept {
        return static_cast < _Ty > ( const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_and ( _Operand ) & _Operand );
    }

    _Ty operator |= ( const _Ty _Operand ) noexcept {
        return static_cast < _Ty > ( this -> _Base :: fetch_or ( _Operand ) | _Operand );
    }

    _Ty operator |= ( const _Ty _Operand ) volatile noexcept {
        return static_cast < _Ty > ( const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_or ( _Operand ) | _Operand );
    }

    _Ty operator ^= ( const _Ty _Operand ) noexcept {
        return static_cast < _Ty > ( this -> _Base :: fetch_xor ( _Operand ) ^ _Operand );
    }

    _Ty operator ^= ( const _Ty _Operand ) volatile noexcept {
        return static_cast < _Ty > ( const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_xor ( _Operand ) ^ _Operand );
    }
};
#line 1748
template < class _Ty >
struct _Atomic_integral_facade < _Ty & > : _Atomic_integral < _Ty & > {

    using _Base = _Atomic_integral < _Ty & >;
    using difference_type = remove_cv_t < _Ty >;
    using typename _Base :: _TVal;

    using _Base :: _Base;

    [ [ nodiscard ] ] static _TVal _Negate ( const _TVal _Value ) noexcept {
        return static_cast < _TVal > ( 0U - static_cast < make_unsigned_t < _TVal >> ( _Value ) );
    }

    _TVal fetch_add ( const _TVal _Operand ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_add ( _Operand );
    }

    _TVal fetch_add ( const _TVal _Operand, const memory_order _Order ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_add ( _Operand, _Order );
    }

    _TVal fetch_sub ( const _TVal _Operand ) const noexcept {
        return fetch_add ( _Negate ( _Operand ) );
    }

    _TVal fetch_sub ( const _TVal _Operand, const memory_order _Order ) const noexcept {
        return fetch_add ( _Negate ( _Operand ), _Order );
    }

    _TVal operator ++ ( int ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: operator ++ ( 0 );
    }

    _TVal operator ++ ( ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: operator ++ ( );
    }

    _TVal operator -- ( int ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: operator -- ( 0 );
    }

    _TVal operator -- ( ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: operator -- ( );
    }

    _TVal operator += ( const _TVal _Operand ) const noexcept {
        return static_cast < _TVal > ( fetch_add ( _Operand ) + _Operand );
    }

    _TVal operator -= ( const _TVal _Operand ) const noexcept {
        return static_cast < _TVal > ( fetch_sub ( _Operand ) - _Operand );
    }

    _TVal fetch_and ( const _TVal _Operand ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_and ( _Operand );
    }

    _TVal fetch_and ( const _TVal _Operand, const memory_order _Order ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_and ( _Operand, _Order );
    }

    _TVal fetch_or ( const _TVal _Operand ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_or ( _Operand );
    }

    _TVal fetch_or ( const _TVal _Operand, const memory_order _Order ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_or ( _Operand, _Order );
    }

    _TVal fetch_xor ( const _TVal _Operand ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_xor ( _Operand );
    }

    _TVal fetch_xor ( const _TVal _Operand, const memory_order _Order ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_xor ( _Operand, _Order );
    }

    _TVal operator &= ( const _TVal _Operand ) const noexcept {
        return static_cast < _TVal > ( fetch_and ( _Operand ) & _Operand );
    }

    _TVal operator |= ( const _TVal _Operand ) const noexcept {
        return static_cast < _TVal > ( fetch_or ( _Operand ) | _Operand );
    }

    _TVal operator ^= ( const _TVal _Operand ) const noexcept {
        return static_cast < _TVal > ( fetch_xor ( _Operand ) ^ _Operand );
    }
};
#line 1941 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template < class _Ty >
struct _Atomic_pointer : _Atomic_storage < _Ty > {
    using _Base = _Atomic_storage < _Ty >;
    using difference_type = ptrdiff_t;

    using _Base :: _Base;

    _Ty fetch_add ( const ptrdiff_t _Diff, const memory_order _Order = memory_order_seq_cst ) noexcept {
        const ptrdiff_t _Shift_bytes =
            static_cast < ptrdiff_t > ( static_cast < size_t > ( _Diff ) * sizeof ( remove_pointer_t < _Ty > ) );
        ptrdiff_t _Result;




        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Result = _InterlockedExchangeAdd64 ( :: std :: _Atomic_address_as < long long > ( this -> _Storage ), _Shift_bytes );


        return reinterpret_cast < _Ty > ( _Result );
    }



    _Ty fetch_add ( const ptrdiff_t _Diff ) volatile noexcept {
        return const_cast < _Atomic_pointer * > ( this ) -> fetch_add ( _Diff );
    }

    _Ty fetch_add ( const ptrdiff_t _Diff, const memory_order _Order ) volatile noexcept {
        return const_cast < _Atomic_pointer * > ( this ) -> fetch_add ( _Diff, _Order );
    }

    _Ty fetch_sub ( const ptrdiff_t _Diff ) volatile noexcept {
        return fetch_add ( static_cast < ptrdiff_t > ( 0 - static_cast < size_t > ( _Diff ) ) );
    }

    _Ty fetch_sub ( const ptrdiff_t _Diff ) noexcept {
        return fetch_add ( static_cast < ptrdiff_t > ( 0 - static_cast < size_t > ( _Diff ) ) );
    }

    _Ty fetch_sub ( const ptrdiff_t _Diff, const memory_order _Order ) volatile noexcept {
        return fetch_add ( static_cast < ptrdiff_t > ( 0 - static_cast < size_t > ( _Diff ) ), _Order );
    }

    _Ty fetch_sub ( const ptrdiff_t _Diff, const memory_order _Order ) noexcept {
        return fetch_add ( static_cast < ptrdiff_t > ( 0 - static_cast < size_t > ( _Diff ) ), _Order );
    }

    _Ty operator ++ ( int ) volatile noexcept {
        return fetch_add ( 1 );
    }

    _Ty operator ++ ( int ) noexcept {
        return fetch_add ( 1 );
    }

    _Ty operator ++ ( ) volatile noexcept {
        return fetch_add ( 1 ) + 1;
    }

    _Ty operator ++ ( ) noexcept {
        return fetch_add ( 1 ) + 1;
    }

    _Ty operator -- ( int ) volatile noexcept {
        return fetch_add ( - 1 );
    }

    _Ty operator -- ( int ) noexcept {
        return fetch_add ( - 1 );
    }

    _Ty operator -- ( ) volatile noexcept {
        return fetch_add ( - 1 ) - 1;
    }

    _Ty operator -- ( ) noexcept {
        return fetch_add ( - 1 ) - 1;
    }

    _Ty operator += ( const ptrdiff_t _Diff ) volatile noexcept {
        return fetch_add ( _Diff ) + _Diff;
    }

    _Ty operator += ( const ptrdiff_t _Diff ) noexcept {
        return fetch_add ( _Diff ) + _Diff;
    }

    _Ty operator -= ( const ptrdiff_t _Diff ) volatile noexcept {
        return fetch_add ( static_cast < ptrdiff_t > ( 0 - static_cast < size_t > ( _Diff ) ) ) - _Diff;
    }

    _Ty operator -= ( const ptrdiff_t _Diff ) noexcept {
        return fetch_add ( static_cast < ptrdiff_t > ( 0 - static_cast < size_t > ( _Diff ) ) ) - _Diff;
    }
};
#line 2037 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template < class _Ty >
struct _Atomic_pointer < _Ty & > : _Atomic_storage < _Ty & > {
    using _Base = _Atomic_storage < _Ty & >;
    using difference_type = ptrdiff_t;
    using typename _Base :: _TVal;

    using _Base :: _Base;

    _TVal fetch_add ( const ptrdiff_t _Diff, const memory_order _Order = memory_order_seq_cst ) const noexcept
         {
        const ptrdiff_t _Shift_bytes =
            static_cast < ptrdiff_t > ( static_cast < size_t > ( _Diff ) * sizeof ( remove_pointer_t < _Ty > ) );
        ptrdiff_t _Result;




        _Check_memory_order ( static_cast < unsigned int > ( _Order ) ); _Result = _InterlockedExchangeAdd64 ( :: std :: _Atomic_address_as < long long > ( this -> _Storage ), _Shift_bytes );


        return reinterpret_cast < _TVal > ( _Result );
    }

    _TVal fetch_sub ( const ptrdiff_t _Diff ) const noexcept {
        return fetch_add ( static_cast < ptrdiff_t > ( 0 - static_cast < size_t > ( _Diff ) ) );
    }

    _TVal fetch_sub ( const ptrdiff_t _Diff, const memory_order _Order ) const noexcept
         {
        return fetch_add ( static_cast < ptrdiff_t > ( 0 - static_cast < size_t > ( _Diff ) ), _Order );
    }

    _TVal operator ++ ( int ) const noexcept {
        return fetch_add ( 1 );
    }

    _TVal operator ++ ( ) const noexcept {
        return fetch_add ( 1 ) + 1;
    }

    _TVal operator -- ( int ) const noexcept {
        return fetch_add ( - 1 );
    }

    _TVal operator -- ( ) const noexcept {
        return fetch_add ( - 1 ) - 1;
    }

    _TVal operator += ( const ptrdiff_t _Diff ) const noexcept {
        return fetch_add ( _Diff ) + _Diff;
    }

    _TVal operator -= ( const ptrdiff_t _Diff ) const noexcept {
        return fetch_add ( static_cast < ptrdiff_t > ( 0 - static_cast < size_t > ( _Diff ) ) ) - _Diff;
    }
};
#line 2096 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template< class _Ty> 
#line 2097
struct _Atomic_nonobject_pointer : public _Atomic_storage< _Ty>  { 
#line 2098
using _Base = _Atomic_storage< _Ty> ; 
#line 2099
using difference_type = ::ptrdiff_t; 
#line 2101
using _Atomic_storage< _Ty> ::_Atomic_storage;
#line 2102
}; 
#line 2104
template< class _Ty> 
#line 2105
struct _Atomic_nonobject_pointer< _Ty &>  : public _Atomic_storage< _Ty &>  { 
#line 2106
using _Base = _Atomic_storage< _Ty &> ; 
#line 2108
using _Atomic_storage< _Ty &> ::_Atomic_storage;
#line 2109
}; 
#line 2113
template< class _TVal, class _Ty = _TVal> using _Choose_atomic_base2_t = typename _Select< is_integral_v< _TVal>  && (!is_same_v< bool, remove_cv_t< _TVal> > )> ::template _Apply< _Atomic_integral_facade< _Ty> , typename _Select< is_pointer_v< _TVal> > ::template _Apply< typename _Select< is_object_v< remove_pointer_t< _TVal> > > ::template _Apply< _Atomic_pointer< _Ty> , _Atomic_nonobject_pointer< _Ty> > , _Atomic_storage< _Ty> > > ; 
#line 2126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template< class _TVal, class _Ty = _TVal> using _Choose_atomic_base_t = _Choose_atomic_base2_t< _TVal, _Ty> ; 
#line 2130 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template < class _Ty >
struct atomic : _Choose_atomic_base_t < _Ty > {
private :
    using _Base = _Choose_atomic_base_t < _Ty >;

public :
    static_assert ( is_trivially_copyable_v < _Ty >, "atomic<T> requires T to be trivially copyable." );
    static_assert ( is_copy_constructible_v < _Ty >, "atomic<T> requires T to be copy constructible." );
    static_assert ( is_move_constructible_v < _Ty >, "atomic<T> requires T to be move constructible." );
    static_assert ( is_copy_assignable_v < _Ty >, "atomic<T> requires T to be copy assignable." );
    static_assert ( is_move_assignable_v < _Ty >, "atomic<T> requires T to be move assignable." );
    static_assert ( ! is_const_v < _Ty >, "atomic<T> requires T to be non-const." );
    static_assert ( ! is_volatile_v < _Ty >, "atomic<T> requires T to be non-volatile." );

    using value_type = _Ty;

    template < class _Uty = _Ty, enable_if_t < is_default_constructible_v < _Uty >, int > = 0 >
    constexpr atomic ( ) noexcept ( is_nothrow_default_constructible_v < _Ty > ) : _Base ( ) { }

     constexpr atomic ( const _Ty _Value ) noexcept : _Base ( _Value ) { }

    atomic ( const atomic & ) = delete;
    atomic & operator = ( const atomic & ) = delete;
    atomic & operator = ( const atomic & ) volatile = delete;





    [ [ nodiscard ] ] bool is_lock_free ( ) const volatile noexcept {
        return _Is_always_lock_free < sizeof ( _Ty ) >;
    }

    [ [ nodiscard ] ] bool is_lock_free ( ) const noexcept {
        return static_cast < const volatile atomic * > ( this ) -> is_lock_free ( );
    }

    _Ty operator = ( const _Ty _Value ) volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        this -> store ( _Value );
        return _Value;
    }

    _Ty operator = ( const _Ty _Value ) noexcept {
        this -> store ( _Value );
        return _Value;
    }






    using _Base :: store;
    void store ( const _Ty _Value ) volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        const_cast < atomic * > ( this ) -> _Base :: store ( _Value );
    }

    void store ( const _Ty _Value, const memory_order _Order ) volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        const_cast < atomic * > ( this ) -> _Base :: store ( _Value, _Order );
    }

    using _Base :: load;
    [ [ nodiscard ] ] _Ty load ( ) const volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return const_cast < const atomic * > ( this ) -> _Base :: load ( );
    }

    [ [ nodiscard ] ] _Ty load ( const memory_order _Order ) const volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return const_cast < const atomic * > ( this ) -> _Base :: load ( _Order );
    }

    using _Base :: exchange;
    _Ty exchange ( const _Ty _Value ) volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return const_cast < atomic * > ( this ) -> _Base :: exchange ( _Value );
    }

    _Ty exchange ( const _Ty _Value, const memory_order _Order ) volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return const_cast < atomic * > ( this ) -> _Base :: exchange ( _Value, _Order );
    }

    using _Base :: compare_exchange_strong;
    bool compare_exchange_strong ( _Ty & _Expected, const _Ty _Desired ) volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return const_cast < atomic * > ( this ) -> _Base :: compare_exchange_strong ( _Expected, _Desired );
    }

    bool compare_exchange_strong ( _Ty & _Expected, const _Ty _Desired, const memory_order _Order ) volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return const_cast < atomic * > ( this ) -> _Base :: compare_exchange_strong ( _Expected, _Desired, _Order );
    }

    bool compare_exchange_strong ( _Ty & _Expected, const _Ty _Desired, const memory_order _Success,
        const memory_order _Failure ) volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return this -> compare_exchange_strong ( _Expected, _Desired, _Combine_cas_memory_orders ( _Success, _Failure ) );
    }

    bool compare_exchange_strong (
        _Ty & _Expected, const _Ty _Desired, const memory_order _Success, const memory_order _Failure ) noexcept {
        return this -> compare_exchange_strong ( _Expected, _Desired, _Combine_cas_memory_orders ( _Success, _Failure ) );
    }

    bool compare_exchange_weak ( _Ty & _Expected, const _Ty _Desired ) volatile noexcept {

        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return this -> compare_exchange_strong ( _Expected, _Desired );
    }

    bool compare_exchange_weak ( _Ty & _Expected, const _Ty _Desired ) noexcept {
        return this -> compare_exchange_strong ( _Expected, _Desired );
    }

    bool compare_exchange_weak ( _Ty & _Expected, const _Ty _Desired, const memory_order _Order ) volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return this -> compare_exchange_strong ( _Expected, _Desired, _Order );
    }

    bool compare_exchange_weak ( _Ty & _Expected, const _Ty _Desired, const memory_order _Order ) noexcept {
        return this -> compare_exchange_strong ( _Expected, _Desired, _Order );
    }

    bool compare_exchange_weak ( _Ty & _Expected, const _Ty _Desired, const memory_order _Success,
        const memory_order _Failure ) volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return this -> compare_exchange_strong ( _Expected, _Desired, _Combine_cas_memory_orders ( _Success, _Failure ) );
    }

    bool compare_exchange_weak (
        _Ty & _Expected, const _Ty _Desired, const memory_order _Success, const memory_order _Failure ) noexcept {
        return this -> compare_exchange_strong ( _Expected, _Desired, _Combine_cas_memory_orders ( _Success, _Failure ) );
    }


















    operator _Ty ( ) const volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return this -> load ( );
    }

    operator _Ty ( ) const noexcept {
        return this -> load ( );
    }
};
#line 2425 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
template < class _Ty >
[ [ nodiscard ] ] bool atomic_is_lock_free ( const volatile atomic < _Ty > * _Mem ) noexcept {
    return _Mem -> is_lock_free ( );
}
#line 2430
template < class _Ty >
[ [ nodiscard ] ] bool atomic_is_lock_free ( const atomic < _Ty > * _Mem ) noexcept {
    return _Mem -> is_lock_free ( );
}
#line 2435
template < class _Ty >
void atomic_store ( volatile atomic < _Ty > * const _Mem, const _Identity_t < _Ty > _Value ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    _Mem -> store ( _Value );
}
#line 2441
template < class _Ty >
void atomic_store ( atomic < _Ty > * const _Mem, const _Identity_t < _Ty > _Value ) noexcept {
    _Mem -> store ( _Value );
}
#line 2446
template < class _Ty >
void atomic_store_explicit (
    volatile atomic < _Ty > * const _Mem, const _Identity_t < _Ty > _Value, const memory_order _Order ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    _Mem -> store ( _Value, _Order );
}
#line 2453
template < class _Ty >
void atomic_store_explicit ( atomic < _Ty > * const _Mem, const _Identity_t < _Ty > _Value, const memory_order _Order ) noexcept {
    _Mem -> store ( _Value, _Order );
}
#line 2458
template < class _Ty >
 void atomic_init (
    volatile atomic < _Ty > * const _Mem, const typename atomic < _Ty > :: value_type _Value ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    :: std :: atomic_store_explicit ( _Mem, _Value, memory_order_relaxed );
}
#line 2465
template < class _Ty >
 void atomic_init (
    atomic < _Ty > * const _Mem, const typename atomic < _Ty > :: value_type _Value ) noexcept {
    :: std :: atomic_store_explicit ( _Mem, _Value, memory_order_relaxed );
}
#line 2471
template < class _Ty >
[ [ nodiscard ] ] _Ty atomic_load ( const volatile atomic < _Ty > * const _Mem ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> load ( );
}
#line 2477
template < class _Ty >
[ [ nodiscard ] ] _Ty atomic_load ( const atomic < _Ty > * const _Mem ) noexcept {
    return _Mem -> load ( );
}
#line 2482
template < class _Ty >
[ [ nodiscard ] ] _Ty atomic_load_explicit ( const volatile atomic < _Ty > * const _Mem, const memory_order _Order ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> load ( _Order );
}
#line 2488
template < class _Ty >
[ [ nodiscard ] ] _Ty atomic_load_explicit ( const atomic < _Ty > * const _Mem, const memory_order _Order ) noexcept {
    return _Mem -> load ( _Order );
}
#line 2493
template < class _Ty >
_Ty atomic_exchange ( volatile atomic < _Ty > * const _Mem, const _Identity_t < _Ty > _Value ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> exchange ( _Value );
}
#line 2499
template < class _Ty >
_Ty atomic_exchange ( atomic < _Ty > * const _Mem, const _Identity_t < _Ty > _Value ) noexcept {
    return _Mem -> exchange ( _Value );
}
#line 2504
template < class _Ty >
_Ty atomic_exchange_explicit (
    volatile atomic < _Ty > * const _Mem, const _Identity_t < _Ty > _Value, const memory_order _Order ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> exchange ( _Value, _Order );
}
#line 2511
template < class _Ty >
_Ty atomic_exchange_explicit (
    atomic < _Ty > * const _Mem, const _Identity_t < _Ty > _Value, const memory_order _Order ) noexcept {
    return _Mem -> exchange ( _Value, _Order );
}
#line 2517
template < class _Ty >
bool atomic_compare_exchange_strong (
    volatile atomic < _Ty > * const _Mem, _Identity_t < _Ty > * const _Expected, const _Identity_t < _Ty > _Desired ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> compare_exchange_strong ( * _Expected, _Desired );
}
#line 2524
template < class _Ty >
bool atomic_compare_exchange_strong (
    atomic < _Ty > * const _Mem, _Identity_t < _Ty > * const _Expected, const _Identity_t < _Ty > _Desired ) noexcept {
    return _Mem -> compare_exchange_strong ( * _Expected, _Desired );
}
#line 2530
template < class _Ty >
bool atomic_compare_exchange_strong_explicit ( volatile atomic < _Ty > * const _Mem, _Identity_t < _Ty > * const _Expected,
    const _Identity_t < _Ty > _Desired, const memory_order _Success, const memory_order _Failure ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> compare_exchange_strong ( * _Expected, _Desired, _Combine_cas_memory_orders ( _Success, _Failure ) );
}
#line 2537
template < class _Ty >
bool atomic_compare_exchange_strong_explicit ( atomic < _Ty > * const _Mem, _Identity_t < _Ty > * const _Expected,
    const _Identity_t < _Ty > _Desired, const memory_order _Success, const memory_order _Failure ) noexcept {
    return _Mem -> compare_exchange_strong ( * _Expected, _Desired, _Combine_cas_memory_orders ( _Success, _Failure ) );
}
#line 2543
template < class _Ty >
bool atomic_compare_exchange_weak (
    volatile atomic < _Ty > * const _Mem, _Identity_t < _Ty > * const _Expected, const _Identity_t < _Ty > _Desired ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> compare_exchange_strong ( * _Expected, _Desired );
}
#line 2550
template < class _Ty >
bool atomic_compare_exchange_weak (
    atomic < _Ty > * const _Mem, _Identity_t < _Ty > * const _Expected, const _Identity_t < _Ty > _Desired ) noexcept {
    return _Mem -> compare_exchange_strong ( * _Expected, _Desired );
}
#line 2556
template < class _Ty >
bool atomic_compare_exchange_weak_explicit ( volatile atomic < _Ty > * const _Mem, _Identity_t < _Ty > * const _Expected,
    const _Identity_t < _Ty > _Desired, const memory_order _Success, const memory_order _Failure ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> compare_exchange_strong ( * _Expected, _Desired, _Combine_cas_memory_orders ( _Success, _Failure ) );
}
#line 2563
template < class _Ty >
bool atomic_compare_exchange_weak_explicit ( atomic < _Ty > * const _Mem, _Identity_t < _Ty > * const _Expected,
    const _Identity_t < _Ty > _Desired, const memory_order _Success, const memory_order _Failure ) noexcept {
    return _Mem -> compare_exchange_strong ( * _Expected, _Desired, _Combine_cas_memory_orders ( _Success, _Failure ) );
}
#line 2569
template < class _Ty >
_Ty atomic_fetch_add ( volatile atomic < _Ty > * _Mem, const typename atomic < _Ty > :: difference_type _Value ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> fetch_add ( _Value );
}
#line 2575
template < class _Ty >
_Ty atomic_fetch_add ( atomic < _Ty > * _Mem, const typename atomic < _Ty > :: difference_type _Value ) noexcept {
    return _Mem -> fetch_add ( _Value );
}
#line 2580
template < class _Ty >
_Ty atomic_fetch_add_explicit ( volatile atomic < _Ty > * _Mem, const typename atomic < _Ty > :: difference_type _Value,
    const memory_order _Order ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> fetch_add ( _Value, _Order );
}
#line 2587
template < class _Ty >
_Ty atomic_fetch_add_explicit (
    atomic < _Ty > * _Mem, const typename atomic < _Ty > :: difference_type _Value, const memory_order _Order ) noexcept {
    return _Mem -> fetch_add ( _Value, _Order );
}
#line 2593
template < class _Ty >
_Ty atomic_fetch_sub ( volatile atomic < _Ty > * _Mem, const typename atomic < _Ty > :: difference_type _Value ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> fetch_sub ( _Value );
}
#line 2599
template < class _Ty >
_Ty atomic_fetch_sub ( atomic < _Ty > * _Mem, const typename atomic < _Ty > :: difference_type _Value ) noexcept {
    return _Mem -> fetch_sub ( _Value );
}
#line 2604
template < class _Ty >
_Ty atomic_fetch_sub_explicit ( volatile atomic < _Ty > * _Mem, const typename atomic < _Ty > :: difference_type _Value,
    const memory_order _Order ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> fetch_sub ( _Value, _Order );
}
#line 2611
template < class _Ty >
_Ty atomic_fetch_sub_explicit (
    atomic < _Ty > * _Mem, const typename atomic < _Ty > :: difference_type _Value, const memory_order _Order ) noexcept {
    return _Mem -> fetch_sub ( _Value, _Order );
}
#line 2617
template < class _Ty >
_Ty atomic_fetch_and ( volatile atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> fetch_and ( _Value );
}
#line 2623
template < class _Ty >
_Ty atomic_fetch_and ( atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value ) noexcept {
    return _Mem -> fetch_and ( _Value );
}
#line 2628
template < class _Ty >
_Ty atomic_fetch_and_explicit (
    volatile atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value, const memory_order _Order ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> fetch_and ( _Value, _Order );
}
#line 2635
template < class _Ty >
_Ty atomic_fetch_and_explicit (
    atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value, const memory_order _Order ) noexcept {
    return _Mem -> fetch_and ( _Value, _Order );
}
#line 2641
template < class _Ty >
_Ty atomic_fetch_or ( volatile atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> fetch_or ( _Value );
}
#line 2647
template < class _Ty >
_Ty atomic_fetch_or ( atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value ) noexcept {
    return _Mem -> fetch_or ( _Value );
}
#line 2652
template < class _Ty >
_Ty atomic_fetch_or_explicit (
    volatile atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value, const memory_order _Order ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> fetch_or ( _Value, _Order );
}
#line 2659
template < class _Ty >
_Ty atomic_fetch_or_explicit (
    atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value, const memory_order _Order ) noexcept {
    return _Mem -> fetch_or ( _Value, _Order );
}
#line 2665
template < class _Ty >
_Ty atomic_fetch_xor ( volatile atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> fetch_xor ( _Value );
}
#line 2671
template < class _Ty >
_Ty atomic_fetch_xor ( atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value ) noexcept {
    return _Mem -> fetch_xor ( _Value );
}
#line 2676
template < class _Ty >
_Ty atomic_fetch_xor_explicit (
    volatile atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value, const memory_order _Order ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> fetch_xor ( _Value, _Order );
}
#line 2683
template < class _Ty >
_Ty atomic_fetch_xor_explicit (
    atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value, const memory_order _Order ) noexcept {
    return _Mem -> fetch_xor ( _Value, _Order );
}
#line 2733 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
using atomic_bool = atomic< bool> ; 
#line 2735
using atomic_char = atomic< char> ; 
#line 2736
using atomic_schar = atomic< signed char> ; 
#line 2737
using atomic_uchar = atomic< unsigned char> ; 
#line 2738
using atomic_short = atomic< short> ; 
#line 2739
using atomic_ushort = atomic< unsigned short> ; 
#line 2740
using atomic_int = atomic< int> ; 
#line 2741
using atomic_uint = atomic< unsigned> ; 
#line 2742
using atomic_long = atomic< long> ; 
#line 2743
using atomic_ulong = atomic< unsigned long> ; 
#line 2744
using atomic_llong = atomic< __int64> ; 
#line 2745
using atomic_ullong = atomic< unsigned __int64> ; 
#line 2750
using atomic_char16_t = atomic< char16_t> ; 
#line 2751
using atomic_char32_t = atomic< char32_t> ; 
#line 2752
using atomic_wchar_t = atomic< __wchar_t> ; 
#line 2754
using atomic_int8_t = atomic< signed char> ; 
#line 2755
using atomic_uint8_t = atomic< unsigned char> ; 
#line 2756
using atomic_int16_t = atomic< short> ; 
#line 2757
using atomic_uint16_t = atomic< unsigned short> ; 
#line 2758
using atomic_int32_t = atomic< int> ; 
#line 2759
using atomic_uint32_t = atomic< unsigned> ; 
#line 2760
using atomic_int64_t = atomic< __int64> ; 
#line 2761
using atomic_uint64_t = atomic< unsigned __int64> ; 
#line 2763
using atomic_int_least8_t = atomic< signed char> ; 
#line 2764
using atomic_uint_least8_t = atomic< unsigned char> ; 
#line 2765
using atomic_int_least16_t = atomic< short> ; 
#line 2766
using atomic_uint_least16_t = atomic< unsigned short> ; 
#line 2767
using atomic_int_least32_t = atomic< int> ; 
#line 2768
using atomic_uint_least32_t = atomic< unsigned> ; 
#line 2769
using atomic_int_least64_t = atomic< __int64> ; 
#line 2770
using atomic_uint_least64_t = atomic< unsigned __int64> ; 
#line 2772
using atomic_int_fast8_t = atomic< signed char> ; 
#line 2773
using atomic_uint_fast8_t = atomic< unsigned char> ; 
#line 2774
using atomic_int_fast16_t = atomic< int> ; 
#line 2775
using atomic_uint_fast16_t = atomic< unsigned> ; 
#line 2776
using atomic_int_fast32_t = atomic< int> ; 
#line 2777
using atomic_uint_fast32_t = atomic< unsigned> ; 
#line 2778
using atomic_int_fast64_t = atomic< __int64> ; 
#line 2779
using atomic_uint_fast64_t = atomic< unsigned __int64> ; 
#line 2781
using atomic_intptr_t = atomic< __int64> ; 
#line 2782
using atomic_uintptr_t = atomic< unsigned __int64> ; 
#line 2783
using atomic_size_t = atomic< unsigned __int64> ; 
#line 2784
using atomic_ptrdiff_t = atomic< __int64> ; 
#line 2785
using atomic_intmax_t = atomic< __int64> ; 
#line 2786
using atomic_uintmax_t = atomic< unsigned __int64> ; 
#line 2799 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
struct atomic_flag { 
#line 2810 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
bool test_and_set(const memory_order _Order = memory_order_seq_cst) noexcept { 
#line 2811
return (_Storage).exchange(true, _Order) != (0); 
#line 2812
} 
#line 2814
bool test_and_set(const memory_order _Order = memory_order_seq_cst) volatile noexcept { 
#line 2815
return (_Storage).exchange(true, _Order) != (0); 
#line 2816
} 
#line 2818
void clear(const memory_order _Order = memory_order_seq_cst) noexcept { 
#line 2819
(_Storage).store(false, _Order); 
#line 2820
} 
#line 2822
void clear(const memory_order _Order = memory_order_seq_cst) volatile noexcept { 
#line 2823
(_Storage).store(false, _Order); 
#line 2824
} 
#line 2826
constexpr atomic_flag() noexcept = default;
#line 2855 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
atomic< long>  _Storage; 
#line 2859 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
}; 
#line 2881 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
inline bool atomic_flag_test_and_set(atomic_flag *const _Flag) noexcept { 
#line 2882
return _Flag->test_and_set(); 
#line 2883
} 
#line 2885
inline bool atomic_flag_test_and_set(volatile atomic_flag *const _Flag) noexcept { 
#line 2886
return _Flag->test_and_set(); 
#line 2887
} 
#line 2889
inline bool atomic_flag_test_and_set_explicit(atomic_flag *const 
#line 2890
_Flag, const memory_order _Order) noexcept { 
#line 2891
return _Flag->test_and_set(_Order); 
#line 2892
} 
#line 2894
inline bool atomic_flag_test_and_set_explicit(volatile atomic_flag *const 
#line 2895
_Flag, const memory_order _Order) noexcept { 
#line 2896
return _Flag->test_and_set(_Order); 
#line 2897
} 
#line 2899
inline void atomic_flag_clear(atomic_flag *const _Flag) noexcept { 
#line 2900
_Flag->clear(); 
#line 2901
} 
#line 2903
inline void atomic_flag_clear(volatile atomic_flag *const _Flag) noexcept { 
#line 2904
_Flag->clear(); 
#line 2905
} 
#line 2907
inline void atomic_flag_clear_explicit(atomic_flag *const _Flag, const memory_order _Order) noexcept { 
#line 2908
_Flag->clear(_Order); 
#line 2909
} 
#line 2911
inline void atomic_flag_clear_explicit(volatile atomic_flag *const 
#line 2912
_Flag, const memory_order _Order) noexcept { 
#line 2913
_Flag->clear(_Order); 
#line 2914
} 
#line 3015 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
}
#line 3042 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\atomic"
#pragma warning(pop)
#pragma pack ( pop )
#line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\system_error"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 37
namespace std { 
#line 38
enum class io_errc { 
#line 39
stream = 1
#line 40
}; 
#line 42
template< class _Enum> 
#line 43
struct is_error_code_enum : public false_type { }; 
#line 46
template<> struct is_error_code_enum< io_errc>  : public true_type { }; 
#line 48
template< class _Ty> constexpr bool 
#line 49
is_error_code_enum_v = (is_error_code_enum< _Ty> ::value); 
#line 51
template< class _Enum> 
#line 52
struct is_error_condition_enum : public false_type { }; 
#line 55
template<> struct is_error_condition_enum< errc>  : public true_type { }; 
#line 57
template< class _Ty> constexpr bool 
#line 58
is_error_condition_enum_v = (is_error_condition_enum< _Ty> ::value); 
#line 60
class error_code; 
#line 61
class error_condition; 
#line 63
namespace _Ensure_adl { 
#line 64
inline void make_error_code() = delete;
#line 65
inline void make_error_condition() = delete;
#line 66
}
#line 68
class error_category; 
#line 70
[[nodiscard]] inline const error_category &generic_category() noexcept; 
#line 71
[[nodiscard]] inline const error_category &iostream_category() noexcept; 
#line 72
[[nodiscard]] inline const error_category &system_category() noexcept; 
#line 74
class __declspec(novtable) error_category { 
#line 81
#pragma warning(push)
#pragma warning(disable : 4355)
public: constexpr error_category() noexcept : _Addr(this) { } 
#pragma warning(pop)
#line 87 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\system_error"
virtual ~error_category() noexcept = default;
#line 89
[[nodiscard]] virtual const char *name() const noexcept = 0; 
#line 91
[[nodiscard]] virtual string message(int _Errval) const = 0; 
#line 93
[[nodiscard]] inline virtual error_condition default_error_condition(int _Errval) const noexcept; 
#line 95
[[nodiscard]] inline virtual bool equivalent(int _Errval, const error_condition & _Cond) const noexcept; 
#line 97
[[nodiscard]] inline virtual bool equivalent(const error_code & _Code, int _Errval) const noexcept; 
#line 99
[[nodiscard]] bool operator==(const error_category &_Right) const noexcept { 
#line 103
return _Bit_cast< unsigned __int64> (_Addr) == _Bit_cast< unsigned __int64> (_Right._Addr); 
#line 105 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\system_error"
} 
#line 112 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\system_error"
[[nodiscard]] bool operator!=(const error_category &_Right) const noexcept { 
#line 113
return !((*this) == _Right); 
#line 114
} 
#line 116
[[nodiscard]] bool operator<(const error_category &_Right) const noexcept { 
#line 120
return _Bit_cast< unsigned __int64> (_Addr) < _Bit_cast< unsigned __int64> (_Right._Addr); 
#line 122 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\system_error"
} 
#line 125 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\system_error"
error_category(const error_category &) = delete;
#line 126
error_category &operator=(const error_category &) = delete;
#line 132
protected: union _Addr_storage { 
#line 134
private: uintptr_t _Num; 
#line 135
error_category *_Ptr; 
#line 138
public: constexpr explicit _Addr_storage(const uintptr_t _Addr_num) noexcept : _Num(_Addr_num) { } 
#line 139
constexpr explicit _Addr_storage(error_category *const _Addr_ptr) noexcept : _Ptr(_Addr_ptr) { } 
#line 142
constexpr _Addr_storage &operator=(const uintptr_t _Addr_num) noexcept { 
#line 143
(_Num) = _Addr_num; 
#line 144
return *this; 
#line 145
} 
#line 146
}; 
#line 150
_Addr_storage _Addr; 
#line 153 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\system_error"
constexpr explicit error_category(const uintptr_t _Addr_) noexcept : _Addr(_Addr_) { } 
#line 155
enum: uintptr_t { 
#line 156
_Future_addr = 1Ui64, 
#line 157
_Generic_addr = 3Ui64, 
#line 158
_Iostream_addr = 5Ui64, 
#line 159
_System_addr = 7Ui64
#line 160
}; 
#line 161
}; 
#line 164
[[nodiscard]] inline bool _System_error_equal(const error_code &, const error_condition &) noexcept; 
#line 167 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\system_error"
class error_code { 
#line 169
public: error_code() noexcept : _Myval(0), _Mycat(&::std::system_category()) { } 
#line 171
error_code(int _Val, const error_category &_Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) { } 
#line 173
template < class _Enum, enable_if_t < is_error_code_enum_v < _Enum >, int > = 0 >
    error_code ( _Enum _Errcode ) noexcept : _Myval ( 0 ), _Mycat ( nullptr ) {
        using _Ensure_adl :: make_error_code;
        * this = make_error_code ( _Errcode );
    }
#line 179
void assign(int _Val, const error_category &_Cat) noexcept { 
#line 180
(_Myval) = _Val; 
#line 181
(_Mycat) = (&_Cat); 
#line 182
} 
#line 184
template < class _Enum, enable_if_t < is_error_code_enum_v < _Enum >, int > = 0 >
    error_code & operator = ( _Enum _Errcode ) noexcept {
        using _Ensure_adl :: make_error_code;
        * this = make_error_code ( _Errcode );
        return * this;
    }
#line 191
void clear() noexcept { 
#line 192
(_Myval) = 0; 
#line 193
(_Mycat) = (&::std::system_category()); 
#line 194
} 
#line 196
[[nodiscard]] int value() const noexcept { 
#line 197
return _Myval; 
#line 198
} 
#line 200
[[nodiscard]] const error_category &category() const noexcept { 
#line 201
return *(_Mycat); 
#line 202
} 
#line 204
[[nodiscard]] inline error_condition default_error_condition() const noexcept; 
#line 206
[[nodiscard]] string message() const { 
#line 207
return this->category().message(this->value()); 
#line 208
} 
#line 210
explicit operator bool() const noexcept { 
#line 211
return this->value() != 0; 
#line 212
} 
#line 215
[[nodiscard]] friend inline bool operator==(const error_code &_Left, const error_code &_Right) noexcept { 
#line 216
return ((_Left.category()) == (_Right.category())) && (_Left.value() == _Right.value()); 
#line 217
} 
#line 219
[[nodiscard]] friend inline bool operator==(const error_code &_Left, const std::error_condition &_Right) noexcept { 
#line 220
return _System_error_equal(_Left, _Right); 
#line 221
} 
#line 231 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\system_error"
[[nodiscard]] friend inline bool operator<(const error_code &_Left, const error_code &_Right) noexcept { 
#line 232
return ((_Left.category()) < (_Right.category())) || (((_Left.category()) == (_Right.category())) && (_Left.value() < _Right.value())); 
#line 234
} 
#line 235
[[nodiscard]] friend inline bool operator==(const std::error_condition &_Left, const error_code &_Right) noexcept { 
#line 236
return _System_error_equal(_Right, _Left); 
#line 237
} 
#line 239
[[nodiscard]] friend inline bool operator!=(const error_code &_Left, const error_code &_Right) noexcept { 
#line 240
return !(_Left == _Right); 
#line 241
} 
#line 243
[[nodiscard]] friend inline bool operator!=(const error_code &_Left, const std::error_condition &_Right) noexcept { 
#line 244
return !_System_error_equal(_Left, _Right); 
#line 245
} 
#line 247
[[nodiscard]] friend inline bool operator!=(const std::error_condition &_Left, const error_code &_Right) noexcept { 
#line 248
return !_System_error_equal(_Right, _Left); 
#line 249
} 
#line 254 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\system_error"
private: int _Myval; 
#line 255
const error_category *_Mycat; 
#line 256
}; 
#line 258
class error_condition { 
#line 260
public: error_condition() noexcept : _Myval(0), _Mycat(&::std::generic_category()) { } 
#line 262
error_condition(int _Val, const error_category &_Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) { } 
#line 264
template < class _Enum, enable_if_t < is_error_condition_enum_v < _Enum >, int > = 0 >
    error_condition ( _Enum _Errcode ) noexcept : _Myval ( 0 ), _Mycat ( nullptr ) {
        using _Ensure_adl :: make_error_condition;
        * this = make_error_condition ( _Errcode );
    }
#line 270
void assign(int _Val, const error_category &_Cat) noexcept { 
#line 271
(_Myval) = _Val; 
#line 272
(_Mycat) = (&_Cat); 
#line 273
} 
#line 275
template < class _Enum, enable_if_t < is_error_condition_enum_v < _Enum >, int > = 0 >
    error_condition & operator = ( _Enum _Errcode ) noexcept {
        using _Ensure_adl :: make_error_condition;
        * this = make_error_condition ( _Errcode );
        return * this;
    }
#line 282
void clear() noexcept { 
#line 283
(_Myval) = 0; 
#line 284
(_Mycat) = (&::std::generic_category()); 
#line 285
} 
#line 287
[[nodiscard]] int value() const noexcept { 
#line 288
return _Myval; 
#line 289
} 
#line 291
[[nodiscard]] const error_category &category() const noexcept { 
#line 292
return *(_Mycat); 
#line 293
} 
#line 295
[[nodiscard]] string message() const { 
#line 296
return this->category().message(this->value()); 
#line 297
} 
#line 299
explicit operator bool() const noexcept { 
#line 300
return this->value() != 0; 
#line 301
} 
#line 304
[[nodiscard]] friend inline bool operator==(const error_condition &_Left, const error_condition &_Right) noexcept { 
#line 305
return ((_Left.category()) == (_Right.category())) && (_Left.value() == _Right.value()); 
#line 306
} 
#line 317 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\system_error"
[[nodiscard]] friend inline bool operator<(const error_condition &_Left, const error_condition &_Right) noexcept { 
#line 318
return ((_Left.category()) < (_Right.category())) || (((_Left.category()) == (_Right.category())) && (_Left.value() < _Right.value())); 
#line 320
} 
#line 321
[[nodiscard]] friend inline bool operator!=(const error_condition &_Left, const error_condition &_Right) noexcept { 
#line 322
return !(_Left == _Right); 
#line 323
} 
#line 329 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\system_error"
friend inline bool operator==(const std::error_code & _Left, const error_condition & _Right) noexcept; 
#line 331
friend inline bool operator==(const error_condition & _Left, const std::error_code & _Right) noexcept; 
#line 332
friend inline bool operator!=(const std::error_code & _Left, const error_condition & _Right) noexcept; 
#line 333
friend inline bool operator!=(const error_condition & _Left, const std::error_code & _Right) noexcept; 
#line 338 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\system_error"
private: int _Myval; 
#line 339
const error_category *_Mycat; 
#line 340
}; 
#line 343
[[nodiscard]] inline bool _System_error_equal(const error_code &_Left, const error_condition &_Right) noexcept { 
#line 344
return _Left.category().equivalent(_Left.value(), _Right) || _Right.category().equivalent(_Left, _Right.value()); 
#line 345
} 
#line 407 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\system_error"
[[nodiscard]] inline error_condition error_category::default_error_condition(int _Errval) const noexcept { 
#line 409
return error_condition(_Errval, *this); 
#line 410
} 
#line 412
[[nodiscard]] inline bool error_category::equivalent(int _Errval, const error_condition &_Cond) const noexcept { 
#line 413
return ((this->default_error_condition(_Errval)) == _Cond); 
#line 414
} 
#line 416
[[nodiscard]] inline bool error_category::equivalent(const error_code &_Code, int _Errval) const noexcept { 
#line 417
return ((*this) == (_Code.category())) && (_Code.value() == _Errval); 
#line 418
} 
#line 420
[[nodiscard]] inline error_condition error_code::default_error_condition() const noexcept { 
#line 422
return this->category().default_error_condition(this->value()); 
#line 423
} 
#line 425
[[nodiscard]] inline error_code make_error_code(errc _Ec) noexcept { 
#line 426
return error_code(static_cast< int>(_Ec), ::std::generic_category()); 
#line 427
} 
#line 429
[[nodiscard]] inline error_code make_error_code(io_errc _Ec) noexcept { 
#line 430
return error_code(static_cast< int>(_Ec), ::std::iostream_category()); 
#line 431
} 
#line 433
[[nodiscard]] inline error_condition make_error_condition(errc _Ec) noexcept { 
#line 434
return error_condition(static_cast< int>(_Ec), ::std::generic_category()); 
#line 435
} 
#line 437
[[nodiscard]] inline error_condition make_error_condition(io_errc _Ec) noexcept { 
#line 438
return error_condition(static_cast< int>(_Ec), ::std::iostream_category()); 
#line 439
} 
#line 442
template<> struct hash< error_code>  { 
#line 443
using argument_type = error_code; 
#line 444
using result_type = size_t; 
#line 446
[[nodiscard]] size_t operator()(const error_code &_Keyval) const noexcept { 
#line 447
return std::hash< int> {}(_Keyval.value()); 
#line 448
} 
#line 449
}; 
#line 452
template<> struct hash< error_condition>  { 
#line 453
using argument_type = error_condition; 
#line 454
using result_type = size_t; 
#line 456
[[nodiscard]] size_t operator()(const error_condition &_Keyval) const noexcept { 
#line 457
return std::hash< int> {}(_Keyval.value()); 
#line 458
} 
#line 459
}; 
#line 461
class [[nodiscard]] _System_error : public runtime_error { 
#line 463
static string _Makestr(error_code _Errcode, string _Message) { 
#line 464
if (!_Message.empty()) { 
#line 465
_Message.append(": "); 
#line 466
}  
#line 468
_Message.append(_Errcode.message()); 
#line 469
return _Message; 
#line 470
} 
#line 473
protected: _System_error(error_code _Errcode) : runtime_error(_Errcode.message()), _Mycode(_Errcode) { } 
#line 475
_System_error(error_code _Errcode, const string &_Message) : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) 
#line 476
{ } 
#line 478
error_code _Mycode; 
#line 479
}; 
#line 481
class [[nodiscard]] system_error : public _System_error { 
#line 483
using _Mybase = _System_error; 
#line 486
public: system_error(error_code _Errcode) : _Mybase(_Errcode) { } 
#line 488
system_error(error_code _Errcode, const string &_Message) : _Mybase(_Errcode, _Message) { } 
#line 490
system_error(error_code _Errcode, const char *_Message) : _Mybase(_Errcode, _Message) { } 
#line 492
system_error(int _Errval, const error_category &_Errcat) : _Mybase(error_code(_Errval, _Errcat)) { } 
#line 494
system_error(int _Errval, const error_category &_Errcat, const string &_Message) : _Mybase(error_code(_Errval, _Errcat), _Message) 
#line 495
{ } 
#line 497
system_error(int _Errval, const error_category &_Errcat, const char *_Message) : _Mybase(error_code(_Errval, _Errcat), _Message) 
#line 498
{ } 
#line 500
[[nodiscard]] const error_code &code() const noexcept { 
#line 501
return _Mycode; 
#line 502
} 
#line 510 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\system_error"
}; 
#line 512
[[noreturn]] inline void _Throw_system_error(const errc _Ec) { 
#line 513
throw system_error{::std::make_error_code(_Ec)}; 
#line 514
} 
#line 516
const char *__cdecl _Syserror_map(int); 
#line 517
int __cdecl _Winerror_map(int); 
#line 519
struct _System_error_message { 
#line 520
char *_Str; 
#line 521
size_t _Length; 
#line 523
explicit _System_error_message(const unsigned long _Ec) noexcept : _Str((nullptr)), _Length(::__std_system_error_allocate_message(_Ec, &(_Str))) 
#line 524
{ } 
#line 526
_System_error_message(const _System_error_message &) = delete;
#line 527
_System_error_message &operator=(const _System_error_message &) = delete;
#line 529
~_System_error_message() { 
#line 530
::__std_system_error_deallocate_message(_Str); 
#line 531
} 
#line 532
}; 
#line 534
class _Generic_error_category : public error_category { 
#line 536
public: constexpr _Generic_error_category() noexcept : error_category(_Generic_addr) { } 
#line 538
[[nodiscard]] virtual const char *name() const noexcept override { 
#line 539
return "generic"; 
#line 540
} 
#line 542
[[nodiscard]] virtual string message(int _Errcode) const override { 
#line 543
return _Syserror_map(_Errcode); 
#line 544
} 
#line 545
}; 
#line 547
class _Iostream_error_category2 : public error_category { 
#line 549
public: constexpr _Iostream_error_category2() noexcept : error_category(_Iostream_addr) { } 
#line 551
[[nodiscard]] virtual const char *name() const noexcept override { 
#line 552
return "iostream"; 
#line 553
} 
#line 555
[[nodiscard]] virtual string message(int _Errcode) const override { 
#line 556
if (_Errcode == (static_cast< int>(io_errc::stream))) { 
#line 557
static constexpr char _Iostream_error[] = "iostream stream error"; 
#line 558
constexpr size_t _Iostream_error_length = (sizeof _Iostream_error - (1)); 
#line 559
return string{_Iostream_error, _Iostream_error_length}; 
#line 560
} else { 
#line 561
return _Syserror_map(_Errcode); 
#line 562
}  
#line 563
} 
#line 564
}; 
#line 566
class _System_error_category : public error_category { 
#line 568
public: constexpr _System_error_category() noexcept : error_category(_System_addr) { } 
#line 570
[[nodiscard]] virtual const char *name() const noexcept override { 
#line 571
return "system"; 
#line 572
} 
#line 574
[[nodiscard]] virtual string message(int _Errcode) const override { 
#line 575
const _System_error_message _Msg(static_cast< unsigned long>(_Errcode)); 
#line 577
if ((_Msg._Str) && ((_Msg._Length) != (0))) { 
#line 579
return string{_Msg._Str, _Msg._Length}; 
#line 580
} else { 
#line 581
static constexpr char _Unknown_error[] = "unknown error"; 
#line 582
constexpr size_t _Unknown_error_length = (sizeof _Unknown_error - (1)); 
#line 583
return string{_Unknown_error, _Unknown_error_length}; 
#line 584
}  
#line 585
} 
#line 587
[[nodiscard]] virtual error_condition default_error_condition(int _Errval) const noexcept override { 
#line 588
if (_Errval == 0) { 
#line 589
return error_condition(0, ::std::generic_category()); 
#line 590
}  
#line 593
const int _Posv = _Winerror_map(_Errval); 
#line 594
if (_Posv == 0) { 
#line 595
return error_condition(_Errval, ::std::system_category()); 
#line 596
} else { 
#line 597
return error_condition(_Posv, ::std::generic_category()); 
#line 598
}  
#line 599
} 
#line 600
}; 
#line 651 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\system_error"
template < class _Ty >
struct _Constexpr_immortalize_impl {
    union {
        _Ty _Storage;
    };

    constexpr _Constexpr_immortalize_impl ( ) noexcept : _Storage { } { }

    _Constexpr_immortalize_impl ( const _Constexpr_immortalize_impl & ) = delete;
    _Constexpr_immortalize_impl & operator = ( const _Constexpr_immortalize_impl & ) = delete;

    [ [ msvc :: noop_dtor ] ] ~ _Constexpr_immortalize_impl ( ) {

    }
};
#line 667
template < class _Ty >
[ [ nodiscard ] ] const _Ty & _Immortalize_memcpy_image ( ) noexcept {
    static _Constexpr_immortalize_impl < _Ty > _Static;
    return _Static . _Storage;
}
#line 693 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\system_error"
[[nodiscard]] inline const error_category &generic_category() noexcept { 
#line 694
return _Immortalize_memcpy_image< _Generic_error_category> (); 
#line 695
} 
#line 697
[[nodiscard]] inline const error_category &iostream_category() noexcept { 
#line 698
return _Immortalize_memcpy_image< _Iostream_error_category2> (); 
#line 699
} 
#line 701
[[nodiscard]] inline const error_category &system_category() noexcept { 
#line 702
return _Immortalize_memcpy_image< _System_error_category> (); 
#line 703
} 
#line 704
}
#line 735 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\system_error"
#pragma warning(pop)
#pragma pack ( pop )
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\typeinfo"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 19
#pragma warning(disable : 4275)
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_typeinfo.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 18
#pragma pack ( push, 8 )
#line 20
extern "C++" {
#line 27 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_typeinfo.h"
struct __type_info_node; 
#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_typeinfo.h"
extern __type_info_node __type_info_root_node; 
#line 36 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_typeinfo.h"
}
#line 39
__pragma( pack ( push, 8 )) extern "C" {
#line 41
struct __std_type_info_data { 
#line 43
const char *_UndecoratedName; 
#line 44
const char _DecoratedName[1]; 
#line 45
__std_type_info_data() = delete;
#line 46
__std_type_info_data(const __std_type_info_data &) = delete;
#line 47
__std_type_info_data(__std_type_info_data &&) = delete;
#line 49
__std_type_info_data &operator=(const __std_type_info_data &) = delete;
#line 50
__std_type_info_data &operator=(__std_type_info_data &&) = delete;
#line 51
}; 
#line 53
int __cdecl __std_type_info_compare(const __std_type_info_data * _Lhs, const __std_type_info_data * _Rhs); 
#line 58
size_t __cdecl __std_type_info_hash(const __std_type_info_data * _Data); 
#line 62
const char *__cdecl __std_type_info_name(__std_type_info_data * _Data, __type_info_node * _RootNode); 
#line 67
}__pragma( pack ( pop )) 
#line 70
extern "C++" {
#line 72
#pragma warning(push)
#pragma warning(disable: 4577)
class type_info { 
#line 78
public: type_info(const type_info &) = delete;
#line 79
type_info &operator=(const type_info &) = delete;
#line 81
[[nodiscard]] size_t hash_code() const noexcept 
#line 82
{ 
#line 83
return __std_type_info_hash(&(_Data)); 
#line 84
} 
#line 86
[[nodiscard]] bool 
#line 90 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_typeinfo.h"
operator==(const type_info &_Other) const noexcept 
#line 91
{ 
#line 99 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_typeinfo.h"
return __std_type_info_compare(&(_Data), &(_Other._Data)) == 0; 
#line 100
} 
#line 103
[[nodiscard]] bool operator!=(const type_info &_Other) const noexcept 
#line 104
{ 
#line 105
return __std_type_info_compare(&(_Data), &(_Other._Data)) != 0; 
#line 106
} 
#line 109 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_typeinfo.h"
[[nodiscard]] bool before(const type_info &_Other) const noexcept 
#line 110
{ 
#line 111
return __std_type_info_compare(&(_Data), &(_Other._Data)) < 0; 
#line 112
} 
#line 114
[[nodiscard]] const char *name() const noexcept 
#line 115
{ 
#line 119
return __std_type_info_name(&(_Data), &__type_info_root_node); 
#line 121 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_typeinfo.h"
} 
#line 123
[[nodiscard]] const char *raw_name() const noexcept 
#line 124
{ 
#line 125
return (_Data)._DecoratedName; 
#line 126
} 
#line 128
virtual ~type_info() noexcept; 
#line 132
private: mutable __std_type_info_data _Data; 
#line 133
}; 
#pragma warning(pop)
#line 136
namespace std { 
#line 137
using ::type_info;
#line 138
}
#line 142
namespace std { 
#line 144
#pragma warning(push)
#pragma warning(disable: 4577)
class [[nodiscard]] bad_cast : public exception { 
#line 151
public: bad_cast() noexcept : exception("bad cast", 1) 
#line 153
{ 
#line 154
} 
#line 156
static bad_cast __construct_from_string_literal(const char *const _Message) noexcept 
#line 157
{ 
#line 158
return bad_cast(_Message, 1); 
#line 159
} 
#line 163
private: bad_cast(const char *const _Message, int) noexcept : exception(_Message, 1) 
#line 165
{ 
#line 166
} 
#line 167
}; 
#line 169
class [[nodiscard]] bad_typeid : public exception { 
#line 174
public: bad_typeid() noexcept : exception("bad typeid", 1) 
#line 176
{ 
#line 177
} 
#line 179
static bad_typeid __construct_from_string_literal(const char *const _Message) noexcept 
#line 180
{ 
#line 181
return bad_typeid(_Message, 1); 
#line 182
} 
#line 186
friend class __non_rtti_object; 
#line 188
private: bad_typeid(const char *const _Message, int) noexcept : exception(_Message, 1) 
#line 190
{ 
#line 191
} 
#line 192
}; 
#line 194
class [[nodiscard]] __non_rtti_object : public bad_typeid { 
#line 199
public: static __non_rtti_object __construct_from_string_literal(const char *const _Message) noexcept 
#line 200
{ 
#line 201
return __non_rtti_object(_Message, 1); 
#line 202
} 
#line 206
private: __non_rtti_object(const char *const _Message, int) noexcept : bad_typeid(_Message, 1) 
#line 208
{ 
#line 209
} 
#line 210
}; 
#line 212
#pragma warning(pop)
}
#line 217 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_typeinfo.h"
}
#line 219
#pragma pack ( pop )
#pragma warning(pop)
#line 26 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\typeinfo"
namespace std { 
#line 29
constexpr int _Small_object_num_ptrs = ((6) + ((16) / sizeof(void *))); 
#line 62 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\typeinfo"
[[noreturn]] inline void _Throw_bad_cast() { 
#line 63
throw bad_cast{}; 
#line 64
} 
#line 66
}
#line 70
#pragma pack ( pop )
#pragma warning(pop)
#line 20 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 31
namespace std { 
#line 135 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _InIt, class _Diff, class _NoThrowFwdIt >
_NoThrowFwdIt uninitialized_copy_n ( const _InIt _First, const _Diff _Count_raw, _NoThrowFwdIt _Dest ) {

    _Algorithm_int_t < _Diff > _Count = _Count_raw;
    if ( _Count <= 0 ) {
        return _Dest;
    }

    auto _UFirst = :: std :: _Get_unwrapped_n ( _First, _Count );
    auto _UDest = :: std :: _Get_unwrapped_n ( _Dest, _Count );
    if constexpr ( _Iter_copy_cat < decltype ( _UFirst ), decltype ( _UDest ) > :: _Bitcopy_constructible ) {
        _UDest = :: std :: _Copy_memmove_n ( _UFirst, static_cast < size_t > ( _Count ), _UDest );
    } else {
        _Uninitialized_backout < decltype ( _UDest ) > _Backout { _UDest };

        for (; _Count > 0; -- _Count, ( void ) ++ _UFirst ) {
            _Backout . _Emplace_back_deref ( _UFirst );
        }

        _UDest = _Backout . _Release ( );
    }

    :: std :: _Seek_wrapped ( _Dest, _UDest );
    return _Dest;
}
#line 444 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _NoThrowFwdIt, class _Diff, class _Tval >
_NoThrowFwdIt uninitialized_fill_n ( _NoThrowFwdIt _First, const _Diff _Count_raw, const _Tval & _Val ) {

    _Algorithm_int_t < _Diff > _Count = _Count_raw;
    if ( _Count <= 0 ) {
        return _First;
    }

    auto _UFirst = :: std :: _Get_unwrapped_n ( _First, _Count );
    if constexpr ( _Fill_memset_is_safe < decltype ( _UFirst ), _Tval > ) {
        :: std :: _Fill_memset ( _UFirst, _Val, static_cast < size_t > ( _Count ) );
        _UFirst += _Count;
    } else {
        if constexpr ( _Fill_zero_memset_is_safe < decltype ( _UFirst ), _Tval > ) {
            if ( :: std :: _Is_all_bits_zero ( _Val ) ) {
                :: std :: _Fill_zero_memset ( _UFirst, static_cast < size_t > ( _Count ) );
                :: std :: _Seek_wrapped ( _First, _UFirst + _Count );
                return _First;
            }
        }

        _Uninitialized_backout < decltype ( _UFirst ) > _Backout { _UFirst };

        for (; _Count > 0; -- _Count ) {
            _Backout . _Emplace_back ( _Val );
        }

        _UFirst = _Backout . _Release ( );
    }

    :: std :: _Seek_wrapped ( _First, _UFirst );
    return _First;
}
#line 938 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _OutIt, class _Ty >
class raw_storage_iterator {
public :
    using iterator_category = output_iterator_tag;
    using value_type = void;



    using difference_type = void;

    using pointer = void;
    using reference = void;

    explicit raw_storage_iterator ( _OutIt _First ) : _Next ( _First ) { }

    [ [ nodiscard ] ] raw_storage_iterator & operator * ( ) {
        return * this;
    }

    raw_storage_iterator & operator = ( const _Ty & _Val ) {
        :: std :: _Construct_in_place ( const_cast < _Remove_cvref_t < decltype ( * _Next ) > & > ( * _Next ), _Val );
        return * this;
    }

    raw_storage_iterator & operator = ( _Ty && _Val ) {
        :: std :: _Construct_in_place ( const_cast < _Remove_cvref_t < decltype ( * _Next ) > & > ( * _Next ), :: std :: move ( _Val ) );
        return * this;
    }

    raw_storage_iterator & operator ++ ( ) {
        ++ _Next;
        return * this;
    }

    raw_storage_iterator operator ++ ( int ) {
        raw_storage_iterator _Ans = * this;
        ++ _Next;
        return _Ans;
    }

    [ [ nodiscard ] ] _OutIt base ( ) const {
        return _Next;
    }

private :
    _OutIt _Next;
};
#line 988 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Ty >
class auto_ptr;
#line 991
template < class _Ty >
struct auto_ptr_ref {
    explicit auto_ptr_ref ( _Ty * _Right ) : _Ref ( _Right ) { }

    _Ty * _Ref;
};
#line 998
template < class _Ty >
class auto_ptr {
public :
    using element_type = _Ty;

    explicit auto_ptr ( _Ty * _Ptr = nullptr ) noexcept : _Myptr ( _Ptr ) { }

    auto_ptr ( auto_ptr & _Right ) noexcept : _Myptr ( _Right . release ( ) ) { }

    auto_ptr ( auto_ptr_ref < _Ty > _Right ) noexcept {
        _Ty * _Ptr = _Right . _Ref;
        _Right . _Ref = nullptr;
        _Myptr = _Ptr;
    }

    template < class _Other >
    operator auto_ptr < _Other > ( ) noexcept {
        return auto_ptr < _Other > ( * this );
    }

    template < class _Other >
    operator auto_ptr_ref < _Other > ( ) noexcept {
        _Other * _Cvtptr = _Myptr;
        auto_ptr_ref < _Other > _Ans ( _Cvtptr );
        _Myptr = nullptr;
        return _Ans;
    }

    template < class _Other >
    auto_ptr & operator = ( auto_ptr < _Other > & _Right ) noexcept {
        reset ( _Right . release ( ) );
        return * this;
    }

    template < class _Other >
    auto_ptr ( auto_ptr < _Other > & _Right ) noexcept : _Myptr ( _Right . release ( ) ) { }

    auto_ptr & operator = ( auto_ptr & _Right ) noexcept {
        reset ( _Right . release ( ) );
        return * this;
    }

    auto_ptr & operator = ( auto_ptr_ref < _Ty > _Right ) noexcept {
        _Ty * _Ptr = _Right . _Ref;
        _Right . _Ref = 0;
        reset ( _Ptr );
        return * this;
    }

    ~ auto_ptr ( ) noexcept {
        delete _Myptr;
    }

    [ [ nodiscard ] ] _Ty & operator * ( ) const noexcept {
        return * get ( );
    }

    [ [ nodiscard ] ] _Ty * operator -> ( ) const noexcept {
        return get ( );
    }

    [ [ nodiscard ] ] _Ty * get ( ) const noexcept {
        return _Myptr;
    }

    _Ty * release ( ) noexcept {
        _Ty * _Tmp = _Myptr;
        _Myptr = nullptr;
        return _Tmp;
    }

    void reset ( _Ty * _Ptr = nullptr ) noexcept {
        if ( _Ptr != _Myptr ) {
            delete _Myptr;
        }

        _Myptr = _Ptr;
    }

private :
    _Ty * _Myptr;
};
#line 1082
#pragma pack(8)
template<> 
#line 1082
class auto_ptr< void>  { 
#line 1084
public: using element_type = void; 
#line 1085
}; 
#pragma pack()
#line 1088 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
#pragma pack(8)
#line 1088
class [[nodiscard]] bad_weak_ptr : public exception { 
#line 1091
public: bad_weak_ptr() noexcept { } 
#line 1093
[[nodiscard]] virtual const char *what() const noexcept override { 
#line 1095
return "bad_weak_ptr"; 
#line 1096
} 
#line 1097
}; 
#pragma pack()
[[noreturn]] inline void _Throw_bad_weak_ptr() { 
#line 1100
throw bad_weak_ptr{}; 
#line 1101
} 
#line 1103
#pragma pack(8)
#line 1103
class __declspec(novtable) _Ref_count_base { 
#line 1115
virtual void _Destroy() noexcept = 0; 
#line 1116
virtual void _Delete_this() noexcept = 0; 
#line 1119 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
_Atomic_counter_t _Uses = (1); 
#line 1120
_Atomic_counter_t _Weaks = (1); 
#line 1123
protected: constexpr _Ref_count_base() noexcept = default;
#line 1126
public: _Ref_count_base(const _Ref_count_base &) = delete;
#line 1127
_Ref_count_base &operator=(const _Ref_count_base &) = delete;
#line 1129
virtual ~_Ref_count_base() noexcept { } 
#line 1131
bool _Incref_nz() noexcept { 
#line 1132
auto &_Volatile_uses = reinterpret_cast< volatile long &>(_Uses); 
#line 1136
long _Count = __iso_volatile_load32(reinterpret_cast< volatile int *>(&_Volatile_uses)); 
#line 1138 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
while (_Count != (0)) { 
#line 1139
const long _Old_value = _InterlockedCompareExchange(&_Volatile_uses, _Count + (1), _Count); 
#line 1140
if (_Old_value == _Count) { 
#line 1141
return true; 
#line 1142
}  
#line 1144
_Count = _Old_value; 
#line 1145
}  
#line 1147
return false; 
#line 1148
} 
#line 1150
void _Incref() noexcept { 
#line 1151
_InterlockedIncrement(reinterpret_cast< volatile long *>(&(_Uses))); 
#line 1152
} 
#line 1154
void _Incwref() noexcept { 
#line 1155
_InterlockedIncrement(reinterpret_cast< volatile long *>(&(_Weaks))); 
#line 1156
} 
#line 1158
void _Decref() noexcept { 
#line 1159
if (_InterlockedDecrement(reinterpret_cast< volatile long *>(&(_Uses))) == (0)) { 
#line 1160
this->_Destroy(); 
#line 1161
this->_Decwref(); 
#line 1162
}  
#line 1163
} 
#line 1165
void _Decwref() noexcept { 
#line 1166
if (_InterlockedDecrement(reinterpret_cast< volatile long *>(&(_Weaks))) == (0)) { 
#line 1167
this->_Delete_this(); 
#line 1168
}  
#line 1169
} 
#line 1171
long _Use_count() const noexcept { 
#line 1172
return static_cast< long>(_Uses); 
#line 1173
} 
#line 1175
virtual void *_Get_deleter(const type_info &) const noexcept { 
#line 1176
return nullptr; 
#line 1177
} 
#line 1178
}; 
#pragma pack()
template < class _Ty >
class _Ref_count : public _Ref_count_base {
public :
    explicit _Ref_count ( _Ty * _Px ) : _Ref_count_base ( ), _Ptr ( _Px ) { }

private :
    void _Destroy ( ) noexcept override {
        delete _Ptr;
    }

    void _Delete_this ( ) noexcept override {
        delete this;
    }

    _Ty * _Ptr;
};
#line 1197
template < class _Resource, class _Dx >
class _Ref_count_resource : public _Ref_count_base {
public :
    _Ref_count_resource ( _Resource _Px, _Dx _Dt )
        : _Ref_count_base ( ), _Mypair ( _One_then_variadic_args_t { }, :: std :: move ( _Dt ), _Px ) { }

    ~ _Ref_count_resource ( ) noexcept override = default;

    void * _Get_deleter ( const type_info & _Typeid ) const noexcept override {

        if ( _Typeid == typeid ( _Dx ) ) {
            return const_cast < _Dx * > ( :: std :: addressof ( _Mypair . _Get_first ( ) ) );
        }




        return nullptr;
    }

private :
    void _Destroy ( ) noexcept override {
        _Mypair . _Get_first ( ) ( _Mypair . _Myval2 );
    }

    void _Delete_this ( ) noexcept override {
        delete this;
    }

    _Compressed_pair < _Dx, _Resource > _Mypair;
};
#line 1229 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Resource, class _Dx, class _Alloc >
class _Ref_count_resource_alloc : public _Ref_count_base {

public :
    _Ref_count_resource_alloc ( _Resource _Px, _Dx _Dt, const _Alloc & _Ax )
        : _Ref_count_base ( ),
          _Mypair ( _One_then_variadic_args_t { }, :: std :: move ( _Dt ), _One_then_variadic_args_t { }, _Ax, _Px ) { }

    ~ _Ref_count_resource_alloc ( ) noexcept override = default;

    void * _Get_deleter ( const type_info & _Typeid ) const noexcept override {

        if ( _Typeid == typeid ( _Dx ) ) {
            return const_cast < _Dx * > ( :: std :: addressof ( _Mypair . _Get_first ( ) ) );
        }




        return nullptr;
    }

private :
    using _Myalty = _Rebind_alloc_t < _Alloc, _Ref_count_resource_alloc >;

    void _Destroy ( ) noexcept override {
        _Mypair . _Get_first ( ) ( _Mypair . _Myval2 . _Myval2 );
    }

    void _Delete_this ( ) noexcept override {
        _Myalty _Al = _Mypair . _Myval2 . _Get_first ( );
        this -> ~ _Ref_count_resource_alloc ( );
        :: std :: _Deallocate_plain ( _Al, this );
    }

    _Compressed_pair < _Dx, _Compressed_pair < _Myalty, _Resource >> _Mypair;
};
#line 1267 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Ty >
struct default_delete;
#line 1270
template < class _Ty, class _Dx = default_delete < _Ty > >
class unique_ptr;
#line 1273
template < class _Ty >
class shared_ptr;
#line 1276
template < class _Ty >
class weak_ptr;
#line 1279
template< class _Yty, class  = void> 
#line 1280
struct _Can_enable_shared : public false_type { }; 
#line 1282
template< class _Yty> 
#line 1283
struct _Can_enable_shared< _Yty, void_t< typename _Yty::_Esft_type> >  : public is_convertible< remove_cv_t< _Yty>  *, typename _Yty::_Esft_type *> ::type { 
#line 1286
}; 
#line 1288
struct _Exception_ptr_access; 
#line 1290
template < class _Ty >
class _Ptr_base {
public :
    using element_type = remove_extent_t < _Ty >;

    [ [ nodiscard ] ] long use_count ( ) const noexcept {
        return _Rep ? _Rep -> _Use_count ( ) : 0;
    }

    template < class _Ty2 >
    [ [ nodiscard ] ] bool owner_before ( const _Ptr_base < _Ty2 > & _Right ) const noexcept {
        return _Rep < _Right . _Rep;
    }

    _Ptr_base ( const _Ptr_base & ) = delete;
    _Ptr_base & operator = ( const _Ptr_base & ) = delete;

protected :
    [ [ nodiscard ] ] element_type * get ( ) const noexcept {
        return _Ptr;
    }

    constexpr _Ptr_base ( ) noexcept = default;








    ~ _Ptr_base ( ) = default;


    template < class _Ty2 >
    void _Move_construct_from ( _Ptr_base < _Ty2 > && _Right ) noexcept {

        _Ptr = _Right . _Ptr;
        _Rep = _Right . _Rep;

        _Right . _Ptr = nullptr;
        _Right . _Rep = nullptr;
    }

    template < class _Ty2 >
    void _Copy_construct_from ( const shared_ptr < _Ty2 > & _Other ) noexcept {

        _Other . _Incref ( );

        _Ptr = _Other . _Ptr;
        _Rep = _Other . _Rep;
    }

    template < class _Ty2 >
    void _Alias_construct_from ( const shared_ptr < _Ty2 > & _Other, element_type * _Px ) noexcept {

        _Other . _Incref ( );

        _Ptr = _Px;
        _Rep = _Other . _Rep;
    }

    template < class _Ty2 >
    void _Alias_move_construct_from ( shared_ptr < _Ty2 > && _Other, element_type * _Px ) noexcept {

        _Ptr = _Px;
        _Rep = _Other . _Rep;

        _Other . _Ptr = nullptr;
        _Other . _Rep = nullptr;
    }

    template < class _Ty0 >
    friend class weak_ptr;

    template < class _Ty2 >
    bool _Construct_from_weak ( const weak_ptr < _Ty2 > & _Other ) noexcept {

        if ( _Other . _Rep && _Other . _Rep -> _Incref_nz ( ) ) {
            _Ptr = _Other . _Ptr;
            _Rep = _Other . _Rep;
            return true;
        }

        return false;
    }

    void _Incref ( ) const noexcept {
        if ( _Rep ) {
            _Rep -> _Incref ( );
        }
    }

    void _Decref ( ) noexcept {
        if ( _Rep ) {
            _Rep -> _Decref ( );
        }
    }

    void _Swap ( _Ptr_base & _Right ) noexcept {
        :: std :: swap ( _Ptr, _Right . _Ptr );
        :: std :: swap ( _Rep, _Right . _Rep );
    }

    template < class _Ty2 >
    void _Weakly_construct_from ( const _Ptr_base < _Ty2 > & _Other ) noexcept {
        if ( _Other . _Rep ) {
            _Ptr = _Other . _Ptr;
            _Rep = _Other . _Rep;
            _Rep -> _Incwref ( );
        } else {
            ;
        }
    }

    template < class _Ty2 >
    void _Weakly_convert_lvalue_avoiding_expired_conversions ( const _Ptr_base < _Ty2 > & _Other ) noexcept {

        if ( _Other . _Rep ) {
            _Rep = _Other . _Rep;
            _Rep -> _Incwref ( );

            if ( _Rep -> _Incref_nz ( ) ) {
                _Ptr = _Other . _Ptr;
                _Rep -> _Decref ( );
            } else {
                ;
            }
        } else {
            ;
        }
    }

    template < class _Ty2 >
    void _Weakly_convert_rvalue_avoiding_expired_conversions ( _Ptr_base < _Ty2 > && _Other ) noexcept {

        _Rep = _Other . _Rep;
        _Other . _Rep = nullptr;

        if ( _Rep && _Rep -> _Incref_nz ( ) ) {
            _Ptr = _Other . _Ptr;
            _Rep -> _Decref ( );
        } else {
            ;
        }

        _Other . _Ptr = nullptr;
    }

    void _Incwref ( ) const noexcept {
        if ( _Rep ) {
            _Rep -> _Incwref ( );
        }
    }

    void _Decwref ( ) noexcept {
        if ( _Rep ) {
            _Rep -> _Decwref ( );
        }
    }

private :
    element_type * _Ptr { nullptr };
    _Ref_count_base * _Rep { nullptr };

    template < class _Ty0 >
    friend class _Ptr_base;

    friend shared_ptr < _Ty >;

    template < class _Ty0 >
    friend struct atomic;

    friend _Exception_ptr_access;


    template < class _Dx, class _Ty0 >
    friend _Dx * get_deleter ( const shared_ptr < _Ty0 > & _Sx ) noexcept;

};
#line 1471 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template< class _Yty, class  = void> 
#line 1472
struct _Can_scalar_delete : public false_type { }; 
#line 1473
template< class _Yty> 
#line 1474
struct _Can_scalar_delete< _Yty, void_t< decltype(delete std::declval< _Yty *> ())> >  : public bool_constant< !is_void_v< _Yty> >  { }; 
#line 1476
template< class _Yty, class  = void> 
#line 1477
struct _Can_array_delete : public false_type { }; 
#line 1478
template< class _Yty> 
#line 1479
struct _Can_array_delete< _Yty, void_t< decltype(delete [] std::declval< _Yty *> ())> >  : public true_type { }; 
#line 1481
template< class _Fx, class _Arg, class  = void> 
#line 1482
struct _Can_call_function_object : public false_type { }; 
#line 1483
template< class _Fx, class _Arg> 
#line 1484
struct _Can_call_function_object< _Fx, _Arg, void_t< decltype(std::declval< _Fx> ()(std::declval< _Arg> ()))> >  : public true_type { }; 
#line 1486
template< class _Yty, class _Ty, class  = void> 
#line 1487
struct _SP_convertible : public is_convertible< _Yty *, _Ty *> ::type { }; 
#line 1489
template< class _Yty, class _Uty, class _Void> 
#line 1490
struct _SP_convertible< _Yty, _Uty [], _Void>  : public false_type { }; 
#line 1491
template< class _Yty, class _Uty> 
#line 1492
struct _SP_convertible< _Yty, _Uty [], void_t< _Yty (*)[]> >  : public is_convertible< _Yty (*)[], _Uty (*)[]> ::type { }; 
#line 1494
template< class _Yty, class _Uty, size_t _Ext, class _Void> 
#line 1495
struct _SP_convertible< _Yty, _Uty [_Ext], _Void>  : public false_type { }; 
#line 1496
template< class _Yty, class _Uty, size_t _Ext> 
#line 1497
struct _SP_convertible< _Yty, _Uty [_Ext], void_t< _Yty (*)[_Ext]> >  : public is_convertible< _Yty (*)[_Ext], _Uty (*)[_Ext]> ::type { 
#line 1498
}; 
#line 1500
template< class _Yty, class _Ty> 
#line 1501
struct _SP_pointer_compatible : public is_convertible< _Yty *, _Ty *> ::type { 
#line 1504
}; 
#line 1505
template< class _Uty, size_t _Ext> 
#line 1506
struct _SP_pointer_compatible< _Uty [_Ext], _Uty []>  : public true_type { 
#line 1508
}; 
#line 1509
template< class _Uty, size_t _Ext> 
#line 1510
struct _SP_pointer_compatible< _Uty [_Ext], const _Uty []>  : public true_type { 
#line 1512
}; 
#line 1513
template< class _Uty, size_t _Ext> 
#line 1514
struct _SP_pointer_compatible< _Uty [_Ext], volatile _Uty []>  : public true_type { 
#line 1516
}; 
#line 1517
template< class _Uty, size_t _Ext> 
#line 1518
struct _SP_pointer_compatible< _Uty [_Ext], const volatile _Uty []>  : public true_type { 
#line 1520
}; 
#line 1522
template < class _Ux >
struct _Temporary_owner {
    _Ux * _Ptr;

    explicit _Temporary_owner ( _Ux * const _Ptr_ ) noexcept : _Ptr ( _Ptr_ ) { }
    _Temporary_owner ( const _Temporary_owner & ) = delete;
    _Temporary_owner & operator = ( const _Temporary_owner & ) = delete;
    ~ _Temporary_owner ( ) {
        delete _Ptr;
    }
};
#line 1534
template < class _UxptrOrNullptr, class _Dx >
struct _Temporary_owner_del {
    _UxptrOrNullptr _Ptr;
    _Dx & _Dt;
    bool _Call_deleter = true;

    explicit _Temporary_owner_del ( const _UxptrOrNullptr _Ptr_, _Dx & _Dt_ ) noexcept : _Ptr ( _Ptr_ ), _Dt ( _Dt_ ) { }
    _Temporary_owner_del ( const _Temporary_owner_del & ) = delete;
    _Temporary_owner_del & operator = ( const _Temporary_owner_del & ) = delete;
    ~ _Temporary_owner_del ( ) {
        if ( _Call_deleter ) {
            _Dt ( _Ptr );
        }
    }
};
#line 1564 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Ty >
class shared_ptr : public _Ptr_base < _Ty > {
private :
    using _Mybase = _Ptr_base < _Ty >;

public :
    using typename _Mybase :: element_type;





    constexpr shared_ptr ( ) noexcept = default;

    constexpr shared_ptr ( nullptr_t ) noexcept { }

    template < class _Ux,
        enable_if_t < conjunction_v < conditional_t < is_array_v < _Ty >, _Can_array_delete < _Ux >, _Can_scalar_delete < _Ux >>,
                        _SP_convertible < _Ux, _Ty >>,
            int > = 0 >
    explicit shared_ptr ( _Ux * _Px ) {
        if constexpr ( is_array_v < _Ty > ) {
            _Setpd ( _Px, default_delete < _Ux [ ] > { } );
        } else {
            _Temporary_owner < _Ux > _Owner ( _Px );
            _Set_ptr_rep_and_enable_shared ( _Owner . _Ptr, new _Ref_count < _Ux > ( _Owner . _Ptr ) );
            _Owner . _Ptr = nullptr;
        }
    }

    template < class _Ux, class _Dx,
        enable_if_t < conjunction_v < is_move_constructible < _Dx >, _Can_call_function_object < _Dx &, _Ux * & >,
                        _SP_convertible < _Ux, _Ty >>,
            int > = 0 >
    shared_ptr ( _Ux * _Px, _Dx _Dt ) {
        _Setpd ( _Px, :: std :: move ( _Dt ) );
    }

    template < class _Ux, class _Dx, class _Alloc,
        enable_if_t < conjunction_v < is_move_constructible < _Dx >, _Can_call_function_object < _Dx &, _Ux * & >,
                        _SP_convertible < _Ux, _Ty >>,
            int > = 0 >
    shared_ptr ( _Ux * _Px, _Dx _Dt, _Alloc _Ax ) {
        _Setpda ( _Px, :: std :: move ( _Dt ), _Ax );
    }

    template < class _Dx,
        enable_if_t < conjunction_v < is_move_constructible < _Dx >, _Can_call_function_object < _Dx &, nullptr_t & >>, int > = 0 >
    shared_ptr ( nullptr_t, _Dx _Dt ) {
        _Setpd ( nullptr, :: std :: move ( _Dt ) );
    }

    template < class _Dx, class _Alloc,
        enable_if_t < conjunction_v < is_move_constructible < _Dx >, _Can_call_function_object < _Dx &, nullptr_t & >>, int > = 0 >
    shared_ptr ( nullptr_t, _Dx _Dt, _Alloc _Ax ) {
        _Setpda ( nullptr, :: std :: move ( _Dt ), _Ax );
    }

    template < class _Ty2 >
    shared_ptr ( const shared_ptr < _Ty2 > & _Right, element_type * _Px ) noexcept {

        this -> _Alias_construct_from ( _Right, _Px );
    }

    template < class _Ty2 >
    shared_ptr ( shared_ptr < _Ty2 > && _Right, element_type * _Px ) noexcept {

        this -> _Alias_move_construct_from ( :: std :: move ( _Right ), _Px );
    }

    shared_ptr ( const shared_ptr & _Other ) noexcept {
        this -> _Copy_construct_from ( _Other );
    }

    template < class _Ty2, enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
    shared_ptr ( const shared_ptr < _Ty2 > & _Other ) noexcept {

        this -> _Copy_construct_from ( _Other );
    }

    shared_ptr ( shared_ptr && _Right ) noexcept {
        this -> _Move_construct_from ( :: std :: move ( _Right ) );
    }

    template < class _Ty2, enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
    shared_ptr ( shared_ptr < _Ty2 > && _Right ) noexcept {
        this -> _Move_construct_from ( :: std :: move ( _Right ) );
    }

    template < class _Ty2, enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
    explicit shared_ptr ( const weak_ptr < _Ty2 > & _Other ) {
        if ( ! this -> _Construct_from_weak ( _Other ) ) {
            _Throw_bad_weak_ptr ( );
        }
    }


    template < class _Ty2, enable_if_t < is_convertible_v < _Ty2 *, _Ty * >, int > = 0 >
    shared_ptr ( auto_ptr < _Ty2 > && _Other ) {
        _Ty2 * _Px = _Other . get ( );
        _Set_ptr_rep_and_enable_shared ( _Px, new _Ref_count < _Ty2 > ( _Px ) );
        _Other . release ( );
    }


    template < class _Ux, class _Dx,
        enable_if_t < conjunction_v < _SP_pointer_compatible < _Ux, _Ty >,
                        is_convertible < typename unique_ptr < _Ux, _Dx > :: pointer, element_type * >>,
            int > = 0 >
    shared_ptr ( unique_ptr < _Ux, _Dx > && _Other ) {
        using _Fancy_t = typename unique_ptr < _Ux, _Dx > :: pointer;
        using _Raw_t = typename unique_ptr < _Ux, _Dx > :: element_type *;
        using _Deleter_t = conditional_t < is_reference_v < _Dx >, decltype ( :: std :: ref ( _Other . get_deleter ( ) ) ), _Dx >;

        const _Fancy_t _Fancy = _Other . get ( );

        if ( _Fancy ) {
            const _Raw_t _Raw = _Fancy;
            const auto _Rx =
                new _Ref_count_resource < _Fancy_t, _Deleter_t > ( _Fancy, :: std :: forward < _Dx > ( _Other . get_deleter ( ) ) );
            _Set_ptr_rep_and_enable_shared ( _Raw, _Rx );
            _Other . release ( );
        }
    }

    ~ shared_ptr ( ) noexcept {
        this -> _Decref ( );
    }

    shared_ptr & operator = ( const shared_ptr & _Right ) noexcept {
        shared_ptr ( _Right ) . swap ( * this );
        return * this;
    }

    template < class _Ty2, enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
    shared_ptr & operator = ( const shared_ptr < _Ty2 > & _Right ) noexcept {
        shared_ptr ( _Right ) . swap ( * this );
        return * this;
    }

    shared_ptr & operator = ( shared_ptr && _Right ) noexcept {
        shared_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
        return * this;
    }

    template < class _Ty2, enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
    shared_ptr & operator = ( shared_ptr < _Ty2 > && _Right ) noexcept {
        shared_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
        return * this;
    }


    template < class _Ty2, enable_if_t < is_convertible_v < _Ty2 *, _Ty * >, int > = 0 >
    shared_ptr & operator = ( auto_ptr < _Ty2 > && _Right ) {
        shared_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
        return * this;
    }


    template < class _Ux, class _Dx,
        enable_if_t < conjunction_v < _SP_pointer_compatible < _Ux, _Ty >,
                        is_convertible < typename unique_ptr < _Ux, _Dx > :: pointer, element_type * >>,
            int > = 0 >
    shared_ptr & operator = ( unique_ptr < _Ux, _Dx > && _Right ) {
        shared_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
        return * this;
    }

    void swap ( shared_ptr & _Other ) noexcept {
        this -> _Swap ( _Other );
    }

    void reset ( ) noexcept {
        shared_ptr ( ) . swap ( * this );
    }

    template < class _Ux,
        enable_if_t < conjunction_v < conditional_t < is_array_v < _Ty >, _Can_array_delete < _Ux >, _Can_scalar_delete < _Ux >>,
                        _SP_convertible < _Ux, _Ty >>,
            int > = 0 >
    void reset ( _Ux * _Px ) {
        shared_ptr ( _Px ) . swap ( * this );
    }

    template < class _Ux, class _Dx,
        enable_if_t < conjunction_v < is_move_constructible < _Dx >, _Can_call_function_object < _Dx &, _Ux * & >,
                        _SP_convertible < _Ux, _Ty >>,
            int > = 0 >
    void reset ( _Ux * _Px, _Dx _Dt ) {
        shared_ptr ( _Px, _Dt ) . swap ( * this );
    }

    template < class _Ux, class _Dx, class _Alloc,
        enable_if_t < conjunction_v < is_move_constructible < _Dx >, _Can_call_function_object < _Dx &, _Ux * & >,
                        _SP_convertible < _Ux, _Ty >>,
            int > = 0 >
    void reset ( _Ux * _Px, _Dx _Dt, _Alloc _Ax ) {
        shared_ptr ( _Px, _Dt, _Ax ) . swap ( * this );
    }

    using _Mybase :: get;

    template < class _Ty2 = _Ty, enable_if_t < ! disjunction_v < is_array < _Ty2 >, is_void < _Ty2 >>, int > = 0 >
    [ [ nodiscard ] ] _Ty2 & operator * ( ) const noexcept {
        return * get ( );
    }

    template < class _Ty2 = _Ty, enable_if_t < ! is_array_v < _Ty2 >, int > = 0 >
    [ [ nodiscard ] ] _Ty2 * operator -> ( ) const noexcept {
        return get ( );
    }

    template < class _Ty2 = _Ty, class _Elem = element_type, enable_if_t < is_array_v < _Ty2 >, int > = 0 >
    [ [ nodiscard ] ] _Elem & operator [ ] ( ptrdiff_t _Idx ) const noexcept {
        return get ( ) [ _Idx ];
    }


     [ [ nodiscard ] ] bool unique ( ) const noexcept {

        return this -> use_count ( ) == 1;
    }


    explicit operator bool ( ) const noexcept {
        return get ( ) != nullptr;
    }

private :
    template < class _UxptrOrNullptr, class _Dx >
    void _Setpd ( const _UxptrOrNullptr _Px, _Dx _Dt ) {
        _Temporary_owner_del < _UxptrOrNullptr, _Dx > _Owner ( _Px, _Dt );
        _Set_ptr_rep_and_enable_shared (
            _Owner . _Ptr, new _Ref_count_resource < _UxptrOrNullptr, _Dx > ( _Owner . _Ptr, :: std :: move ( _Dt ) ) );
        _Owner . _Call_deleter = false;
    }

    template < class _UxptrOrNullptr, class _Dx, class _Alloc >
    void _Setpda ( const _UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax ) {
        using _Alref_alloc = _Rebind_alloc_t < _Alloc, _Ref_count_resource_alloc < _UxptrOrNullptr, _Dx, _Alloc >>;

        _Temporary_owner_del < _UxptrOrNullptr, _Dx > _Owner ( _Px, _Dt );
        _Alref_alloc _Alref ( _Ax );
        _Alloc_construct_ptr < _Alref_alloc > _Constructor ( _Alref );
        _Constructor . _Allocate ( );
        :: std :: _Construct_in_place ( * _Constructor . _Ptr, _Owner . _Ptr, :: std :: move ( _Dt ), _Ax );
        _Set_ptr_rep_and_enable_shared ( _Owner . _Ptr, :: std :: _Unfancy ( _Constructor . _Ptr ) );
        _Constructor . _Ptr = nullptr;
        _Owner . _Call_deleter = false;
    }

































    template < class _Ty0, class ... _Types >
    friend shared_ptr < _Ty0 > make_shared ( _Types && ... _Args );

    template < class _Ty0, class _Alloc, class ... _Types >
    friend shared_ptr < _Ty0 > allocate_shared ( const _Alloc & _Al_arg, _Types && ... _Args );


    template < class _Ux >
    void _Set_ptr_rep_and_enable_shared ( _Ux * const _Px, _Ref_count_base * const _Rx ) noexcept {
        this -> _Ptr = _Px;
        this -> _Rep = _Rx;
        if constexpr ( conjunction_v < negation < is_array < _Ty >>, negation < is_volatile < _Ux >>, _Can_enable_shared < _Ux >> ) {
            if ( _Px && _Px -> _Wptr . expired ( ) ) {
                _Px -> _Wptr = shared_ptr < remove_cv_t < _Ux >> ( * this, const_cast < remove_cv_t < _Ux > * > ( _Px ) );
            }
        }
    }

    void _Set_ptr_rep_and_enable_shared ( nullptr_t, _Ref_count_base * const _Rx ) noexcept {
        this -> _Ptr = nullptr;
        this -> _Rep = _Rx;
    }
};
#line 1879 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] bool operator == ( const shared_ptr < _Ty1 > & _Left, const shared_ptr < _Ty2 > & _Right ) noexcept {
    return _Left . get ( ) == _Right . get ( );
}
#line 1890 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] bool operator != ( const shared_ptr < _Ty1 > & _Left, const shared_ptr < _Ty2 > & _Right ) noexcept {
    return _Left . get ( ) != _Right . get ( );
}
#line 1895
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] bool operator < ( const shared_ptr < _Ty1 > & _Left, const shared_ptr < _Ty2 > & _Right ) noexcept {
    return _Left . get ( ) < _Right . get ( );
}
#line 1900
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] bool operator >= ( const shared_ptr < _Ty1 > & _Left, const shared_ptr < _Ty2 > & _Right ) noexcept {
    return _Left . get ( ) >= _Right . get ( );
}
#line 1905
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] bool operator > ( const shared_ptr < _Ty1 > & _Left, const shared_ptr < _Ty2 > & _Right ) noexcept {
    return _Left . get ( ) > _Right . get ( );
}
#line 1910
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] bool operator <= ( const shared_ptr < _Ty1 > & _Left, const shared_ptr < _Ty2 > & _Right ) noexcept {
    return _Left . get ( ) <= _Right . get ( );
}
#line 1916 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Ty >
[ [ nodiscard ] ] bool operator == ( const shared_ptr < _Ty > & _Left, nullptr_t ) noexcept {
    return _Left . get ( ) == nullptr;
}
#line 1927 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Ty >
[ [ nodiscard ] ] bool operator == ( nullptr_t, const shared_ptr < _Ty > & _Right ) noexcept {
    return nullptr == _Right . get ( );
}
#line 1932
template < class _Ty >
[ [ nodiscard ] ] bool operator != ( const shared_ptr < _Ty > & _Left, nullptr_t ) noexcept {
    return _Left . get ( ) != nullptr;
}
#line 1937
template < class _Ty >
[ [ nodiscard ] ] bool operator != ( nullptr_t, const shared_ptr < _Ty > & _Right ) noexcept {
    return nullptr != _Right . get ( );
}
#line 1942
template < class _Ty >
[ [ nodiscard ] ] bool operator < ( const shared_ptr < _Ty > & _Left, nullptr_t ) noexcept {
    return _Left . get ( ) < static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr );
}
#line 1947
template < class _Ty >
[ [ nodiscard ] ] bool operator < ( nullptr_t, const shared_ptr < _Ty > & _Right ) noexcept {
    return static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr ) < _Right . get ( );
}
#line 1952
template < class _Ty >
[ [ nodiscard ] ] bool operator >= ( const shared_ptr < _Ty > & _Left, nullptr_t ) noexcept {
    return _Left . get ( ) >= static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr );
}
#line 1957
template < class _Ty >
[ [ nodiscard ] ] bool operator >= ( nullptr_t, const shared_ptr < _Ty > & _Right ) noexcept {
    return static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr ) >= _Right . get ( );
}
#line 1962
template < class _Ty >
[ [ nodiscard ] ] bool operator > ( const shared_ptr < _Ty > & _Left, nullptr_t ) noexcept {
    return _Left . get ( ) > static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr );
}
#line 1967
template < class _Ty >
[ [ nodiscard ] ] bool operator > ( nullptr_t, const shared_ptr < _Ty > & _Right ) noexcept {
    return static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr ) > _Right . get ( );
}
#line 1972
template < class _Ty >
[ [ nodiscard ] ] bool operator <= ( const shared_ptr < _Ty > & _Left, nullptr_t ) noexcept {
    return _Left . get ( ) <= static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr );
}
#line 1977
template < class _Ty >
[ [ nodiscard ] ] bool operator <= ( nullptr_t, const shared_ptr < _Ty > & _Right ) noexcept {
    return static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr ) <= _Right . get ( );
}
#line 1983 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Out, const shared_ptr < _Ty > & _Px ) {

    return _Out << _Px . get ( );
}
#line 1989
template < class _Ty >
void swap ( shared_ptr < _Ty > & _Left, shared_ptr < _Ty > & _Right ) noexcept {
    _Left . swap ( _Right );
}
#line 1994
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] shared_ptr < _Ty1 > static_pointer_cast ( const shared_ptr < _Ty2 > & _Other ) noexcept {

    const auto _Ptr = static_cast < typename shared_ptr < _Ty1 > :: element_type * > ( _Other . get ( ) );
    return shared_ptr < _Ty1 > ( _Other, _Ptr );
}
#line 2001
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] shared_ptr < _Ty1 > static_pointer_cast ( shared_ptr < _Ty2 > && _Other ) noexcept {

    const auto _Ptr = static_cast < typename shared_ptr < _Ty1 > :: element_type * > ( _Other . get ( ) );
    return shared_ptr < _Ty1 > ( :: std :: move ( _Other ), _Ptr );
}
#line 2008
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] shared_ptr < _Ty1 > const_pointer_cast ( const shared_ptr < _Ty2 > & _Other ) noexcept {

    const auto _Ptr = const_cast < typename shared_ptr < _Ty1 > :: element_type * > ( _Other . get ( ) );
    return shared_ptr < _Ty1 > ( _Other, _Ptr );
}
#line 2015
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] shared_ptr < _Ty1 > const_pointer_cast ( shared_ptr < _Ty2 > && _Other ) noexcept {

    const auto _Ptr = const_cast < typename shared_ptr < _Ty1 > :: element_type * > ( _Other . get ( ) );
    return shared_ptr < _Ty1 > ( :: std :: move ( _Other ), _Ptr );
}
#line 2022
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] shared_ptr < _Ty1 > reinterpret_pointer_cast ( const shared_ptr < _Ty2 > & _Other ) noexcept {

    const auto _Ptr = reinterpret_cast < typename shared_ptr < _Ty1 > :: element_type * > ( _Other . get ( ) );
    return shared_ptr < _Ty1 > ( _Other, _Ptr );
}
#line 2029
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] shared_ptr < _Ty1 > reinterpret_pointer_cast ( shared_ptr < _Ty2 > && _Other ) noexcept {

    const auto _Ptr = reinterpret_cast < typename shared_ptr < _Ty1 > :: element_type * > ( _Other . get ( ) );
    return shared_ptr < _Ty1 > ( :: std :: move ( _Other ), _Ptr );
}
#line 2037
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] shared_ptr < _Ty1 > dynamic_pointer_cast ( const shared_ptr < _Ty2 > & _Other ) noexcept {

    const auto _Ptr = dynamic_cast < typename shared_ptr < _Ty1 > :: element_type * > ( _Other . get ( ) );

    if ( _Ptr ) {
        return shared_ptr < _Ty1 > ( _Other, _Ptr );
    }

    return { };
}
#line 2049
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] shared_ptr < _Ty1 > dynamic_pointer_cast ( shared_ptr < _Ty2 > && _Other ) noexcept {

    const auto _Ptr = dynamic_cast < typename shared_ptr < _Ty1 > :: element_type * > ( _Other . get ( ) );

    if ( _Ptr ) {
        return shared_ptr < _Ty1 > ( :: std :: move ( _Other ), _Ptr );
    }

    return { };
}
#line 2068 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Dx, class _Ty >
[ [ nodiscard ] ] _Dx * get_deleter ( const shared_ptr < _Ty > & _Sx ) noexcept {

    if ( _Sx . _Rep ) {
        return static_cast < _Dx * > ( _Sx . _Rep -> _Get_deleter ( typeid ( _Dx ) ) );
    }

    return nullptr;
}
#line 2088 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Ty >
class _Ref_count_obj2 : public _Ref_count_base {
public :
    template < class ... _Types >
    explicit _Ref_count_obj2 ( _Types && ... _Args ) : _Ref_count_base ( ) {






        {
            :: std :: _Construct_in_place ( _Storage . _Value, :: std :: forward < _Types > ( _Args ) ... );
        }
    }

    ~ _Ref_count_obj2 ( ) noexcept override {





    }

    union {
        _Wrap < remove_cv_t < _Ty >> _Storage;
    };

private :
    void _Destroy ( ) noexcept override {
        :: std :: _Destroy_in_place ( _Storage . _Value );
    }

    void _Delete_this ( ) noexcept override {
        delete this;
    }
};
#line 2472 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Ty, class _Alloc >
class _Ref_count_obj_alloc3 : public _Ebco_base < _Rebind_alloc_t < _Alloc, _Ty > >, public _Ref_count_base {

private :
    static_assert ( is_same_v < _Ty, remove_cv_t < _Ty >>, "allocate_shared should remove_cv_t" );

    using _Rebound = _Rebind_alloc_t < _Alloc, _Ty >;

public :
    template < class ... _Types >
    explicit _Ref_count_obj_alloc3 ( const _Alloc & _Al_arg, _Types && ... _Args )
        : _Ebco_base < _Rebound > ( _Al_arg ), _Ref_count_base ( ) {






        allocator_traits < _Rebound > :: construct (
            this -> _Get_val ( ), :: std :: addressof ( _Storage . _Value ), :: std :: forward < _Types > ( _Args ) ... );
    }

    union {
        _Wrap < _Ty > _Storage;
    };

private :
    ~ _Ref_count_obj_alloc3 ( ) noexcept override {



    }

    void _Destroy ( ) noexcept override {
        allocator_traits < _Rebound > :: destroy ( this -> _Get_val ( ), :: std :: addressof ( _Storage . _Value ) );
    }

    void _Delete_this ( ) noexcept override {
        _Rebind_alloc_t < _Alloc, _Ref_count_obj_alloc3 > _Al ( this -> _Get_val ( ) );
        this -> ~ _Ref_count_obj_alloc3 ( );
        :: std :: _Deallocate_plain ( _Al, this );
    }
};
#line 2910 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Ty, class ... _Types >

[ [ nodiscard ( "This function constructs an object wrapped by a smart pointer and has no other effects; it is not useful to call this function a" "nd discard the return value." ) ] ] shared_ptr < _Ty > make_shared ( _Types && ... _Args ) {
    const auto _Rx = new _Ref_count_obj2 < _Ty > ( :: std :: forward < _Types > ( _Args ) ... );
    shared_ptr < _Ty > _Ret;
    _Ret . _Set_ptr_rep_and_enable_shared ( :: std :: addressof ( _Rx -> _Storage . _Value ), _Rx );
    return _Ret;
}
#line 3000 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Ty, class _Alloc, class ... _Types >

[ [ nodiscard ( "This function constructs an object wrapped by a smart pointer and has no other effects; it is not useful to call this function a" "nd discard the return value." ) ] ] shared_ptr < _Ty > allocate_shared ( const _Alloc & _Al, _Types && ... _Args ) {



    using _Refoa = _Ref_count_obj_alloc3 < remove_cv_t < _Ty >, _Alloc >;
    using _Alblock = _Rebind_alloc_t < _Alloc, _Refoa >;
    _Alblock _Rebound ( _Al );
    _Alloc_construct_ptr < _Alblock > _Constructor { _Rebound };
    _Constructor . _Allocate ( );
    :: std :: _Construct_in_place ( * _Constructor . _Ptr, _Al, :: std :: forward < _Types > ( _Args ) ... );
    shared_ptr < _Ty > _Ret;
    const auto _Ptr = reinterpret_cast < _Ty * > ( :: std :: addressof ( _Constructor . _Ptr -> _Storage . _Value ) );
    _Ret . _Set_ptr_rep_and_enable_shared ( _Ptr, :: std :: _Unfancy ( _Constructor . _Release ( ) ) );
    return _Ret;
}
#line 3135 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Ty >
class weak_ptr : public _Ptr_base < _Ty > {
public :





    template < class _Ty2, class = const _Ty2 * >
    static constexpr bool _Must_avoid_expired_conversions_from = true;


    template < class _Ty2 >
    static constexpr bool
        _Must_avoid_expired_conversions_from < _Ty2, decltype ( static_cast < const _Ty2 * > ( static_cast < _Ty * > ( nullptr ) ) ) > =
            false;


    constexpr weak_ptr ( ) noexcept { }

    weak_ptr ( const weak_ptr & _Other ) noexcept {
        this -> _Weakly_construct_from ( _Other );
    }

    template < class _Ty2, enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
    weak_ptr ( const shared_ptr < _Ty2 > & _Other ) noexcept {
        this -> _Weakly_construct_from ( _Other );
    }

    template < class _Ty2, enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
    weak_ptr ( const weak_ptr < _Ty2 > & _Other ) noexcept {



        constexpr bool _Avoid_expired_conversions = _Must_avoid_expired_conversions_from < _Ty2 >;


        if constexpr ( _Avoid_expired_conversions ) {
            this -> _Weakly_convert_lvalue_avoiding_expired_conversions ( _Other );
        } else {
            this -> _Weakly_construct_from ( _Other );
        }
    }

    weak_ptr ( weak_ptr && _Other ) noexcept {
        this -> _Move_construct_from ( :: std :: move ( _Other ) );
    }

    template < class _Ty2, enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
    weak_ptr ( weak_ptr < _Ty2 > && _Other ) noexcept {



        constexpr bool _Avoid_expired_conversions = _Must_avoid_expired_conversions_from < _Ty2 >;


        if constexpr ( _Avoid_expired_conversions ) {
            this -> _Weakly_convert_rvalue_avoiding_expired_conversions ( :: std :: move ( _Other ) );
        } else {
            this -> _Move_construct_from ( :: std :: move ( _Other ) );
        }
    }

    ~ weak_ptr ( ) noexcept {
        this -> _Decwref ( );
    }

    weak_ptr & operator = ( const weak_ptr & _Right ) noexcept {
        weak_ptr ( _Right ) . swap ( * this );
        return * this;
    }

    template < class _Ty2, enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
    weak_ptr & operator = ( const weak_ptr < _Ty2 > & _Right ) noexcept {
        weak_ptr ( _Right ) . swap ( * this );
        return * this;
    }

    weak_ptr & operator = ( weak_ptr && _Right ) noexcept {
        weak_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
        return * this;
    }

    template < class _Ty2, enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
    weak_ptr & operator = ( weak_ptr < _Ty2 > && _Right ) noexcept {
        weak_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
        return * this;
    }

    template < class _Ty2, enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
    weak_ptr & operator = ( const shared_ptr < _Ty2 > & _Right ) noexcept {
        weak_ptr ( _Right ) . swap ( * this );
        return * this;
    }

    void reset ( ) noexcept {
        weak_ptr { } . swap ( * this );
    }

    void swap ( weak_ptr & _Other ) noexcept {
        this -> _Swap ( _Other );
    }

    [ [ nodiscard ] ] bool expired ( ) const noexcept {
        return this -> use_count ( ) == 0;
    }

    [ [ nodiscard ] ] shared_ptr < _Ty > lock ( ) const noexcept {
        shared_ptr < _Ty > _Ret;
        ( void ) _Ret . _Construct_from_weak ( * this );
        return _Ret;
    }
};
#line 3254 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Ty >
void swap ( weak_ptr < _Ty > & _Left, weak_ptr < _Ty > & _Right ) noexcept {
    _Left . swap ( _Right );
}
#line 3259
template < class _Ty >
class enable_shared_from_this {
public :
    using _Esft_type = enable_shared_from_this;

    [ [ nodiscard ] ] shared_ptr < _Ty > shared_from_this ( ) {
        return shared_ptr < _Ty > ( _Wptr );
    }

    [ [ nodiscard ] ] shared_ptr < const _Ty > shared_from_this ( ) const {
        return shared_ptr < const _Ty > ( _Wptr );
    }

    [ [ nodiscard ] ] weak_ptr < _Ty > weak_from_this ( ) noexcept {
        return _Wptr;
    }

    [ [ nodiscard ] ] weak_ptr < const _Ty > weak_from_this ( ) const noexcept {
        return _Wptr;
    }

protected :
    constexpr enable_shared_from_this ( ) noexcept : _Wptr ( ) { }

    enable_shared_from_this ( const enable_shared_from_this & ) noexcept : _Wptr ( ) {

    }

    enable_shared_from_this & operator = ( const enable_shared_from_this & ) noexcept {
        return * this;
    }

    ~ enable_shared_from_this ( ) = default;

private :
    template < class _Yty >
    friend class shared_ptr;

    mutable weak_ptr < _Ty > _Wptr;
};
#line 3300
template < class _Ty >
struct default_delete {
    constexpr default_delete ( ) noexcept = default;

    template < class _Ty2, enable_if_t < is_convertible_v < _Ty2 *, _Ty * >, int > = 0 >
    inline default_delete ( const default_delete < _Ty2 > & ) noexcept { }

    inline void operator ( ) ( _Ty * _Ptr ) const noexcept {
        static_assert ( 0 < sizeof ( _Ty ), "can\'t delete an incomplete type" );
        delete _Ptr;
    }
};
#line 3313
template< class _Ty> 
#pragma pack(8)
#line 3314
struct default_delete< _Ty []>  { 
#line 3315
constexpr default_delete() noexcept = default;
#line 3317
template < class _Uty, enable_if_t < is_convertible_v < _Uty ( * ) [ ], _Ty ( * ) [ ] >, int > = 0 >
    inline default_delete ( const default_delete < _Uty [ ] > & ) noexcept { }
#line 3320
template < class _Uty, enable_if_t < is_convertible_v < _Uty ( * ) [ ], _Ty ( * ) [ ] >, int > = 0 >
    inline void operator ( ) ( _Uty * _Ptr ) const noexcept {
        static_assert ( 0 < sizeof ( _Uty ), "can\'t delete an incomplete type" );
        delete [ ] _Ptr;
    }
#line 3325
}; 
#pragma pack(8)
template< class _Ty, class _Dx_noref, class  = void> 
#line 3328
struct _Get_deleter_pointer_type { 
#line 3329
using type = _Ty *; 
#line 3330
}; 
#line 3332
template< class _Ty, class _Dx_noref> 
#line 3333
struct _Get_deleter_pointer_type< _Ty, _Dx_noref, void_t< typename _Dx_noref::pointer> >  { 
#line 3334
using type = typename _Dx_noref::pointer; 
#line 3335
}; 
#line 3337
template< class _Dx2> using _Unique_ptr_enable_default_t = enable_if_t< conjunction_v< negation< is_pointer< _Dx2> > , is_default_constructible< _Dx2> > , int> ; 
#line 3341
template< class , class  = void> constexpr bool 
#line 3342
_Can_form_pointer = false; 
#line 3343
template< class _Ty> constexpr bool 
#line 3344
_Can_form_pointer< _Ty, void_t< _Ty *> >  = true; 
#line 3346
template < class _Ty, class _Dx >
class unique_ptr {
public :
    static_assert ( _Can_form_pointer < _Ty >,
        "unique_ptr<T, D> requires T* to be a valid type (N5001 [unique.ptr.single.general]/1)." );

    using pointer = typename _Get_deleter_pointer_type < _Ty, remove_reference_t < _Dx >> :: type;
    using element_type = _Ty;
    using deleter_type = _Dx;

    template < class _Dx2 = _Dx, _Unique_ptr_enable_default_t < _Dx2 > = 0 >
    constexpr unique_ptr ( ) noexcept : _Mypair ( _Zero_then_variadic_args_t { } ) { }

    template < class _Dx2 = _Dx, _Unique_ptr_enable_default_t < _Dx2 > = 0 >
    constexpr unique_ptr ( nullptr_t ) noexcept : _Mypair ( _Zero_then_variadic_args_t { } ) { }

    inline unique_ptr & operator = ( nullptr_t ) noexcept {
        reset ( );
        return * this;
    }



    template < class _Dx2 = _Dx, _Unique_ptr_enable_default_t < _Dx2 > = 0 >
    inline explicit unique_ptr ( pointer _Ptr ) noexcept : _Mypair ( _Zero_then_variadic_args_t { }, _Ptr ) { }

    template < class _Dx2 = _Dx, enable_if_t < is_constructible_v < _Dx2, const _Dx2 & >, int > = 0 >
    inline unique_ptr ( pointer _Ptr, const _Dx & _Dt ) noexcept : _Mypair ( _One_then_variadic_args_t { }, _Dt, _Ptr ) { }

    template < class _Dx2 = _Dx,
        enable_if_t < conjunction_v < negation < is_reference < _Dx2 >>, is_constructible < _Dx2, _Dx2 >>, int > = 0 >
    inline unique_ptr ( pointer _Ptr, _Dx && _Dt ) noexcept
        : _Mypair ( _One_then_variadic_args_t { }, :: std :: move ( _Dt ), _Ptr ) { }

    template < class _Dx2 = _Dx,
        enable_if_t < conjunction_v < is_reference < _Dx2 >, is_constructible < _Dx2, remove_reference_t < _Dx2 >> >, int > = 0 >
    unique_ptr ( pointer, remove_reference_t < _Dx > && ) = delete;

    template < class _Dx2 = _Dx, enable_if_t < is_move_constructible_v < _Dx2 >, int > = 0 >
    inline unique_ptr ( unique_ptr && _Right ) noexcept
        : _Mypair ( _One_then_variadic_args_t { }, :: std :: forward < _Dx > ( _Right . get_deleter ( ) ), _Right . release ( ) ) { }

    template < class _Ty2, class _Dx2,
        enable_if_t <
            conjunction_v < negation < is_array < _Ty2 >>, is_convertible < typename unique_ptr < _Ty2, _Dx2 > :: pointer, pointer >,
                conditional_t < is_reference_v < _Dx >, is_same < _Dx2, _Dx >, is_convertible < _Dx2, _Dx >> >,
            int > = 0 >
    inline unique_ptr ( unique_ptr < _Ty2, _Dx2 > && _Right ) noexcept
        : _Mypair ( _One_then_variadic_args_t { }, :: std :: forward < _Dx2 > ( _Right . get_deleter ( ) ), _Right . release ( ) ) { }


    template < class _Ty2,
        enable_if_t < conjunction_v < is_convertible < _Ty2 *, pointer >, is_same < _Dx, default_delete < _Ty >> >, int > = 0 >
    unique_ptr ( auto_ptr < _Ty2 > && _Right ) noexcept : _Mypair ( _Zero_then_variadic_args_t { }, _Right . release ( ) ) { }


    template < class _Ty2, class _Dx2,
        enable_if_t < conjunction_v < negation < is_array < _Ty2 >>, is_assignable < _Dx &, _Dx2 >,
                        is_convertible < typename unique_ptr < _Ty2, _Dx2 > :: pointer, pointer >>,
            int > = 0 >
    inline unique_ptr & operator = ( unique_ptr < _Ty2, _Dx2 > && _Right ) noexcept {
        reset ( _Right . release ( ) );
        _Mypair . _Get_first ( ) = :: std :: forward < _Dx2 > ( _Right . _Mypair . _Get_first ( ) );
        return * this;
    }

    template < class _Dx2 = _Dx, enable_if_t < is_move_assignable_v < _Dx2 >, int > = 0 >
    inline unique_ptr & operator = ( unique_ptr && _Right ) noexcept {
        reset ( _Right . release ( ) );
        _Mypair . _Get_first ( ) = :: std :: forward < _Dx > ( _Right . _Mypair . _Get_first ( ) );
        return * this;
    }

    inline void swap ( unique_ptr & _Right ) noexcept {
        using :: std :: swap;
        swap ( _Mypair . _Myval2, _Right . _Mypair . _Myval2 );
        swap ( _Mypair . _Get_first ( ), _Right . _Mypair . _Get_first ( ) );
    }

    inline ~ unique_ptr ( ) noexcept {
        if ( _Mypair . _Myval2 ) {
            _Mypair . _Get_first ( ) ( _Mypair . _Myval2 );
        }









    }

    [ [ nodiscard ] ] inline _Dx & get_deleter ( ) noexcept {
        return _Mypair . _Get_first ( );
    }

    [ [ nodiscard ] ] inline const _Dx & get_deleter ( ) const noexcept {
        return _Mypair . _Get_first ( );
    }

    [ [ nodiscard ] ] inline add_lvalue_reference_t < _Ty > operator * ( ) const noexcept ( noexcept ( * :: std :: declval < pointer > ( ) ) ) {
        return * _Mypair . _Myval2;
    }

    [ [ nodiscard ] ] inline pointer operator -> ( ) const noexcept {
        return _Mypair . _Myval2;
    }

    [ [ nodiscard ] ] inline pointer get ( ) const noexcept {
        return _Mypair . _Myval2;
    }

    inline explicit operator bool ( ) const noexcept {
        return static_cast < bool > ( _Mypair . _Myval2 );
    }

    inline pointer release ( ) noexcept {
        return :: std :: exchange ( _Mypair . _Myval2, nullptr );
    }

    inline void reset ( pointer _Ptr = nullptr ) noexcept {
        pointer _Old = :: std :: exchange ( _Mypair . _Myval2, _Ptr );
        if ( _Old ) {
            _Mypair . _Get_first ( ) ( _Old );
        }
    }

    unique_ptr ( const unique_ptr & ) = delete;
    unique_ptr & operator = ( const unique_ptr & ) = delete;

private :
    template < class, class >
    friend class unique_ptr;

    _Compressed_pair < _Dx, pointer > _Mypair;
};
#line 3485 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Ty, class _Dx >
class unique_ptr < _Ty [ ], _Dx > {
public :
    using pointer = typename _Get_deleter_pointer_type < _Ty, remove_reference_t < _Dx >> :: type;
    using element_type = _Ty;
    using deleter_type = _Dx;

    template < class _Dx2 = _Dx, _Unique_ptr_enable_default_t < _Dx2 > = 0 >
    constexpr unique_ptr ( ) noexcept : _Mypair ( _Zero_then_variadic_args_t { } ) { }

    template < class _Uty, class _Is_nullptr = is_same < _Uty, nullptr_t >>
    using _Enable_ctor_reset =
        enable_if_t < is_same_v < _Uty, pointer > || _Is_nullptr :: value
                        || ( is_same_v < pointer, element_type * > && is_pointer_v < _Uty >
                            && is_convertible_v < remove_pointer_t < _Uty > ( * ) [ ], element_type ( * ) [ ] > ),
            int >;

    template < class _Uty, class _Dx2 = _Dx, _Unique_ptr_enable_default_t < _Dx2 > = 0, _Enable_ctor_reset < _Uty > = 0 >
    inline explicit unique_ptr ( _Uty _Ptr ) noexcept : _Mypair ( _Zero_then_variadic_args_t { }, _Ptr ) { }

    template < class _Uty, class _Dx2 = _Dx, enable_if_t < is_constructible_v < _Dx2, const _Dx2 & >, int > = 0,
        _Enable_ctor_reset < _Uty > = 0 >
    inline unique_ptr ( _Uty _Ptr, const _Dx & _Dt ) noexcept : _Mypair ( _One_then_variadic_args_t { }, _Dt, _Ptr ) { }

    template < class _Uty, class _Dx2 = _Dx,
        enable_if_t < conjunction_v < negation < is_reference < _Dx2 >>, is_constructible < _Dx2, _Dx2 >>, int > = 0,
        _Enable_ctor_reset < _Uty > = 0 >
    inline unique_ptr ( _Uty _Ptr, _Dx && _Dt ) noexcept
        : _Mypair ( _One_then_variadic_args_t { }, :: std :: move ( _Dt ), _Ptr ) { }

    template < class _Uty, class _Dx2 = _Dx,
        enable_if_t < conjunction_v < is_reference < _Dx2 >, is_constructible < _Dx2, remove_reference_t < _Dx2 >> >, int > = 0 >
    unique_ptr ( _Uty, remove_reference_t < _Dx > && ) = delete;

    template < class _Dx2 = _Dx, enable_if_t < is_move_constructible_v < _Dx2 >, int > = 0 >
    inline unique_ptr ( unique_ptr && _Right ) noexcept
        : _Mypair ( _One_then_variadic_args_t { }, :: std :: forward < _Dx > ( _Right . get_deleter ( ) ), _Right . release ( ) ) { }

    template < class _Dx2 = _Dx, enable_if_t < is_move_assignable_v < _Dx2 >, int > = 0 >
    inline unique_ptr & operator = ( unique_ptr && _Right ) noexcept {
        if ( this != :: std :: addressof ( _Right ) ) {
            reset ( _Right . release ( ) );
            _Mypair . _Get_first ( ) = :: std :: move ( _Right . _Mypair . _Get_first ( ) );
        }

        return * this;
    }

    template < class _Uty, class _Ex, class _More, class _UP_pointer = typename unique_ptr < _Uty, _Ex > :: pointer,
        class _UP_element_type = typename unique_ptr < _Uty, _Ex > :: element_type >
    using _Enable_conversion = enable_if_t <
        conjunction_v < is_array < _Uty >, is_same < pointer, element_type * >, is_same < _UP_pointer, _UP_element_type * >,
            is_convertible < _UP_element_type ( * ) [ ], element_type ( * ) [ ] >, _More >,
        int >;

    template < class _Uty, class _Ex,
        _Enable_conversion < _Uty, _Ex, conditional_t < is_reference_v < _Dx >, is_same < _Ex, _Dx >, is_convertible < _Ex, _Dx >> > =
            0 >
    inline unique_ptr ( unique_ptr < _Uty, _Ex > && _Right ) noexcept
        : _Mypair ( _One_then_variadic_args_t { }, :: std :: forward < _Ex > ( _Right . get_deleter ( ) ), _Right . release ( ) ) { }

    template < class _Uty, class _Ex, _Enable_conversion < _Uty, _Ex, is_assignable < _Dx &, _Ex >> = 0 >
    inline unique_ptr & operator = ( unique_ptr < _Uty, _Ex > && _Right ) noexcept {
        reset ( _Right . release ( ) );
        _Mypair . _Get_first ( ) = :: std :: forward < _Ex > ( _Right . _Mypair . _Get_first ( ) );
        return * this;
    }

    template < class _Dx2 = _Dx, _Unique_ptr_enable_default_t < _Dx2 > = 0 >
    constexpr unique_ptr ( nullptr_t ) noexcept : _Mypair ( _Zero_then_variadic_args_t { } ) { }

    inline unique_ptr & operator = ( nullptr_t ) noexcept {
        reset ( );
        return * this;
    }

    inline void reset ( nullptr_t = nullptr ) noexcept {
        reset ( pointer ( ) );
    }

    inline void swap ( unique_ptr & _Right ) noexcept {
        using :: std :: swap;
        swap ( _Mypair . _Myval2, _Right . _Mypair . _Myval2 );
        swap ( _Mypair . _Get_first ( ), _Right . _Mypair . _Get_first ( ) );
    }

    inline ~ unique_ptr ( ) noexcept {
        if ( _Mypair . _Myval2 ) {
            _Mypair . _Get_first ( ) ( _Mypair . _Myval2 );
        }









    }

    [ [ nodiscard ] ] inline _Dx & get_deleter ( ) noexcept {
        return _Mypair . _Get_first ( );
    }

    [ [ nodiscard ] ] inline const _Dx & get_deleter ( ) const noexcept {
        return _Mypair . _Get_first ( );
    }

    [ [ nodiscard ] ] inline _Ty & operator [ ] ( size_t _Idx ) const noexcept {
        return _Mypair . _Myval2 [ _Idx ];
    }

    [ [ nodiscard ] ] inline pointer get ( ) const noexcept {
        return _Mypair . _Myval2;
    }

    inline explicit operator bool ( ) const noexcept {
        return static_cast < bool > ( _Mypair . _Myval2 );
    }

    inline pointer release ( ) noexcept {
        return :: std :: exchange ( _Mypair . _Myval2, nullptr );
    }

    template < class _Uty, _Enable_ctor_reset < _Uty, false_type > = 0 >
    inline void reset ( _Uty _Ptr ) noexcept {
        pointer _Old = :: std :: exchange ( _Mypair . _Myval2, _Ptr );
        if ( _Old ) {
            _Mypair . _Get_first ( ) ( _Old );
        }
    }

    unique_ptr ( const unique_ptr & ) = delete;
    unique_ptr & operator = ( const unique_ptr & ) = delete;

private :
    template < class, class >
    friend class unique_ptr;

    _Compressed_pair < _Dx, pointer > _Mypair;
};
#line 3628 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Ty, class ... _Types, enable_if_t < ! is_array_v < _Ty >, int > = 0 >
[ [ nodiscard ( "This function constructs an object wrapped by a smart pointer and has no other effects; it is not useful to call this function a" "nd discard the return value." ) ] ] inline unique_ptr < _Ty > make_unique ( _Types && ... _Args ) {
    return unique_ptr < _Ty > ( new _Ty ( :: std :: forward < _Types > ( _Args ) ... ) );
}
#line 3633
template < class _Ty, enable_if_t < is_array_v < _Ty > && extent_v < _Ty > == 0, int > = 0 >
[ [ nodiscard ( "This function constructs an object wrapped by a smart pointer and has no other effects; it is not useful to call this function a" "nd discard the return value." ) ] ] inline unique_ptr < _Ty > make_unique ( const size_t _Size ) {
    using _Elem = remove_extent_t < _Ty >;
    return unique_ptr < _Ty > ( new _Elem [ _Size ] ( ) );
}
#line 3639
template < class _Ty, class ... _Types, enable_if_t < extent_v < _Ty > != 0, int > = 0 >
void make_unique ( _Types && ... ) = delete;
#line 3660 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Ty, class _Dx, enable_if_t < _Is_swappable < _Dx > :: value, int > = 0 >
inline void swap ( unique_ptr < _Ty, _Dx > & _Left, unique_ptr < _Ty, _Dx > & _Right ) noexcept {
    _Left . swap ( _Right );
}
#line 3665
template < class _Ty1, class _Dx1, class _Ty2, class _Dx2 >
[ [ nodiscard ] ] inline bool operator == ( const unique_ptr < _Ty1, _Dx1 > & _Left, const unique_ptr < _Ty2, _Dx2 > & _Right ) {
    return _Left . get ( ) == _Right . get ( );
}
#line 3671
template < class _Ty1, class _Dx1, class _Ty2, class _Dx2 >
[ [ nodiscard ] ] bool operator != ( const unique_ptr < _Ty1, _Dx1 > & _Left, const unique_ptr < _Ty2, _Dx2 > & _Right ) {
    return ! ( _Left == _Right );
}
#line 3677 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Ty1, class _Dx1, class _Ty2, class _Dx2 >
[ [ nodiscard ] ] bool operator < ( const unique_ptr < _Ty1, _Dx1 > & _Left, const unique_ptr < _Ty2, _Dx2 > & _Right ) {
    using _Ptr1 = typename unique_ptr < _Ty1, _Dx1 > :: pointer;
    using _Ptr2 = typename unique_ptr < _Ty2, _Dx2 > :: pointer;
    using _Common = common_type_t < _Ptr1, _Ptr2 >;
    return less < _Common > { } ( _Left . get ( ), _Right . get ( ) );
}
#line 3685
template < class _Ty1, class _Dx1, class _Ty2, class _Dx2 >
[ [ nodiscard ] ] bool operator >= ( const unique_ptr < _Ty1, _Dx1 > & _Left, const unique_ptr < _Ty2, _Dx2 > & _Right ) {
    return ! ( _Left < _Right );
}
#line 3690
template < class _Ty1, class _Dx1, class _Ty2, class _Dx2 >
[ [ nodiscard ] ] bool operator > ( const unique_ptr < _Ty1, _Dx1 > & _Left, const unique_ptr < _Ty2, _Dx2 > & _Right ) {
    return _Right < _Left;
}
#line 3695
template < class _Ty1, class _Dx1, class _Ty2, class _Dx2 >
[ [ nodiscard ] ] bool operator <= ( const unique_ptr < _Ty1, _Dx1 > & _Left, const unique_ptr < _Ty2, _Dx2 > & _Right ) {
    return ! ( _Right < _Left );
}
#line 3711 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Ty, class _Dx >
[ [ nodiscard ] ] inline bool operator == ( const unique_ptr < _Ty, _Dx > & _Left, nullptr_t ) noexcept {
    return ! _Left;
}
#line 3717
template < class _Ty, class _Dx >
[ [ nodiscard ] ] bool operator == ( nullptr_t, const unique_ptr < _Ty, _Dx > & _Right ) noexcept {
    return ! _Right;
}
#line 3722
template < class _Ty, class _Dx >
[ [ nodiscard ] ] bool operator != ( const unique_ptr < _Ty, _Dx > & _Left, nullptr_t ) noexcept {
    return ! ( _Left == nullptr );
}
#line 3727
template < class _Ty, class _Dx >
[ [ nodiscard ] ] bool operator != ( nullptr_t, const unique_ptr < _Ty, _Dx > & _Right ) noexcept {
    return ! ( nullptr == _Right );
}
#line 3733 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template < class _Ty, class _Dx >
[ [ nodiscard ] ] inline bool operator < ( const unique_ptr < _Ty, _Dx > & _Left, nullptr_t ) {
    using _Ptr = typename unique_ptr < _Ty, _Dx > :: pointer;
    return less < _Ptr > { } ( _Left . get ( ), nullptr );
}
#line 3739
template < class _Ty, class _Dx >
[ [ nodiscard ] ] inline bool operator < ( nullptr_t, const unique_ptr < _Ty, _Dx > & _Right ) {
    using _Ptr = typename unique_ptr < _Ty, _Dx > :: pointer;
    return less < _Ptr > { } ( nullptr, _Right . get ( ) );
}
#line 3745
template < class _Ty, class _Dx >
[ [ nodiscard ] ] inline bool operator >= ( const unique_ptr < _Ty, _Dx > & _Left, nullptr_t ) {
    return ! ( _Left < nullptr );
}
#line 3750
template < class _Ty, class _Dx >
[ [ nodiscard ] ] inline bool operator >= ( nullptr_t, const unique_ptr < _Ty, _Dx > & _Right ) {
    return ! ( nullptr < _Right );
}
#line 3755
template < class _Ty, class _Dx >
[ [ nodiscard ] ] inline bool operator > ( const unique_ptr < _Ty, _Dx > & _Left, nullptr_t ) {
    return nullptr < _Left;
}
#line 3760
template < class _Ty, class _Dx >
[ [ nodiscard ] ] inline bool operator > ( nullptr_t, const unique_ptr < _Ty, _Dx > & _Right ) {
    return _Right < nullptr;
}
#line 3765
template < class _Ty, class _Dx >
[ [ nodiscard ] ] inline bool operator <= ( const unique_ptr < _Ty, _Dx > & _Left, nullptr_t ) {
    return ! ( nullptr < _Left );
}
#line 3770
template < class _Ty, class _Dx >
[ [ nodiscard ] ] inline bool operator <= ( nullptr_t, const unique_ptr < _Ty, _Dx > & _Right ) {
    return ! ( _Right < nullptr );
}
#line 3784 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template< class _OutTy, class _PxTy, class  = void> 
#line 3785
struct _Can_stream_unique_ptr : public false_type { }; 
#line 3786
template< class _OutTy, class _PxTy> 
#line 3787
struct _Can_stream_unique_ptr< _OutTy, _PxTy, void_t< decltype(std::declval< _OutTy> () << std::declval< _PxTy> ().get())> >  : public true_type { 
#line 3788
}; 
#line 3790
template < class _Elem, class _Traits, class _Yty, class _Dx,
    enable_if_t < _Can_stream_unique_ptr < basic_ostream < _Elem, _Traits > &, const unique_ptr < _Yty, _Dx > & > :: value, int > = 0 >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Out, const unique_ptr < _Yty, _Dx > & _Px ) {

    _Out << _Px . get ( );
    return _Out;
}
#line 3799
enum class pointer_safety { relaxed, preferred, strict}; 
#line 3801
inline void declare_reachable(void *) { } 
#line 3803
template < class _Ty >
_Ty * undeclare_reachable ( _Ty * _Ptr ) {
    return _Ptr;
}
#line 3808
inline void declare_no_pointers(char *, size_t) { } 
#line 3810
inline void undeclare_no_pointers(char *, size_t) { } 
#line 3812
inline pointer_safety get_pointer_safety() noexcept { 
#line 3813
return pointer_safety::relaxed; 
#line 3814
} 
#line 3817 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
template< class _Ty = void> struct owner_less; 
#line 3820
template < class _Ty >
struct owner_less < shared_ptr < _Ty > > {
    using first_argument_type = shared_ptr < _Ty >;
    using second_argument_type = shared_ptr < _Ty >;
    using result_type = bool;

    [ [ nodiscard ] ] bool operator ( ) ( const shared_ptr < _Ty > & _Left, const shared_ptr < _Ty > & _Right ) const noexcept {
        return _Left . owner_before ( _Right );
    }

    [ [ nodiscard ] ] bool operator ( ) ( const shared_ptr < _Ty > & _Left, const weak_ptr < _Ty > & _Right ) const noexcept {
        return _Left . owner_before ( _Right );
    }

    [ [ nodiscard ] ] bool operator ( ) ( const weak_ptr < _Ty > & _Left, const shared_ptr < _Ty > & _Right ) const noexcept {
        return _Left . owner_before ( _Right );
    }
};
#line 3839
template < class _Ty >
struct owner_less < weak_ptr < _Ty > > {
    using first_argument_type = weak_ptr < _Ty >;
    using second_argument_type = weak_ptr < _Ty >;
    using result_type = bool;

    [ [ nodiscard ] ] bool operator ( ) ( const weak_ptr < _Ty > & _Left, const weak_ptr < _Ty > & _Right ) const noexcept {
        return _Left . owner_before ( _Right );
    }

    [ [ nodiscard ] ] bool operator ( ) ( const weak_ptr < _Ty > & _Left, const shared_ptr < _Ty > & _Right ) const noexcept {
        return _Left . owner_before ( _Right );
    }

    [ [ nodiscard ] ] bool operator ( ) ( const shared_ptr < _Ty > & _Left, const weak_ptr < _Ty > & _Right ) const noexcept {
        return _Left . owner_before ( _Right );
    }
};
#line 3859
template<> struct owner_less< void>  { 
#line 3860
template < class _Ty, class _Uty >
    [ [ nodiscard ] ] bool operator ( ) ( const shared_ptr < _Ty > & _Left, const shared_ptr < _Uty > & _Right ) const noexcept {
        return _Left . owner_before ( _Right );
    }
#line 3865
template < class _Ty, class _Uty >
    [ [ nodiscard ] ] bool operator ( ) ( const shared_ptr < _Ty > & _Left, const weak_ptr < _Uty > & _Right ) const noexcept {
        return _Left . owner_before ( _Right );
    }
#line 3870
template < class _Ty, class _Uty >
    [ [ nodiscard ] ] bool operator ( ) ( const weak_ptr < _Ty > & _Left, const shared_ptr < _Uty > & _Right ) const noexcept {
        return _Left . owner_before ( _Right );
    }
#line 3875
template < class _Ty, class _Uty >
    [ [ nodiscard ] ] bool operator ( ) ( const weak_ptr < _Ty > & _Left, const weak_ptr < _Uty > & _Right ) const noexcept {
        return _Left . owner_before ( _Right );
    }
#line 3880
using is_transparent = int; 
#line 3881
}; 
#line 3883
template < class _Ty, class _Dx >
struct hash < unique_ptr < _Ty, _Dx > > : _Conditionally_enabled_hash < unique_ptr < _Ty, _Dx >,
                                        is_default_constructible_v < hash < typename unique_ptr < _Ty, _Dx > :: pointer > > > {
    static size_t _Do_hash ( const unique_ptr < _Ty, _Dx > & _Keyval )
        noexcept ( _Is_nothrow_hashable < typename unique_ptr < _Ty, _Dx > :: pointer > :: value ) {
        return hash < typename unique_ptr < _Ty, _Dx > :: pointer > { } ( _Keyval . get ( ) );
    }
};
#line 3892
template < class _Ty >
struct hash < shared_ptr < _Ty > > {
    using argument_type = shared_ptr < _Ty >;
    using result_type = size_t;

    [ [ nodiscard ] ] size_t operator ( ) ( const shared_ptr < _Ty > & _Keyval ) const noexcept {
        return hash < typename shared_ptr < _Ty > :: element_type * > ( ) ( _Keyval . get ( ) );
    }
};
#line 3914 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
extern "C" {
#line 3915
void __cdecl _Lock_shared_ptr_spin_lock() noexcept; 
#line 3916
void __cdecl _Unlock_shared_ptr_spin_lock() noexcept; 
#line 3917
}
#line 3919
struct _Shared_ptr_spin_lock { 
#line 3920
_Shared_ptr_spin_lock() { 
#line 3921
_Lock_shared_ptr_spin_lock(); 
#line 3922
} 
#line 3924
~_Shared_ptr_spin_lock() noexcept { 
#line 3925
_Unlock_shared_ptr_spin_lock(); 
#line 3926
} 
#line 3927
}; 
#line 3929
template < class _Ty >
 [ [ nodiscard ] ] bool atomic_is_lock_free ( const shared_ptr < _Ty > * ) {

    return false;
}
#line 3935
template < class _Ty >
 [ [ nodiscard ] ] shared_ptr < _Ty > atomic_load_explicit (
    const shared_ptr < _Ty > * _Ptr, memory_order ) {

    _Shared_ptr_spin_lock _Lock;
    shared_ptr < _Ty > _Result = * _Ptr;
    return _Result;
}
#line 3944
template < class _Ty >
 [ [ nodiscard ] ] shared_ptr < _Ty > atomic_load (
    const shared_ptr < _Ty > * _Ptr ) {
    return :: std :: atomic_load_explicit ( _Ptr, memory_order_seq_cst );
}
#line 3950
template < class _Ty >
 void atomic_store_explicit (
    shared_ptr < _Ty > * _Ptr, shared_ptr < _Ty > _Other, memory_order ) {

    _Shared_ptr_spin_lock _Lock;
    _Ptr -> swap ( _Other );
}
#line 3958
template < class _Ty >
 void atomic_store (
    shared_ptr < _Ty > * _Ptr, shared_ptr < _Ty > _Other ) {
    :: std :: atomic_store_explicit ( _Ptr, :: std :: move ( _Other ), memory_order_seq_cst );
}
#line 3964
template < class _Ty >
 shared_ptr < _Ty > atomic_exchange_explicit (
    shared_ptr < _Ty > * _Ptr, shared_ptr < _Ty > _Other, memory_order ) {

    _Shared_ptr_spin_lock _Lock;
    _Ptr -> swap ( _Other );
    return _Other;
}
#line 3973
template < class _Ty >
 shared_ptr < _Ty > atomic_exchange (
    shared_ptr < _Ty > * _Ptr, shared_ptr < _Ty > _Other ) {

    return :: std :: atomic_exchange_explicit ( _Ptr, :: std :: move ( _Other ), memory_order_seq_cst );
}
#line 3980
template < class _Ty >
 bool atomic_compare_exchange_weak_explicit ( shared_ptr < _Ty > * _Ptr,
    shared_ptr < _Ty > * _Exp, shared_ptr < _Ty > _Value, memory_order, memory_order ) {
    shared_ptr < _Ty > _Old_exp;
    _Shared_ptr_spin_lock _Lock;
    bool _Success = _Ptr -> get ( ) == _Exp -> get ( ) && ! _Ptr -> owner_before ( * _Exp ) && ! _Exp -> owner_before ( * _Ptr );
    if ( _Success ) {
        _Ptr -> swap ( _Value );
    } else {
        _Exp -> swap ( _Old_exp );
        * _Exp = * _Ptr;
    }
    return _Success;
}
#line 3995
template < class _Ty >
 bool atomic_compare_exchange_weak (
    shared_ptr < _Ty > * _Ptr, shared_ptr < _Ty > * _Exp, shared_ptr < _Ty > _Value ) {

    return :: std :: atomic_compare_exchange_weak_explicit (
        _Ptr, _Exp, :: std :: move ( _Value ), memory_order_seq_cst, memory_order_seq_cst );
}
#line 4003
template < class _Ty >
 bool atomic_compare_exchange_strong_explicit ( shared_ptr < _Ty > * _Ptr,
    shared_ptr < _Ty > * _Exp, shared_ptr < _Ty > _Value, memory_order, memory_order ) {
    return :: std :: atomic_compare_exchange_weak_explicit (
        _Ptr, _Exp, :: std :: move ( _Value ), memory_order_seq_cst, memory_order_seq_cst );
}
#line 4010
template < class _Ty >
 bool atomic_compare_exchange_strong (
    shared_ptr < _Ty > * _Ptr, shared_ptr < _Ty > * _Exp, shared_ptr < _Ty > _Value ) {

    return :: std :: atomic_compare_exchange_strong_explicit (
        _Ptr, _Exp, :: std :: move ( _Value ), memory_order_seq_cst, memory_order_seq_cst );
}
#line 4500 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
namespace [[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to suppress this warning.")]] tr1 { 
#line 4501
using std::allocate_shared;
#line 4502
using std::bad_weak_ptr;
#line 4503
using std::const_pointer_cast;
#line 4504
using std::dynamic_pointer_cast;
#line 4505
using std::enable_shared_from_this;
#line 4506
using std::get_deleter;
#line 4507
using std::make_shared;
#line 4508
using std::shared_ptr;
#line 4509
using std::static_pointer_cast;
#line 4510
using std::swap;
#line 4511
using std::weak_ptr;
#line 4512
}
#line 4515 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\memory"
}
#line 4522
#pragma warning(pop)
#pragma pack ( pop )
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xfacet"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 22
namespace std { 
#line 23
class _Facet_base { 
#line 25
public: virtual ~_Facet_base() noexcept { } 
#line 28
virtual void _Incref() noexcept = 0; 
#line 31
virtual _Facet_base *_Decref() noexcept = 0; 
#line 32
}; 
#line 37 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xfacet"
void __cdecl _Facet_Register(_Facet_base *); 
#line 39 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xfacet"
}
#line 42
#pragma warning(pop)
#pragma pack ( pop )
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_xlocinfo_types.hpp"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 18
extern "C" {
#line 20
struct _Collvec { 
#line 21
unsigned _Page; 
#line 22
__wchar_t *_LocaleName; 
#line 23
}; 
#line 25
struct _Ctypevec { 
#line 26
unsigned _Page; 
#line 27
const short *_Table; 
#line 28
int _Delfl; 
#line 29
__wchar_t *_LocaleName; 
#line 30
}; 
#line 32
struct _Cvtvec { 
#line 33
unsigned _Page; 
#line 34
unsigned _Mbcurmax; 
#line 35
int _Isclocale; 
#line 36
unsigned char _Isleadbyte[32]; 
#line 37
}; 
#line 39
}
#line 43
#pragma warning(pop)
#pragma pack ( pop )
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cctype"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 20
namespace std { 
#line 21
using ::isalnum;
#line 22
using ::isalpha;
#line 23
using ::iscntrl;
#line 24
using ::isdigit;
#line 25
using ::isgraph;
#line 26
using ::islower;
#line 27
using ::isprint;
#line 28
using ::ispunct;
#line 29
using ::isspace;
#line 30
using ::isupper;
#line 31
using ::isxdigit;
#line 32
using ::tolower;
#line 33
using ::toupper;
#line 35
using ::isblank;
#line 36
}
#line 40
#pragma warning(pop)
#pragma pack ( pop )
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\locale.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 18
__pragma( pack ( push, 8 )) extern "C" {
#line 34
struct lconv { 
#line 36
char *decimal_point; 
#line 37
char *thousands_sep; 
#line 38
char *grouping; 
#line 39
char *int_curr_symbol; 
#line 40
char *currency_symbol; 
#line 41
char *mon_decimal_point; 
#line 42
char *mon_thousands_sep; 
#line 43
char *mon_grouping; 
#line 44
char *positive_sign; 
#line 45
char *negative_sign; 
#line 46
char int_frac_digits; 
#line 47
char frac_digits; 
#line 48
char p_cs_precedes; 
#line 49
char p_sep_by_space; 
#line 50
char n_cs_precedes; 
#line 51
char n_sep_by_space; 
#line 52
char p_sign_posn; 
#line 53
char n_sign_posn; 
#line 54
__wchar_t *_W_decimal_point; 
#line 55
__wchar_t *_W_thousands_sep; 
#line 56
__wchar_t *_W_int_curr_symbol; 
#line 57
__wchar_t *_W_currency_symbol; 
#line 58
__wchar_t *_W_mon_decimal_point; 
#line 59
__wchar_t *_W_mon_thousands_sep; 
#line 60
__wchar_t *_W_positive_sign; 
#line 61
__wchar_t *_W_negative_sign; 
#line 62
}; 
#line 64
struct tm; 
#line 88
void __cdecl _lock_locales(); 
#line 89
void __cdecl _unlock_locales(); 
#line 92
int __cdecl _configthreadlocale(int _Flag); 
#line 97
char *__cdecl setlocale(int _Category, const char * _Locale); 
#line 103
lconv *__cdecl localeconv(); 
#line 106
_locale_t __cdecl _get_current_locale(); 
#line 109
_locale_t __cdecl _create_locale(int _Category, const char * _Locale); 
#line 114
void __cdecl _free_locale(_locale_t _Locale); 
#line 120
__wchar_t *__cdecl _wsetlocale(int _Category, const __wchar_t * _Locale); 
#line 126
_locale_t __cdecl _wcreate_locale(int _Category, const __wchar_t * _Locale); 
#line 133
__wchar_t **__cdecl ___lc_locale_name_func(); 
#line 134
unsigned __cdecl ___lc_codepage_func(); 
#line 135
unsigned __cdecl ___lc_collate_cp_func(); 
#line 143
char *__cdecl _Getdays(); 
#line 147
char *__cdecl _Getmonths(); 
#line 149
void *__cdecl _Gettnames(); 
#line 153
__wchar_t *__cdecl _W_Getdays(); 
#line 157
__wchar_t *__cdecl _W_Getmonths(); 
#line 159
void *__cdecl _W_Gettnames(); 
#line 162
size_t __cdecl _Strftime(char * _Buffer, size_t _Max_size, const char * _Format, const tm * _Timeptr, void * _Lc_time_arg); 
#line 170
size_t __cdecl _Wcsftime(__wchar_t * _Buffer, size_t _Max_size, const __wchar_t * _Format, const tm * _Timeptr, void * _Lc_time_arg); 
#line 181 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\ucrt\\locale.h"
}__pragma( pack ( pop )) 
#line 183
#pragma warning(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\clocale"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 20
namespace std { 
#line 21
using ::lconv;
#line 22
using ::localeconv;
#line 23
using ::setlocale;
#line 24
}
#line 28
#pragma warning(pop)
#pragma pack ( pop )
#line 18 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocinfo"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 25
extern "C" {
#line 46
_Collvec __cdecl _Getcoll() noexcept; 
#line 47
_Ctypevec __cdecl _Getctype() noexcept; 
#line 48
_Cvtvec __cdecl _Getcvt() noexcept; 
#line 49
int __cdecl _Getdateorder() noexcept; 
#line 56
int __cdecl _Mbrtowc(__wchar_t *, const char *, size_t _Max_multibyte, mbstate_t *, const _Cvtvec *) noexcept; 
#line 60 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocinfo"
int __cdecl _Strcoll(const char *, const char *, const char *, const char *, const _Collvec *) noexcept; 
#line 62
size_t __cdecl _Strxfrm(char * _String1, char * _End1, const char *, const char *, const _Collvec *) noexcept; 
#line 65
int __cdecl _Tolower(int, const _Ctypevec *) noexcept; 
#line 66
int __cdecl _Toupper(int, const _Ctypevec *) noexcept; 
#line 68
int __cdecl _Wcrtomb(char *, __wchar_t, mbstate_t *, const _Cvtvec *) noexcept; 
#line 69
int __cdecl _Wcscoll(const __wchar_t *, const __wchar_t *, const __wchar_t *, const __wchar_t *, const _Collvec *) noexcept; 
#line 71
size_t __cdecl _Wcsxfrm(__wchar_t * _String1, __wchar_t * _End1, const __wchar_t *, const __wchar_t *, const _Collvec *) noexcept; 
#line 75
short __cdecl _Getwctype(__wchar_t, const _Ctypevec *) noexcept; 
#line 76
const __wchar_t *__cdecl _Getwctypes(const __wchar_t *, const __wchar_t *, short *, const _Ctypevec *) noexcept; 
#line 78
__wchar_t __cdecl _Towlower(__wchar_t, const _Ctypevec *) noexcept; 
#line 79
__wchar_t __cdecl _Towupper(__wchar_t, const _Ctypevec *) noexcept; 
#line 81
}
#line 83
extern "C" {
#line 87
char *__cdecl _Getdays(); 
#line 89
char *__cdecl _Getmonths(); 
#line 91
void *__cdecl _Gettnames(); 
#line 93
size_t __cdecl _Strftime(char *, size_t _Maxsize, const char *, const tm *, void *); 
#line 96
__wchar_t *__cdecl _W_Getdays(); 
#line 98
__wchar_t *__cdecl _W_Getmonths(); 
#line 100
void *__cdecl _W_Gettnames(); 
#line 102
size_t __cdecl _Wcsftime(__wchar_t *, size_t _Maxsize, const __wchar_t *, const tm *, void *); 
#line 104
}
#line 106
namespace std { 
#line 107
class _Timevec { 
#line 109
public: explicit _Timevec(void *_Ptr = 0) : _Timeptr(_Ptr) { } 
#line 111
_Timevec(const _Timevec &_Right) : _Timeptr((nullptr)) { 
#line 112
((*this) = _Right); 
#line 113
} 
#line 115
~_Timevec() noexcept { 
#line 116
::free(_Timeptr); 
#line 117
} 
#line 119
_Timevec &operator=(const _Timevec &_Right) { 
#line 120
if (this != (&_Right)) { 
#line 121
::free(_Timeptr); 
#line 122
(_Timeptr) = (_Right._Timeptr); 
#line 123
((const_cast< _Timevec &>(_Right))._Timeptr) = (nullptr); 
#line 124
}  
#line 126
return *this; 
#line 127
} 
#line 129
void *_Getptr() const { 
#line 130
return _Timeptr; 
#line 131
} 
#line 134
private: void *_Timeptr; 
#line 135
}; 
#line 137
template < class _Elem >
class _Yarn {
public :
     _Yarn ( ) noexcept : _Myptr ( nullptr ), _Nul ( 0 ) { }

     _Yarn ( const _Yarn & _Right ) noexcept : _Myptr ( nullptr ), _Nul ( 0 ) {
        * this = _Right;
    }

     _Yarn ( const _Elem * _Right ) noexcept : _Myptr ( nullptr ), _Nul ( 0 ) {
        * this = _Right;
    }

    _Yarn & operator = ( const _Yarn & _Right ) noexcept {
        return * this = _Right . _Myptr;
    }

    _Yarn & operator = ( const _Elem * _Right ) noexcept {
        if ( _Myptr != _Right ) {
            _Tidy ( );

            if ( _Right ) {
                const _Elem * _Ptr = _Right;
                while ( * _Ptr != _Elem { } ) {
                    ++ _Ptr;
                }

                const auto _Count = ( ++ _Ptr - _Right ) * sizeof ( _Elem );




                _Myptr = static_cast < _Elem * > ( :: malloc ( _Count ) );


                if ( _Myptr ) {
                    :: memcpy ( _Myptr, _Right, _Count );
                }
            }
        }

        return * this;
    }

     ~ _Yarn ( ) noexcept {
        _Tidy ( );
    }

    [ [ nodiscard ] ] bool empty ( ) const noexcept {
        return _Myptr == nullptr;
    }

      const _Elem * c_str ( ) const noexcept {
        return _Myptr ? _Myptr : & _Nul;
    }

    [ [ nodiscard ] ] bool _Empty ( ) const noexcept {
        return _Myptr == nullptr;
    }

      const _Elem * _C_str ( ) const noexcept {
        return _Myptr ? _Myptr : & _Nul;
    }

private :
    void _Tidy ( ) noexcept {
        if ( _Myptr ) {



            :: free ( _Myptr );

        }

        _Myptr = nullptr;
    }

    _Elem * _Myptr;
    _Elem _Nul;
};
#line 218 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocinfo"
class _Locinfo { 
#line 220
public: using _Collvec = ::_Collvec; 
#line 221
using _Ctypevec = ::_Ctypevec; 
#line 222
using _Cvtvec = ::_Cvtvec; 
#line 223
using _Timevec = std::_Timevec; 
#line 225
static void __cdecl _Locinfo_ctor(_Locinfo *, const char *); 
#line 226
static void __cdecl _Locinfo_ctor(_Locinfo *, int, const char *); 
#line 227
static void __cdecl _Locinfo_dtor(_Locinfo *); 
#line 228
static _Locinfo &__cdecl _Locinfo_Addcats(_Locinfo *, int, const char *); 
#line 230
_Locinfo(const char *_Pch = "C") : _Lock(0) 
#line 234 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocinfo"
{ 
#line 235
if (_Pch) { 
#line 236
_Locinfo_ctor(this, _Pch); 
#line 237
return; 
#line 238
}  
#line 240
_Xruntime_error("bad locale name"); 
#line 241
} 
#line 243
_Locinfo(int _Cat, const char *_Pch) : _Lock(0) 
#line 247 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocinfo"
{ 
#line 248
if (_Pch) { 
#line 249
_Locinfo_ctor(this, _Cat, _Pch); 
#line 250
return; 
#line 251
}  
#line 253
_Xruntime_error("bad locale name"); 
#line 254
} 
#line 256
~_Locinfo() noexcept { 
#line 257
_Locinfo_dtor(this); 
#line 258
} 
#line 260
_Locinfo &_Addcats(int _Cat, const char *_Pch) { 
#line 261
if (_Pch) { 
#line 262
return _Locinfo_Addcats(this, _Cat, _Pch); 
#line 263
}  
#line 265
_Xruntime_error("bad locale name"); 
#line 266
} 
#line 268
const char *_Getname() const { 
#line 269
return (_Newlocname)._C_str(); 
#line 270
} 
#line 272
_Collvec _Getcoll() const { 
#line 273
return ::_Getcoll(); 
#line 274
} 
#line 276
_Ctypevec _Getctype() const { 
#line 277
return ::_Getctype(); 
#line 278
} 
#line 280
_Cvtvec _Getcvt() const { 
#line 281
return ::_Getcvt(); 
#line 282
} 
#line 284
const lconv *_Getlconv() const { 
#line 285
return localeconv(); 
#line 286
} 
#line 288
_Timevec _Gettnames() const { 
#line 289
return ((_Timevec)(::_Gettnames())); 
#line 290
} 
#line 292
const char *_Getdays() const { 
#line 293
const char *_Ptr = ::_Getdays(); 
#line 294
if (_Ptr) { 
#line 295
(((const_cast< _Locinfo *>(this))->_Days) = _Ptr); 
#line 296
::free(const_cast< char *>(_Ptr)); 
#line 297
}  
#line 299
return (!(_Days)._Empty()) ? (_Days)._C_str() : (":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday"); 
#line 302
} 
#line 304
const char *_Getmonths() const { 
#line 305
const char *_Ptr = ::_Getmonths(); 
#line 306
if (_Ptr) { 
#line 307
(((const_cast< _Locinfo *>(this))->_Months) = _Ptr); 
#line 308
::free(const_cast< char *>(_Ptr)); 
#line 309
}  
#line 311
return (!(_Months)._Empty()) ? (_Months)._C_str() : (":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:De" "cember"); 
#line 316
} 
#line 318
const char *_Getfalse() const { 
#line 319
return "false"; 
#line 320
} 
#line 322
const char *_Gettrue() const { 
#line 323
return "true"; 
#line 324
} 
#line 326
int _Getdateorder() const { 
#line 327
return ::_Getdateorder(); 
#line 328
} 
#line 330
_Timevec _W_Gettnames() const { 
#line 331
return ((_Timevec)(::_W_Gettnames())); 
#line 332
} 
#line 334
const unsigned short *_W_Getdays() const { 
#line 335
const __wchar_t *_Ptr = ::_W_Getdays(); 
#line 336
if (_Ptr) { 
#line 337
(((const_cast< _Locinfo *>(this))->_W_Days) = _Ptr); 
#line 338
::free(const_cast< __wchar_t *>(_Ptr)); 
#line 339
}  
#line 341
const __wchar_t *_Ret; 
#line 343
if ((_W_Days)._Empty()) { 
#line 344
_Ret = (L"\x3a\x53\x75\x6e\x3a\x53\x75\x6e\x64\x61\x79\x3a\x4d\x6f\x6e\x3a\x4d\x6f\x6e\x64\x61\x79\x3a\x54\x75\x65\x3a\x54\x75\x65\x73\x64" L"\x61\x79\x3a\x57\x65\x64\x3a\x57\x65\x64\x6e\x65\x73\x64\x61\x79\x3a\x54\x68\x75\x3a\x54\x68\x75\x72\x73\x64\x61\x79\x3a\x46\x72" L"\x69\x3a\x46\x72\x69\x64\x61\x79\x3a\x53\x61\x74\x3a\x53\x61\x74\x75\x72\x64\x61\x79"); 
#line 345
} else { 
#line 346
_Ret = (_W_Days)._C_str(); 
#line 347
}  
#line 349
return reinterpret_cast< const unsigned short *>(_Ret); 
#line 350
} 
#line 352
const unsigned short *_W_Getmonths() const { 
#line 353
const __wchar_t *_Ptr = ::_W_Getmonths(); 
#line 354
if (_Ptr) { 
#line 355
(((const_cast< _Locinfo *>(this))->_W_Months) = _Ptr); 
#line 356
::free(const_cast< __wchar_t *>(_Ptr)); 
#line 357
}  
#line 359
const __wchar_t *_Ret; 
#line 361
if ((_W_Months)._Empty()) { 
#line 362
_Ret = (L"\x3a\x4a\x61\x6e\x3a\x4a\x61\x6e\x75\x61\x72\x79\x3a\x46\x65\x62\x3a\x46\x65\x62\x72\x75\x61\x72\x79\x3a\x4d\x61\x72\x3a\x4d\x61" L"\x72\x63\x68\x3a\x41\x70\x72\x3a\x41\x70\x72\x69\x6c\x3a\x4d\x61\x79\x3a\x4d\x61\x79\x3a\x4a\x75\x6e\x3a\x4a\x75\x6e\x65\x3a\x4a" L"\x75\x6c\x3a\x4a\x75\x6c\x79\x3a\x41\x75\x67\x3a\x41\x75\x67\x75\x73\x74\x3a\x53\x65\x70\x3a\x53\x65\x70\x74\x65\x6d\x62\x65\x72" L"\x3a\x4f\x63\x74\x3a\x4f\x63\x74\x6f\x62\x65\x72\x3a\x4e\x6f\x76\x3a\x4e\x6f\x76\x65\x6d\x62\x65\x72\x3a\x44\x65\x63\x3a\x44\x65" L"\x63\x65\x6d\x62\x65\x72"); 
#line 364
} else { 
#line 365
_Ret = (_W_Months)._C_str(); 
#line 366
}  
#line 368
return reinterpret_cast< const unsigned short *>(_Ret); 
#line 369
} 
#line 371
_Locinfo(const _Locinfo &) = delete;
#line 372
_Locinfo &operator=(const _Locinfo &) = delete;
#line 378
private: _Lockit _Lock; 
#line 381 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocinfo"
_Yarn< char>  _Days; 
#line 382
_Yarn< char>  _Months; 
#line 383
_Yarn< __wchar_t>  _W_Days; 
#line 384
_Yarn< __wchar_t>  _W_Months; 
#line 385
_Yarn< char>  _Oldlocname; 
#line 386
_Yarn< char>  _Newlocname; 
#line 387
}; 
#line 389
template < class _Elem >
int __cdecl _LStrcoll ( const _Elem * _First1, const _Elem * _Last1, const _Elem * _First2, const _Elem * _Last2,
    const _Locinfo :: _Collvec * ) {
    for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ++ _First2 ) {
        if ( * _First1 < * _First2 ) {
            return - 1;
        } else if ( * _First2 < * _First1 ) {
            return + 1;
        }
    }

    return _First2 != _Last2 ? - 1 : _First1 != _Last1 ? + 1 : 0;
}
#line 404
template<> inline int __cdecl _LStrcoll(const char *_First1, const char *_Last1, const char *_First2, const char *_Last2, const _Locinfo::_Collvec *
#line 405
_Vector) { 
#line 406
return _Strcoll(_First1, _Last1, _First2, _Last2, _Vector); 
#line 407
} 
#line 410
template<> inline int __cdecl _LStrcoll(const __wchar_t *_First1, const __wchar_t *_Last1, const __wchar_t *_First2, const __wchar_t *
#line 411
_Last2, const _Locinfo::_Collvec *
#line 412
_Vector) { 
#line 413
return _Wcscoll(_First1, _Last1, _First2, _Last2, _Vector); 
#line 414
} 
#line 416
template < class _Elem >
size_t __cdecl _LStrxfrm ( _Elem * _First1, _Elem * _Last1, const _Elem * _First2, const _Elem * _Last2,
    const _Locinfo :: _Collvec * ) {
    const ptrdiff_t _Count = _Last2 - _First2;
    if ( _Count <= _Last1 - _First1 ) {
        :: memcpy ( _First1, _First2, _Count * sizeof ( _Elem ) );
    }

    return _Count;
}
#line 428
template<> inline size_t __cdecl _LStrxfrm(char *_First1, char *
#line 429
_Last1, const char *_First2, const char *_Last2, const _Locinfo::_Collvec *
#line 430
_Vector) { 
#line 431
return _Strxfrm(_First1, _Last1, _First2, _Last2, _Vector); 
#line 432
} 
#line 435
template<> inline size_t __cdecl _LStrxfrm(__wchar_t *_First1, __wchar_t *
#line 436
_Last1, const __wchar_t *_First2, const __wchar_t *_Last2, const _Locinfo::_Collvec *
#line 437
_Vector) { 
#line 438
return _Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector); 
#line 439
} 
#line 440
}
#line 443
#pragma warning(pop)
#pragma pack ( pop )
#line 17 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocale"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 24
namespace std { 
#line 25
template< class _Dummy> 
#line 26
class _Locbase { }; 
#line 28
template< class _Elem> class collate; 
#line 32
struct _Crt_new_delete { 
#line 61
}; 
#line 64
class locale : public _Locbase< int> , public _Crt_new_delete { 
#line 66
public: using category = int; 
#line 68
static constexpr category collate = ((1 << 1) >> 1); 
#line 69
static constexpr category ctype = ((1 << 2) >> 1); 
#line 70
static constexpr category monetary = ((1 << 3) >> 1); 
#line 71
static constexpr category numeric = ((1 << 4) >> 1); 
#line 72
static constexpr category time = ((1 << 5) >> 1); 
#line 73
static constexpr category messages = ((1 << 6) >> 1); 
#line 74
static constexpr category all = (((1 << (6 + 1)) >> 1) - 1); 
#line 75
static constexpr category none = 0; 
#line 77
class id { 
#line 82
public: template < int = 0 >
        id ( ) noexcept { }
#line 86 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocale"
id(const id &) = delete;
#line 87
id &operator=(const id &) = delete;
#line 89
template < int = 0 >
        size_t _Get_index ( ) {
            if ( _Id == 0 ) {
                { :: std :: _Lockit _Lock ( 0 );
                if ( _Id == 0 ) {
                    _Id = static_cast < size_t > ( ++ _Id_cnt );
                }
                }
            }
            return _Id;
        }
#line 108
private: size_t _Id = (0); 
#line 110
static int _Id_cnt; 
#line 111
}; 
#line 113
struct _Facet_guard; 
#line 115
class facet : public _Facet_base, public _Crt_new_delete { 
#line 118
friend struct _Facet_guard; 
#line 121
public: static size_t __cdecl _Getcat(const facet ** = 0, const locale * = 0) { 
#line 123
return static_cast< size_t>(-1); 
#line 124
} 
#line 126
virtual void _Incref() noexcept override { 
#line 127
_InterlockedIncrement(reinterpret_cast< volatile long *>(&(_Myrefs))); 
#line 128
} 
#line 130
virtual _Facet_base *_Decref() noexcept override { 
#line 131
if (_InterlockedDecrement(reinterpret_cast< volatile long *>(&(_Myrefs))) == (0)) { 
#line 132
return this; 
#line 133
}  
#line 135
return nullptr; 
#line 136
} 
#line 139
private: _Atomic_counter_t _Myrefs; 
#line 142
protected: explicit facet(size_t _Initrefs = 0) noexcept : _Myrefs(static_cast< _Atomic_counter_t>(_Initrefs)) 
#line 144
{ } 
#line 146
virtual ~facet() noexcept override { } 
#line 149
public: facet(const facet &) = delete;
#line 150
facet &operator=(const facet &) = delete;
#line 151
}; 
#line 153
struct [[nodiscard]] _Facet_guard { 
#line 154
facet *_Target; 
#line 155
~_Facet_guard() { 
#line 156
if (_Target) { 
#line 157
delete (_Target)->_Decref(); 
#line 158
}  
#line 159
} 
#line 160
}; 
#line 162
class _Locimp : public facet { 
#line 164
protected: virtual ~_Locimp() noexcept { 
#line 165
_Locimp_dtor(this); 
#line 166
} 
#line 169
private: static _Locimp *__cdecl _New_Locimp(bool _Transparent = false); 
#line 170
static _Locimp *__cdecl _New_Locimp(const _Locimp & _Right); 
#line 172
static void __cdecl _Locimp_dtor(_Locimp *); 
#line 173
static void __cdecl _Locimp_Addfac(_Locimp *, facet *, size_t); 
#line 174
static void __cdecl _Locimp_ctor(_Locimp *, const _Locimp &); 
#line 176
friend class locale; 
#line 178
_Locimp(bool _Transparent) : facet(1), _Facetvec((nullptr)), _Facetcount((0)), _Catmask(none), _Xparent(_Transparent), _Name("*") 
#line 179
{ 
#line 180
} 
#line 182
_Locimp(const _Locimp &_Right) : facet(1), _Facetvec((nullptr)), _Facetcount(_Right._Facetcount), _Catmask(_Right._Catmask), _Xparent(_Right._Xparent), _Name((_Right._Name).c_str()) 
#line 184
{ 
#line 185
_Locimp_ctor(this, _Right); 
#line 186
} 
#line 188
void _Addfac(facet *_Pfacet, size_t _Id) { 
#line 189
_Locimp_Addfac(this, _Pfacet, _Id); 
#line 190
} 
#line 192
static _Locimp *__cdecl _Makeloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 195
static void __cdecl _Makewloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 199
static void __cdecl _Makeushloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 203 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocale"
static void __cdecl _Makexloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 206
facet **_Facetvec; 
#line 207
size_t _Facetcount; 
#line 208
category _Catmask; 
#line 209
bool _Xparent; 
#line 210
_Yarn< char>  _Name; 
#line 212
static _Locimp *_Clocptr; 
#line 215
public: _Locimp &operator=(const _Locimp &) = delete;
#line 216
}; 
#line 218
template < class _Elem, class _Traits, class _Alloc >
    bool operator ( ) (
        const basic_string < _Elem, _Traits, _Alloc > & _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) const {

        const auto & _Coll_fac = :: std :: use_facet < :: std :: collate < _Elem >> ( * this );

        const _Elem * const _Left_data = _Left . data ( );
        const _Elem * const _Right_data = _Right . data ( );
        return _Coll_fac . compare ( _Left_data, _Left_data + _Left . size ( ), _Right_data, _Right_data + _Right . size ( ) ) < 0;
    }
#line 229
template < class _Facet >
    locale combine ( const locale & _Loc ) const {
        _Facet * _Facptr;

        try {
        _Facptr = const_cast < _Facet * > ( :: std :: addressof ( :: std :: use_facet < _Facet > ( _Loc ) ) );
        } catch ( ... ) {
        _Xruntime_error ( "locale::combine facet missing" );
        }

        _Locimp * _Newimp = _Locimp :: _New_Locimp ( * _Ptr );
        _Newimp -> _Addfac ( _Facptr, _Facet :: id . _Get_index ( ) );
        _Newimp -> _Catmask = none;
        _Newimp -> _Name = "*";
        return locale { _Secret_locale_construct_tag { }, _Newimp };
    }
#line 246
template < class _Facet >
    locale ( const locale & _Loc, const _Facet * _Facptr ) : _Ptr ( _Locimp :: _New_Locimp ( * _Loc . _Ptr ) ) {
        if ( _Facptr ) {
            _Ptr -> _Addfac ( const_cast < _Facet * > ( _Facptr ), _Facet :: id . _Get_index ( ) );
            _Ptr -> _Catmask = none;
            _Ptr -> _Name = "*";
        }
    }
#line 255
#pragma warning(push)
#pragma warning(disable : 26495)
#line 265
locale(_Uninitialized) { } 
#pragma warning(pop)
#line 268
locale(const locale &_Right) noexcept : _Ptr(_Right._Ptr) { 
#line 269
(_Ptr)->_Incref(); 
#line 270
} 
#line 272
locale() noexcept : _Ptr(_Init(true)) { } 
#line 275
locale(const locale &_Loc, const locale &_Other, category _Cat) : _Ptr(_Locimp::_New_Locimp(*(_Loc._Ptr))) { 
#line 277
if (_Cat != none) { 
#line 278
; 
#line 279
_Facet_guard _Guard{_Ptr}; 
#line 280
{ _Locinfo _Lobj; 
#line 281
_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, &_Other); 
#line 282
_Lobj._Addcats((_Loc._Ptr)->_Catmask, (_Loc.name()).c_str()); 
#line 283
_Lobj._Addcats((_Other._Ptr)->_Catmask, (_Other.name()).c_str()); 
#line 284
((_Ptr)->_Catmask) = (((_Loc._Ptr)->_Catmask) | ((_Other._Ptr)->_Catmask)); 
#line 285
(((_Ptr)->_Name) = (_Lobj._Getname())); 
#line 286
} 
#line 287
(_Guard._Target) = (nullptr); 
#line 288
}  
#line 289
} 
#line 292
private: void _Construct(const string &_Str, category _Cat) { 
#line 293
; 
#line 295
bool _Bad = false; 
#line 296
_Init(); 
#line 297
if (_Cat != none) { 
#line 298
_Facet_guard _Guard{_Ptr}; 
#line 299
{ _Locinfo _Lobj(_Cat, _Str.c_str()); 
#line 300
if (this->_Badname(_Lobj)) { 
#line 301
_Bad = true; 
#line 302
} else { 
#line 303
_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, nullptr); 
#line 304
((_Ptr)->_Catmask) = _Cat; 
#line 305
(((_Ptr)->_Name) = (_Str.c_str())); 
#line 306
}  
#line 307
} 
#line 308
(_Guard._Target) = (nullptr); 
#line 309
}  
#line 311
if (_Bad) { 
#line 312
delete (_Ptr)->_Decref(); 
#line 313
_Xruntime_error("bad locale name"); 
#line 314
}  
#line 315
} 
#line 318
public: explicit locale(const char *_Locname, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) { 
#line 322
if (_Locname) { 
#line 323
this->_Construct(_Locname, _Cat); 
#line 324
return; 
#line 325
}  
#line 327
_Xruntime_error("bad locale name"); 
#line 328
} 
#line 330
locale(const locale &_Loc, const char *_Locname, category _Cat) : _Ptr(_Locimp::_New_Locimp(*(_Loc._Ptr))) { 
#line 334
if (_Locname) { 
#line 335
this->_Construct(_Locname, _Cat); 
#line 336
return; 
#line 337
}  
#line 339
_Xruntime_error("bad locale name"); 
#line 340
} 
#line 342
explicit locale(const string &_Str, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) { 
#line 344
this->_Construct(_Str, _Cat); 
#line 345
} 
#line 347
locale(const locale &_Loc, const string &_Str, category _Cat) : _Ptr(_Locimp::_New_Locimp(*(_Loc._Ptr))) { 
#line 349
this->_Construct(_Str, _Cat); 
#line 350
} 
#line 353 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocale"
~locale() noexcept { 
#line 354
if (_Ptr) { 
#line 355
delete (_Ptr)->_Decref(); 
#line 356
}  
#line 357
} 
#line 359
const locale &operator=(const locale &_Right) noexcept { 
#line 360
if ((_Ptr) != (_Right._Ptr)) { 
#line 361
delete (_Ptr)->_Decref(); 
#line 362
(_Ptr) = (_Right._Ptr); 
#line 363
(_Ptr)->_Incref(); 
#line 364
}  
#line 365
return *this; 
#line 366
} 
#line 368
string name() const { 
#line 369
return ((_Ptr) ? ((_Ptr)->_Name).c_str() : string{}); 
#line 370
} 
#line 372
const char *_C_str() const noexcept { 
#line 373
return (_Ptr) ? ((_Ptr)->_Name).c_str() : (""); 
#line 374
} 
#line 376
const facet *_Getfacet(size_t _Id) const { 
#line 377
const facet *_Facptr = (_Id < ((_Ptr)->_Facetcount)) ? ((_Ptr)->_Facetvec)[_Id] : (nullptr); 
#line 378
if (_Facptr || (!((_Ptr)->_Xparent))) { 
#line 379
return _Facptr; 
#line 380
}  
#line 383
_Locimp *_Ptr0 = _Getgloballocale(); 
#line 384
if (_Id < (_Ptr0->_Facetcount)) { 
#line 385
return (_Ptr0->_Facetvec)[_Id]; 
#line 386
}  
#line 388
return nullptr; 
#line 389
} 
#line 391
[[nodiscard]] bool operator==(const locale &_Loc) const noexcept { 
#line 392
return ((_Ptr) == (_Loc._Ptr)) || ((::strcmp(this->_C_str(), "*") != 0) && (::strcmp(this->_C_str(), _Loc._C_str()) == 0)); 
#line 393
} 
#line 396
[[nodiscard]] bool operator!=(const locale &_Right) const noexcept { 
#line 397
return !((*this) == _Right); 
#line 398
} 
#line 401 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocale"
static const locale &__cdecl classic(); 
#line 403
static locale __cdecl global(const locale &); 
#line 406
[[deprecated("warning STL4048: locale::empty() is a non-Standard extension and will be removed in the future. A default-constructed locale can" " be used instead. You can define _SILENCE_LOCALE_EMPTY_DEPRECATION_WARNING or _SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS to suppre" "ss this warning.")]] static locale __cdecl empty(); 
#line 409
private: struct _Secret_locale_construct_tag { 
#line 410
explicit _Secret_locale_construct_tag() = default;
#line 411
}; 
#line 413
explicit locale(_Secret_locale_construct_tag, _Locimp *_Ptrimp) : _Ptr(_Ptrimp) { } 
#line 415
static _Locimp *__cdecl _Init(bool _Do_incref = false); 
#line 416
static _Locimp *__cdecl _Getgloballocale(); 
#line 417
static void __cdecl _Setgloballocale(void *); 
#line 419
bool _Badname(const _Locinfo &_Lobj) { 
#line 420
return ::strcmp(_Lobj._Getname(), "*") == 0; 
#line 421
} 
#line 423
_Locimp *_Ptr; 
#line 424
}; 
#line 426
template< class _Facet> 
#line 427
struct _Facetptr { 
#line 428
static const locale::facet *_Psave; 
#line 429
}; 
#line 431
template< class _Facet> const locale::facet *
#line 432
_Facetptr< _Facet> ::_Psave = (nullptr); 
#line 434
template < class _Facet >
const _Facet & __cdecl use_facet ( const locale & _Loc ) {
    { :: std :: _Lockit _Lock ( 0 );
    const locale :: facet * _Psave = _Facetptr < _Facet > :: _Psave;

    const size_t _Id = _Facet :: id . _Get_index ( );
    const locale :: facet * _Pf = _Loc . _Getfacet ( _Id );

    if ( ! _Pf ) {
        if ( _Psave ) {
            _Pf = _Psave;
        } else if ( _Facet :: _Getcat ( & _Psave, & _Loc ) == static_cast < size_t > ( - 1 ) ) {

            _Throw_bad_cast ( );



        } else {
            auto _Pfmod = const_cast < locale :: facet * > ( _Psave );
            unique_ptr < _Facet_base > _Psave_guard ( static_cast < _Facet_base * > ( _Pfmod ) );




            _Facet_Register ( _Pfmod );


            _Pfmod -> _Incref ( );
            _Facetptr < _Facet > :: _Psave = _Psave;
            _Pf = _Psave;

            ( void ) _Psave_guard . release ( );
        }
    }

    return static_cast < const _Facet & > ( * _Pf );
    }
}
#line 473 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocale"
template < class _Elem >
char __cdecl _Maklocbyte ( _Elem _Char, const _Locinfo :: _Cvtvec & ) {

    return static_cast < char > ( static_cast < unsigned char > ( _Char ) );
}
#line 480
template<> inline char __cdecl _Maklocbyte(__wchar_t _Char, const _Locinfo::_Cvtvec &_Cvt) { 
#line 482
char _Byte = '\000'; 
#line 483
mbstate_t _Mbst1 = {}; 
#line 484
_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt); 
#line 485
return _Byte; 
#line 486
} 
#line 490
template<> inline char __cdecl _Maklocbyte(unsigned short _Char, const _Locinfo::_Cvtvec &_Cvt) { 
#line 492
char _Byte = '\000'; 
#line 493
mbstate_t _Mbst1 = {}; 
#line 494
_Wcrtomb(&_Byte, static_cast< __wchar_t>(_Char), &_Mbst1, &_Cvt); 
#line 495
return _Byte; 
#line 496
} 
#line 499 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocale"
template < class _Elem >
_Elem __cdecl _Maklocchr ( char _Byte, _Elem *, const _Locinfo :: _Cvtvec & ) {

    return static_cast < _Elem > ( static_cast < unsigned char > ( _Byte ) );
}
#line 506
template<> inline __wchar_t __cdecl _Maklocchr(char _Byte, __wchar_t *, const _Locinfo::_Cvtvec &_Cvt) { 
#line 508
__wchar_t _Wc = L'\x0'; 
#line 509
mbstate_t _Mbst1 = {}; 
#line 510
_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt); 
#line 511
return _Wc; 
#line 512
} 
#line 516
template<> inline unsigned short __cdecl _Maklocchr(char _Byte, unsigned short *, const _Locinfo::_Cvtvec &_Cvt) { 
#line 518
unsigned short _Wc = (0); 
#line 519
mbstate_t _Mbst1 = {}; 
#line 520
_Mbrtowc(reinterpret_cast< __wchar_t *>(&_Wc), &_Byte, 1, &_Mbst1, &_Cvt); 
#line 521
return _Wc; 
#line 522
} 
#line 525 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocale"
template < class _Elem >
_Elem * __cdecl _Maklocstr ( const char * _Ptr, _Elem *, const _Locinfo :: _Cvtvec & ) {

    size_t _Count = :: strlen ( _Ptr ) + 1;

    _Elem * _Ptrdest = static_cast < _Elem * > ( calloc ( _Count, sizeof ( _Elem ) ) );

    if ( ! _Ptrdest ) {
        _Xbad_alloc ( );
    }

    for ( _Elem * _Ptrnext = _Ptrdest; 0 < _Count; -- _Count, ++ _Ptrnext, ++ _Ptr ) {
        * _Ptrnext = static_cast < _Elem > ( static_cast < unsigned char > ( * _Ptr ) );
    }

    return _Ptrdest;
}
#line 544
template<> inline __wchar_t *__cdecl _Maklocstr(const char *_Ptr, __wchar_t *, const _Locinfo::_Cvtvec &_Cvt) { 
#line 546
size_t _Count; 
#line 547
size_t _Count1; 
#line 548
size_t _Wchars; 
#line 549
const char *_Ptr1; 
#line 550
int _Bytes; 
#line 551
__wchar_t _Wc; 
#line 552
mbstate_t _Mbst1 = {}; 
#line 554
_Count1 = (::strlen(_Ptr) + (1)); 
#line 555
for (((_Count = _Count1), (_Wchars = (0))), (_Ptr1 = _Ptr); (0) < _Count; ((_Count -= _Bytes), (_Ptr1 += _Bytes)), (++_Wchars)) { 
#line 556
if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) { 
#line 557
break; 
#line 558
}  
#line 559
}  
#line 561
++_Wchars; 
#line 563
__wchar_t *_Ptrdest = static_cast< __wchar_t *>(calloc(_Wchars, sizeof(__wchar_t))); 
#line 565
if (!_Ptrdest) { 
#line 566
_Xbad_alloc(); 
#line 567
}  
#line 569
__wchar_t *_Ptrnext = _Ptrdest; 
#line 570
mbstate_t _Mbst2 = {}; 
#line 572
for (; (0) < _Wchars; (((_Count -= _Bytes), (_Ptr += _Bytes)), (--_Wchars)), (++_Ptrnext)) { 
#line 573
if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) { 
#line 574
break; 
#line 575
}  
#line 576
}  
#line 578
(*_Ptrnext) = L'\x0'; 
#line 580
return _Ptrdest; 
#line 581
} 
#line 585
template<> inline unsigned short *__cdecl _Maklocstr(const char *_Ptr, unsigned short *, const _Locinfo::_Cvtvec &_Cvt) { 
#line 587
size_t _Count; 
#line 588
size_t _Count1; 
#line 589
size_t _Wchars; 
#line 590
const char *_Ptr1; 
#line 591
int _Bytes; 
#line 592
unsigned short _Wc; 
#line 593
mbstate_t _Mbst1 = {}; 
#line 595
_Count1 = (::strlen(_Ptr) + (1)); 
#line 596
for (((_Count = _Count1), (_Wchars = (0))), (_Ptr1 = _Ptr); (0) < _Count; ((_Count -= _Bytes), (_Ptr1 += _Bytes)), (++_Wchars)) { 
#line 597
if ((_Bytes = _Mbrtowc(reinterpret_cast< __wchar_t *>(&_Wc), _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) { 
#line 598
break; 
#line 599
}  
#line 600
}  
#line 602
++_Wchars; 
#line 604
__wchar_t *_Ptrdest = static_cast< __wchar_t *>(calloc(_Wchars, sizeof(__wchar_t))); 
#line 606
if (!_Ptrdest) { 
#line 607
_Xbad_alloc(); 
#line 608
}  
#line 610
__wchar_t *_Ptrnext = _Ptrdest; 
#line 611
mbstate_t _Mbst2 = {}; 
#line 612
for (; (0) < _Wchars; (((_Count -= _Bytes), (_Ptr += _Bytes)), (--_Wchars)), (++_Ptrnext)) { 
#line 613
if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) { 
#line 614
break; 
#line 615
}  
#line 616
}  
#line 618
(*_Ptrnext) = L'\x0'; 
#line 619
return reinterpret_cast< unsigned short *>(_Ptrdest); 
#line 620
} 
#line 623 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocale"
class codecvt_base : public locale::facet { 
#line 627
public: enum { 
#line 628
ok, 
#line 629
partial, 
#line 630
error, 
#line 631
noconv
#line 632
}; 
#line 633
using result = int; 
#line 635
codecvt_base(size_t _Refs = 0) noexcept : locale::facet(_Refs) 
#line 636
{ } 
#line 638
bool always_noconv() const noexcept { 
#line 640
return this->do_always_noconv(); 
#line 641
} 
#line 643
int max_length() const noexcept { 
#line 645
return this->do_max_length(); 
#line 646
} 
#line 648
int encoding() const noexcept { 
#line 649
return this->do_encoding(); 
#line 650
} 
#line 652
virtual ~codecvt_base() noexcept { } 
#line 655
protected: virtual bool do_always_noconv() const noexcept { 
#line 657
return false; 
#line 658
} 
#line 660
virtual int do_max_length() const noexcept { 
#line 662
return 1; 
#line 663
} 
#line 665
virtual int do_encoding() const noexcept { 
#line 666
return 1; 
#line 667
} 
#line 668
}; 
#line 670
template< class _Ty> constexpr bool 
#line 671
_Is_one_byte_char_like_v = _Is_any_of_v< remove_cv_t< _Ty> , signed char, unsigned char, char> ; 
#line 680
template< class _Elem, class _Byte> constexpr bool 
#line 681
_Is_codecvt_do_always_noconv_v = is_same_v< _Byte, _Elem>  || (_Is_one_byte_char_like_v< _Byte>  && _Is_one_byte_char_like_v< _Elem> ); 
#line 684
template < class _Elem, class _Byte, class _Statype >
class codecvt : public codecvt_base {
public :








    static_assert ( ! 0 || is_same_v < codecvt, codecvt < char, char, mbstate_t >>,
        "Unsupported facet specialization; see N4950 [locale.category]. Either use a Standard specialization or define _ENFORCE_FACET_SPE" "CIALIZATIONS=0 to suppress this error." );

    using intern_type = _Elem;
    using extern_type = _Byte;
    using state_type = _Statype;

    result in ( _Statype & _State, const _Byte * _First1, const _Byte * _Last1, const _Byte * & _Mid1,
        _Elem * _First2, _Elem * _Last2, _Elem * & _Mid2 ) const {
        return do_in ( _State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2 );
    }

    result out ( _Statype & _State, const _Elem * _First1, const _Elem * _Last1, const _Elem * & _Mid1,
        _Byte * _First2, _Byte * _Last2, _Byte * & _Mid2 ) const {
        return do_out ( _State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2 );
    }

    result unshift ( _Statype & _State, _Byte * _First2, _Byte * _Last2, _Byte * & _Mid2 ) const {

        return do_unshift ( _State, _First2, _Last2, _Mid2 );
    }

    int length ( _Statype & _State, const _Byte * _First1, const _Byte * _Last1, size_t _Count ) const {


        return do_length ( _State, _First1, _Last1, _Count );
    }

     static locale :: id id;

    explicit codecvt ( size_t _Refs = 0 ) : codecvt_base ( _Refs ) {
        _Init ( _Locinfo ( ) );
    }

    explicit codecvt ( const _Locinfo & _Lobj, size_t _Refs = 0 ) : codecvt_base ( _Refs ) {
        _Init ( _Lobj );
    }

    static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = nullptr, const locale * _Ploc = nullptr ) {

        if ( _Ppf && ! * _Ppf ) {
            * _Ppf = new codecvt ( _Locinfo ( _Ploc -> _C_str ( ) ) );
        }

        return 2;
    }

protected :
     ~ codecvt ( ) noexcept override { }

    void _Init ( const _Locinfo & ) { }

    bool do_always_noconv ( ) const noexcept override {

        return _Is_codecvt_do_always_noconv_v < _Elem, _Byte >;
    }

    virtual result do_in ( _Statype &, const _Byte * _First1, const _Byte * _Last1, const _Byte * & _Mid1,
        _Elem * _First2, _Elem * _Last2, _Elem * & _Mid2 ) const {
        _Mid1 = _First1;
        _Mid2 = _First2;
        if constexpr ( _Is_codecvt_do_always_noconv_v < _Elem, _Byte > ) {
            return noconv;
        } else {

            for (; _Mid1 != _Last1; ++ _Mid1, ++ _Mid2 ) {
                if ( _Mid2 == _Last2 ) {
                    return partial;
                }
                * _Mid2 = static_cast < _Elem > ( * _Mid1 );
            }

            return ok;
        }
    }

    virtual result do_out ( _Statype &, const _Elem * _First1, const _Elem * _Last1, const _Elem * & _Mid1,
        _Byte * _First2, _Byte * _Last2, _Byte * & _Mid2 ) const {
        _Mid1 = _First1;
        _Mid2 = _First2;
        if constexpr ( _Is_codecvt_do_always_noconv_v < _Elem, _Byte > ) {
            return noconv;
        } else {

            for (; _Mid1 != _Last1; ++ _Mid1, ++ _Mid2 ) {
                if ( _Mid2 == _Last2 ) {
                    return partial;
                }
                * _Mid2 = static_cast < _Byte > ( * _Mid1 );
            }

            return ok;
        }
    }

    virtual result do_unshift ( _Statype &, _Byte * _First2, _Byte *, _Byte * & _Mid2 ) const {

        _Mid2 = _First2;
        return noconv;
    }

    virtual int do_length (
        _Statype &, const _Byte * _First1, const _Byte * _Last1, size_t _Count ) const {



        const auto _Dist = static_cast < size_t > ( ( :: std :: min ) ( _Last1 - _First1, ptrdiff_t { 2147483647 } ) );
        return static_cast < int > ( ( :: std :: min ) ( _Count, _Dist ) );
    }
};
#line 811
template< class _Elem, class _Byte, class _Statype> locale::id 
#line 812
codecvt< _Elem, _Byte, _Statype> ::id; 
#line 818
template < class _CvtTy, class _Byte, class _Statype >
[ [ nodiscard ] ] int _Codecvt_do_length (
    const _CvtTy & _Cvt, _Statype & _State, const _Byte * _First1, const _Byte * _Last1, size_t _Count ) {



    __pragma(warning(push))                            __pragma(warning(disable : 4996))
    using _Elem = typename _CvtTy :: intern_type;
    __pragma(warning(pop))

    _Adl_verify_range ( _First1, _Last1 );
    const auto _Old_first1 = _First1;

    while ( _Count > 0 && _First1 != _Last1 ) {
        const _Byte * _Mid1;
        _Elem * _Mid2;
        _Elem _Ch;



        __pragma(warning(push))                                __pragma(warning(disable : 4996))
        const auto _Result = _Cvt . _CvtTy :: do_in ( _State, _First1, _Last1, _Mid1, & _Ch, & _Ch + 1, _Mid2 );
        __pragma(warning(pop))

        if ( _Result != codecvt_base :: ok ) {
            if ( _Result == codecvt_base :: noconv ) {
                _First1 += ( :: std :: min ) ( static_cast < size_t > ( _Last1 - _First1 ), _Count );
            }

            break;
        }

        if ( _Mid2 == & _Ch + 1 ) {
            -- _Count;
        }

        _First1 = _Mid1;
    }

    return static_cast < int > ( ( :: std :: min ) ( _First1 - _Old_first1, ptrdiff_t { 2147483647 } ) );
}
#line 860
enum _Codecvt_mode { _Consume_header = 4, _Generate_header = 2}; 
#line 864
template<> class codecvt< char16_t, char, _Mbstatet>  : public codecvt_base { 
#line 867
public: using intern_type = char16_t; 
#line 868
using extern_type = char; 
#line 869
using state_type = mbstate_t; 
#line 871
result in(mbstate_t &_State, const char *_First1, const char *_Last1, const char *&_Mid1, char16_t *
#line 872
_First2, char16_t *_Last2, char16_t *&_Mid2) const { 
#line 874
return this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 875
} 
#line 877
result out(mbstate_t &_State, const char16_t *_First1, const char16_t *_Last1, const char16_t *&
#line 878
_Mid1, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 880
return this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 881
} 
#line 883
result unshift(mbstate_t &_State, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 885
return this->do_unshift(_State, _First2, _Last2, _Mid2); 
#line 886
} 
#line 888
int length(mbstate_t &_State, const char *_First1, const char *_Last1, size_t _Count) const { 
#line 891
return this->do_length(_State, _First1, _Last1, _Count); 
#line 892
} 
#line 894
static locale::id id; 
#line 896
explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs), _Maxcode((1114111)), _Mode(_Consume_header) 
#line 897
{ 
#line 898
{ _Locinfo _Lobj; 
#line 899
this->_Init(_Lobj); 
#line 900
} 
#line 901
} 
#line 903
explicit codecvt(const _Locinfo &_Lobj, size_t _Refs = 0) : codecvt_base(_Refs), _Maxcode((1114111)), _Mode(_Consume_header) 
#line 904
{ 
#line 905
this->_Init(_Lobj); 
#line 906
} 
#line 908
codecvt(const _Locinfo &
#line 909
_Lobj, unsigned long _Maxcode_arg, _Codecvt_mode _Mode_arg, size_t _Refs = 0) : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg) 
#line 910
{ 
#line 911
this->_Init(_Lobj); 
#line 912
} 
#line 914
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *_Ploc = 0) { 
#line 916
if (_Ppf && (!(*_Ppf))) { 
#line 917
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 918
(*_Ppf) = (new std::codecvt< char16_t, char, _Mbstatet> (((_Locinfo)(_Ploc->_C_str())))); 
#line 919
__pragma( warning(pop)) 
#line 920
}  
#line 922
return 2; 
#line 923
} 
#line 926
protected: virtual ~codecvt() noexcept override { } 
#line 928
void _Init(const _Locinfo &) { } 
#line 930
virtual result do_in(mbstate_t &_State, const char *_First1, const char *_Last1, const char *&
#line 931
_Mid1, char16_t *_First2, char16_t *_Last2, char16_t *&_Mid2) const { 
#line 933
unsigned short *_Pstate = reinterpret_cast< unsigned short *>(&_State); 
#line 934
_Mid1 = _First1; 
#line 935
_Mid2 = _First2; 
#line 937
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 938
unsigned char _By = static_cast< unsigned char>(*_Mid1); 
#line 939
unsigned long _Ch; 
#line 940
int _Nextra; 
#line 941
int _Nskip; 
#line 943
if ((*_Pstate) > 1) { 
#line 944
if ((_By < 128) || (192 <= _By)) { 
#line 945
return codecvt< char16_t, char, _Mbstatet> ::error; 
#line 946
}  
#line 949
++_Mid1; 
#line 950
(*(_Mid2++)) = (static_cast< char16_t>((*_Pstate) | (_By & 63))); 
#line 951
(*_Pstate) = (1); 
#line 952
continue; 
#line 953
}  
#line 955
if (_By < 128U) { 
#line 956
_Ch = _By; 
#line 957
_Nextra = 0; 
#line 958
} else { if (_By < 192U) { 
#line 959
++_Mid1; 
#line 960
return codecvt< char16_t, char, _Mbstatet> ::error; 
#line 961
} else { if (_By < 224U) { 
#line 962
_Ch = (static_cast< unsigned long>(_By & 31)); 
#line 963
_Nextra = 1; 
#line 964
} else { if (_By < 240U) { 
#line 965
_Ch = (static_cast< unsigned long>(_By & 15)); 
#line 966
_Nextra = 2; 
#line 967
} else { if (_By < 248U) { 
#line 968
_Ch = (static_cast< unsigned long>(_By & 7)); 
#line 969
_Nextra = 3; 
#line 970
} else { 
#line 971
_Ch = (static_cast< unsigned long>(_By & 3)); 
#line 972
_Nextra = ((_By < 252) ? 4 : 5); 
#line 973
}  }  }  }  }  
#line 975
_Nskip = ((_Nextra < 3) ? 0 : 1); 
#line 976
_First1 = _Mid1; 
#line 978
if (_Nextra == 0) { 
#line 979
++_Mid1; 
#line 980
} else { if ((_Last1 - _Mid1) < ((_Nextra + 1) - _Nskip)) { 
#line 981
break; 
#line 982
} else { 
#line 983
for (++_Mid1; _Nskip < _Nextra; (--_Nextra), (++_Mid1)) { 
#line 984
if (((_By = (static_cast< unsigned char>(*_Mid1))) < 128U) || (192U <= _By)) { 
#line 985
return codecvt< char16_t, char, _Mbstatet> ::error; 
#line 986
} else { 
#line 987
_Ch = ((_Ch << 6) | (_By & 63)); 
#line 988
}  
#line 989
}  
#line 990
}  }  
#line 992
if (0 < _Nskip) { 
#line 993
_Ch <<= 6; 
#line 994
}  
#line 996
if ((((_Maxcode) < (1114111U)) ? _Maxcode : (1114111U)) < _Ch) { 
#line 997
return codecvt< char16_t, char, _Mbstatet> ::error; 
#line 998
}  
#line 1000
if ((65535U) < _Ch) { 
#line 1001
unsigned short _Ch0 = static_cast< unsigned short>((55296) | ((_Ch >> 10) - (64))); 
#line 1003
(*(_Mid2++)) = (static_cast< char16_t>(_Ch0)); 
#line 1004
(*_Pstate) = (static_cast< unsigned short>((56320) | (_Ch & (1023)))); 
#line 1005
continue; 
#line 1006
}  
#line 1008
if (_Nskip != 0) { 
#line 1009
if (_Mid1 == _Last1) { 
#line 1010
_Mid1 = _First1; 
#line 1011
break; 
#line 1012
}  
#line 1014
if (((_By = (static_cast< unsigned char>(*(_Mid1++)))) < 128U) || (192U <= _By)) { 
#line 1015
return codecvt< char16_t, char, _Mbstatet> ::error; 
#line 1016
}  
#line 1018
_Ch |= (_By & 63); 
#line 1019
}  
#line 1021
if ((*_Pstate) == 0U) { 
#line 1022
(*_Pstate) = (1); 
#line 1024
if ((((_Mode) & (_Consume_header)) != 0) && (_Ch == (65279U))) { 
#line 1025
const result _Ans = this->do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1027
if (_Ans == (codecvt< char16_t, char, _Mbstatet> ::partial)) { 
#line 1028
(*_Pstate) = (0); 
#line 1029
_Mid1 = _First1; 
#line 1030
}  
#line 1032
return _Ans; 
#line 1033
}  
#line 1034
}  
#line 1036
(*(_Mid2++)) = (static_cast< char16_t>(_Ch)); 
#line 1037
}   
#line 1039
return (_First1 == _Mid1) ? codecvt< char16_t, char, _Mbstatet> ::partial : codecvt< char16_t, char, _Mbstatet> ::ok; 
#line 1040
} 
#line 1042
virtual result do_out(mbstate_t &_State, const char16_t *_First1, const char16_t *_Last1, const char16_t *&
#line 1043
_Mid1, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 1045
unsigned short *_Pstate = reinterpret_cast< unsigned short *>(&_State); 
#line 1046
_Mid1 = _First1; 
#line 1047
_Mid2 = _First2; 
#line 1049
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 1050
unsigned long _Ch; 
#line 1051
const unsigned short _Ch1 = static_cast< unsigned short>(*_Mid1); 
#line 1052
bool _Save = false; 
#line 1054
if (1 < (*_Pstate)) { 
#line 1055
if ((_Ch1 < 56320U) || (57344U <= _Ch1)) { 
#line 1056
return codecvt< char16_t, char, _Mbstatet> ::error; 
#line 1057
}  
#line 1059
_Ch = (static_cast< unsigned long>(((*_Pstate) << 10) | (_Ch1 - 56320))); 
#line 1060
} else { if ((55296U <= _Ch1) && (_Ch1 < 56320U)) { 
#line 1061
_Ch = (static_cast< unsigned long>(((_Ch1 - 55296) + 64) << 10)); 
#line 1062
_Save = true; 
#line 1063
} else { 
#line 1064
_Ch = _Ch1; 
#line 1065
}  }  
#line 1067
char _By; 
#line 1068
int _Nextra; 
#line 1070
if (_Ch < (128U)) { 
#line 1071
_By = (static_cast< char>(_Ch)); 
#line 1072
_Nextra = 0; 
#line 1073
} else { if (_Ch < (2048U)) { 
#line 1074
_By = (static_cast< char>((192) | (_Ch >> 6))); 
#line 1075
_Nextra = 1; 
#line 1076
} else { if (_Ch < (65536U)) { 
#line 1077
_By = (static_cast< char>((224) | (_Ch >> 12))); 
#line 1078
_Nextra = 2; 
#line 1079
} else { 
#line 1080
_By = (static_cast< char>((240) | (_Ch >> 18))); 
#line 1081
_Nextra = 3; 
#line 1082
}  }  }  
#line 1084
int _Nput = (_Nextra < 3) ? _Nextra + 1 : (_Save ? 1 : 3); 
#line 1086
if ((_Last2 - _Mid2) < _Nput) { 
#line 1087
break; 
#line 1088
}  
#line 1090
if (((*_Pstate) == 0U) && (((_Mode) & (_Generate_header)) != 0)) { 
#line 1091
if ((_Last2 - _Mid2) < (3 + _Nput)) { 
#line 1092
break; 
#line 1093
}  
#line 1096
(*(_Mid2++)) = '\357'; 
#line 1097
(*(_Mid2++)) = '\273'; 
#line 1098
(*(_Mid2++)) = '\277'; 
#line 1099
}  
#line 1101
++_Mid1; 
#line 1102
if (_Save || (_Nextra < 3)) { 
#line 1103
(*(_Mid2++)) = _By; 
#line 1104
--_Nput; 
#line 1105
}  
#line 1107
for (; 0 < _Nput; --_Nput) { 
#line 1108
(*(_Mid2++)) = (static_cast< char>(((_Ch >> (6 * (--_Nextra))) & (63)) | (128))); 
#line 1109
}  
#line 1111
(*_Pstate) = (static_cast< unsigned short>(_Save ? _Ch >> 10 : (1))); 
#line 1112
}  
#line 1114
return (_First1 == _Mid1) ? codecvt< char16_t, char, _Mbstatet> ::partial : codecvt< char16_t, char, _Mbstatet> ::ok; 
#line 1115
} 
#line 1117
virtual result do_unshift(mbstate_t &_State, char *_First2, char *, char *&_Mid2) const { 
#line 1119
unsigned short *_Pstate = reinterpret_cast< unsigned short *>(&_State); 
#line 1120
_Mid2 = _First2; 
#line 1122
return (1U < (*_Pstate)) ? codecvt< char16_t, char, _Mbstatet> ::error : codecvt< char16_t, char, _Mbstatet> ::ok; 
#line 1123
} 
#line 1125
friend int _Codecvt_do_length<> (const std::codecvt< char16_t, char, _Mbstatet>  &, mbstate_t &, const char *, const char *, size_t); 
#line 1127
virtual int do_length(mbstate_t &
#line 1128
_State, const char *_First1, const char *_Last1, size_t _Count) const { 
#line 1129
return _Codecvt_do_length(*this, _State, _First1, _Last1, _Count); 
#line 1130
} 
#line 1132
virtual bool do_always_noconv() const noexcept override { 
#line 1134
return false; 
#line 1135
} 
#line 1137
virtual int do_max_length() const noexcept override { 
#line 1140
if (((_Mode) & (_Consume_header)) != 0) { 
#line 1141
return 9; 
#line 1142
}  
#line 1144
if (((_Mode) & (_Generate_header)) != 0) { 
#line 1145
return 7; 
#line 1146
}  
#line 1148
return 6; 
#line 1149
} 
#line 1151
virtual int do_encoding() const noexcept override { 
#line 1152
return 0; 
#line 1153
} 
#line 1156
private: unsigned long _Maxcode; 
#line 1157
_Codecvt_mode _Mode; 
#line 1158
}; 
#line 1162
template<> class codecvt< char32_t, char, _Mbstatet>  : public codecvt_base { 
#line 1165
public: using intern_type = char32_t; 
#line 1166
using extern_type = char; 
#line 1167
using state_type = mbstate_t; 
#line 1169
result in(mbstate_t &_State, const char *_First1, const char *_Last1, const char *&_Mid1, char32_t *
#line 1170
_First2, char32_t *_Last2, char32_t *&_Mid2) const { 
#line 1172
return this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1173
} 
#line 1175
result out(mbstate_t &_State, const char32_t *_First1, const char32_t *_Last1, const char32_t *&
#line 1176
_Mid1, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 1178
return this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1179
} 
#line 1181
result unshift(mbstate_t &_State, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 1183
return this->do_unshift(_State, _First2, _Last2, _Mid2); 
#line 1184
} 
#line 1186
int length(mbstate_t &_State, const char *_First1, const char *_Last1, size_t _Count) const { 
#line 1189
return this->do_length(_State, _First1, _Last1, _Count); 
#line 1190
} 
#line 1192
static locale::id id; 
#line 1194
explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs), _Maxcode((4294967295U)), _Mode(_Consume_header) 
#line 1195
{ 
#line 1196
{ _Locinfo _Lobj; 
#line 1197
this->_Init(_Lobj); 
#line 1198
} 
#line 1199
} 
#line 1201
explicit codecvt(const _Locinfo &_Lobj, size_t _Refs = 0) : codecvt_base(_Refs), _Maxcode((4294967295U)), _Mode(_Consume_header) 
#line 1202
{ 
#line 1203
this->_Init(_Lobj); 
#line 1204
} 
#line 1206
codecvt(const _Locinfo &
#line 1207
_Lobj, unsigned long _Maxcode_arg, _Codecvt_mode _Mode_arg, size_t _Refs = 0) : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg) 
#line 1208
{ 
#line 1209
this->_Init(_Lobj); 
#line 1210
} 
#line 1212
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *_Ploc = 0) { 
#line 1214
if (_Ppf && (!(*_Ppf))) { 
#line 1215
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 1216
(*_Ppf) = (new std::codecvt< char32_t, char, _Mbstatet> (((_Locinfo)(_Ploc->_C_str())))); 
#line 1217
__pragma( warning(pop)) 
#line 1218
}  
#line 1220
return 2; 
#line 1221
} 
#line 1224
protected: virtual ~codecvt() noexcept override { } 
#line 1226
void _Init(const _Locinfo &) { } 
#line 1228
virtual result do_in(mbstate_t &_State, const char *_First1, const char *_Last1, const char *&
#line 1229
_Mid1, char32_t *_First2, char32_t *_Last2, char32_t *&_Mid2) const { 
#line 1231
char *_Pstate = reinterpret_cast< char *>(&_State); 
#line 1232
_Mid1 = _First1; 
#line 1233
_Mid2 = _First2; 
#line 1235
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 1236
unsigned char _By = static_cast< unsigned char>(*_Mid1); 
#line 1237
unsigned long _Ch; 
#line 1238
int _Nextra; 
#line 1240
if (_By < 128U) { 
#line 1241
_Ch = _By; 
#line 1242
_Nextra = 0; 
#line 1243
} else { if (_By < 192U) { 
#line 1244
++_Mid1; 
#line 1245
return codecvt< char32_t, char, _Mbstatet> ::error; 
#line 1246
} else { if (_By < 224U) { 
#line 1247
_Ch = (static_cast< unsigned long>(_By & 31)); 
#line 1248
_Nextra = 1; 
#line 1249
} else { if (_By < 240U) { 
#line 1250
_Ch = (static_cast< unsigned long>(_By & 15)); 
#line 1251
_Nextra = 2; 
#line 1252
} else { if (_By < 248U) { 
#line 1253
_Ch = (static_cast< unsigned long>(_By & 7)); 
#line 1254
_Nextra = 3; 
#line 1255
} else { 
#line 1256
_Ch = (static_cast< unsigned long>(_By & 3)); 
#line 1257
_Nextra = ((_By < 252) ? 4 : 5); 
#line 1258
}  }  }  }  }  
#line 1260
if (_Nextra == 0) { 
#line 1261
++_Mid1; 
#line 1262
} else { if ((_Last1 - _Mid1) < (_Nextra + 1)) { 
#line 1263
break; 
#line 1264
} else { 
#line 1265
for (++_Mid1; 0 < _Nextra; (--_Nextra), (++_Mid1)) { 
#line 1266
if (((_By = (static_cast< unsigned char>(*_Mid1))) < 128U) || (192U <= _By)) { 
#line 1267
return codecvt< char32_t, char, _Mbstatet> ::error; 
#line 1268
} else { 
#line 1269
_Ch = ((_Ch << 6) | (_By & 63)); 
#line 1270
}  
#line 1271
}  
#line 1272
}  }  
#line 1274
if ((*_Pstate) == 0) { 
#line 1275
(*_Pstate) = (1); 
#line 1277
if ((((_Mode) & (_Consume_header)) != 0) && (_Ch == (65279U))) { 
#line 1278
const result _Ans = this->do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1280
if (_Ans == (codecvt< char32_t, char, _Mbstatet> ::partial)) { 
#line 1281
(*_Pstate) = (0); 
#line 1282
_Mid1 = _First1; 
#line 1283
}  
#line 1284
return _Ans; 
#line 1285
}  
#line 1286
}  
#line 1288
if ((_Maxcode) < _Ch) { 
#line 1289
return codecvt< char32_t, char, _Mbstatet> ::error; 
#line 1290
}  
#line 1292
(*(_Mid2++)) = (static_cast< char32_t>(_Ch)); 
#line 1293
}  
#line 1295
return (_First1 == _Mid1) ? codecvt< char32_t, char, _Mbstatet> ::partial : codecvt< char32_t, char, _Mbstatet> ::ok; 
#line 1296
} 
#line 1298
virtual result do_out(mbstate_t &_State, const char32_t *_First1, const char32_t *_Last1, const char32_t *&
#line 1299
_Mid1, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 1301
char *_Pstate = reinterpret_cast< char *>(&_State); 
#line 1302
_Mid1 = _First1; 
#line 1303
_Mid2 = _First2; 
#line 1305
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 1306
char _By; 
#line 1307
int _Nextra; 
#line 1308
unsigned long _Ch = static_cast< unsigned long>(*_Mid1); 
#line 1310
if ((_Maxcode) < _Ch) { 
#line 1311
return codecvt< char32_t, char, _Mbstatet> ::error; 
#line 1312
}  
#line 1314
if (_Ch < (128U)) { 
#line 1315
_By = (static_cast< char>(_Ch)); 
#line 1316
_Nextra = 0; 
#line 1317
} else { if (_Ch < (2048U)) { 
#line 1318
_By = (static_cast< char>((192) | (_Ch >> 6))); 
#line 1319
_Nextra = 1; 
#line 1320
} else { if (_Ch < (65536U)) { 
#line 1321
_By = (static_cast< char>((224) | (_Ch >> 12))); 
#line 1322
_Nextra = 2; 
#line 1323
} else { if (_Ch < (2097152U)) { 
#line 1324
_By = (static_cast< char>((240) | (_Ch >> 18))); 
#line 1325
_Nextra = 3; 
#line 1326
} else { if (_Ch < (67108864U)) { 
#line 1327
_By = (static_cast< char>((248) | (_Ch >> 24))); 
#line 1328
_Nextra = 4; 
#line 1329
} else { 
#line 1330
_By = (static_cast< char>((252) | ((_Ch >> 30) & (3)))); 
#line 1331
_Nextra = 5; 
#line 1332
}  }  }  }  }  
#line 1334
if ((*_Pstate) == 0) { 
#line 1335
(*_Pstate) = (1); 
#line 1336
if (((_Mode) & (_Generate_header)) != 0) { 
#line 1337
if ((_Last2 - _Mid2) < ((3 + 1) + _Nextra)) { 
#line 1338
return codecvt< char32_t, char, _Mbstatet> ::partial; 
#line 1339
}  
#line 1342
(*(_Mid2++)) = '\357'; 
#line 1343
(*(_Mid2++)) = '\273'; 
#line 1344
(*(_Mid2++)) = '\277'; 
#line 1345
}  
#line 1346
}  
#line 1348
if ((_Last2 - _Mid2) < (1 + _Nextra)) { 
#line 1349
break; 
#line 1350
}  
#line 1352
++_Mid1; 
#line 1353
for ((*(_Mid2++)) = _By; 0 < _Nextra;) { 
#line 1354
(*(_Mid2++)) = (static_cast< char>(((_Ch >> (6 * (--_Nextra))) & (63)) | (128))); 
#line 1355
}  
#line 1356
}  
#line 1357
return (_First1 == _Mid1) ? codecvt< char32_t, char, _Mbstatet> ::partial : codecvt< char32_t, char, _Mbstatet> ::ok; 
#line 1358
} 
#line 1360
virtual result do_unshift(mbstate_t &, char *_First2, char *, char *&_Mid2) const { 
#line 1362
_Mid2 = _First2; 
#line 1363
return codecvt< char32_t, char, _Mbstatet> ::noconv; 
#line 1364
} 
#line 1366
friend int _Codecvt_do_length<> (const std::codecvt< char32_t, char, _Mbstatet>  &, mbstate_t &, const char *, const char *, size_t); 
#line 1368
virtual int do_length(mbstate_t &
#line 1369
_State, const char *_First1, const char *_Last1, size_t _Count) const { 
#line 1370
return _Codecvt_do_length(*this, _State, _First1, _Last1, _Count); 
#line 1371
} 
#line 1373
virtual bool do_always_noconv() const noexcept override { 
#line 1375
return false; 
#line 1376
} 
#line 1378
virtual int do_max_length() const noexcept override { 
#line 1380
return (((_Mode) & ((_Consume_header) | (_Generate_header))) != 0) ? 9 : 6; 
#line 1381
} 
#line 1383
virtual int do_encoding() const noexcept override { 
#line 1385
return (((_Mode) & ((_Consume_header) | (_Generate_header))) != 0) ? -1 : 0; 
#line 1387
} 
#line 1390
private: unsigned long _Maxcode; 
#line 1391
_Codecvt_mode _Mode; 
#line 1392
}; 
#line 1939 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocale"
template<> class codecvt< __wchar_t, char, _Mbstatet>  : public codecvt_base { 
#line 1942
public: using intern_type = __wchar_t; 
#line 1943
using extern_type = char; 
#line 1944
using state_type = mbstate_t; 
#line 1946
result in(mbstate_t &_State, const char *_First1, const char *_Last1, const char *&_Mid1, __wchar_t *
#line 1947
_First2, __wchar_t *_Last2, __wchar_t *&_Mid2) const { 
#line 1949
return this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1950
} 
#line 1952
result out(mbstate_t &_State, const __wchar_t *_First1, const __wchar_t *_Last1, const __wchar_t *&
#line 1953
_Mid1, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 1955
return this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1956
} 
#line 1958
result unshift(mbstate_t &_State, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 1960
return this->do_unshift(_State, _First2, _Last2, _Mid2); 
#line 1961
} 
#line 1963
int length(mbstate_t &_State, const char *_First1, const char *_Last1, size_t _Count) const { 
#line 1966
return this->do_length(_State, _First1, _Last1, _Count); 
#line 1967
} 
#line 1969
static locale::id id; 
#line 1971
explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs) { 
#line 1972
{ _Locinfo _Lobj; 
#line 1973
this->_Init(_Lobj); 
#line 1974
} 
#line 1975
} 
#line 1977
explicit codecvt(const _Locinfo &_Lobj, size_t _Refs = 0) : codecvt_base(_Refs) { 
#line 1978
this->_Init(_Lobj); 
#line 1979
} 
#line 1981
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *_Ploc = 0) { 
#line 1983
if (_Ppf && (!(*_Ppf))) { 
#line 1984
(*_Ppf) = (new std::codecvt< __wchar_t, char, _Mbstatet> (((_Locinfo)(_Ploc->_C_str())))); 
#line 1985
}  
#line 1987
return 2; 
#line 1988
} 
#line 1991
protected: virtual ~codecvt() noexcept override { } 
#line 1993
void _Init(const _Locinfo &_Lobj) { 
#line 1994
(_Cvt) = _Lobj._Getcvt(); 
#line 1995
} 
#line 1997
virtual result do_in(mbstate_t &, const char *_First1, const char *_Last1, const char *&_Mid1, __wchar_t *
#line 1998
_First2, __wchar_t *_Last2, __wchar_t *&_Mid2) const { 
#line 2000
mbstate_t _Mystate{}; 
#line 2001
_Adl_verify_range(_First1, _Last1); 
#line 2002
_Adl_verify_range(_First2, _Last2); 
#line 2003
_Mid1 = _First1; 
#line 2004
_Mid2 = _First2; 
#line 2005
for (; ;) { 
#line 2006
if (_Mid1 == _Last1) { 
#line 2007
return ok; 
#line 2008
}  
#line 2010
if (_Mid2 == _Last2) { 
#line 2011
return partial; 
#line 2012
}  
#line 2014
int _Bytes = _Mbrtowc(_Mid2, _Mid1, static_cast< size_t>(_Last1 - _Mid1), &_Mystate, &(_Cvt)); 
#line 2015
switch (_Bytes) { 
#line 2016
case -2:  
#line 2017
return partial; 
#line 2019
case -1:  
#line 2020
return error; 
#line 2022
case 0:  
#line 2023
_Bytes = 1; 
#line 2024
; 
#line 2026
default:  
#line 2027
_Mid1 += _Bytes; 
#line 2028
++_Mid2; 
#line 2029
break; 
#line 2030
}  
#line 2031
}  
#line 2032
} 
#line 2034
virtual result do_out(mbstate_t &_State, const __wchar_t *_First1, const __wchar_t *_Last1, const __wchar_t *&
#line 2035
_Mid1, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 2037
_Adl_verify_range(_First1, _Last1); 
#line 2038
_Adl_verify_range(_First2, _Last2); 
#line 2039
_Mid1 = _First1; 
#line 2040
_Mid2 = _First2; 
#line 2041
int _Bytes; 
#line 2043
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 2044
if ((5) <= (_Last2 - _Mid2)) { 
#line 2045
if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &(_Cvt))) < 0) { 
#line 2046
return error; 
#line 2047
} else { 
#line 2048
++_Mid1; 
#line 2049
_Mid2 += _Bytes; 
#line 2050
}  
#line 2051
} else { 
#line 2052
char _Buf[5]; 
#line 2053
mbstate_t _Stsave = _State; 
#line 2055
if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &(_Cvt))) < 0) { 
#line 2056
return error; 
#line 2057
} else { if ((_Last2 - _Mid2) < _Bytes) { 
#line 2058
_State = _Stsave; 
#line 2059
break; 
#line 2060
} else { 
#line 2061
::memcpy(_Mid2, _Buf, static_cast< size_t>(_Bytes)); 
#line 2062
++_Mid1; 
#line 2063
_Mid2 += _Bytes; 
#line 2064
}  }  
#line 2065
}  
#line 2066
}  
#line 2068
return (_Mid1 == _Last1) ? ok : partial; 
#line 2069
} 
#line 2071
virtual result do_unshift(mbstate_t &_State, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 2073
_Adl_verify_range(_First2, _Last2); 
#line 2074
_Mid2 = _First2; 
#line 2075
result _Ans = (ok); 
#line 2076
int _Bytes; 
#line 2077
char _Buf[5]; 
#line 2078
mbstate_t _Stsave = _State; 
#line 2080
if ((_Bytes = _Wcrtomb(_Buf, L'\x0', &_State, &(_Cvt))) <= 0) { 
#line 2081
_Ans = (error); 
#line 2082
} else { if ((_Last2 - _Mid2) < (--_Bytes)) { 
#line 2083
_State = _Stsave; 
#line 2084
_Ans = (partial); 
#line 2085
} else { if (0 < _Bytes) { 
#line 2086
::memcpy(_Mid2, _Buf, static_cast< size_t>(_Bytes)); 
#line 2087
_Mid2 += _Bytes; 
#line 2088
}  }  }  
#line 2089
return _Ans; 
#line 2090
} 
#line 2092
virtual int do_length(mbstate_t &
#line 2093
_State, const char *_First1, const char *_Last1, size_t _Count) const { 
#line 2096
_Adl_verify_range(_First1, _Last1); 
#line 2097
const auto _Old_first1 = _First1; 
#line 2099
for (; (_Count > (0U)) && (_First1 != _Last1); --_Count) { 
#line 2100
__wchar_t _Ch; 
#line 2101
int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast< size_t>(_Last1 - _First1), &_State, &(_Cvt)); 
#line 2102
if (_Bytes < 0) { 
#line 2103
break; 
#line 2104
}  
#line 2106
if (_Bytes == 0) { 
#line 2107
_Bytes = 1; 
#line 2108
}  
#line 2111
_First1 += _Bytes; 
#line 2112
}  
#line 2114
return static_cast< int>((::std::min)(_First1 - _Old_first1, (ptrdiff_t)2147483647)); 
#line 2115
} 
#line 2117
virtual bool do_always_noconv() const noexcept override { 
#line 2119
return false; 
#line 2120
} 
#line 2122
virtual int do_max_length() const noexcept override { 
#line 2124
return static_cast< int>((_Cvt)._Mbcurmax); 
#line 2125
} 
#line 2127
virtual int do_encoding() const noexcept override { 
#line 2129
return ((_Cvt)._Mbcurmax) == (1); 
#line 2130
} 
#line 2133
private: _Locinfo::_Cvtvec _Cvt; 
#line 2134
}; 
#line 2138
template<> class codecvt< unsigned short, char, _Mbstatet>  : public codecvt_base { 
#line 2141
public: using intern_type = unsigned short; 
#line 2142
using extern_type = char; 
#line 2143
using state_type = mbstate_t; 
#line 2145
result in(mbstate_t &_State, const char *_First1, const char *_Last1, const char *&_Mid1, unsigned short *
#line 2146
_First2, unsigned short *_Last2, unsigned short *&_Mid2) const { 
#line 2148
return this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 2149
} 
#line 2151
result out(mbstate_t &_State, const unsigned short *_First1, const unsigned short *_Last1, const unsigned short *&
#line 2152
_Mid1, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 2154
return this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 2155
} 
#line 2157
result unshift(mbstate_t &_State, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 2159
return this->do_unshift(_State, _First2, _Last2, _Mid2); 
#line 2160
} 
#line 2162
int length(mbstate_t &_State, const char *_First1, const char *_Last1, size_t _Count) const { 
#line 2165
return this->do_length(_State, _First1, _Last1, _Count); 
#line 2166
} 
#line 2168
static locale::id id; 
#line 2170
explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs) { 
#line 2171
{ _Locinfo _Lobj; 
#line 2172
this->_Init(_Lobj); 
#line 2173
} 
#line 2174
} 
#line 2176
explicit codecvt(const _Locinfo &_Lobj, size_t _Refs = 0) : codecvt_base(_Refs) { 
#line 2177
this->_Init(_Lobj); 
#line 2178
} 
#line 2180
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *_Ploc = 0) { 
#line 2182
if (_Ppf && (!(*_Ppf))) { 
#line 2183
(*_Ppf) = (new std::codecvt< unsigned short, char, _Mbstatet> (((_Locinfo)(_Ploc->_C_str())))); 
#line 2184
}  
#line 2186
return 2; 
#line 2187
} 
#line 2190
protected: virtual ~codecvt() noexcept override { } 
#line 2192
void _Init(const _Locinfo &_Lobj) { 
#line 2193
(_Cvt) = _Lobj._Getcvt(); 
#line 2194
} 
#line 2196
virtual result do_in(mbstate_t &, const char *_First1, const char *_Last1, const char *&_Mid1, unsigned short *
#line 2197
_First2, unsigned short *_Last2, unsigned short *&_Mid2) const { 
#line 2199
mbstate_t _Mystate{}; 
#line 2200
_Adl_verify_range(_First1, _Last1); 
#line 2201
_Adl_verify_range(_First2, _Last2); 
#line 2202
_Mid1 = _First1; 
#line 2203
_Mid2 = _First2; 
#line 2204
for (; ;) { 
#line 2205
if (_Mid1 == _Last1) { 
#line 2206
return ok; 
#line 2207
}  
#line 2209
if (_Mid2 == _Last2) { 
#line 2210
return partial; 
#line 2211
}  
#line 2213
int _Bytes = _Mbrtowc(reinterpret_cast< __wchar_t *>(_Mid2), _Mid1, static_cast< size_t>(_Last1 - _Mid1), &_Mystate, &(_Cvt)); 
#line 2215
switch (_Bytes) { 
#line 2216
case -2:  
#line 2217
return partial; 
#line 2219
case -1:  
#line 2220
return error; 
#line 2222
case 0:  
#line 2223
_Bytes = 1; 
#line 2224
; 
#line 2226
default:  
#line 2227
_Mid1 += _Bytes; 
#line 2228
++_Mid2; 
#line 2229
break; 
#line 2230
}  
#line 2231
}  
#line 2232
} 
#line 2234
virtual result do_out(mbstate_t &_State, const unsigned short *_First1, const unsigned short *
#line 2235
_Last1, const unsigned short *&_Mid1, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 2237
_Adl_verify_range(_First1, _Last1); 
#line 2238
_Adl_verify_range(_First2, _Last2); 
#line 2239
_Mid1 = _First1; 
#line 2240
_Mid2 = _First2; 
#line 2241
int _Bytes; 
#line 2243
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 2244
if ((5) <= (_Last2 - _Mid2)) { 
#line 2245
if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &(_Cvt))) < 0) { 
#line 2246
return error; 
#line 2247
} else { 
#line 2248
++_Mid1; 
#line 2249
_Mid2 += _Bytes; 
#line 2250
}  
#line 2251
} else { 
#line 2252
char _Buf[5]; 
#line 2253
mbstate_t _Stsave = _State; 
#line 2255
if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &(_Cvt))) < 0) { 
#line 2256
return error; 
#line 2257
} else { if ((_Last2 - _Mid2) < _Bytes) { 
#line 2258
_State = _Stsave; 
#line 2259
break; 
#line 2260
} else { 
#line 2261
::memcpy(_Mid2, _Buf, static_cast< size_t>(_Bytes)); 
#line 2262
++_Mid1; 
#line 2263
_Mid2 += _Bytes; 
#line 2264
}  }  
#line 2265
}  
#line 2266
}  
#line 2268
return (_Mid1 == _Last1) ? ok : partial; 
#line 2269
} 
#line 2271
virtual result do_unshift(mbstate_t &_State, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 2273
_Adl_verify_range(_First2, _Last2); 
#line 2274
_Mid2 = _First2; 
#line 2275
result _Ans = (ok); 
#line 2276
int _Bytes; 
#line 2277
char _Buf[5]; 
#line 2278
mbstate_t _Stsave = _State; 
#line 2280
if ((_Bytes = _Wcrtomb(_Buf, L'\x0', &_State, &(_Cvt))) <= 0) { 
#line 2281
_Ans = (error); 
#line 2282
} else { if ((_Last2 - _Mid2) < (--_Bytes)) { 
#line 2283
_State = _Stsave; 
#line 2284
_Ans = (partial); 
#line 2285
} else { if (0 < _Bytes) { 
#line 2286
::memcpy(_Mid2, _Buf, static_cast< size_t>(_Bytes)); 
#line 2287
_Mid2 += _Bytes; 
#line 2288
}  }  }  
#line 2290
return _Ans; 
#line 2291
} 
#line 2293
virtual int do_length(mbstate_t &
#line 2294
_State, const char *_First1, const char *_Last1, size_t _Count) const { 
#line 2297
_Adl_verify_range(_First1, _Last1); 
#line 2298
const auto _Old_first1 = _First1; 
#line 2300
for (; (_Count > (0U)) && (_First1 != _Last1); --_Count) { 
#line 2301
__wchar_t _Ch; 
#line 2302
int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast< size_t>(_Last1 - _First1), &_State, &(_Cvt)); 
#line 2303
if (_Bytes < 0) { 
#line 2304
break; 
#line 2305
}  
#line 2307
if (_Bytes == 0) { 
#line 2308
_Bytes = 1; 
#line 2309
}  
#line 2312
_First1 += _Bytes; 
#line 2313
}  
#line 2315
return static_cast< int>((::std::min)(_First1 - _Old_first1, (ptrdiff_t)2147483647)); 
#line 2316
} 
#line 2318
virtual bool do_always_noconv() const noexcept override { 
#line 2320
return false; 
#line 2321
} 
#line 2323
virtual int do_max_length() const noexcept override { 
#line 2325
return static_cast< int>((_Cvt)._Mbcurmax); 
#line 2326
} 
#line 2328
virtual int do_encoding() const noexcept override { 
#line 2330
return ((_Cvt)._Mbcurmax) == 1U; 
#line 2331
} 
#line 2334
private: _Locinfo::_Cvtvec _Cvt; 
#line 2335
}; 
#line 2338 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocale"
template < class _Elem, class _Byte, class _Statype >
class codecvt_byname : public codecvt < _Elem, _Byte, _Statype > {
public :
    static_assert ( ! 0
                      || _Is_any_of_v < codecvt_byname, codecvt_byname < char, char, mbstate_t >,
                          codecvt_byname < wchar_t, char, mbstate_t >>,
        "Unsupported facet specialization; see N4950 [locale.category]. Either use a Standard specialization or define _ENFORCE_FACET_SPE" "CIALIZATIONS=0 to suppress this error." );

    explicit codecvt_byname ( const char * _Locname, size_t _Refs = 0 )
        : codecvt < _Elem, _Byte, _Statype > ( _Locinfo ( _Locname ), _Refs ) { }

    explicit codecvt_byname ( const string & _Str, size_t _Refs = 0 )
        : codecvt < _Elem, _Byte, _Statype > ( _Locinfo ( _Str . c_str ( ) ), _Refs ) { }

protected :
     ~ codecvt_byname ( ) noexcept override { }
};
#line 2356
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 2359
template<> class codecvt_byname< char16_t, char, _Mbstatet>  : public codecvt< char16_t, char, _Mbstatet>  { 
#line 2362
public: explicit codecvt_byname(const char *_Locname, size_t _Refs = 0) : std::codecvt< char16_t, char, _Mbstatet> (((_Locinfo)(_Locname)), _Refs) 
#line 2363
{ } 
#line 2365
explicit codecvt_byname(const string &_Str, size_t _Refs = 0) : std::codecvt< char16_t, char, _Mbstatet> (((_Locinfo)(_Str.c_str())), _Refs) 
#line 2366
{ } 
#line 2369
protected: virtual ~codecvt_byname() noexcept override { } 
#line 2370
}; 
#line 2373
template<> class codecvt_byname< char32_t, char, _Mbstatet>  : public codecvt< char32_t, char, _Mbstatet>  { 
#line 2376
public: explicit codecvt_byname(const char *_Locname, size_t _Refs = 0) : std::codecvt< char32_t, char, _Mbstatet> (((_Locinfo)(_Locname)), _Refs) 
#line 2377
{ } 
#line 2379
explicit codecvt_byname(const string &_Str, size_t _Refs = 0) : std::codecvt< char32_t, char, _Mbstatet> (((_Locinfo)(_Str.c_str())), _Refs) 
#line 2380
{ } 
#line 2383
protected: virtual ~codecvt_byname() noexcept override { } 
#line 2384
}; 
#line 2416
__pragma( warning(pop)) 
#line 2428
struct ctype_base : public locale::facet { 
#line 2431
enum { 
#line 2432
alnum = (((4 | 2) | 1) | 256), 
#line 2433
alpha = ((2 | 1) | 256), 
#line 2434
cntrl = 32, 
#line 2435
digit = 4, 
#line 2436
graph = ((((4 | 2) | 16) | 1) | 256), 
#line 2437
lower = 2, 
#line 2438
print = ((((((4 | 2) | 16) | 64) | 1) | 256) | 128), 
#line 2439
punct = 16, 
#line 2440
space = (8 | 64), 
#line 2441
upper = 1, 
#line 2442
xdigit = 128, 
#line 2443
blank = (8 | 64)
#line 2444
}; 
#line 2445
using mask = short; 
#line 2447
ctype_base(size_t _Refs = 0) noexcept : locale::facet(_Refs) 
#line 2448
{ } 
#line 2450
virtual ~ctype_base() noexcept override { } 
#line 2451
}; 
#line 2463
template < class _Elem >
class ctype : public ctype_base {
public :

    static_assert ( ! 0 || _Always_false < _Elem >, "Unsupported facet specialization; see N4950 [locale.category]. Either use a Standard specialization or define _ENFORCE_FACET_SPE" "CIALIZATIONS=0 to suppress this error." );

    using char_type = _Elem;

    bool is ( mask _Maskval, _Elem _Ch ) const {
        return do_is ( _Maskval, _Ch );
    }

    const _Elem * is ( const _Elem * _First, const _Elem * _Last,
        mask * _Dest ) const {
        return do_is ( _First, _Last, _Dest );
    }

    const _Elem * scan_is ( mask _Maskval, const _Elem * _First,
        const _Elem * _Last ) const {
        return do_scan_is ( _Maskval, _First, _Last );
    }

    const _Elem * scan_not ( mask _Maskval, const _Elem * _First,
        const _Elem * _Last ) const {
        return do_scan_not ( _Maskval, _First, _Last );
    }

    _Elem tolower ( _Elem _Ch ) const {
        return do_tolower ( _Ch );
    }

    const _Elem * tolower (
        _Elem * _First, const _Elem * _Last ) const {
        return do_tolower ( _First, _Last );
    }

    _Elem toupper ( _Elem _Ch ) const {
        return do_toupper ( _Ch );
    }

    const _Elem * toupper (
        _Elem * _First, const _Elem * _Last ) const {
        return do_toupper ( _First, _Last );
    }

    _Elem widen ( char _Byte ) const {
        return do_widen ( _Byte );
    }

    const char * widen ( const char * _First, const char * _Last,
        _Elem * _Dest ) const {
        return do_widen ( _First, _Last, _Dest );
    }

    char narrow ( _Elem _Ch, char _Dflt = '\000' ) const {
        return do_narrow ( _Ch, _Dflt );
    }

    const _Elem * narrow ( const _Elem * _First, const _Elem * _Last, char _Dflt,
        char * _Dest ) const {
        return do_narrow ( _First, _Last, _Dflt, _Dest );
    }

     static locale :: id id;

    explicit ctype ( size_t _Refs = 0 ) : ctype_base ( _Refs ) {
        { _Locinfo _Lobj;
        _Init ( _Lobj );
        }
    }

     ctype ( const _Locinfo & _Lobj, size_t _Refs = 0 ) : ctype_base ( _Refs ) {
        _Init ( _Lobj );
    }

    static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = nullptr, const locale * _Ploc = nullptr ) {
        if ( _Ppf && ! * _Ppf ) {
            * _Ppf = new ctype < _Elem > ( _Locinfo ( _Ploc -> _C_str ( ) ) );
        }

        return 2;
    }

protected :
     ~ ctype ( ) noexcept override {
        if ( _Ctype . _Delfl ) {
            :: free ( const_cast < short * > ( _Ctype . _Table ) );
        }

        :: free ( _Ctype . _LocaleName );
    }

    void _Init ( const _Locinfo & _Lobj ) {
        _Ctype = _Lobj . _Getctype ( );
        _Cvt = _Lobj . _Getcvt ( );
    }

    virtual bool do_is (
        mask _Maskval, _Elem _Ch ) const {
        return ( _Ctype . _Table [ static_cast < unsigned char > ( narrow ( _Ch ) ) ] & _Maskval ) != 0;
    }

    virtual const _Elem * do_is ( const _Elem * _First, const _Elem * _Last,
        mask * _Dest ) const {
        _Adl_verify_range ( _First, _Last );
        for (; _First != _Last; ++ _First, ++ _Dest ) {
            * _Dest = _Ctype . _Table [ static_cast < unsigned char > ( narrow ( * _First ) ) ];
        }

        return _First;
    }

    virtual const _Elem * do_scan_is ( mask _Maskval, const _Elem * _First,
        const _Elem * _Last ) const {
        _Adl_verify_range ( _First, _Last );
        while ( _First != _Last && ! is ( _Maskval, * _First ) ) {
            ++ _First;
        }

        return _First;
    }

    virtual const _Elem * do_scan_not ( mask _Maskval, const _Elem * _First,
        const _Elem * _Last ) const {
        _Adl_verify_range ( _First, _Last );
        while ( _First != _Last && is ( _Maskval, * _First ) ) {
            ++ _First;
        }

        return _First;
    }

    virtual _Elem do_tolower ( _Elem _Ch ) const {
        unsigned char _Byte = static_cast < unsigned char > ( narrow ( _Ch, '\000' ) );
        if ( _Byte == '\000' ) {
            return _Ch;
        }

        return widen ( static_cast < char > ( _Tolower ( _Byte, & _Ctype ) ) );
    }

    virtual const _Elem * do_tolower ( _Elem * _First,
        const _Elem * _Last ) const {
        _Adl_verify_range ( _First, _Last );
        for (; _First != _Last; ++ _First ) {
            unsigned char _Byte = static_cast < unsigned char > ( narrow ( * _First, '\000' ) );
            if ( _Byte != '\000' ) {
                * _First = ( widen ( static_cast < char > ( _Tolower ( _Byte, & _Ctype ) ) ) );
            }
        }
        return _First;
    }

    virtual _Elem do_toupper ( _Elem _Ch ) const {
        unsigned char _Byte = static_cast < unsigned char > ( narrow ( _Ch, '\000' ) );
        if ( _Byte == '\000' ) {
            return _Ch;
        }

        return widen ( static_cast < char > ( _Toupper ( _Byte, & _Ctype ) ) );
    }

    virtual const _Elem * do_toupper ( _Elem * _First,
        const _Elem * _Last ) const {
        _Adl_verify_range ( _First, _Last );
        for (; _First != _Last; ++ _First ) {
            unsigned char _Byte = static_cast < unsigned char > ( narrow ( * _First, '\000' ) );
            if ( _Byte != '\000' ) {
                * _First = ( widen ( static_cast < char > ( _Toupper ( _Byte, & _Ctype ) ) ) );
            }
        }

        return _First;
    }

    virtual _Elem do_widen ( char _Byte ) const {
        return _Maklocchr ( _Byte, static_cast < _Elem * > ( nullptr ), _Cvt );
    }

    virtual const char * do_widen (
        const char * _First, const char * _Last, _Elem * _Dest ) const {
        _Adl_verify_range ( _First, _Last );
        for (; _First != _Last; ++ _First, ++ _Dest ) {
            * _Dest = _Maklocchr ( * _First, static_cast < _Elem * > ( nullptr ), _Cvt );
        }

        return _First;
    }

    char _Donarrow ( _Elem _Ch, char _Dflt ) const {
        char _Byte;
        if ( _Ch == _Elem { } ) {
            return '\000';
        }

        if ( ( _Byte = _Maklocbyte ( _Ch, _Cvt ) ) == '\000' ) {
            return _Dflt;
        }

        return _Byte;
    }

    virtual char do_narrow ( _Elem _Ch, char _Dflt ) const {
        return _Donarrow ( _Ch, _Dflt );
    }

    virtual const _Elem * do_narrow ( const _Elem * _First, const _Elem * _Last, char _Dflt,
        char * _Dest ) const {
        _Adl_verify_range ( _First, _Last );
        for (; _First != _Last; ++ _First, ++ _Dest ) {
            * _Dest = _Donarrow ( * _First, _Dflt );
        }

        return _First;
    }

private :
    _Locinfo :: _Ctypevec _Ctype;
    _Locinfo :: _Cvtvec _Cvt;
};
#line 2689
template< class _Elem> locale::id 
#line 2690
ctype< _Elem> ::id; 
#line 2697
template<> class ctype< char>  : public ctype_base { 
#line 2699
public: using _Elem = char; 
#line 2700
using char_type = _Elem; 
#line 2702
bool is(mask _Maskval, _Elem _Ch) const { 
#line 2703
return ((((_Ctype)._Table)[static_cast< unsigned char>(_Ch)]) & _Maskval) != 0; 
#line 2704
} 
#line 2706
const _Elem *is(const _Elem *_First, const _Elem *_Last, mask *
#line 2707
_Dest) const { 
#line 2708
_Adl_verify_range(_First, _Last); 
#line 2709
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 2710
(*_Dest) = (((_Ctype)._Table)[static_cast< unsigned char>(*_First)]); 
#line 2711
}  
#line 2713
return _First; 
#line 2714
} 
#line 2716
const _Elem *scan_is(mask _Maskval, const _Elem *_First, const _Elem *
#line 2717
_Last) const { 
#line 2718
_Adl_verify_range(_First, _Last); 
#line 2719
while ((_First != _Last) && (!this->is(_Maskval, *_First))) { 
#line 2720
++_First; 
#line 2721
}  
#line 2723
return _First; 
#line 2724
} 
#line 2726
const _Elem *scan_not(mask _Maskval, const _Elem *_First, const _Elem *
#line 2727
_Last) const { 
#line 2728
_Adl_verify_range(_First, _Last); 
#line 2729
while ((_First != _Last) && this->is(_Maskval, *_First)) { 
#line 2730
++_First; 
#line 2731
}  
#line 2733
return _First; 
#line 2734
} 
#line 2736
_Elem tolower(_Elem _Ch) const { 
#line 2737
return this->do_tolower(_Ch); 
#line 2738
} 
#line 2740
const _Elem *tolower(_Elem *
#line 2741
_First, const _Elem *_Last) const { 
#line 2742
return this->do_tolower(_First, _Last); 
#line 2743
} 
#line 2745
_Elem toupper(_Elem _Ch) const { 
#line 2746
return this->do_toupper(_Ch); 
#line 2747
} 
#line 2749
const _Elem *toupper(_Elem *
#line 2750
_First, const _Elem *_Last) const { 
#line 2751
return this->do_toupper(_First, _Last); 
#line 2752
} 
#line 2754
_Elem widen(char _Byte) const { 
#line 2755
return this->do_widen(_Byte); 
#line 2756
} 
#line 2758
const _Elem *widen(const char *_First, const char *_Last, _Elem *
#line 2759
_Dest) const { 
#line 2760
return this->do_widen(_First, _Last, _Dest); 
#line 2761
} 
#line 2763
_Elem narrow(_Elem _Ch, char _Dflt = '\000') const { 
#line 2764
return this->do_narrow(_Ch, _Dflt); 
#line 2765
} 
#line 2767
const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char _Dflt, char *
#line 2768
_Dest) const { 
#line 2769
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#line 2770
} 
#line 2772
static locale::id id; 
#line 2774
explicit ctype(const mask *_Table = 0, bool _Deletetable = false, size_t 
#line 2775
_Refs = 0) : ctype_base(_Refs) 
#line 2776
{ 
#line 2777
{ _Locinfo _Lobj; 
#line 2778
this->_Init(_Lobj); 
#line 2779
} 
#line 2781
this->_Tidy(); 
#line 2782
if (_Table) { 
#line 2783
((_Ctype)._Table) = _Table; 
#line 2784
((_Ctype)._Delfl) = (_Deletetable ? -1 : 0); 
#line 2785
} else { 
#line 2786
((_Ctype)._Table) = classic_table(); 
#line 2787
((_Ctype)._Delfl) = 0; 
#line 2788
}  
#line 2789
} 
#line 2791
ctype(const _Locinfo &_Lobj, size_t _Refs = 0) : ctype_base(_Refs) { 
#line 2792
this->_Init(_Lobj); 
#line 2793
} 
#line 2795
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *_Ploc = 0) { 
#line 2796
if (_Ppf && (!(*_Ppf))) { 
#line 2797
(*_Ppf) = (new std::ctype< char> (((_Locinfo)(_Ploc->_C_str())))); 
#line 2798
}  
#line 2800
return 2; 
#line 2801
} 
#line 2803
const mask *table() const noexcept { 
#line 2804
return (_Ctype)._Table; 
#line 2805
} 
#line 2807
static const mask *__cdecl classic_table() noexcept { 
#line 2808
return ::std::use_facet< std::ctype< char> > (locale::classic()).table(); 
#line 2809
} 
#line 2811
static const size_t table_size = (1 << 8); 
#line 2814
protected: virtual ~ctype() noexcept override { 
#line 2815
this->_Tidy(); 
#line 2816
} 
#line 2818
void _Init(const _Locinfo &_Lobj) { 
#line 2819
(_Ctype) = _Lobj._Getctype(); 
#line 2820
} 
#line 2822
void _Tidy() noexcept { 
#line 2823
if (0 < ((_Ctype)._Delfl)) { 
#line 2824
::free(const_cast< short *>((_Ctype)._Table)); 
#line 2825
} else { if (((_Ctype)._Delfl) < 0) { 
#line 2826
delete [] ((_Ctype)._Table); 
#line 2827
}  }  
#line 2829
::free((_Ctype)._LocaleName); 
#line 2830
} 
#line 2832
virtual _Elem do_tolower(_Elem _Ch) const { 
#line 2833
return static_cast< _Elem>(_Tolower(static_cast< unsigned char>(_Ch), &(_Ctype))); 
#line 2834
} 
#line 2836
virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
#line 2837
_Last) const { 
#line 2838
_Adl_verify_range(_First, _Last); 
#line 2839
for (; _First != _Last; ++_First) { 
#line 2840
(*_First) = (static_cast< _Elem>(_Tolower(static_cast< unsigned char>(*_First), &(_Ctype)))); 
#line 2841
}  
#line 2843
return _First; 
#line 2844
} 
#line 2846
virtual _Elem do_toupper(_Elem _Ch) const { 
#line 2847
return static_cast< _Elem>(_Toupper(static_cast< unsigned char>(_Ch), &(_Ctype))); 
#line 2848
} 
#line 2850
virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
#line 2851
_Last) const { 
#line 2852
_Adl_verify_range(_First, _Last); 
#line 2853
for (; _First != _Last; ++_First) { 
#line 2854
(*_First) = (static_cast< _Elem>(_Toupper(static_cast< unsigned char>(*_First), &(_Ctype)))); 
#line 2855
}  
#line 2857
return _First; 
#line 2858
} 
#line 2860
virtual _Elem do_widen(char _Byte) const { 
#line 2861
return _Byte; 
#line 2862
} 
#line 2864
virtual const _Elem *do_widen(const char *
#line 2865
_First, const char *_Last, _Elem *_Dest) const { 
#line 2866
_Adl_verify_range(_First, _Last); 
#line 2867
::memcpy(_Dest, _First, static_cast< size_t>(_Last - _First)); 
#line 2868
return _Last; 
#line 2869
} 
#line 2871
virtual _Elem do_narrow(_Elem _Ch, char) const { 
#line 2872
return _Ch; 
#line 2873
} 
#line 2875
virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *_Last, char, char *
#line 2876
_Dest) const { 
#line 2877
_Adl_verify_range(_First, _Last); 
#line 2878
::memcpy(_Dest, _First, static_cast< size_t>(_Last - _First)); 
#line 2879
return _Last; 
#line 2880
} 
#line 2883
private: _Locinfo::_Ctypevec _Ctype; 
#line 2884
}; 
#line 2887
template<> class ctype< __wchar_t>  : public ctype_base { 
#line 2890
public: using _Elem = __wchar_t; 
#line 2891
using char_type = _Elem; 
#line 2893
bool is(mask _Maskval, _Elem _Ch) const { 
#line 2894
return this->do_is(_Maskval, _Ch); 
#line 2895
} 
#line 2897
const _Elem *is(const _Elem *_First, const _Elem *_Last, mask *
#line 2898
_Dest) const { 
#line 2899
return this->do_is(_First, _Last, _Dest); 
#line 2900
} 
#line 2902
const _Elem *scan_is(mask _Maskval, const _Elem *_First, const _Elem *
#line 2903
_Last) const { 
#line 2904
return this->do_scan_is(_Maskval, _First, _Last); 
#line 2905
} 
#line 2907
const _Elem *scan_not(mask _Maskval, const _Elem *_First, const _Elem *
#line 2908
_Last) const { 
#line 2909
return this->do_scan_not(_Maskval, _First, _Last); 
#line 2910
} 
#line 2912
_Elem tolower(_Elem _Ch) const { 
#line 2913
return this->do_tolower(_Ch); 
#line 2914
} 
#line 2916
const _Elem *tolower(_Elem *
#line 2917
_First, const _Elem *_Last) const { 
#line 2918
return this->do_tolower(_First, _Last); 
#line 2919
} 
#line 2921
_Elem toupper(_Elem _Ch) const { 
#line 2922
return this->do_toupper(_Ch); 
#line 2923
} 
#line 2925
const _Elem *toupper(_Elem *
#line 2926
_First, const _Elem *_Last) const { 
#line 2927
return this->do_toupper(_First, _Last); 
#line 2928
} 
#line 2930
_Elem widen(char _Byte) const { 
#line 2931
return this->do_widen(_Byte); 
#line 2932
} 
#line 2934
const char *widen(const char *_First, const char *_Last, _Elem *
#line 2935
_Dest) const { 
#line 2936
return this->do_widen(_First, _Last, _Dest); 
#line 2937
} 
#line 2939
char narrow(_Elem _Ch, char _Dflt = '\000') const { 
#line 2940
return this->do_narrow(_Ch, _Dflt); 
#line 2941
} 
#line 2943
const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char _Dflt, char *
#line 2944
_Dest) const { 
#line 2945
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#line 2946
} 
#line 2948
static locale::id id; 
#line 2950
explicit ctype(size_t _Refs = 0) : ctype_base(_Refs) { 
#line 2951
{ _Locinfo _Lobj; 
#line 2952
this->_Init(_Lobj); 
#line 2953
} 
#line 2954
} 
#line 2956
ctype(const _Locinfo &_Lobj, size_t _Refs = 0) : ctype_base(_Refs) { 
#line 2957
this->_Init(_Lobj); 
#line 2958
} 
#line 2960
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *_Ploc = 0) { 
#line 2961
if (_Ppf && (!(*_Ppf))) { 
#line 2962
(*_Ppf) = (new std::ctype< __wchar_t> (((_Locinfo)(_Ploc->_C_str())))); 
#line 2963
}  
#line 2965
return 2; 
#line 2966
} 
#line 2969
protected: virtual ~ctype() noexcept override { 
#line 2970
if ((_Ctype)._Delfl) { 
#line 2971
::free(const_cast< short *>((_Ctype)._Table)); 
#line 2972
}  
#line 2974
::free((_Ctype)._LocaleName); 
#line 2975
} 
#line 2977
void _Init(const _Locinfo &_Lobj) { 
#line 2978
(_Ctype) = _Lobj._Getctype(); 
#line 2979
(_Cvt) = _Lobj._Getcvt(); 
#line 2980
} 
#line 2982
virtual bool do_is(mask 
#line 2983
_Maskval, _Elem _Ch) const { 
#line 2984
return ((::_Getwctype(_Ch, &(_Ctype))) & _Maskval) != 0; 
#line 2985
} 
#line 2987
virtual const _Elem *do_is(const _Elem *_First, const _Elem *_Last, mask *
#line 2988
_Dest) const { 
#line 2989
_Adl_verify_range(_First, _Last); 
#line 2990
return ::_Getwctypes(_First, _Last, _Dest, &(_Ctype)); 
#line 2991
} 
#line 2993
virtual const _Elem *do_scan_is(mask _Maskval, const _Elem *_First, const _Elem *
#line 2994
_Last) const { 
#line 2995
_Adl_verify_range(_First, _Last); 
#line 2996
while ((_First != _Last) && (!this->is(_Maskval, *_First))) { 
#line 2997
++_First; 
#line 2998
}  
#line 3000
return _First; 
#line 3001
} 
#line 3003
virtual const _Elem *do_scan_not(mask _Maskval, const _Elem *_First, const _Elem *
#line 3004
_Last) const { 
#line 3005
_Adl_verify_range(_First, _Last); 
#line 3006
while ((_First != _Last) && this->is(_Maskval, *_First)) { 
#line 3007
++_First; 
#line 3008
}  
#line 3010
return _First; 
#line 3011
} 
#line 3013
virtual _Elem do_tolower(_Elem _Ch) const { 
#line 3014
return _Towlower(_Ch, &(_Ctype)); 
#line 3015
} 
#line 3017
virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
#line 3018
_Last) const { 
#line 3019
_Adl_verify_range(_First, _Last); 
#line 3020
for (; _First != _Last; ++_First) { 
#line 3021
(*_First) = _Towlower(*_First, &(_Ctype)); 
#line 3022
}  
#line 3024
return _First; 
#line 3025
} 
#line 3027
virtual _Elem do_toupper(_Elem _Ch) const { 
#line 3028
return _Towupper(_Ch, &(_Ctype)); 
#line 3029
} 
#line 3031
virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
#line 3032
_Last) const { 
#line 3033
_Adl_verify_range(_First, _Last); 
#line 3034
for (; _First != _Last; ++_First) { 
#line 3035
(*_First) = _Towupper(*_First, &(_Ctype)); 
#line 3036
}  
#line 3038
return _First; 
#line 3039
} 
#line 3041
_Elem _Dowiden(char _Byte) const { 
#line 3042
mbstate_t _Mbst = {}; 
#line 3043
__wchar_t _Wc; 
#line 3044
return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &(_Cvt)) < 0) ? static_cast< __wchar_t>((wint_t)65535) : _Wc; 
#line 3045
} 
#line 3047
virtual _Elem do_widen(char _Byte) const { 
#line 3048
return this->_Dowiden(_Byte); 
#line 3049
} 
#line 3051
virtual const char *do_widen(const char *
#line 3052
_First, const char *_Last, _Elem *_Dest) const { 
#line 3053
_Adl_verify_range(_First, _Last); 
#line 3054
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 3055
(*_Dest) = this->_Dowiden(*_First); 
#line 3056
}  
#line 3058
return _First; 
#line 3059
} 
#line 3061
char _Donarrow(_Elem _Ch, char _Dflt) const { 
#line 3062
char _Buf[5]; 
#line 3063
mbstate_t _Mbst = {}; 
#line 3064
return (_Wcrtomb(_Buf, _Ch, &_Mbst, &(_Cvt)) != 1) ? _Dflt : (_Buf[0]); 
#line 3065
} 
#line 3067
virtual char do_narrow(_Elem _Ch, char _Dflt) const { 
#line 3068
return this->_Donarrow(_Ch, _Dflt); 
#line 3069
} 
#line 3071
virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *_Last, char _Dflt, char *
#line 3072
_Dest) const { 
#line 3073
_Adl_verify_range(_First, _Last); 
#line 3074
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 3075
(*_Dest) = this->_Donarrow(*_First, _Dflt); 
#line 3076
}  
#line 3078
return _First; 
#line 3079
} 
#line 3082
private: _Locinfo::_Ctypevec _Ctype; 
#line 3083
_Locinfo::_Cvtvec _Cvt; 
#line 3084
}; 
#line 3088
template<> class ctype< unsigned short>  : public ctype_base { 
#line 3091
public: using _Elem = unsigned short; 
#line 3092
using char_type = _Elem; 
#line 3094
bool is(mask _Maskval, _Elem _Ch) const { 
#line 3095
return this->do_is(_Maskval, _Ch); 
#line 3096
} 
#line 3098
const _Elem *is(const _Elem *_First, const _Elem *_Last, mask *
#line 3099
_Dest) const { 
#line 3100
return this->do_is(_First, _Last, _Dest); 
#line 3101
} 
#line 3103
const _Elem *scan_is(mask _Maskval, const _Elem *_First, const _Elem *
#line 3104
_Last) const { 
#line 3105
return this->do_scan_is(_Maskval, _First, _Last); 
#line 3106
} 
#line 3108
const _Elem *scan_not(mask _Maskval, const _Elem *_First, const _Elem *
#line 3109
_Last) const { 
#line 3110
return this->do_scan_not(_Maskval, _First, _Last); 
#line 3111
} 
#line 3113
_Elem tolower(_Elem _Ch) const { 
#line 3114
return this->do_tolower(_Ch); 
#line 3115
} 
#line 3117
const _Elem *tolower(_Elem *
#line 3118
_First, const _Elem *_Last) const { 
#line 3119
return this->do_tolower(_First, _Last); 
#line 3120
} 
#line 3122
_Elem toupper(_Elem _Ch) const { 
#line 3123
return this->do_toupper(_Ch); 
#line 3124
} 
#line 3126
const _Elem *toupper(_Elem *
#line 3127
_First, const _Elem *_Last) const { 
#line 3128
return this->do_toupper(_First, _Last); 
#line 3129
} 
#line 3131
_Elem widen(char _Byte) const { 
#line 3132
return this->do_widen(_Byte); 
#line 3133
} 
#line 3135
const char *widen(const char *_First, const char *_Last, _Elem *
#line 3136
_Dest) const { 
#line 3137
return this->do_widen(_First, _Last, _Dest); 
#line 3138
} 
#line 3140
char narrow(_Elem _Ch, char _Dflt = '\000') const { 
#line 3141
return this->do_narrow(_Ch, _Dflt); 
#line 3142
} 
#line 3144
const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char _Dflt, char *
#line 3145
_Dest) const { 
#line 3146
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#line 3147
} 
#line 3149
static locale::id id; 
#line 3151
explicit ctype(size_t _Refs = 0) : ctype_base(_Refs) { 
#line 3152
{ _Locinfo _Lobj; 
#line 3153
this->_Init(_Lobj); 
#line 3154
} 
#line 3155
} 
#line 3157
ctype(const _Locinfo &_Lobj, size_t _Refs = 0) : ctype_base(_Refs) { 
#line 3158
this->_Init(_Lobj); 
#line 3159
} 
#line 3161
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *_Ploc = 0) { 
#line 3162
if (_Ppf && (!(*_Ppf))) { 
#line 3163
(*_Ppf) = (new std::ctype< unsigned short> (((_Locinfo)(_Ploc->_C_str())))); 
#line 3164
}  
#line 3166
return 2; 
#line 3167
} 
#line 3170
protected: virtual ~ctype() noexcept override { 
#line 3171
if ((_Ctype)._Delfl) { 
#line 3172
::free(const_cast< short *>((_Ctype)._Table)); 
#line 3173
}  
#line 3175
::free((_Ctype)._LocaleName); 
#line 3176
} 
#line 3178
void _Init(const _Locinfo &_Lobj) { 
#line 3179
(_Ctype) = _Lobj._Getctype(); 
#line 3180
(_Cvt) = _Lobj._Getcvt(); 
#line 3181
} 
#line 3183
virtual bool do_is(mask 
#line 3184
_Maskval, _Elem _Ch) const { 
#line 3185
return ((::_Getwctype(_Ch, &(_Ctype))) & _Maskval) != 0; 
#line 3186
} 
#line 3188
virtual const _Elem *do_is(const _Elem *_First, const _Elem *_Last, mask *
#line 3189
_Dest) const { 
#line 3190
_Adl_verify_range(_First, _Last); 
#line 3191
return reinterpret_cast< const _Elem *>(::_Getwctypes(reinterpret_cast< const __wchar_t *>(_First), reinterpret_cast< const __wchar_t *>(_Last), _Dest, &(_Ctype))); 
#line 3193
} 
#line 3195
virtual const _Elem *do_scan_is(mask _Maskval, const _Elem *_First, const _Elem *
#line 3196
_Last) const { 
#line 3197
_Adl_verify_range(_First, _Last); 
#line 3198
while ((_First != _Last) && (!this->is(_Maskval, *_First))) { 
#line 3199
++_First; 
#line 3200
}  
#line 3202
return _First; 
#line 3203
} 
#line 3205
virtual const _Elem *do_scan_not(mask _Maskval, const _Elem *_First, const _Elem *
#line 3206
_Last) const { 
#line 3207
_Adl_verify_range(_First, _Last); 
#line 3208
while ((_First != _Last) && this->is(_Maskval, *_First)) { 
#line 3209
++_First; 
#line 3210
}  
#line 3212
return _First; 
#line 3213
} 
#line 3215
virtual _Elem do_tolower(_Elem _Ch) const { 
#line 3216
return _Towlower(_Ch, &(_Ctype)); 
#line 3217
} 
#line 3219
virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
#line 3220
_Last) const { 
#line 3221
_Adl_verify_range(_First, _Last); 
#line 3222
for (; _First != _Last; ++_First) { 
#line 3223
(*_First) = (_Towlower(*_First, &(_Ctype))); 
#line 3224
}  
#line 3226
return _First; 
#line 3227
} 
#line 3229
virtual _Elem do_toupper(_Elem _Ch) const { 
#line 3230
return _Towupper(_Ch, &(_Ctype)); 
#line 3231
} 
#line 3233
virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
#line 3234
_Last) const { 
#line 3235
_Adl_verify_range(_First, _Last); 
#line 3236
for (; _First != _Last; ++_First) { 
#line 3237
(*_First) = (_Towupper(*_First, &(_Ctype))); 
#line 3238
}  
#line 3240
return _First; 
#line 3241
} 
#line 3243
_Elem _Dowiden(char _Byte) const { 
#line 3244
mbstate_t _Mbst = {}; 
#line 3245
unsigned short _Wc; 
#line 3247
if (_Mbrtowc(reinterpret_cast< __wchar_t *>(&_Wc), &_Byte, 1, &_Mbst, &(_Cvt)) < 0) { 
#line 3248
return static_cast< unsigned short>((wint_t)65535); 
#line 3249
}  
#line 3251
return _Wc; 
#line 3252
} 
#line 3254
virtual _Elem do_widen(char _Byte) const { 
#line 3255
return this->_Dowiden(_Byte); 
#line 3256
} 
#line 3258
virtual const char *do_widen(const char *
#line 3259
_First, const char *_Last, _Elem *_Dest) const { 
#line 3260
_Adl_verify_range(_First, _Last); 
#line 3261
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 3262
(*_Dest) = this->_Dowiden(*_First); 
#line 3263
}  
#line 3265
return _First; 
#line 3266
} 
#line 3268
char _Donarrow(_Elem _Ch, char _Dflt) const { 
#line 3269
char _Buf[5]; 
#line 3270
mbstate_t _Mbst = {}; 
#line 3271
return (_Wcrtomb(_Buf, _Ch, &_Mbst, &(_Cvt)) != 1) ? _Dflt : (_Buf[0]); 
#line 3272
} 
#line 3274
virtual char do_narrow(_Elem _Ch, char _Dflt) const { 
#line 3275
return this->_Donarrow(_Ch, _Dflt); 
#line 3276
} 
#line 3278
virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *_Last, char _Dflt, char *
#line 3279
_Dest) const { 
#line 3280
_Adl_verify_range(_First, _Last); 
#line 3281
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 3282
(*_Dest) = this->_Donarrow(*_First, _Dflt); 
#line 3283
}  
#line 3285
return _First; 
#line 3286
} 
#line 3289
private: _Locinfo::_Ctypevec _Ctype; 
#line 3290
_Locinfo::_Cvtvec _Cvt; 
#line 3291
}; 
#line 3294 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocale"
template < class _Elem >
class ctype_byname : public ctype < _Elem > {
public :
    static_assert ( ! 0 || _Is_any_of_v < _Elem, char, wchar_t >, "Unsupported facet specialization; see N4950 [locale.category]. Either use a Standard specialization or define _ENFORCE_FACET_SPE" "CIALIZATIONS=0 to suppress this error." );

    explicit ctype_byname ( const char * _Locname, size_t _Refs = 0 )
        : ctype < _Elem > ( _Locinfo ( _Locname ), _Refs ) { }

    explicit ctype_byname ( const string & _Str, size_t _Refs = 0 )
        : ctype < _Elem > ( _Locinfo ( _Str . c_str ( ) ), _Refs ) { }

protected :
     ~ ctype_byname ( ) noexcept override { }
};
#line 3309
enum class _Case_sensitive: bool { _Nope, _Yes}; 
#line 3311
template < class _InIt, class _Elem >
int __cdecl _Getloctxt (
    _InIt & _First, _InIt & _Last, size_t _Numfields, const _Elem * _Ptr, const _Case_sensitive _Matching ) {

    for ( size_t _Off = 0; _Ptr [ _Off ] != _Elem { }; ++ _Off ) {
        if ( _Ptr [ _Off ] == _Ptr [ 0 ] ) {
            ++ _Numfields;
        }
    }

    string _Str ( _Numfields, '\000' );
    const ctype < _Elem > & _CType = :: std :: use_facet < ctype < _Elem >> ( locale { } );

    int _Ans = - 2;
    for ( size_t _Column = 1;; ++ _Column, ( void ) ++ _First, _Ans = - 1 ) {
        bool _Prefix = false;
        size_t _Off = 0;
        size_t _Field = 0;

        for (; _Field < _Numfields; ++ _Field ) {
            while ( _Ptr [ _Off ] != _Elem { } && _Ptr [ _Off ] != _Ptr [ 0 ] ) {
                ++ _Off;
            }

            if ( _Str [ _Field ] != '\000' ) {
                _Off += _Str [ _Field ];
            } else if ( _Ptr [ _Off += _Column ] == _Ptr [ 0 ]
                       || _Ptr [ _Off ] == _Elem { } ) {
                _Str [ _Field ] = static_cast < char > ( _Column < 127 ? _Column : 127 );
                _Ans = static_cast < int > ( _Field );
            } else if ( _First == _Last
                       || ( _Matching == _Case_sensitive :: _Yes
                               ? _Ptr [ _Off ] != * _First
                               : _CType . tolower ( _Ptr [ _Off ] ) != _CType . tolower ( static_cast < _Elem > ( * _First ) ) ) ) {
                _Str [ _Field ] = static_cast < char > ( _Column < 127 ? _Column : 127 );
            } else {
                _Prefix = true;
            }
        }

        if ( ! _Prefix || _First == _Last ) {
            break;
        }
    }
    return _Ans;
}
#line 3363 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocale"
}
#line 3366
#pragma warning(pop)
#pragma pack ( pop )
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xiosbase"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 21
namespace std { 
#line 22
template< class _Dummy> 
#line 23
class _Iosb { 
#line 25
public: enum _Fmtflags { 
#line 26
_Fmtmask = 65535, 
#line 27
_Fmtzero = 0
#line 28
}; 
#line 30
static constexpr int skipws = 1; 
#line 31
static constexpr int unitbuf = 2; 
#line 32
static constexpr int uppercase = 4; 
#line 33
static constexpr int showbase = 8; 
#line 34
static constexpr int showpoint = 16; 
#line 35
static constexpr int showpos = 32; 
#line 36
static constexpr int left = 64; 
#line 37
static constexpr int right = 128; 
#line 38
static constexpr int internal = 256; 
#line 39
static constexpr int dec = 512; 
#line 40
static constexpr int oct = 1024; 
#line 41
static constexpr int hex = 2048; 
#line 42
static constexpr int scientific = 4096; 
#line 43
static constexpr int fixed = 8192; 
#line 45
static constexpr int boolalpha = 16384; 
#line 46
static constexpr int adjustfield = ((left | right) | internal); 
#line 47
static constexpr int basefield = ((dec | oct) | hex); 
#line 48
static constexpr int floatfield = (scientific | fixed); 
#line 50
enum _Iostate { 
#line 51
_Statmask = 23
#line 52
}; 
#line 54
static constexpr int goodbit = 0; 
#line 55
static constexpr int eofbit = 1; 
#line 56
static constexpr int failbit = 2; 
#line 57
static constexpr int badbit = 4; 
#line 59
static constexpr int in = 1; 
#line 60
static constexpr int out = 2; 
#line 61
static constexpr int ate = 4; 
#line 62
static constexpr int app = 8; 
#line 63
static constexpr int trunc = 16; 
#line 64
static constexpr int binary = 32; 
#line 65
static constexpr int _Nocreate = 64; 
#line 66
static constexpr int _Noreplace = 128; 
#line 71 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xiosbase"
static constexpr int beg = 0; 
#line 72
static constexpr int cur = 1; 
#line 73
static constexpr int end = 2; 
#line 75
static constexpr int _Default_open_prot = 64; 
#line 79
enum _Dummy_enum { _Dummy_enum_val = 1}; 
#line 80
enum _Openmode { _Openmask = 255}; 
#line 81
enum _Seekdir { _Seekbeg, _Seekcur, _Seekend}; 
#line 82
enum { _Openprot = 64}; 
#line 83
}; 
#line 85
class ios_base : public _Iosb< int>  { 
#line 87
public: using fmtflags = int; 
#line 88
using iostate = int; 
#line 89
using openmode = int; 
#line 90
using seekdir = int; 
#line 93
using streamoff = std::streamoff; 
#line 94
using streampos = std::streampos; 
#line 97 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xiosbase"
enum event { 
#line 98
erase_event, 
#line 99
imbue_event, 
#line 100
copyfmt_event
#line 101
}; 
#line 103
using event_callback = void (__cdecl *)(event, ios_base &, int); 
#line 106
using io_state = unsigned; 
#line 107
using open_mode = unsigned; 
#line 108
using seek_dir = unsigned; 
#line 111 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xiosbase"
class [[nodiscard]] failure : public system_error { 
#line 113
public: explicit failure(const string &_Message, const error_code &_Errcode = ::std::make_error_code(io_errc::stream)) : system_error(_Errcode, _Message) 
#line 114
{ } 
#line 116
explicit failure(const char *_Message, const error_code &_Errcode = ::std::make_error_code(io_errc::stream)) : system_error(_Errcode, _Message) 
#line 117
{ } 
#line 125 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xiosbase"
}; 
#line 127
class Init { 
#line 129
public: Init() { 
#line 130
_Init_ctor(this); 
#line 131
} 
#line 133
~Init() noexcept { 
#line 134
_Init_dtor(this); 
#line 135
} 
#line 138
private: static void __cdecl _Init_ctor(Init *); 
#line 139
static void __cdecl _Init_dtor(Init *); 
#line 141
static int _Init_cnt; 
#line 143
static int &__cdecl _Init_cnt_func(); 
#line 144
}; 
#line 146
explicit operator bool() const noexcept { 
#line 147
return !this->fail(); 
#line 148
} 
#line 150
[[nodiscard]] bool operator!() const noexcept { 
#line 151
return this->fail(); 
#line 152
} 
#line 154
void clear(iostate _State, bool _Reraise) { 
#line 155
_State &= (_Statmask); 
#line 156
(_Mystate) = _State; 
#line 157
const auto _Filtered = _State & (_Except); 
#line 158
if (_Filtered) { 
#line 159
if (_Reraise) { 
#line 160
throw; 
#line 161
}  
#line 163
const char *_Msg; 
#line 164
if (_Filtered & ios_base::badbit) { 
#line 165
_Msg = ("ios_base::badbit set"); 
#line 166
} else { if (_Filtered & ios_base::failbit) { 
#line 167
_Msg = ("ios_base::failbit set"); 
#line 168
} else { 
#line 169
_Msg = ("ios_base::eofbit set"); 
#line 170
}  }  
#line 172
throw ((failure)(_Msg)); 
#line 173
}  
#line 174
} 
#line 176
void clear(iostate _State = goodbit) { 
#line 177
this->clear(_State, false); 
#line 178
} 
#line 181
void clear(io_state _State) { 
#line 182
this->clear(static_cast< iostate>(_State)); 
#line 183
} 
#line 186 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xiosbase"
[[nodiscard]] iostate rdstate() const noexcept { 
#line 187
return _Mystate; 
#line 188
} 
#line 190
void setstate(iostate 
#line 191
_State, bool _Exreraise) { 
#line 192
this->clear(this->rdstate() | _State, _Exreraise); 
#line 193
} 
#line 195
void setstate(iostate _State) { 
#line 196
this->clear(this->rdstate() | _State, false); 
#line 197
} 
#line 200
void setstate(io_state _State) { 
#line 201
this->setstate(static_cast< iostate>(_State)); 
#line 202
} 
#line 205 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xiosbase"
[[nodiscard]] bool good() const noexcept { 
#line 206
return this->rdstate() == ios_base::goodbit; 
#line 207
} 
#line 209
[[nodiscard]] bool eof() const noexcept { 
#line 210
return this->rdstate() & ios_base::eofbit; 
#line 211
} 
#line 213
[[nodiscard]] bool fail() const noexcept { 
#line 214
return this->rdstate() & (ios_base::badbit | ios_base::failbit); 
#line 215
} 
#line 217
[[nodiscard]] bool bad() const noexcept { 
#line 218
return this->rdstate() & ios_base::badbit; 
#line 219
} 
#line 221
[[nodiscard]] iostate exceptions() const noexcept { 
#line 222
return _Except; 
#line 223
} 
#line 225
void exceptions(iostate _Newexcept) { 
#line 226
(_Except) = (_Newexcept & (_Statmask)); 
#line 227
this->clear(this->rdstate()); 
#line 228
} 
#line 231
void exceptions(io_state _State) { 
#line 232
this->exceptions(static_cast< iostate>(_State)); 
#line 233
} 
#line 236 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xiosbase"
[[nodiscard]] fmtflags flags() const noexcept { 
#line 237
return _Fmtfl; 
#line 238
} 
#line 240
fmtflags flags(fmtflags _Newfmtflags) noexcept { 
#line 242
const fmtflags _Oldfmtflags = _Fmtfl; 
#line 243
(_Fmtfl) = (_Newfmtflags & (_Fmtmask)); 
#line 244
return _Oldfmtflags; 
#line 245
} 
#line 247
fmtflags setf(fmtflags _Newfmtflags) noexcept { 
#line 249
const fmtflags _Oldfmtflags = _Fmtfl; 
#line 250
(_Fmtfl) |= (_Newfmtflags & (_Fmtmask)); 
#line 251
return _Oldfmtflags; 
#line 252
} 
#line 254
fmtflags setf(fmtflags _Newfmtflags, fmtflags _Mask) noexcept { 
#line 256
const fmtflags _Oldfmtflags = _Fmtfl; 
#line 257
(_Fmtfl) = ((_Oldfmtflags & (~_Mask)) | ((_Newfmtflags & _Mask) & (_Fmtmask))); 
#line 258
return _Oldfmtflags; 
#line 259
} 
#line 261
void unsetf(fmtflags _Mask) noexcept { 
#line 263
(_Fmtfl) &= (~_Mask); 
#line 264
} 
#line 266
[[nodiscard]] streamsize precision() const noexcept { 
#line 267
return _Prec; 
#line 268
} 
#line 270
streamsize precision(streamsize _Newprecision) noexcept { 
#line 272
const streamsize _Oldprecision = _Prec; 
#line 273
(_Prec) = _Newprecision; 
#line 274
return _Oldprecision; 
#line 275
} 
#line 277
[[nodiscard]] streamsize width() const noexcept { 
#line 278
return _Wide; 
#line 279
} 
#line 281
streamsize width(streamsize _Newwidth) noexcept { 
#line 283
const streamsize _Oldwidth = _Wide; 
#line 284
(_Wide) = _Newwidth; 
#line 285
return _Oldwidth; 
#line 286
} 
#line 288
[[nodiscard]] locale getloc() const noexcept { 
#line 289
return *(_Ploc); 
#line 290
} 
#line 292
locale imbue(const locale &_Loc) { 
#line 293
locale _Oldlocale = *(_Ploc); 
#line 294
((*(_Ploc)) = _Loc); 
#line 295
this->_Callfns(imbue_event); 
#line 296
return _Oldlocale; 
#line 297
} 
#line 299
[[nodiscard]] static int __cdecl xalloc() { 
#line 300
{ _Lockit _Lock(2); 
#line 301
return _Index++; 
#line 302
} 
#line 303
} 
#line 305
[[nodiscard]] long &iword(int _Idx) { 
#line 306
return this->_Findarr(_Idx)._Lo; 
#line 307
} 
#line 309
[[nodiscard]] void *&pword(int _Idx) { 
#line 310
return this->_Findarr(_Idx)._Vp; 
#line 311
} 
#line 313
void register_callback(event_callback _Pfn, int _Idx) { 
#line 315
(_Calls) = (new _Fnarray(_Idx, _Pfn, _Calls)); 
#line 316
} 
#line 318
ios_base &copyfmt(const ios_base &_Other) { 
#line 319
if (this != ::std::addressof(_Other)) { 
#line 320
this->_Tidy(); 
#line 321
((*(_Ploc)) = (*(_Other._Ploc))); 
#line 322
(_Fmtfl) = (_Other._Fmtfl); 
#line 323
(_Prec) = (_Other._Prec); 
#line 324
(_Wide) = (_Other._Wide); 
#line 325
_Iosarray *_Ptr = _Other._Arr; 
#line 327
for ((_Arr) = (nullptr); _Ptr; _Ptr = (_Ptr->_Next)) { 
#line 328
if (((_Ptr->_Lo) != (0)) || (_Ptr->_Vp)) { 
#line 329
this->iword(_Ptr->_Index) = (_Ptr->_Lo); 
#line 330
this->pword(_Ptr->_Index) = (_Ptr->_Vp); 
#line 331
}  
#line 332
}  
#line 334
for (_Fnarray *_Pfa = _Other._Calls; _Pfa; _Pfa = (_Pfa->_Next)) { 
#line 335
this->register_callback(_Pfa->_Pfn, _Pfa->_Index); 
#line 336
}  
#line 338
this->_Callfns(copyfmt_event); 
#line 339
this->exceptions(_Other._Except); 
#line 340
}  
#line 341
return *this; 
#line 342
} 
#line 344
static bool __cdecl sync_with_stdio(bool _Newsync = true) { 
#line 346
{ _Lockit _Lock(2); 
#line 347
const bool _Oldsync = _Sync; 
#line 348
_Sync = _Newsync; 
#line 349
return _Oldsync; 
#line 350
} 
#line 351
} 
#line 353
void swap(ios_base &_Right) noexcept { 
#line 354
if (this != ::std::addressof(_Right)) { 
#line 355
::std::swap(_Mystate, _Right._Mystate); 
#line 356
::std::swap(_Except, _Right._Except); 
#line 357
::std::swap(_Fmtfl, _Right._Fmtfl); 
#line 358
::std::swap(_Prec, _Right._Prec); 
#line 359
::std::swap(_Wide, _Right._Wide); 
#line 361
::std::swap(_Arr, _Right._Arr); 
#line 362
::std::swap(_Calls, _Right._Calls); 
#line 363
::std::swap(_Ploc, _Right._Ploc); 
#line 364
}  
#line 365
} 
#line 367
virtual ~ios_base() noexcept { 
#line 368
_Ios_base_dtor(this); 
#line 369
} 
#line 371
static void __cdecl _Addstd(ios_base *); 
#line 373
size_t _Stdstr{(0)}; 
#line 376
protected: ios_base() { } 
#line 378
void _Init() { 
#line 379
(_Ploc) = (nullptr); 
#line 380
(_Stdstr) = (0); 
#line 381
(_Except) = goodbit; 
#line 382
(_Fmtfl) = (skipws | dec); 
#line 383
(_Prec) = (6); 
#line 384
(_Wide) = (0); 
#line 385
(_Arr) = (nullptr); 
#line 386
(_Calls) = (nullptr); 
#line 387
this->clear(goodbit); 
#line 388
(_Ploc) = (new locale); 
#line 389
} 
#line 392
private: struct _Iosarray : public _Crt_new_delete { 
#line 394
_Iosarray(int _Idx, _Iosarray *_Link) : _Next(_Link), _Index(_Idx), _Lo((0)), _Vp((nullptr)) 
#line 395
{ } 
#line 397
_Iosarray *_Next; 
#line 398
int _Index; 
#line 399
long _Lo; 
#line 400
void *_Vp; 
#line 401
}; 
#line 403
struct _Fnarray : public _Crt_new_delete { 
#line 404
_Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link) : _Next(_Link), _Index(_Idx), _Pfn(_Pnew) 
#line 405
{ } 
#line 407
_Fnarray *_Next; 
#line 408
int _Index; 
#line 409
event_callback _Pfn; 
#line 410
}; 
#line 412
void _Callfns(event _Ev) { 
#line 413
for (_Fnarray *_Pfa = _Calls; _Pfa; _Pfa = (_Pfa->_Next)) { 
#line 414
(*(_Pfa->_Pfn))(_Ev, *this, _Pfa->_Index); 
#line 415
}  
#line 416
} 
#line 418
_Iosarray &_Findarr(int _Idx) { 
#line 419
_Iosarray *_Ptr1; 
#line 420
_Iosarray *_Ptr2; 
#line 422
for ((_Ptr1 = (_Arr)), (_Ptr2 = (nullptr)); _Ptr1; _Ptr1 = (_Ptr1->_Next)) { 
#line 423
if ((_Ptr1->_Index) == _Idx) { 
#line 424
return *_Ptr1; 
#line 425
} else { if (((!_Ptr2) && ((_Ptr1->_Lo) == (0))) && (!(_Ptr1->_Vp))) { 
#line 426
_Ptr2 = _Ptr1; 
#line 427
}  }  
#line 428
}  
#line 430
if (_Ptr2) { 
#line 431
(_Ptr2->_Index) = _Idx; 
#line 432
return *_Ptr2; 
#line 433
}  
#line 435
(_Arr) = (new _Iosarray(_Idx, _Arr)); 
#line 436
return *(_Arr); 
#line 437
} 
#line 439
void _Tidy() noexcept { 
#line 440
this->_Callfns(erase_event); 
#line 441
_Iosarray *_Ptr1; 
#line 442
_Iosarray *_Ptr2; 
#line 444
for (_Ptr1 = (_Arr); _Ptr1; _Ptr1 = _Ptr2) { 
#line 445
_Ptr2 = (_Ptr1->_Next); 
#line 446
delete _Ptr1; 
#line 447
}  
#line 448
(_Arr) = (nullptr); 
#line 450
_Fnarray *_Pfa1; 
#line 451
_Fnarray *_Pfa2; 
#line 452
for (_Pfa1 = (_Calls); _Pfa1; _Pfa1 = _Pfa2) { 
#line 453
_Pfa2 = (_Pfa1->_Next); 
#line 454
delete _Pfa1; 
#line 455
}  
#line 456
(_Calls) = (nullptr); 
#line 457
} 
#line 459
iostate _Mystate{0}; 
#line 460
iostate _Except{0}; 
#line 461
fmtflags _Fmtfl{0}; 
#line 462
streamsize _Prec{0i64}; 
#line 463
streamsize _Wide{0i64}; 
#line 464
_Iosarray *_Arr{(nullptr)}; 
#line 465
_Fnarray *_Calls{(nullptr)}; 
#line 466
locale *_Ploc{(nullptr)}; 
#line 468
static int _Index; 
#line 469
static bool _Sync; 
#line 471
static void __cdecl _Ios_base_dtor(ios_base *); 
#line 474
public: ios_base(const ios_base &) = delete;
#line 475
ios_base &operator=(const ios_base &) = delete;
#line 476
}; 
#line 477
}
#line 480
#pragma warning(pop)
#pragma pack ( pop )
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\streambuf"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 19
namespace std { 
#line 20
template < class _Elem, class _Traits >
class basic_streambuf {
protected :
     basic_streambuf ( ) : _Plocale ( new locale ) {
        _Init ( );
    }

     basic_streambuf ( _Uninitialized ) noexcept { }

     basic_streambuf ( const basic_streambuf & _Right ) : _Plocale ( new locale { _Right . getloc ( ) } ) {
        _Init ( );
        setp ( _Right . pbase ( ), _Right . pptr ( ), _Right . epptr ( ) );
        setg ( _Right . eback ( ), _Right . gptr ( ), _Right . egptr ( ) );
    }

    basic_streambuf & operator = ( const basic_streambuf & _Right ) {
        if ( this != :: std :: addressof ( _Right ) ) {
            setp ( _Right . pbase ( ), _Right . pptr ( ), _Right . epptr ( ) );
            setg ( _Right . eback ( ), _Right . gptr ( ), _Right . egptr ( ) );
            pubimbue ( _Right . getloc ( ) );
        }
        return * this;
    }

    void swap ( basic_streambuf & _Right ) noexcept {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Elem * _Pfirst0 = pbase ( );
            _Elem * _Pnext0 = pptr ( );
            _Elem * _Pend = epptr ( );
            _Elem * _Gfirst0 = eback ( );
            _Elem * _Gnext0 = gptr ( );
            _Elem * _Gend = egptr ( );

            setp ( _Right . pbase ( ), _Right . pptr ( ), _Right . epptr ( ) );
            _Right . setp ( _Pfirst0, _Pnext0, _Pend );

            setg ( _Right . eback ( ), _Right . gptr ( ), _Right . egptr ( ) );
            _Right . setg ( _Gfirst0, _Gnext0, _Gend );

            :: std :: swap ( _Plocale, _Right . _Plocale );
        }
    }

public :
    using char_type = _Elem;
    using traits_type = _Traits;

    virtual ~ basic_streambuf ( ) noexcept {
        delete _Plocale;
    }

    using int_type = typename _Traits :: int_type;
    using pos_type = typename _Traits :: pos_type;
    using off_type = typename _Traits :: off_type;

    pos_type pubseekoff ( off_type _Off, ios_base :: seekdir _Way,
        ios_base :: openmode _Mode = ios_base :: in | ios_base :: out ) {
        return seekoff ( _Off, _Way, _Mode );
    }


    pos_type pubseekoff ( off_type _Off, ios_base :: seek_dir _Way,
        ios_base :: open_mode _Mode ) {
        return pubseekoff ( _Off, static_cast < ios_base :: seekdir > ( _Way ), static_cast < ios_base :: openmode > ( _Mode ) );
    }


    pos_type pubseekpos ( pos_type _Pos,
        ios_base :: openmode _Mode = ios_base :: in | ios_base :: out ) {
        return seekpos ( _Pos, _Mode );
    }


    pos_type pubseekpos ( pos_type _Pos,
        ios_base :: open_mode _Mode ) {
        return seekpos ( _Pos, static_cast < ios_base :: openmode > ( _Mode ) );
    }


    basic_streambuf * pubsetbuf ( _Elem * _Buffer,
        streamsize _Count ) {
        return setbuf ( _Buffer, _Count );
    }

    locale pubimbue ( const locale & _Newlocale ) {
        locale _Oldlocale = * _Plocale;
        imbue ( _Newlocale );
        * _Plocale = _Newlocale;
        return _Oldlocale;
    }

    locale getloc ( ) const noexcept {
        return * _Plocale;
    }

    streamsize in_avail ( ) {
        streamsize _Res = _Gnavail ( );
        return 0 < _Res ? _Res : showmanyc ( );
    }

    int pubsync ( ) {
        return sync ( );
    }

    int_type sbumpc ( ) {
        return 0 < _Gnavail ( ) ? _Traits :: to_int_type ( * _Gninc ( ) ) : uflow ( );
    }

    int_type sgetc ( ) {
        return 0 < _Gnavail ( ) ? _Traits :: to_int_type ( * gptr ( ) ) : underflow ( );
    }

    streamsize sgetn ( _Elem * _Ptr,
        streamsize _Count ) {
        return xsgetn ( _Ptr, _Count );
    }

    int_type snextc ( ) {
        return 1 < _Gnavail ( ) ? _Traits :: to_int_type ( * _Gnpreinc ( ) )
             : _Traits :: eq_int_type ( _Traits :: eof ( ), sbumpc ( ) ) ? _Traits :: eof ( )
                                                              : sgetc ( );
    }

    int_type sputbackc ( _Elem _Ch ) {
        if ( gptr ( ) && eback ( ) < gptr ( ) && _Traits :: eq ( _Ch, gptr ( ) [ - 1 ] ) ) {
            return _Traits :: to_int_type ( * _Gndec ( ) );
        }

        return pbackfail ( _Traits :: to_int_type ( _Ch ) );
    }


    void stossc ( ) {
        if ( 0 < _Gnavail ( ) ) {
            _Gninc ( );
        } else {
            uflow ( );
        }
    }


    int_type sungetc ( ) {
        return gptr ( ) && eback ( ) < gptr ( ) ? _Traits :: to_int_type ( * _Gndec ( ) ) : pbackfail ( );
    }

    int_type sputc ( _Elem _Ch ) {
        return 0 < _Pnavail ( ) ? _Traits :: to_int_type ( * _Pninc ( ) = _Ch ) : overflow ( _Traits :: to_int_type ( _Ch ) );
    }

    streamsize sputn ( const _Elem * _Ptr,
        streamsize _Count ) {
        return xsputn ( _Ptr, _Count );
    }

    virtual void _Lock ( ) { }

    virtual void _Unlock ( ) { }

protected :
    _Elem * eback ( ) const noexcept {
        return * _IGfirst;
    }

    _Elem * gptr ( ) const noexcept {
        return * _IGnext;
    }

    _Elem * pbase ( ) const noexcept {
        return * _IPfirst;
    }

    _Elem * pptr ( ) const noexcept {
        return * _IPnext;
    }

    _Elem * egptr ( ) const noexcept {
        return * _IGnext + * _IGcount;
    }

    void gbump ( int _Off ) noexcept {

        * _IGcount -= _Off;
        * _IGnext += _Off;
    }

    void setg ( _Elem * _First, _Elem * _Next, _Elem * _Last ) noexcept {

        * _IGfirst = _First;
        * _IGnext = _Next;
        * _IGcount = static_cast < int > ( _Last - _Next );
    }

    _Elem * epptr ( ) const noexcept {
        return * _IPnext + * _IPcount;
    }

    _Elem * _Gndec ( ) noexcept {
        ++ * _IGcount;
        return -- * _IGnext;
    }

    _Elem * _Gninc ( ) noexcept {
        -- * _IGcount;
        return ( * _IGnext ) ++;
    }

    _Elem * _Gnpreinc ( ) noexcept {
        -- * _IGcount;
        return ++ ( * _IGnext );
    }

    streamsize _Gnavail ( ) const noexcept {
        return * _IGnext ? * _IGcount : 0;
    }

    void pbump ( int _Off ) noexcept {

        * _IPcount -= _Off;
        * _IPnext += _Off;
    }

    void setp ( _Elem * _First, _Elem * _Last ) noexcept {

        * _IPfirst = _First;
        * _IPnext = _First;
        * _IPcount = static_cast < int > ( _Last - _First );
    }

    void setp ( _Elem * _First, _Elem * _Next, _Elem * _Last ) noexcept {

        * _IPfirst = _First;
        * _IPnext = _Next;
        * _IPcount = static_cast < int > ( _Last - _Next );
    }

    _Elem * _Pninc ( ) noexcept {
        -- * _IPcount;
        return ( * _IPnext ) ++;
    }

    streamsize _Pnavail ( ) const noexcept {
        return * _IPnext ? * _IPcount : 0;
    }

    void _Init ( ) noexcept {
        _IGfirst = & _Gfirst;
        _IPfirst = & _Pfirst;
        _IGnext = & _Gnext;
        _IPnext = & _Pnext;
        _IGcount = & _Gcount;
        _IPcount = & _Pcount;
        setp ( nullptr, nullptr );
        setg ( nullptr, nullptr, nullptr );
    }

    void _Init ( _Elem * * _Gf, _Elem * * _Gn, int * _Gc, _Elem * * _Pf, _Elem * * _Pn, int * _Pc ) noexcept {

        _IGfirst = _Gf;
        _IPfirst = _Pf;
        _IGnext = _Gn;
        _IPnext = _Pn;
        _IGcount = _Gc;
        _IPcount = _Pc;
    }

    virtual int_type overflow ( int_type = _Traits :: eof ( ) ) {
        return _Traits :: eof ( );
    }

    virtual int_type pbackfail ( int_type = _Traits :: eof ( ) ) {

        return _Traits :: eof ( );
    }

    virtual streamsize showmanyc ( ) {
        return 0;
    }

    virtual int_type underflow ( ) {
        return _Traits :: eof ( );
    }

    virtual int_type uflow ( ) {
        return _Traits :: eq_int_type ( _Traits :: eof ( ), underflow ( ) ) ? _Traits :: eof ( ) : _Traits :: to_int_type ( * _Gninc ( ) );
    }

    virtual streamsize xsgetn ( _Elem * _Ptr, streamsize _Count ) {
        const streamsize _Start_count = _Count;

        while ( 0 < _Count ) {
            streamsize _Size = _Gnavail ( );
            if ( 0 < _Size ) {
                if ( _Count < _Size ) {
                    _Size = _Count;
                }

                _Traits :: copy ( _Ptr, gptr ( ), static_cast < size_t > ( _Size ) );
                _Ptr += _Size;
                _Count -= _Size;
                gbump ( static_cast < int > ( _Size ) );
            } else {
                const int_type _Meta = uflow ( );
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                    break;
                }


                * _Ptr ++ = _Traits :: to_char_type ( _Meta );
                -- _Count;
            }
        }

        return _Start_count - _Count;
    }

    virtual streamsize xsputn ( const _Elem * _Ptr, streamsize _Count ) {

        const streamsize _Start_count = _Count;
        while ( 0 < _Count ) {
            streamsize _Size = _Pnavail ( );
            if ( 0 < _Size ) {
                if ( _Count < _Size ) {
                    _Size = _Count;
                }

                _Traits :: copy ( pptr ( ), _Ptr, static_cast < size_t > ( _Size ) );
                _Ptr += _Size;
                _Count -= _Size;
                pbump ( static_cast < int > ( _Size ) );
            } else if ( _Traits :: eq_int_type ( _Traits :: eof ( ), overflow ( _Traits :: to_int_type ( * _Ptr ) ) ) ) {
                break;
            } else {
                ++ _Ptr;
                -- _Count;
            }
        }

        return _Start_count - _Count;
    }

    virtual pos_type seekoff (
        off_type, ios_base :: seekdir, ios_base :: openmode = ios_base :: in | ios_base :: out ) {

        return pos_type { off_type { - 1 } };
    }

    virtual pos_type seekpos ( pos_type, ios_base :: openmode = ios_base :: in | ios_base :: out ) {

        return pos_type { off_type { - 1 } };
    }

    virtual basic_streambuf * setbuf ( _Elem *, streamsize ) {

        return this;
    }

    virtual int sync ( ) {
        return 0;
    }

    virtual void imbue ( const locale & ) { }

private :
    _Elem * _Gfirst { };
    _Elem * _Pfirst { };
    _Elem * * _IGfirst { };
    _Elem * * _IPfirst { };
    _Elem * _Gnext { };
    _Elem * _Pnext { };
    _Elem * * _IGnext { };
    _Elem * * _IPnext { };

    int _Gcount { };
    int _Pcount { };
    int * _IGcount { };
    int * _IPcount { };

protected :
    locale * _Plocale { };
};
#line 412 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\streambuf"
}
#line 416
#pragma warning(pop)
#pragma pack ( pop )
#line 18 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocnum"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 25
extern "C" {
#line 27
long __cdecl _Stolx(const char *, char **, int, int *) noexcept; 
#line 29
unsigned long __cdecl _Stoulx(const char *, char **, int, int *) noexcept; 
#line 31
__int64 __cdecl _Stollx(const char *, char **, int, int *) noexcept; 
#line 33
unsigned __int64 __cdecl _Stoullx(const char *, char **, int, int *) noexcept; 
#line 36
}
#line 38
namespace std { 
#line 40
constexpr size_t _Max_int_dig = (32); 
#line 42
inline double _Stodx_v3(const char *_Str, char **_Endptr, int *_Perr) noexcept { 
#line 43
int &_Errno_ref = *_errno(); 
#line 44
const int _Orig = _Errno_ref; 
#line 46
_Errno_ref = 0; 
#line 47
double _Val = ::strtod(_Str, _Endptr); 
#line 48
(*_Perr) = _Errno_ref; 
#line 49
_Errno_ref = _Orig; 
#line 51
return _Val; 
#line 52
} 
#line 54
inline float _Stofx_v3(const char *_Str, char **_Endptr, int *_Perr) noexcept { 
#line 55
int &_Errno_ref = *_errno(); 
#line 56
const int _Orig = _Errno_ref; 
#line 58
_Errno_ref = 0; 
#line 59
float _Val = ::strtof(_Str, _Endptr); 
#line 60
(*_Perr) = _Errno_ref; 
#line 61
_Errno_ref = _Orig; 
#line 63
return _Val; 
#line 64
} 
#line 66
template < class _Elem, size_t _Base_size >
size_t _Find_elem ( const _Elem ( & _Base ) [ _Base_size ], const _Elem _Ch ) {


    return static_cast < size_t > ( :: std :: _Find_unchecked ( _Base, _Base + ( _Base_size - 1 ), _Ch ) - _Base );
}
#line 73
inline __wchar_t *_Maklocwcs(const __wchar_t *_Ptr) { 
#line 74
const size_t _Count = ::wcslen(_Ptr) + (1); 
#line 76
__wchar_t *_Ptrdest = static_cast< __wchar_t *>(calloc(_Count, sizeof(__wchar_t))); 
#line 78
if (!_Ptrdest) { 
#line 79
_Xbad_alloc(); 
#line 80
}  
#line 82
::wmemcpy(_Ptrdest, _Ptr, _Count); 
#line 83
return _Ptrdest; 
#line 84
} 
#line 86
template < class _Elem >
class numpunct : public locale :: facet {
private :
    friend _Tidy_guard < numpunct >;

public :
    static_assert ( ! 0 || _Is_any_of_v < _Elem, char, wchar_t >, "Unsupported facet specialization; see N4950 [locale.category]. Either use a Standard specialization or define _ENFORCE_FACET_SPE" "CIALIZATIONS=0 to suppress this error." );

    using string_type = basic_string < _Elem, char_traits < _Elem >, allocator < _Elem >>;
    using char_type = _Elem;

      static locale :: id id;

    _Elem decimal_point ( ) const {
        return do_decimal_point ( );
    }

    _Elem thousands_sep ( ) const {
        return do_thousands_sep ( );
    }

    string grouping ( ) const {
        return do_grouping ( );
    }

    string_type falsename ( ) const {
        return do_falsename ( );
    }

    string_type truename ( ) const {
        return do_truename ( );
    }

    explicit numpunct ( size_t _Refs = 0 ) : locale :: facet ( _Refs ) {
        { _Locinfo _Lobj;
        _Init ( _Lobj );
        if ( _Kseparator == 0 ) {
            _Kseparator =
                _Maklocchr ( ',', static_cast < _Elem * > ( nullptr ), _Lobj . _Getcvt ( ) );
        }
        }
    }

    numpunct ( const _Locinfo & _Lobj, size_t _Refs = 0, bool _Isdef = false ) : locale :: facet ( _Refs ) {
        _Init ( _Lobj, _Isdef );
    }

    static size_t _Getcat ( const locale :: facet * * _Ppf = nullptr, const locale * _Ploc = nullptr ) {

        if ( _Ppf && ! * _Ppf ) {
            * _Ppf = new numpunct < _Elem > ( _Locinfo ( _Ploc -> _C_str ( ) ), 0, true );
        }
        return 4;
    }

protected :
     ~ numpunct ( ) noexcept override {
        _Tidy ( );
    }

    numpunct ( const char * _Locname, size_t _Refs = 0, bool _Isdef = false ) : locale :: facet ( _Refs ) {
        { _Locinfo _Lobj ( _Locname );
        _Init ( _Lobj, _Isdef );
        }
    }

    void _Init ( const _Locinfo & _Lobj, bool _Isdef = false ) {
        const lconv * _Ptr = _Lobj . _Getlconv ( );
        _Locinfo :: _Cvtvec _Cvt = _Lobj . _Getcvt ( );

        _Grouping = nullptr;
        _Falsename = nullptr;
        _Truename = nullptr;

        _Tidy_guard < numpunct > _Guard { this };
        _Grouping = _Maklocstr ( _Isdef ? "" : _Ptr -> grouping, static_cast < char * > ( nullptr ), _Cvt );
        _Falsename = _Maklocstr ( _Lobj . _Getfalse ( ), static_cast < _Elem * > ( nullptr ), _Cvt );
        _Truename = _Maklocstr ( _Lobj . _Gettrue ( ), static_cast < _Elem * > ( nullptr ), _Cvt );
        _Guard . _Target = nullptr;

        if ( _Isdef ) {
            _Dp = _Maklocchr ( '.', static_cast < _Elem * > ( nullptr ), _Cvt );
            _Kseparator = _Maklocchr ( ',', static_cast < _Elem * > ( nullptr ), _Cvt );
        } else {
            if constexpr ( is_same_v < _Elem, wchar_t > ) {
                _Dp = _Ptr -> _W_decimal_point [ 0 ];
                _Kseparator = _Ptr -> _W_thousands_sep [ 0 ];
            } else {
                _Dp = _Maklocchr ( _Ptr -> decimal_point [ 0 ], static_cast < _Elem * > ( nullptr ), _Cvt );
                _Kseparator = _Maklocchr ( _Ptr -> thousands_sep [ 0 ], static_cast < _Elem * > ( nullptr ), _Cvt );
            }
        }
    }

    virtual _Elem do_decimal_point ( ) const {
        return _Dp;
    }

    virtual _Elem do_thousands_sep ( ) const {
        return _Kseparator;
    }

    virtual string do_grouping ( ) const {
        return string { _Grouping };
    }

    virtual string_type do_falsename ( ) const {
        return string_type { _Falsename };
    }

    virtual string_type do_truename ( ) const {
        return string_type { _Truename };
    }

private :
    void _Tidy ( ) noexcept {
        :: free ( const_cast < char * > ( _Grouping ) );
        :: free ( const_cast < _Elem * > ( _Falsename ) );
        :: free ( const_cast < _Elem * > ( _Truename ) );
    }

    const char * _Grouping;
    _Elem _Dp;
    _Elem _Kseparator;
    const _Elem * _Falsename;
    const _Elem * _Truename;
};
#line 214
template < class _Elem >
class numpunct_byname : public numpunct < _Elem > {
public :
    static_assert ( ! 0 || _Is_any_of_v < _Elem, char, wchar_t >, "Unsupported facet specialization; see N4950 [locale.category]. Either use a Standard specialization or define _ENFORCE_FACET_SPE" "CIALIZATIONS=0 to suppress this error." );

    explicit numpunct_byname ( const char * _Locname, size_t _Refs = 0 )
        : numpunct < _Elem > ( _Locname, _Refs ) { }

    explicit numpunct_byname ( const string & _Str, size_t _Refs = 0 )
        : numpunct < _Elem > ( _Str . c_str ( ), _Refs ) { }

protected :
     ~ numpunct_byname ( ) noexcept override { }
};
#line 235
template< class _Elem> locale::id 
#line 236
numpunct< _Elem> ::id; 
#line 243 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocnum"
struct _Num_get_parse_result { 
#line 247
int8_t _Base; 
#line 248
bool _Bad_grouping; 
#line 249
}; 
#line 251
template < class _Elem, class _InIt = istreambuf_iterator < _Elem, char_traits < _Elem > > >
class num_get : public locale :: facet {
public :
    static_assert ( ! 0 || _Is_any_of_v < _Elem, char, wchar_t >, "Unsupported facet specialization; see N4950 [locale.category]. Either use a Standard specialization or define _ENFORCE_FACET_SPE" "CIALIZATIONS=0 to suppress this error." );

    static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = nullptr, const locale * _Ploc = nullptr ) {

        if ( _Ppf && ! * _Ppf ) {
            * _Ppf = new num_get < _Elem, _InIt > ( _Locinfo ( _Ploc -> _C_str ( ) ) );
        }

        return 4;
    }

     static locale :: id id;

protected :
     ~ num_get ( ) noexcept override { }

    void _Init ( const _Locinfo & ) { }

public :
    explicit num_get ( size_t _Refs = 0 ) : locale :: facet ( _Refs ) {
        { _Locinfo _Lobj;
        _Init ( _Lobj );
        }
    }

     num_get ( const _Locinfo & _Lobj, size_t _Refs = 0 ) : locale :: facet ( _Refs ) {
        _Init ( _Lobj );
    }

    using char_type = _Elem;
    using iter_type = _InIt;

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        bool & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        unsigned short & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        unsigned int & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        long & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        unsigned long & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        long long & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        unsigned long long & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        float & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        double & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        long double & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        void * & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

protected :
    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        bool & _Val ) const {
        _Adl_verify_range ( _First, _Last );
        if ( _Iosbase . flags ( ) & ios_base :: boolalpha ) {
            const auto & _Punct_fac = :: std :: use_facet < numpunct < _Elem >> ( _Iosbase . getloc ( ) );
            basic_string < _Elem > _Str ( static_cast < size_t > ( 1 ), _Elem { } );
            _Str += _Punct_fac . falsename ( );
            _Str . push_back ( _Elem { } );
            _Str += _Punct_fac . truename ( );
            switch ( _Getloctxt ( _First, _Last, 2, _Str . c_str ( ), _Case_sensitive :: _Yes ) ) {
            case 0 :
                _Val = false;
                break;
            case 1 :
                _Val = true;
                break;
            default :
                _Val = false;
                _State = ios_base :: failbit;
                break;
            }
        } else {
            char _Ac [ _Max_int_dig ];
            const auto _Parse_result =
                _Parse_int_with_locale ( _Ac, _First, _Last, _Iosbase . flags ( ), _Iosbase . getloc ( ) );
            if ( _Parse_result . _Base < 0 ) {


                _Val = false;
                _State = ios_base :: failbit;
            } else {
                char * _Ep;
                int _Errno;
                const long _Ans = :: _Stolx ( _Ac, & _Ep, _Parse_result . _Base, & _Errno );
                if ( _Ep == _Ac || _Errno != 0
                    || _Parse_result . _Bad_grouping ) {
                    _Val = true;
                    _State = ios_base :: failbit;
                } else {
                    _Val = _Ans != 0;
                    if ( _Ans != 0 && _Ans != 1 ) {
                        _State = ios_base :: failbit;
                    }
                }
            }
        }

        if ( _First == _Last ) {
            _State |= ios_base :: eofbit;
        }

        return _First;
    }

    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        unsigned short & _Val ) const {
        _Adl_verify_range ( _First, _Last );
        char _Ac [ _Max_int_dig ];
        const auto _Parse_result =
            _Parse_int_with_locale ( _Ac, _First, _Last, _Iosbase . flags ( ), _Iosbase . getloc ( ) );
        if ( _Parse_result . _Base < 0 ) {
            _State = ios_base :: failbit;
            _Val = 0;
        } else {
            const bool _Minus = _Ac [ 0 ] == '-';
            const char * _Digits = _Ac;


            if ( _Minus ) {
                ++ _Digits;
            }

            char * _Ep;
            int _Errno;
            const unsigned long _Tmp = :: _Stoulx ( _Digits, & _Ep, _Parse_result . _Base, & _Errno );
            _Val = static_cast < unsigned short > ( _Tmp );
            if ( _Ep == _Digits || _Errno != 0 || _Tmp > 65535 ) {
                _State = ios_base :: failbit;
                _Val = 65535;
            } else if ( _Minus ) {

                _Val = static_cast < unsigned short > ( 0 - _Val );
            }

            if ( _Parse_result . _Bad_grouping ) {
                _State = ios_base :: failbit;
            }
        }

        if ( _First == _Last ) {
            _State |= ios_base :: eofbit;
        }

        return _First;
    }

    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        unsigned int & _Val ) const {
        static_assert ( sizeof ( unsigned int ) == sizeof ( unsigned long ),
            "Bad overflow assumptions due to sizeof(unsigned int) != sizeof(unsigned long)" );
        unsigned long _Tmp;
        _First = num_get :: do_get ( _First, _Last, _Iosbase, _State, _Tmp );
        _Val = _Tmp;
        return _First;
    }

    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        long & _Val ) const {
        _Adl_verify_range ( _First, _Last );
        char _Ac [ _Max_int_dig ];
        const auto _Parse_result =
            _Parse_int_with_locale ( _Ac, _First, _Last, _Iosbase . flags ( ), _Iosbase . getloc ( ) );
        if ( _Parse_result . _Base < 0 ) {
            _State = ios_base :: failbit;
            _Val = 0;
        } else {
            char * _Ep;
            int _Errno;
            _Val = :: _Stolx ( _Ac, & _Ep, _Parse_result . _Base, & _Errno );
            if ( _Ep == _Ac || _Errno != 0
                || _Parse_result . _Bad_grouping ) {
                _State = ios_base :: failbit;
            }
        }

        if ( _First == _Last ) {
            _State |= ios_base :: eofbit;
        }

        return _First;
    }

    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        unsigned long & _Val ) const {
        _Adl_verify_range ( _First, _Last );
        char _Ac [ _Max_int_dig ];
        const auto _Parse_result =
            _Parse_int_with_locale ( _Ac, _First, _Last, _Iosbase . flags ( ), _Iosbase . getloc ( ) );
        if ( _Parse_result . _Base < 0 ) {
            _State = ios_base :: failbit;
            _Val = 0;
        } else {
            char * _Ep;
            int _Errno;
            _Val = :: _Stoulx ( _Ac, & _Ep, _Parse_result . _Base, & _Errno );
            if ( _Ep == _Ac || _Errno != 0
                || _Parse_result . _Bad_grouping ) {
                _State = ios_base :: failbit;
            }
        }

        if ( _First == _Last ) {
            _State |= ios_base :: eofbit;
        }

        return _First;
    }

    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        long long & _Val ) const {
        _Adl_verify_range ( _First, _Last );
        char _Ac [ _Max_int_dig ];
        const auto _Parse_result =
            _Parse_int_with_locale ( _Ac, _First, _Last, _Iosbase . flags ( ), _Iosbase . getloc ( ) );
        if ( _Parse_result . _Base < 0 ) {
            _State = ios_base :: failbit;
            _Val = 0;
        } else {
            char * _Ep;
            int _Errno;
            _Val = :: _Stollx ( _Ac, & _Ep, _Parse_result . _Base, & _Errno );
            if ( _Ep == _Ac || _Errno != 0
                || _Parse_result . _Bad_grouping ) {
                _State = ios_base :: failbit;
            }
        }

        if ( _First == _Last ) {
            _State |= ios_base :: eofbit;
        }

        return _First;
    }

    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        unsigned long long & _Val ) const {
        _Adl_verify_range ( _First, _Last );
        char _Ac [ _Max_int_dig ];
        const auto _Parse_result =
            _Parse_int_with_locale ( _Ac, _First, _Last, _Iosbase . flags ( ), _Iosbase . getloc ( ) );
        if ( _Parse_result . _Base < 0 ) {
            _State = ios_base :: failbit;
            _Val = 0;
        } else {
            int _Errno;
            char * _Ep;
            _Val = :: _Stoullx ( _Ac, & _Ep, _Parse_result . _Base, & _Errno );
            if ( _Ep == _Ac || _Errno != 0
                || _Parse_result . _Bad_grouping ) {
                _State = ios_base :: failbit;
            }
        }

        if ( _First == _Last ) {
            _State |= ios_base :: eofbit;
        }

        return _First;
    }






    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        float & _Val ) const {
        _Adl_verify_range ( _First, _Last );
        char _Ac [ ( 8 + 768 + 16 ) ];
        const auto _Parse_result =
            _Parse_fp_with_locale ( _Ac, 768, _First, _Last, _Iosbase . getloc ( ) );
        if ( _Parse_result . _Base == 0 ) {
            _State = ios_base :: failbit;
            _Val = (0.0F);
        } else {
            int _Errno;
            char * _Ep;
            _Val = :: std :: _Stofx_v3 ( _Ac, & _Ep, & _Errno );
            if ( _Ep == _Ac || _Errno != 0
                || _Parse_result . _Bad_grouping ) {
                _State = ios_base :: failbit;
            }
        }

        if ( _First == _Last ) {
            _State |= ios_base :: eofbit;
        }

        return _First;
    }

    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        double & _Val ) const {
        _Adl_verify_range ( _First, _Last );
        char _Ac [ ( 8 + 768 + 16 ) ];
        const auto _Parse_result =
            _Parse_fp_with_locale ( _Ac, 768, _First, _Last, _Iosbase . getloc ( ) );
        if ( _Parse_result . _Base == 0 ) {
            _State = ios_base :: failbit;
            _Val = (0.0);
        } else {
            int _Errno;
            char * _Ep;
            _Val = :: std :: _Stodx_v3 ( _Ac, & _Ep, & _Errno );
            if ( _Ep == _Ac || _Errno != 0
                || _Parse_result . _Bad_grouping ) {
                _State = ios_base :: failbit;
            }
        }

        if ( _First == _Last ) {
            _State |= ios_base :: eofbit;
        }

        return _First;
    }



    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        long double & _Val ) const {



        double _Result;
        _First = num_get :: do_get ( _First, _Last, _Iosbase, _State, _Result );
        _Val = _Result;
        return _First;
    }

    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        void * & _Val ) const {
        _Adl_verify_range ( _First, _Last );
        char _Ac [ _Max_int_dig ];
        const auto _Parse_result =
            _Parse_int_with_locale ( _Ac, _First, _Last, ios_base :: hex, _Iosbase . getloc ( ) );
        if ( _Parse_result . _Base < 0 ) {
            _State = ios_base :: failbit;
            _Val = nullptr;
        } else {
            int _Errno;
            char * _Ep;

            _Val = reinterpret_cast < void * > ( :: _Stoullx ( _Ac, & _Ep, _Parse_result . _Base, & _Errno ) );



            if ( _Ep == _Ac || _Errno != 0 ) {
                _State = ios_base :: failbit;
                _Val = nullptr;
            }

            if ( _Parse_result . _Bad_grouping ) {
                _State = ios_base :: failbit;
            }
        }

        if ( _First == _Last ) {
            _State |= ios_base :: eofbit;
        }

        return _First;
    }

private :
    template < int = 0 >
    static _Num_get_parse_result _Parse_int_with_locale (
        char * const _Ac, _InIt & _First, _InIt & _Last, ios_base :: fmtflags _Basefield, const locale & _Loc ) {

        const auto & _Punct_fac = :: std :: use_facet < numpunct < _Elem >> ( _Loc );
        const string _Grouping = _Punct_fac . grouping ( );
        const _Elem _Kseparator = _Grouping . empty ( ) ? _Elem { } : _Punct_fac . thousands_sep ( );

        constexpr int _Numget_signoff = 22;
        constexpr int _Numget_xoff = 24;
        static constexpr char _Src [ ] = "0123456789ABCDEFabcdef-+Xx";
        _Elem _Atoms [ sizeof ( _Src ) ];
        const ctype < _Elem > & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Loc );
        _Ctype_fac . widen ( :: std :: begin ( _Src ), :: std :: end ( _Src ), _Atoms );

        bool _Bad_grouping = false;


        if ( _Kseparator != _Elem { } ) {
            while ( _First != _Last && * _First == _Kseparator ) {
                ++ _First;
                _Bad_grouping = true;
            }
        }

        char * _Ptr = _Ac;

        if ( _First != _Last ) {
            if ( * _First == _Atoms [ _Numget_signoff + 1 ] ) {
                * _Ptr ++ = '+';
                ++ _First;
            } else if ( * _First == _Atoms [ _Numget_signoff ] ) {
                * _Ptr ++ = '-';
                ++ _First;
            }
        }


        if ( _Kseparator != _Elem { } ) {
            while ( _First != _Last && * _First == _Kseparator ) {
                ++ _First;
                _Bad_grouping = true;
            }
        }

        _Basefield &= ios_base :: basefield;

        int8_t _Base;
        if ( _Basefield == ios_base :: oct ) {
            _Base = 8;
        } else if ( _Basefield == ios_base :: hex ) {
            _Base = 16;
        } else if ( _Basefield == ios_base :: _Fmtzero ) {
            _Base = 0;
        } else {
            _Base = 10;
        }

        bool _Seendigit = false;
        bool _Nonzero = false;

        if ( _First != _Last && * _First == _Atoms [ 0 ] ) {
            _Seendigit = true;
            ++ _First;
            if ( _First != _Last && ( * _First == _Atoms [ _Numget_xoff + 1 ] || * _First == _Atoms [ _Numget_xoff ] )
                && ( _Base == 0 || _Base == 16 ) ) {
                _Base = 16;
                _Seendigit = false;
                ++ _First;
            } else if ( _Base == 0 ) {
                _Base = 8;
            }
        }

        const auto _Dlen = static_cast < size_t > ( _Base == 0 || _Base == 10 ? 10 : _Base == 8 ? 8 : 16 + 6 );
        string _Groups ( 1, static_cast < char > ( _Seendigit ) );
        size_t _Groups_arr_idx = 0;

        for ( char * const _Pe = & _Ac [ _Max_int_dig - 1 ]; _First != _Last; ++ _First ) {
            size_t _Idx = :: std :: _Find_elem ( _Atoms, * _First );
            if ( _Idx < _Dlen ) {
                * _Ptr = _Src [ _Idx ];
                if ( ( _Nonzero || * _Ptr != '0' ) && _Ptr < _Pe ) {
                    ++ _Ptr;
                    _Nonzero = true;
                }

                _Seendigit = true;
                if ( _Groups [ _Groups_arr_idx ] != 127 ) {
                    ++ _Groups [ _Groups_arr_idx ];
                }
            } else if ( _Kseparator == _Elem { } || * _First != _Kseparator ) {
                break;
            } else if ( _Groups [ _Groups_arr_idx ] == '\000' ) {
                _Bad_grouping = true;
            } else {
                _Groups . push_back ( '\000' );
                ++ _Groups_arr_idx;
            }
        }

        if ( _Groups_arr_idx != 0 ) {
            if ( _Groups [ _Groups_arr_idx ] > '\000' ) {
                ++ _Groups_arr_idx;
            } else {
                _Bad_grouping = true;
            }
        }


        if ( _Kseparator != _Elem { } ) {
            while ( _First != _Last && * _First == _Kseparator ) {
                ++ _First;
                _Bad_grouping = true;
            }
        }

        const char * _Grouping_iter = _Grouping . data ( );
        const char * const _Grouping_end = _Grouping_iter + _Grouping . size ( );
        for ( char _Current_grouping_count = '\000'; _Seendigit && ! _Bad_grouping && _Groups_arr_idx > 0; ) {
            if ( _Grouping_iter != _Grouping_end ) {
                _Current_grouping_count = * _Grouping_iter;
                ++ _Grouping_iter;
            }

            -- _Groups_arr_idx;
            if ( ( _Current_grouping_count > '\000' && _Current_grouping_count != 127 )
                && ( ( _Groups_arr_idx > 0 && _Groups [ _Groups_arr_idx ] != _Current_grouping_count )
                    || ( _Groups_arr_idx == 0 && _Groups [ _Groups_arr_idx ] > _Current_grouping_count ) ) ) {
                _Bad_grouping = true;
            }

        }

        if ( ! _Seendigit ) {
            return { static_cast < int8_t > ( ~ _Base ), false };
        }

        if ( ! _Nonzero ) {
            * _Ptr ++ = '0';
        }

        * _Ptr = '\000';
        return { _Base, _Bad_grouping };
    }

    template < int = 0 >
    static _Num_get_parse_result _Parse_fp_with_locale (
        char * const _Ac, const int _Max_sig_dig, _InIt & _First, _InIt & _Last, const locale & _Loc ) {

        char * _Ptr = _Ac;

        constexpr size_t _Offset_dec_digit_end = 10;
        constexpr size_t _Offset_hex_digit_end = 22;
        constexpr size_t _Offset_neg_sign = 22;
        constexpr size_t _Offset_pos_sign = 23;
        constexpr size_t _Offset_upper_x = 24;
        constexpr size_t _Offset_lower_x = 25;
        constexpr size_t _Offset_upper_p = 26;
        constexpr size_t _Offset_lower_p = 27;
        constexpr size_t _Offset_upper_e = 14;
        constexpr size_t _Offset_lower_e = 20;
        static constexpr char _Src [ ] = "0123456789ABCDEFabcdef-+XxPp";
        _Elem _Atoms [ sizeof ( _Src ) ];
        const auto & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Loc );
        _Ctype_fac . widen ( :: std :: begin ( _Src ), :: std :: end ( _Src ), _Atoms );

        const _Elem _Positive_sign = _Atoms [ _Offset_pos_sign ];
        const _Elem _Negative_sign = _Atoms [ _Offset_neg_sign ];
        const _Elem _Zero_wc = _Atoms [ 0 ];

        const auto & _Punct_fac = :: std :: use_facet < numpunct < _Elem >> ( _Loc );
        const string _Grouping = _Punct_fac . grouping ( );
        const _Elem _Kseparator = _Grouping . empty ( ) ? _Elem { } : _Punct_fac . thousands_sep ( );

        bool _Bad_grouping = false;


        if ( ! _Grouping . empty ( ) ) {
            while ( _First != _Last && * _First == _Kseparator ) {
                ++ _First;
                _Bad_grouping = true;
            }
        }

        if ( _First != _Last ) {
            if ( * _First == _Positive_sign ) {
                * _Ptr ++ = '+';
                ++ _First;
            } else if ( * _First == _Negative_sign ) {
                * _Ptr ++ = '-';
                ++ _First;
            }
        }

        * _Ptr ++ = '0';

        bool _Parse_hex = false;
        bool _Seendigit = false;
        char _Initial_dec_leading_zero = '\000';
        if ( _First != _Last && * _First == _Zero_wc ) {
            ++ _First;
            if ( _First == _Last ) {
                * _Ptr = '\000';
                return { 10, _Bad_grouping };
            }

            if ( * _First == _Atoms [ _Offset_lower_x ] || * _First == _Atoms [ _Offset_upper_x ] ) {
                _Parse_hex = true;
                ++ _First;
                * _Ptr ++ = 'x';
            } else {
                _Seendigit = true;
                ++ _Initial_dec_leading_zero;
            }
        }

        bool _Has_unaccumulated_digits = false;
        int _Significant = 0;
        ptrdiff_t _Power_of_rep_base = 0;

        const size_t _Offset_digit_end = _Parse_hex ? _Offset_hex_digit_end : _Offset_dec_digit_end;
        if ( _Grouping . empty ( ) ) {
            for ( size_t _Idx; _First != _Last && ( _Idx = :: std :: _Find_elem ( _Atoms, * _First ) ) < _Offset_digit_end;
                _Seendigit = true, ( void ) ++ _First ) {
                if ( _Significant >= _Max_sig_dig ) {
                    ++ _Power_of_rep_base;
                    if ( _Idx > 0 ) {
                        _Has_unaccumulated_digits = true;
                    }
                } else if ( _Idx != 0 || _Significant != 0 ) {
                    * _Ptr ++ = _Src [ _Idx ];
                    ++ _Significant;
                }
            }
        } else {

            while ( _First != _Last && * _First == _Kseparator ) {
                ++ _First;
                _Bad_grouping = true;
            }

            string _Groups ( 1, _Initial_dec_leading_zero );
            size_t _Groups_arr_idx = 0;

            for (; _First != _Last; ++ _First ) {
                const size_t _Idx = :: std :: _Find_elem ( _Atoms, * _First );
                if ( _Idx < _Offset_digit_end ) {
                    _Seendigit = true;
                    if ( _Significant >= _Max_sig_dig ) {
                        ++ _Power_of_rep_base;
                        if ( _Idx > 0 ) {
                            _Has_unaccumulated_digits = true;
                        }
                    } else if ( _Idx != 0 || _Significant != 0 ) {
                        * _Ptr ++ = _Src [ _Idx ];
                        ++ _Significant;
                    }

                    if ( _Groups [ _Groups_arr_idx ] != 127 ) {
                        ++ _Groups [ _Groups_arr_idx ];
                    }
                } else if ( * _First != _Kseparator ) {
                    break;
                } else if ( _Groups [ _Groups_arr_idx ] == '\000' ) {
                    _Bad_grouping = true;
                } else {
                    _Groups . push_back ( '\000' );
                    ++ _Groups_arr_idx;
                }
            }

            if ( _Groups_arr_idx != 0 ) {
                if ( _Groups [ _Groups_arr_idx ] > '\000' ) {
                    ++ _Groups_arr_idx;
                } else {
                    _Bad_grouping = true;
                }
            }


            while ( _First != _Last && * _First == _Kseparator ) {
                ++ _First;
                _Bad_grouping = true;
            }

            const char * _Grouping_iter = _Grouping . data ( );
            const char * const _Grouping_end = _Grouping_iter + _Grouping . size ( );
            char _Current_grouping_count = '\000';
            while ( ! _Bad_grouping && _Groups_arr_idx > 0 ) {
                if ( _Grouping_iter != _Grouping_end ) {
                    _Current_grouping_count = * _Grouping_iter;
                    ++ _Grouping_iter;
                }

                -- _Groups_arr_idx;
                if ( ( _Current_grouping_count > '\000' && _Current_grouping_count != 127 )
                    && ( ( _Groups_arr_idx > 0 && _Groups [ _Groups_arr_idx ] != _Current_grouping_count )
                        || ( _Groups_arr_idx == 0 && _Groups [ _Groups_arr_idx ] > _Current_grouping_count ) ) ) {
                    _Bad_grouping = true;
                }

            }
        }

        if ( _Parse_hex && _Seendigit && _Significant == 0 ) {

            * _Ptr ++ = '0';
        }

        const char _Decimal_point = ( :: localeconv ( ) ) -> decimal_point [ 0 ];
        if ( _First != _Last && * _First == _Punct_fac . decimal_point ( ) ) {
            * _Ptr ++ = _Decimal_point;
            ++ _First;
        }

        if ( _Significant == 0 ) {
            for (; _First != _Last && * _First == _Zero_wc; _Seendigit = true, ( void ) ++ _First ) {
                -- _Power_of_rep_base;
            }
        }

        for ( size_t _Idx; _First != _Last && ( _Idx = :: std :: _Find_elem ( _Atoms, * _First ) ) < _Offset_digit_end;
            _Seendigit = true, ( void ) ++ _First ) {
            if ( _Significant < _Max_sig_dig ) {
                * _Ptr ++ = _Src [ _Idx ];
                ++ _Significant;
            } else if ( _Idx > 0 ) {
                _Has_unaccumulated_digits = true;
            }
        }

        if ( _Has_unaccumulated_digits ) {
            char & _Last_got_digit = _Ptr [ - 1 ] == _Decimal_point ? _Ptr [ - 2 ] : _Ptr [ - 1 ];
            if ( _Last_got_digit == '0' || _Last_got_digit == ( _Parse_hex ? '8' : '5' ) ) {
                ++ _Last_got_digit;
            }
        }

        const _Elem _Lower_exp_wc = _Atoms [ _Parse_hex ? _Offset_lower_p : _Offset_lower_e ];
        const _Elem _Upper_exp_wc = _Atoms [ _Parse_hex ? _Offset_upper_p : _Offset_upper_e ];

        bool _Exponent_part_negative = false;
        ptrdiff_t _Exponent_part = 0;
        if ( _Seendigit && _First != _Last
            && ( * _First == _Lower_exp_wc || * _First == _Upper_exp_wc ) ) {
            ++ _First;
            _Seendigit = false;
            _Significant = 0;

            if ( _First != _Last ) {
                if ( * _First == _Positive_sign ) {
                    ++ _First;
                } else if ( * _First == _Negative_sign ) {
                    _Exponent_part_negative = true;
                    ++ _First;
                }
            }

            for (; _First != _Last && * _First == _Zero_wc; ++ _First ) {
                _Seendigit = true;
            }

            for ( size_t _Idx; _First != _Last && ( _Idx = :: std :: _Find_elem ( _Atoms, * _First ) ) < _Offset_dec_digit_end;
                _Seendigit = true, ( void ) ++ _First ) {
                if ( _Exponent_part < 9223372036854775807i64 / 10
                    || ( _Exponent_part == 9223372036854775807i64 / 10
                        && static_cast < ptrdiff_t > ( _Idx ) <= 9223372036854775807i64 % 10 ) ) {
                    _Exponent_part = _Exponent_part * 10 + static_cast < ptrdiff_t > ( _Idx );
                } else {
                    _Exponent_part = 9223372036854775807i64;
                }
            }

            if ( _Exponent_part_negative ) {
                _Exponent_part = - _Exponent_part;
            }
        }

        if ( ! _Seendigit ) {
            return { 0, false };
        }

        constexpr int _Dec_exp_abs_bound = 1100;
        constexpr int _Hex_exp_abs_bound = 4200;

        const ptrdiff_t _Exp_abs_bound = _Parse_hex ? _Hex_exp_abs_bound : _Dec_exp_abs_bound;
        const ptrdiff_t _Exp_rep_abs_bound = _Parse_hex ? _Hex_exp_abs_bound / 4 : _Dec_exp_abs_bound;




        for ( ptrdiff_t _Power_of_rep_adjusted = _Power_of_rep_base;; ) {
            if ( _Exponent_part >= 0 && _Power_of_rep_adjusted >= 0
                && ( _Exponent_part >= _Exp_abs_bound || _Power_of_rep_adjusted >= _Exp_rep_abs_bound ) ) {
                _Exponent_part = _Exp_abs_bound;
                break;
            } else if ( _Exponent_part <= 0 && _Power_of_rep_adjusted <= 0
                       && ( _Exponent_part <= - _Exp_abs_bound || _Power_of_rep_adjusted <= - _Exp_rep_abs_bound ) ) {
                _Exponent_part = - _Exp_abs_bound;
                break;
            } else if ( :: std :: abs ( _Exponent_part ) <= _Exp_abs_bound
                       && :: std :: abs ( _Power_of_rep_adjusted ) <= _Exp_rep_abs_bound ) {

                _Exponent_part += _Parse_hex ? _Power_of_rep_adjusted * 4 : _Power_of_rep_adjusted;
                if ( _Exponent_part > _Exp_abs_bound ) {
                    _Exponent_part = _Exp_abs_bound;
                } else if ( _Exponent_part < - _Exp_abs_bound ) {
                    _Exponent_part = - _Exp_abs_bound;
                }
                break;
            } else {


                const ptrdiff_t _Exponent_part_preadjustment_round_up =
                    _Parse_hex ? ( :: std :: abs ( _Exponent_part ) - 1 ) / 4 + 1 : :: std :: abs ( _Exponent_part );
                const ptrdiff_t _Exp_rep_adjustment =
                    ( :: std :: min ) ( _Exponent_part_preadjustment_round_up, :: std :: abs ( _Power_of_rep_base ) );

                if ( _Exponent_part >= 0 ) {
                    _Exponent_part -= _Parse_hex ? _Exp_rep_adjustment * 4 : _Exp_rep_adjustment;
                    _Power_of_rep_adjusted += _Exp_rep_adjustment;
                } else {
                    _Exponent_part += _Parse_hex ? _Exp_rep_adjustment * 4 : _Exp_rep_adjustment;
                    _Power_of_rep_adjusted -= _Exp_rep_adjustment;
                }
            }
        }

        if ( _Exponent_part != 0 ) {
            * _Ptr ++ = _Parse_hex ? 'p' : 'e';
            if ( _Exponent_part < 0 ) {
                * _Ptr ++ = '-';
            }

            char * const _Rev_begin = _Ptr;
            for ( ptrdiff_t _Exponent_part_abs = :: std :: abs ( _Exponent_part ); _Exponent_part_abs != 0;
                _Exponent_part_abs /= 10 ) {
                * _Ptr ++ = static_cast < char > ( '0' + _Exponent_part_abs % 10 );
            }
            :: std :: reverse ( _Rev_begin, _Ptr );
        }

        * _Ptr = '\000';
        return { static_cast < int8_t > ( _Parse_hex ? 16 : 10 ), _Bad_grouping };
    }


    int __cdecl _Getifld (
        char * _Ac, _InIt & _First, _InIt & _Last, ios_base :: fmtflags _Basefield, const locale & _Loc ) const {

        static constexpr char _Src [ ] = "0123456789ABCDEFabcdef-+Xx";
        const char * volatile _Ptr = _Src;
        ( void ) _Ptr;

        const auto _Parse_result = _Parse_int_with_locale ( _Ac, _First, _Last, _Basefield, _Loc );
        if ( _Parse_result . _Base < 0 || _Parse_result . _Bad_grouping ) {
            * _Ac = '\000';
        }
        return _Parse_result . _Base < 0 ? ~ _Parse_result . _Base : _Parse_result . _Base;
    }







    int __cdecl _Getffld ( char * _Ac, _InIt & _First, _InIt & _Last, ios_base & _Iosbase, int * _Phexexp ) const {

        static constexpr char _Src [ ] = "0123456789-+Ee";
        const char * volatile _Ptr = & _Src [ 0 ];
        ( void ) _Ptr;
        const int _Max_sig_dig = ( * _Phexexp == 1000000000 ? 768 : 36 );
        const auto _Parse_result = _Parse_fp_with_locale ( _Ac, _Max_sig_dig, _First, _Last, _Iosbase . getloc ( ) );
        if ( _Parse_result . _Base == 0 || _Parse_result . _Bad_grouping ) {
            * _Ac = '\000';
        }

        if ( _Parse_result . _Base == 16 ) {
            * _Phexexp = 0;
        }
        return 0;
    }


    int __cdecl _Getffldx ( char * _Ac, _InIt & _First, _InIt & _Last, ios_base & _Iosbase, int * _Phexexp ) const {

        static constexpr char _Src [ ] = "0123456789ABCDEFabcdef-+XxPp";
        const char * volatile _Ptr = & _Src [ 0 ];
        ( void ) _Ptr;
        const int _Max_sig_dig = ( * _Phexexp == 1000000000 ? 768 : 36 );
        const auto _Parse_result = _Parse_fp_with_locale ( _Ac, _Max_sig_dig, _First, _Last, _Iosbase . getloc ( ) );
        if ( _Parse_result . _Base == 0 || _Parse_result . _Bad_grouping ) {
            * _Ac = '\000';
        }

        if ( _Parse_result . _Base == 16 ) {
            * _Phexexp = 0;
        }
        return 0;
    }




};
#line 1170 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocnum"
template< class _Elem, class _InIt> locale::id 
#line 1171
num_get< _Elem, _InIt> ::id; 
#line 1177
template < class _Ty >
int _Float_put_desired_precision ( const streamsize _Precision, const ios_base :: fmtflags _Float_flags ) {

    const bool _Is_hex = _Float_flags == ( ios_base :: fixed | ios_base :: scientific );
    if ( _Is_hex ) {

        if constexpr ( is_same_v < _Ty, double > ) {
            return ( ( 53 - 1 ) + 3 ) / 4;
        } else if constexpr ( is_same_v < _Ty, long double > ) {
            return ( ( 53 - 1 ) + 3 ) / 4;
        } else {
            ;
        }
    }

    if ( _Precision > 0 ) {
        return static_cast < int > ( _Precision );
    } else if ( _Precision == 0 ) {
        const bool _Is_default_float = _Float_flags == 0;
        if ( _Is_default_float ) {
            return 1;
        } else {
            return 0;
        }
    } else {
        constexpr int _Default_precision = 6;
        return _Default_precision;
    }
}
#line 1207
template < class _Elem, class _OutIt = ostreambuf_iterator < _Elem, char_traits < _Elem > > >
class num_put : public locale :: facet {
public :
    static_assert ( ! 0 || _Is_any_of_v < _Elem, char, wchar_t >, "Unsupported facet specialization; see N4950 [locale.category]. Either use a Standard specialization or define _ENFORCE_FACET_SPE" "CIALIZATIONS=0 to suppress this error." );

    static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = nullptr, const locale * _Ploc = nullptr ) {

        if ( _Ppf && ! * _Ppf ) {
            * _Ppf = new num_put < _Elem, _OutIt > ( _Locinfo ( _Ploc -> _C_str ( ) ) );
        }

        return 4;
    }

     static locale :: id id;

protected :
     ~ num_put ( ) noexcept override { }

    void _Init ( const _Locinfo & ) { }

public :
    explicit num_put ( size_t _Refs = 0 ) : locale :: facet ( _Refs ) {
        { _Locinfo _Lobj;
        _Init ( _Lobj );
        }
    }

     num_put ( const _Locinfo & _Lobj, size_t _Refs = 0 ) : locale :: facet ( _Refs ) {
        _Init ( _Lobj );
    }

    using char_type = _Elem;
    using iter_type = _OutIt;

    _OutIt put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, bool _Val ) const {
        return do_put ( _Dest, _Iosbase, _Fill, _Val );
    }

    _OutIt put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, long _Val ) const {
        return do_put ( _Dest, _Iosbase, _Fill, _Val );
    }

    _OutIt put ( _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill,
        unsigned long _Val ) const {
        return do_put ( _Dest, _Iosbase, _Fill, _Val );
    }

    _OutIt put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, long long _Val ) const {
        return do_put ( _Dest, _Iosbase, _Fill, _Val );
    }

    _OutIt put ( _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill,
        unsigned long long _Val ) const {
        return do_put ( _Dest, _Iosbase, _Fill, _Val );
    }

    _OutIt put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, double _Val ) const {
        return do_put ( _Dest, _Iosbase, _Fill, _Val );
    }

    _OutIt put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, long double _Val ) const {
        return do_put ( _Dest, _Iosbase, _Fill, _Val );
    }

    _OutIt put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, const void * _Val ) const {
        return do_put ( _Dest, _Iosbase, _Fill, _Val );
    }

protected :
    virtual _OutIt do_put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, bool _Val ) const {
        if ( ! ( _Iosbase . flags ( ) & ios_base :: boolalpha ) ) {
            return do_put ( _Dest, _Iosbase, _Fill, static_cast < long > ( _Val ) );
        } else {
            const auto & _Punct_fac = :: std :: use_facet < numpunct < _Elem >> ( _Iosbase . getloc ( ) );
            basic_string < _Elem > _Str;
            if ( _Val ) {
                _Str . assign ( _Punct_fac . truename ( ) );
            } else {
                _Str . assign ( _Punct_fac . falsename ( ) );
            }

            size_t _Fillcount;
            if ( _Iosbase . width ( ) <= 0 || static_cast < size_t > ( _Iosbase . width ( ) ) <= _Str . size ( ) ) {
                _Fillcount = 0;
            } else {
                _Fillcount = static_cast < size_t > ( _Iosbase . width ( ) ) - _Str . size ( );
            }

            if ( ( _Iosbase . flags ( ) & ios_base :: adjustfield ) != ios_base :: left ) {
                _Dest = _Rep ( _Dest, _Fill, _Fillcount );
                _Fillcount = 0;
            }
            _Dest = _Put ( _Dest, _Str . c_str ( ), _Str . size ( ) );
            _Iosbase . width ( 0 );
            return _Rep ( _Dest, _Fill, _Fillcount );
        }
    }

#pragma warning(push)
#pragma warning(disable : 4774)
    virtual _OutIt do_put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, long _Val ) const {
        char _Buf [ 2 * _Max_int_dig ];
        char _Fmt [ 6 ];

        return _Iput ( _Dest, _Iosbase, _Fill, _Buf,
            static_cast < size_t > ( :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "ld", _Iosbase . flags ( ) ), _Val ) ) );
    }

    virtual _OutIt do_put ( _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill,
        unsigned long _Val ) const {
        char _Buf [ 2 * _Max_int_dig ];
        char _Fmt [ 6 ];

        return _Iput ( _Dest, _Iosbase, _Fill, _Buf,
            static_cast < size_t > ( :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "lu", _Iosbase . flags ( ) ), _Val ) ) );
    }

    virtual _OutIt do_put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, long long _Val ) const {
        char _Buf [ 2 * _Max_int_dig ];
        char _Fmt [ 8 ];

        return _Iput ( _Dest, _Iosbase, _Fill, _Buf,
            static_cast < size_t > ( :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "Ld", _Iosbase . flags ( ) ), _Val ) ) );
    }

    virtual _OutIt do_put ( _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill,
        unsigned long long _Val ) const {
        char _Buf [ 2 * _Max_int_dig ];
        char _Fmt [ 8 ];

        return _Iput ( _Dest, _Iosbase, _Fill, _Buf,
            static_cast < size_t > ( :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "Lu", _Iosbase . flags ( ) ), _Val ) ) );
    }

    virtual _OutIt do_put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, double _Val ) const {
        string _Buf;
        char _Fmt [ 8 ];
        const auto _Float_flags = _Iosbase . flags ( ) & ios_base :: floatfield;
        const bool _Is_fixed = _Float_flags == ios_base :: fixed;
        const bool _Is_hex = _Float_flags == ( ios_base :: fixed | ios_base :: scientific );
        const streamsize _Precision = _Is_hex ? - 1 : _Iosbase . precision ( );
        const int _Desired_precision =
            _Float_put_desired_precision < double > ( _Precision, _Float_flags );
        size_t _Bufsize = static_cast < size_t > ( _Desired_precision );
        if ( _Is_fixed && (10000000000.0) < :: fabs ( _Val ) ) {
            int _Ptwo;
            ( void ) :: frexp ( _Val, & _Ptwo );
            _Bufsize += :: abs ( _Ptwo ) * 30103L / 100000L;
        }

        _Buf . resize ( _Bufsize + 50 );
        const bool _Is_finite = ( :: std :: isfinite ) ( _Val );
        const auto _Adjusted_flags =
            _Is_finite ? _Iosbase . flags ( ) : _Iosbase . flags ( ) & ~ ios_base :: showpoint;
        const auto _Ngen = static_cast < size_t > ( :: sprintf_s (
            & _Buf [ 0 ], _Buf . size ( ), _Ffmt ( _Fmt, 0, _Adjusted_flags ), static_cast < int > ( _Precision ), _Val ) );

        return _Fput_v3 ( _Dest, _Iosbase, _Fill, _Buf . c_str ( ), _Ngen, _Is_finite );
    }

    virtual _OutIt do_put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, long double _Val ) const {
        string _Buf;
        char _Fmt [ 8 ];
        const auto _Float_flags = _Iosbase . flags ( ) & ios_base :: floatfield;
        const bool _Is_fixed = _Float_flags == ios_base :: fixed;
        const bool _Is_hex = _Float_flags == ( ios_base :: fixed | ios_base :: scientific );
        const streamsize _Precision = _Is_hex ? - 1 : _Iosbase . precision ( );
        const int _Desired_precision =
            _Float_put_desired_precision < long double > ( _Precision, _Float_flags );
        size_t _Bufsize = static_cast < size_t > ( _Desired_precision );
        if ( _Is_fixed && (10000000000.0) < :: fabsl ( _Val ) ) {
            int _Ptwo;
            ( void ) :: frexpl ( _Val, & _Ptwo );
            _Bufsize += :: abs ( _Ptwo ) * 30103L / 100000L;
        }

        _Buf . resize ( _Bufsize + 50 );
        const bool _Is_finite = ( :: std :: isfinite ) ( _Val );
        const auto _Adjusted_flags =
            _Is_finite ? _Iosbase . flags ( ) : _Iosbase . flags ( ) & ~ ios_base :: showpoint;
        const auto _Ngen = static_cast < size_t > ( :: sprintf_s (
            & _Buf [ 0 ], _Buf . size ( ), _Ffmt ( _Fmt, 'L', _Adjusted_flags ), static_cast < int > ( _Precision ), _Val ) );

        return _Fput_v3 ( _Dest, _Iosbase, _Fill, _Buf . c_str ( ), _Ngen, _Is_finite );
    }
#pragma warning(pop)

    virtual _OutIt do_put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, const void * _Val ) const {
        char _Buf [ 2 * _Max_int_dig ];

        return _Iput (
            _Dest, _Iosbase, _Fill, _Buf, static_cast < size_t > ( :: sprintf_s ( _Buf, sizeof ( _Buf ), "%p", _Val ) ) );
    }

private :
    char * __cdecl _Ffmt (
        char * _Fmt, char _Spec, ios_base :: fmtflags _Flags ) const {
        char * _Ptr = _Fmt;
        * _Ptr ++ = '%';

        if ( _Flags & ios_base :: showpos ) {
            * _Ptr ++ = '+';
        }

        if ( _Flags & ios_base :: showpoint ) {
            * _Ptr ++ = '#';
        }

        * _Ptr ++ = '.';
        * _Ptr ++ = '*';
        if ( _Spec != '\000' ) {
            * _Ptr ++ = _Spec;
        }

        char _Ch;
        ios_base :: fmtflags _Ffl = _Flags & ios_base :: floatfield;
        if ( _Flags & ios_base :: uppercase ) {
            if ( _Ffl == ios_base :: fixed ) {
                _Ch = 'F';
            } else if ( _Ffl == ( ios_base :: scientific | ios_base :: fixed ) ) {
                _Ch = 'A';
            } else if ( _Ffl == ios_base :: scientific ) {
                _Ch = 'E';
            } else {
                _Ch = 'G';
            }
        } else {
            if ( _Ffl == ios_base :: fixed ) {
                _Ch = 'f';
            } else if ( _Ffl == ( ios_base :: scientific | ios_base :: fixed ) ) {
                _Ch = 'a';
            } else if ( _Ffl == ios_base :: scientific ) {
                _Ch = 'e';
            } else {
                _Ch = 'g';
            }
        }
        * _Ptr ++ = _Ch;

        * _Ptr = '\000';
        return _Fmt;
    }

    _OutIt __cdecl _Fput ( _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, const char * _Buf,
        size_t _Count ) const {
        return _Fput_v3 ( _Dest, _Iosbase, _Fill, _Buf, _Count, true );
    }

    template < int = 0 >
    _OutIt _Fput_v3 ( _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, const char * _Buf, size_t _Count,
        bool _Is_finite_val ) const {
        auto _Prefix = static_cast < size_t > ( 0 < _Count && ( * _Buf == '+' || * _Buf == '-' ) );
        const char * _Exps;
        if ( ( _Iosbase . flags ( ) & ios_base :: floatfield ) != ( ios_base :: scientific | ios_base :: fixed ) ) {
            _Exps = "eE";
        } else {
            _Exps = "pP";
            if ( _Prefix + 2 <= _Count && _Buf [ _Prefix ] == '0'
                && ( _Buf [ _Prefix + 1 ] == 'x' || _Buf [ _Prefix + 1 ] == 'X' ) ) {
                _Prefix += 2;
            }
        }
        const size_t _Eoff = :: strcspn ( & _Buf [ 0 ], _Exps );
        char _Dp [ 2 ] = { "." };
        _Dp [ 0 ] = ( :: localeconv ( ) ) -> decimal_point [ 0 ];
        const size_t _Poff = :: strcspn ( & _Buf [ 0 ], & _Dp [ 0 ] );

        const ctype < _Elem > & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Iosbase . getloc ( ) );
        basic_string < _Elem > _Groupstring ( _Count, _Elem ( 0 ) );
        _Ctype_fac . widen ( _Buf, _Buf + _Count, & _Groupstring [ 0 ] );

        const auto & _Punct_fac = :: std :: use_facet < numpunct < _Elem >> ( _Iosbase . getloc ( ) );
        const string _Grouping = _Punct_fac . grouping ( );
        const _Elem _Kseparator = _Punct_fac . thousands_sep ( );

        if ( _Poff != _Count ) {
            _Groupstring [ _Poff ] = _Punct_fac . decimal_point ( );
        }

        if ( _Is_finite_val ) {
            size_t _Off = _Poff == _Count ? _Eoff : _Poff;
            const char * _Pg = & _Grouping [ 0 ];
            while ( * _Pg != 127 && '\000' < * _Pg && static_cast < size_t > ( * _Pg ) < _Off - _Prefix ) {

                _Groupstring . insert ( _Off -= * _Pg, 1, _Kseparator );
                if ( '\000' < _Pg [ 1 ] ) {
                    ++ _Pg;
                }
            }
        }

        _Count = _Groupstring . size ( );

        size_t _Fillcount;
        if ( _Iosbase . width ( ) <= 0 || static_cast < size_t > ( _Iosbase . width ( ) ) <= _Count ) {
            _Fillcount = 0;
        } else {
            _Fillcount = static_cast < size_t > ( _Iosbase . width ( ) ) - _Count;
        }

        ios_base :: fmtflags _Adjustfield = _Iosbase . flags ( ) & ios_base :: adjustfield;
        if ( _Adjustfield != ios_base :: left && _Adjustfield != ios_base :: internal ) {
            _Dest = _Rep ( _Dest, _Fill, _Fillcount );
            _Fillcount = 0;
            _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );
        } else if ( _Adjustfield == ios_base :: internal ) {
            _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );
            _Dest = _Rep ( _Dest, _Fill, _Fillcount );
            _Fillcount = 0;
        } else {
            _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );
        }

        _Dest = _Put ( _Dest, & _Groupstring [ _Prefix ], _Count - _Prefix );
        _Iosbase . width ( 0 );
        return _Rep ( _Dest, _Fill, _Fillcount );
    }

    char * __cdecl _Ifmt (
        char * _Fmt, const char * _Spec, ios_base :: fmtflags _Flags ) const {
        char * _Ptr = _Fmt;
        * _Ptr ++ = '%';

        if ( _Flags & ios_base :: showpos ) {
            * _Ptr ++ = '+';
        }

        if ( _Flags & ios_base :: showbase ) {
            * _Ptr ++ = '#';
        }

        if ( _Spec [ 0 ] != 'L' ) {
            * _Ptr ++ = _Spec [ 0 ];
        } else {
            * _Ptr ++ = 'I';
            * _Ptr ++ = '6';
            * _Ptr ++ = '4';
        }

        ios_base :: fmtflags _Basefield = _Flags & ios_base :: basefield;
        * _Ptr ++ = _Basefield == ios_base :: oct ? 'o'
                                      : _Basefield != ios_base :: hex ? _Spec [ 1 ]
                                      : _Flags & ios_base :: uppercase ? 'X'
                                                                     : 'x';
        * _Ptr = '\000';
        return _Fmt;
    }

    _OutIt __cdecl _Iput ( _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, char * _Buf,
        size_t _Count ) const {
        auto _Prefix = static_cast < size_t > ( 0 < _Count && ( * _Buf == '+' || * _Buf == '-' ) );
        if ( ( _Iosbase . flags ( ) & ios_base :: basefield ) == ios_base :: hex && _Prefix + 2 <= _Count && _Buf [ _Prefix ] == '0'
            && ( _Buf [ _Prefix + 1 ] == 'x' || _Buf [ _Prefix + 1 ] == 'X' ) ) {
            _Prefix += 2;
        }

        const ctype < _Elem > & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Iosbase . getloc ( ) );
        basic_string < _Elem > _Groupstring ( _Count, _Elem ( 0 ) );
        _Ctype_fac . widen ( _Buf, _Buf + _Count, & _Groupstring [ 0 ] );

        const auto & _Punct_fac = :: std :: use_facet < numpunct < _Elem >> ( _Iosbase . getloc ( ) );
        const string _Grouping = _Punct_fac . grouping ( );
        const char * _Pg = & _Grouping [ 0 ];
        if ( * _Pg != 127 && '\000' < * _Pg ) {
            const _Elem _Kseparator = _Punct_fac . thousands_sep ( );
            while ( * _Pg != 127 && '\000' < * _Pg && static_cast < size_t > ( * _Pg ) < _Count - _Prefix ) {

                _Count -= * _Pg;
                _Groupstring . insert ( _Count, 1, _Kseparator );
                if ( '\000' < _Pg [ 1 ] ) {
                    ++ _Pg;
                }
            }
        }

        _Count = _Groupstring . size ( );

        size_t _Fillcount;
        if ( _Iosbase . width ( ) <= 0 || static_cast < size_t > ( _Iosbase . width ( ) ) <= _Count ) {
            _Fillcount = 0;
        } else {
            _Fillcount = static_cast < size_t > ( _Iosbase . width ( ) ) - _Count;
        }

        ios_base :: fmtflags _Adjustfield = _Iosbase . flags ( ) & ios_base :: adjustfield;
        if ( _Adjustfield != ios_base :: left && _Adjustfield != ios_base :: internal ) {
            _Dest = _Rep ( _Dest, _Fill, _Fillcount );
            _Fillcount = 0;
            _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );
        } else if ( _Adjustfield == ios_base :: internal ) {
            _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );
            _Dest = _Rep ( _Dest, _Fill, _Fillcount );
            _Fillcount = 0;
        } else {
            _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );
        }

        _Dest = _Put ( _Dest, & _Groupstring [ _Prefix ], _Count - _Prefix );
        _Iosbase . width ( 0 );
        return _Rep ( _Dest, _Fill, _Fillcount );
    }

    _OutIt __cdecl _Put (
        _OutIt _Dest, const _Elem * _Ptr, size_t _Count ) const {
        for (; 0 < _Count; -- _Count, ( void ) ++ _Dest, ++ _Ptr ) {
            * _Dest = * _Ptr;
        }

        return _Dest;
    }

    _OutIt __cdecl _Rep ( _OutIt _Dest, _Elem _Ch, size_t _Count ) const {
        for (; 0 < _Count; -- _Count, ( void ) ++ _Dest ) {
            * _Dest = _Ch;
        }

        return _Dest;
    }
};
#line 1645
template< class _Elem, class _OutIt> locale::id 
#line 1646
num_put< _Elem, _OutIt> ::id; 
#line 1672 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xlocnum"
}
#line 1675
#pragma warning(pop)
#pragma pack ( pop )
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ios"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 19
namespace std { 
#line 20
template < class _Elem, class _Traits >
class basic_ios : public ios_base {
public :
    using _Myos = basic_ostream < _Elem, _Traits >;
    using _Mysb = basic_streambuf < _Elem, _Traits >;
    using _Ctype = ctype < _Elem >;
    using char_type = _Elem;
    using traits_type = _Traits;
    using int_type = typename _Traits :: int_type;
    using pos_type = typename _Traits :: pos_type;
    using off_type = typename _Traits :: off_type;

    explicit basic_ios ( _Mysb * _Strbuf ) {
        init ( _Strbuf );
    }

     ~ basic_ios ( ) noexcept override { }

    void clear ( iostate _State = goodbit, bool _Reraise = false ) {

        ios_base :: clear ( _State | ( _Mystrbuf ? ios_base :: goodbit : ios_base :: badbit ), _Reraise );
    }


    void clear ( io_state _State ) {
        clear ( static_cast < iostate > ( _State ) );
    }


    void setstate ( iostate _State, bool _Reraise = false ) {

        clear ( rdstate ( ) | _State, _Reraise );
    }


    void setstate ( io_state _State ) {
        setstate ( static_cast < iostate > ( _State ) );
    }


    basic_ios & copyfmt ( const basic_ios & _Right ) {
        _Tiestr = _Right . tie ( );
        _Fillch = _Right . fill ( );
        ios_base :: copyfmt ( _Right );
        return * this;
    }

    _Myos * tie ( ) const noexcept {
        return _Tiestr;
    }

    _Myos * tie ( _Myos * _Newtie ) noexcept {
        _Myos * _Oldtie = _Tiestr;
        _Tiestr = _Newtie;
        return _Oldtie;
    }

    [ [ nodiscard ] ] _Mysb * rdbuf ( ) const noexcept {
        return _Mystrbuf;
    }

    _Mysb * rdbuf ( _Mysb * _Strbuf ) {
        _Mysb * _Oldstrbuf = _Mystrbuf;
        _Mystrbuf = _Strbuf;
        clear ( );
        return _Oldstrbuf;
    }

    locale imbue ( const locale & _Loc ) {
        locale _Oldlocale = ios_base :: imbue ( _Loc );
        const auto _Rdbuf = rdbuf ( );
        if ( _Rdbuf ) {
            _Rdbuf -> pubimbue ( _Loc );
        }

        return _Oldlocale;
    }

    _Elem fill ( ) const noexcept {
        return _Fillch;
    }

    _Elem fill ( _Elem _Newfill ) noexcept {
        _Elem _Oldfill = _Fillch;
        _Fillch = _Newfill;
        return _Oldfill;
    }

    char narrow ( _Elem _Ch, char _Dflt = '\000' ) const {
        return :: std :: use_facet < _Ctype > ( getloc ( ) ) . narrow ( _Ch, _Dflt );
    }

    _Elem widen ( char _Byte ) const {
        return :: std :: use_facet < _Ctype > ( getloc ( ) ) . widen ( _Byte );
    }

    void move ( basic_ios & _Right ) noexcept {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Mystrbuf = nullptr;
            _Tiestr = nullptr;
            this -> swap ( _Right );
        }
    }

    void move ( basic_ios && _Right ) noexcept {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Mystrbuf = nullptr;
            _Tiestr = nullptr;
            this -> swap ( _Right );
        }
    }

    void swap ( basic_ios & _Right ) noexcept {
        ios_base :: swap ( _Right );
        :: std :: swap ( _Fillch, _Right . _Fillch );
        :: std :: swap ( _Tiestr, _Right . _Tiestr );
    }

    void set_rdbuf ( _Mysb * _Strbuf ) noexcept {

        _Mystrbuf = _Strbuf;
    }

protected :
    void init ( _Mysb * _Strbuf = nullptr, bool _Isstd = false ) {

        _Init ( );
        _Mystrbuf = _Strbuf;
        _Tiestr = nullptr;
        _Fillch = widen ( ' ' );

        if ( ! _Mystrbuf ) {
            setstate ( badbit );
        }

        if ( _Isstd ) {
            _Addstd ( this );
        }
    }

     basic_ios ( ) { }

private :
    _Mysb * _Mystrbuf { };
    _Myos * _Tiestr { };
    _Elem _Fillch { };

public :
     basic_ios ( const basic_ios & ) = delete;
    basic_ios & operator = ( const basic_ios & ) = delete;
};
#line 184 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ios"
inline ios_base &__cdecl boolalpha(ios_base &_Iosbase) { 
#line 185
_Iosbase.setf(ios_base::boolalpha); 
#line 186
return _Iosbase; 
#line 187
} 
#line 189
inline ios_base &__cdecl dec(ios_base &_Iosbase) { 
#line 190
_Iosbase.setf(ios_base::dec, ios_base::basefield); 
#line 191
return _Iosbase; 
#line 192
} 
#line 194
inline ios_base &__cdecl defaultfloat(ios_base &_Iosbase) { 
#line 195
_Iosbase.unsetf(ios_base::floatfield); 
#line 196
return _Iosbase; 
#line 197
} 
#line 199
inline ios_base &__cdecl fixed(ios_base &_Iosbase) { 
#line 200
_Iosbase.setf(ios_base::fixed, ios_base::floatfield); 
#line 201
return _Iosbase; 
#line 202
} 
#line 204
inline ios_base &__cdecl hex(ios_base &_Iosbase) { 
#line 205
_Iosbase.setf(ios_base::hex, ios_base::basefield); 
#line 206
return _Iosbase; 
#line 207
} 
#line 209
inline ios_base &__cdecl hexfloat(ios_base &_Iosbase) { 
#line 210
_Iosbase.setf(ios_base::scientific | ios_base::fixed, ios_base::floatfield); 
#line 211
return _Iosbase; 
#line 212
} 
#line 214
inline ios_base &__cdecl internal(ios_base &_Iosbase) { 
#line 215
_Iosbase.setf(ios_base::internal, ios_base::adjustfield); 
#line 216
return _Iosbase; 
#line 217
} 
#line 219
inline ios_base &__cdecl left(ios_base &_Iosbase) { 
#line 220
_Iosbase.setf(ios_base::left, ios_base::adjustfield); 
#line 221
return _Iosbase; 
#line 222
} 
#line 224
inline ios_base &__cdecl noboolalpha(ios_base &_Iosbase) { 
#line 225
_Iosbase.unsetf(ios_base::boolalpha); 
#line 226
return _Iosbase; 
#line 227
} 
#line 229
inline ios_base &__cdecl noshowbase(ios_base &_Iosbase) { 
#line 230
_Iosbase.unsetf(ios_base::showbase); 
#line 231
return _Iosbase; 
#line 232
} 
#line 234
inline ios_base &__cdecl noshowpoint(ios_base &_Iosbase) { 
#line 235
_Iosbase.unsetf(ios_base::showpoint); 
#line 236
return _Iosbase; 
#line 237
} 
#line 239
inline ios_base &__cdecl noshowpos(ios_base &_Iosbase) { 
#line 240
_Iosbase.unsetf(ios_base::showpos); 
#line 241
return _Iosbase; 
#line 242
} 
#line 244
inline ios_base &__cdecl noskipws(ios_base &_Iosbase) { 
#line 245
_Iosbase.unsetf(ios_base::skipws); 
#line 246
return _Iosbase; 
#line 247
} 
#line 249
inline ios_base &__cdecl nounitbuf(ios_base &_Iosbase) { 
#line 250
_Iosbase.unsetf(ios_base::unitbuf); 
#line 251
return _Iosbase; 
#line 252
} 
#line 254
inline ios_base &__cdecl nouppercase(ios_base &_Iosbase) { 
#line 255
_Iosbase.unsetf(ios_base::uppercase); 
#line 256
return _Iosbase; 
#line 257
} 
#line 259
inline ios_base &__cdecl oct(ios_base &_Iosbase) { 
#line 260
_Iosbase.setf(ios_base::oct, ios_base::basefield); 
#line 261
return _Iosbase; 
#line 262
} 
#line 264
inline ios_base &__cdecl right(ios_base &_Iosbase) { 
#line 265
_Iosbase.setf(ios_base::right, ios_base::adjustfield); 
#line 266
return _Iosbase; 
#line 267
} 
#line 269
inline ios_base &__cdecl scientific(ios_base &_Iosbase) { 
#line 270
_Iosbase.setf(ios_base::scientific, ios_base::floatfield); 
#line 271
return _Iosbase; 
#line 272
} 
#line 274
inline ios_base &__cdecl showbase(ios_base &_Iosbase) { 
#line 275
_Iosbase.setf(ios_base::showbase); 
#line 276
return _Iosbase; 
#line 277
} 
#line 279
inline ios_base &__cdecl showpoint(ios_base &_Iosbase) { 
#line 280
_Iosbase.setf(ios_base::showpoint); 
#line 281
return _Iosbase; 
#line 282
} 
#line 284
inline ios_base &__cdecl showpos(ios_base &_Iosbase) { 
#line 285
_Iosbase.setf(ios_base::showpos); 
#line 286
return _Iosbase; 
#line 287
} 
#line 289
inline ios_base &__cdecl skipws(ios_base &_Iosbase) { 
#line 290
_Iosbase.setf(ios_base::skipws); 
#line 291
return _Iosbase; 
#line 292
} 
#line 294
inline ios_base &__cdecl unitbuf(ios_base &_Iosbase) { 
#line 295
_Iosbase.setf(ios_base::unitbuf); 
#line 296
return _Iosbase; 
#line 297
} 
#line 299
inline ios_base &__cdecl uppercase(ios_base &_Iosbase) { 
#line 300
_Iosbase.setf(ios_base::uppercase); 
#line 301
return _Iosbase; 
#line 302
} 
#line 305
namespace [[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to suppress this warning.")]] tr1 { 
#line 306
using std::hexfloat;
#line 307
}
#line 310 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ios"
}
#line 314
#pragma warning(pop)
#pragma pack ( pop )
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_ostream.hpp"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 19
namespace std { 
#pragma vtordisp(push, 2)
#line 22
template < class _Elem, class _Traits >
class basic_ostream : virtual public basic_ios < _Elem, _Traits > {
public :
    using _Myios = basic_ios < _Elem, _Traits >;
    using _Mysb = basic_streambuf < _Elem, _Traits >;
    using _Iter = ostreambuf_iterator < _Elem, _Traits >;
    using _Nput = num_put < _Elem, _Iter >;

    explicit basic_ostream ( basic_streambuf < _Elem, _Traits > * _Strbuf, bool _Isstd = false ) {
        _Myios :: init ( _Strbuf, _Isstd );
    }

     basic_ostream ( _Uninitialized, bool _Addit = true ) {
        if ( _Addit ) {
            this -> _Addstd ( this );
        }
    }

protected :
     basic_ostream ( basic_ostream && _Right ) noexcept ( false ) {
        _Myios :: init ( );
        _Myios :: move ( :: std :: move ( _Right ) );
    }

    basic_ostream & operator = ( basic_ostream && _Right ) noexcept {
        this -> swap ( _Right );
        return * this;
    }

    void swap ( basic_ostream & _Right ) noexcept {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Myios :: swap ( _Right );
        }
    }

public :
     basic_ostream ( const basic_ostream & ) = delete;
    basic_ostream & operator = ( const basic_ostream & ) = delete;

     ~ basic_ostream ( ) noexcept override { }

    using int_type = typename _Traits :: int_type;
    using pos_type = typename _Traits :: pos_type;
    using off_type = typename _Traits :: off_type;

    class _Sentry_base {
    public :
         _Sentry_base ( basic_ostream & _Ostr ) : _Myostr ( _Ostr ) {
            const auto _Rdbuf = _Myostr . rdbuf ( );
            if ( _Rdbuf ) {
                _Rdbuf -> _Lock ( );
            }
        }

         ~ _Sentry_base ( ) noexcept {
            const auto _Rdbuf = _Myostr . rdbuf ( );
            if ( _Rdbuf ) {
                _Rdbuf -> _Unlock ( );
            }
        }

        basic_ostream & _Myostr;

        _Sentry_base & operator = ( const _Sentry_base & ) = delete;
    };

    class sentry : public _Sentry_base {
    public :
        explicit sentry ( basic_ostream & _Ostr ) : _Sentry_base ( _Ostr ) {
            if ( ! _Ostr . good ( ) ) {
                _Ok = false;
                return;
            }

            const auto _Tied = _Ostr . tie ( );
            if ( ! _Tied || _Tied == :: std :: addressof ( _Ostr ) ) {
                _Ok = true;
                return;
            }

            _Tied -> flush ( );
            _Ok = _Ostr . good ( );
        }

        __pragma(warning(push))                                __pragma(warning(disable : 4996))
         ~ sentry ( ) noexcept {



            const bool _Zero_uncaught_exceptions = ! :: std :: uncaught_exception ( );




            if ( _Zero_uncaught_exceptions ) {
                this -> _Myostr . _Osfx ( );
            }
        }
        __pragma(warning(pop))

        explicit operator bool ( ) const {
            return _Ok;
        }

         sentry ( const sentry & ) = delete;
        sentry & operator = ( const sentry & ) = delete;

    private :
        bool _Ok;
    };






    [ [ deprecated ( "warning STL4045: The ipfx(), isfx(), opfx(), and osfx() functions are removed before C++98 (see WG21-N0794) but kept as non-Stan" "dard extensions. They will be removed in the future, and the member classes sentry should be used instead. You can define _SILEN" "CE_IO_PFX_SFX_DEPRECATION_WARNING or _SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS to suppress this warning." ) ] ] bool opfx ( ) {
        if ( ! this -> good ( ) ) {
            return false;
        }

        const auto _Tied = _Myios :: tie ( );
        if ( ! _Tied || _Myios :: tie ( ) == this ) {
            return true;
        }

        _Tied -> flush ( );
        return this -> good ( );
    }


    [ [ deprecated ( "warning STL4045: The ipfx(), isfx(), opfx(), and osfx() functions are removed before C++98 (see WG21-N0794) but kept as non-Stan" "dard extensions. They will be removed in the future, and the member classes sentry should be used instead. You can define _SILEN" "CE_IO_PFX_SFX_DEPRECATION_WARNING or _SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS to suppress this warning." ) ] ] void osfx ( ) noexcept {
        _Osfx ( );
    }



    void _Osfx ( ) noexcept {
        try {
        if ( this -> good ( ) && this -> flags ( ) & ios_base :: unitbuf ) {
            if ( _Myios :: rdbuf ( ) -> pubsync ( ) == - 1 ) {
                _Myios :: setstate ( ios_base :: badbit );
            }
        }
        } catch ( ... ) {
        }
    }




















    basic_ostream & operator << ( basic_ostream & ( __cdecl * _Pfn ) ( basic_ostream & ) ) {

        return _Pfn ( * this );
    }

    basic_ostream & operator << ( _Myios & ( __cdecl * _Pfn ) ( _Myios & ) ) {

        _Pfn ( * this );
        return * this;
    }

    basic_ostream & operator << ( ios_base & ( __cdecl * _Pfn ) ( ios_base & ) ) {

        _Pfn ( * this );
        return * this;
    }

    basic_ostream & operator << ( bool _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), _Val ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( short _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );
            ios_base :: fmtflags _Bfl = this -> flags ( ) & ios_base :: basefield;

            long _Tmp;
            if ( _Bfl == ios_base :: oct || _Bfl == ios_base :: hex ) {
                _Tmp = static_cast < long > ( static_cast < unsigned short > ( _Val ) );
            } else {
                _Tmp = static_cast < long > ( _Val );
            }

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), _Tmp ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }









    basic_ostream & operator << ( unsigned short _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), static_cast < unsigned long > ( _Val ) )
                    . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( int _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );
            ios_base :: fmtflags _Bfl = this -> flags ( ) & ios_base :: basefield;

            long _Tmp;
            if ( _Bfl == ios_base :: oct || _Bfl == ios_base :: hex ) {
                _Tmp = static_cast < long > ( static_cast < unsigned int > ( _Val ) );
            } else {
                _Tmp = static_cast < long > ( _Val );
            }

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), _Tmp ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( unsigned int _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), static_cast < unsigned long > ( _Val ) )
                    . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( long _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), _Val ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( unsigned long _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), _Val ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( long long _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), _Val ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( unsigned long long _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), _Val ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( float _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), static_cast < double > ( _Val ) ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( double _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), _Val ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( long double _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), _Val ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( const void * _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), _Val ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }















    basic_ostream & operator << ( _Mysb * _Strbuf ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        bool _Copied = false;
        const sentry _Ok ( * this );

        if ( _Ok && _Strbuf ) {
            for ( int_type _Meta = _Traits :: eof ( );; _Copied = true ) {
                try {
                _Meta = _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ? _Strbuf -> sgetc ( ) : _Strbuf -> snextc ( );
                } catch ( ... ) {



                _Myios :: setstate ( ios_base :: failbit, _Myios :: exceptions ( ) == ios_base :: failbit );
                }

                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                    break;
                }

                try {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Myios :: rdbuf ( ) -> sputc ( _Traits :: to_char_type ( _Meta ) ) ) ) {
                    _State |= ios_base :: badbit;
                    break;
                }
                } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
            }
        }

        this -> width ( 0 );
        int _Setstate_with;
        if ( _Strbuf ) {
            if ( _Copied ) {
                _Setstate_with = _State;
            } else {
                _Setstate_with = _State | ios_base :: failbit;
            }
        } else {
            _Setstate_with = ios_base :: badbit;
        }

        _Myios :: setstate ( _Setstate_with );
        return * this;
    }

    basic_ostream & put ( _Elem _Ch ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( ! _Ok ) {
            _State |= ios_base :: badbit;
        } else {
            try {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Myios :: rdbuf ( ) -> sputc ( _Ch ) ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & write ( const _Elem * _Str, streamsize _Count ) {

        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( ! _Ok ) {
            _State |= ios_base :: badbit;
        } else if ( 0 < _Count ) {
            try {
            if ( _Myios :: rdbuf ( ) -> sputn ( _Str, _Count ) != _Count ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & flush ( ) {
        const auto _Rdbuf = _Myios :: rdbuf ( );
        if ( _Rdbuf ) {
            const sentry _Ok ( * this );

            if ( _Ok ) {
                ios_base :: iostate _State = ios_base :: goodbit;
                try {
                if ( _Rdbuf -> pubsync ( ) == - 1 ) {
                    _State |= ios_base :: badbit;
                }
                } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
                _Myios :: setstate ( _State );
            }
        }
        return * this;
    }

    basic_ostream & seekp ( pos_type _Pos ) {
        const sentry _Ok ( * this );

        if ( ! this -> fail ( ) ) {
            ios_base :: iostate _State = ios_base :: goodbit;
            try {
            if ( static_cast < off_type > ( _Myios :: rdbuf ( ) -> pubseekpos ( _Pos, ios_base :: out ) ) == - 1 ) {
                _State |= ios_base :: failbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
            _Myios :: setstate ( _State );
        }

        return * this;
    }

    basic_ostream & seekp ( off_type _Off, ios_base :: seekdir _Way ) {

        const sentry _Ok ( * this );

        if ( ! this -> fail ( ) ) {
            ios_base :: iostate _State = ios_base :: goodbit;
            try {
            if ( static_cast < off_type > ( _Myios :: rdbuf ( ) -> pubseekoff ( _Off, _Way, ios_base :: out ) ) == - 1 ) {
                _State |= ios_base :: failbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
            _Myios :: setstate ( _State );
        }

        return * this;
    }

    pos_type tellp ( ) {
        const sentry _Ok ( * this );

        if ( ! this -> fail ( ) ) {
            try {
            return _Myios :: rdbuf ( ) -> pubseekoff ( 0, ios_base :: cur, ios_base :: out );
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        return pos_type { off_type { - 1 } };
    }
};
#line 626 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_ostream.hpp"
#pragma vtordisp(pop)
#line 687 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_ostream.hpp"
template < class _Elem, class _Traits >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr, const char * _Val ) {
    ios_base :: iostate _State = ios_base :: goodbit;
    streamsize _Count = static_cast < streamsize > ( :: strlen ( _Val ) );
    streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count ? 0 : _Ostr . width ( ) - _Count;
    const typename basic_ostream < _Elem, _Traits > :: sentry _Ok ( _Ostr );

    if ( ! _Ok ) {
        _State |= ios_base :: badbit;
    } else {
        try {
        const ctype < _Elem > & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Ostr . getloc ( ) );
        if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left ) {
            for (; 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= ios_base :: badbit;
                    break;
                }
            }
        }

        for (; _State == ios_base :: goodbit && 0 < _Count; -- _Count, ++ _Val ) {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ctype_fac . widen ( * _Val ) ) ) ) {
                _State |= ios_base :: badbit;
            }
        }

        if ( _State == ios_base :: goodbit ) {
            for (; 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= ios_base :: badbit;
                    break;
                }
            }
        }

        _Ostr . width ( 0 );
        } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
    }

    _Ostr . setstate ( _State );
    return _Ostr;
}
#line 731
template < class _Elem, class _Traits >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr, char _Ch ) {
    ios_base :: iostate _State = ios_base :: goodbit;
    const typename basic_ostream < _Elem, _Traits > :: sentry _Ok ( _Ostr );

    if ( _Ok ) {
        const ctype < _Elem > & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Ostr . getloc ( ) );
        streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

        try {
        if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left ) {
            for (; _State == ios_base :: goodbit && 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= ios_base :: badbit;
                }
            }
        }

        if ( _State == ios_base :: goodbit
            && _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ctype_fac . widen ( _Ch ) ) ) ) {
            _State |= ios_base :: badbit;
        }

        for (; _State == ios_base :: goodbit && 0 < _Pad; -- _Pad ) {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                _State |= ios_base :: badbit;
            }
        }
        } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
    }

    _Ostr . width ( 0 );
    _Ostr . setstate ( _State );
    return _Ostr;
}
#line 767
template < class _Traits >
basic_ostream < char, _Traits > & operator << ( basic_ostream < char, _Traits > & _Ostr, const char * _Val ) {

    using _Elem = char;
    using _Myos = basic_ostream < _Elem, _Traits >;

    ios_base :: iostate _State = ios_base :: goodbit;
    streamsize _Count = static_cast < streamsize > ( _Traits :: length ( _Val ) );
    streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count ? 0 : _Ostr . width ( ) - _Count;
    const typename _Myos :: sentry _Ok ( _Ostr );

    if ( ! _Ok ) {
        _State |= ios_base :: badbit;
    } else {
        try {
        if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left ) {
            for (; 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= ios_base :: badbit;
                    break;
                }
            }
        }

        if ( _State == ios_base :: goodbit && _Ostr . rdbuf ( ) -> sputn ( _Val, _Count ) != _Count ) {
            _State |= ios_base :: badbit;
        }

        if ( _State == ios_base :: goodbit ) {
            for (; 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= ios_base :: badbit;
                    break;
                }
            }
        }

        _Ostr . width ( 0 );
        } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
    }

    _Ostr . setstate ( _State );
    return _Ostr;
}
#line 812
template < class _Traits >
basic_ostream < char, _Traits > & operator << ( basic_ostream < char, _Traits > & _Ostr, char _Ch ) {

    using _Elem = char;
    using _Myos = basic_ostream < _Elem, _Traits >;

    ios_base :: iostate _State = ios_base :: goodbit;
    const typename _Myos :: sentry _Ok ( _Ostr );

    if ( _Ok ) {
        streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

        try {
        if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left ) {
            for (; _State == ios_base :: goodbit && 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= ios_base :: badbit;
                }
            }
        }

        if ( _State == ios_base :: goodbit && _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ch ) ) ) {
            _State |= ios_base :: badbit;
        }

        for (; _State == ios_base :: goodbit && 0 < _Pad; -- _Pad ) {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                _State |= ios_base :: badbit;
            }
        }
        } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
    }

    _Ostr . width ( 0 );
    _Ostr . setstate ( _State );
    return _Ostr;
}
#line 850
template < class _Elem, class _Traits >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr, const _Elem * _Val ) {
    using _Myos = basic_ostream < _Elem, _Traits >;

    ios_base :: iostate _State = ios_base :: goodbit;
    streamsize _Count = static_cast < streamsize > ( _Traits :: length ( _Val ) );
    streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count ? 0 : _Ostr . width ( ) - _Count;
    const typename _Myos :: sentry _Ok ( _Ostr );

    if ( ! _Ok ) {
        _State |= ios_base :: badbit;
    } else {
        try {
        if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left ) {
            for (; 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= ios_base :: badbit;
                    break;
                }
            }
        }

        if ( _State == ios_base :: goodbit && _Ostr . rdbuf ( ) -> sputn ( _Val, _Count ) != _Count ) {
            _State |= ios_base :: badbit;
        }

        if ( _State == ios_base :: goodbit ) {
            for (; 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= ios_base :: badbit;
                    break;
                }
            }
        }

        _Ostr . width ( 0 );
        } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
    }

    _Ostr . setstate ( _State );
    return _Ostr;
}
#line 893
template < class _Elem, class _Traits >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr, _Elem _Ch ) {
    using _Myos = basic_ostream < _Elem, _Traits >;

    ios_base :: iostate _State = ios_base :: goodbit;
    const typename _Myos :: sentry _Ok ( _Ostr );

    if ( _Ok ) {
        streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

        try {
        if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left ) {
            for (; _State == ios_base :: goodbit && 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= ios_base :: badbit;
                }
            }
        }

        if ( _State == ios_base :: goodbit && _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ch ) ) ) {
            _State |= ios_base :: badbit;
        }

        for (; _State == ios_base :: goodbit && 0 < _Pad; -- _Pad ) {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                _State |= ios_base :: badbit;
            }
        }
        } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
    }

    _Ostr . width ( 0 );
    _Ostr . setstate ( _State );
    return _Ostr;
}
#line 929
template < class _Traits >
basic_ostream < char, _Traits > & operator << ( basic_ostream < char, _Traits > & _Ostr, const signed char * _Val ) {

    return _Ostr << reinterpret_cast < const char * > ( _Val );
}
#line 935
template < class _Traits >
basic_ostream < char, _Traits > & operator << ( basic_ostream < char, _Traits > & _Ostr, signed char _Ch ) {
    return _Ostr << static_cast < char > ( _Ch );
}
#line 940
template < class _Traits >
basic_ostream < char, _Traits > & operator << ( basic_ostream < char, _Traits > & _Ostr, const unsigned char * _Val ) {

    return _Ostr << reinterpret_cast < const char * > ( _Val );
}
#line 946
template < class _Traits >
basic_ostream < char, _Traits > & operator << ( basic_ostream < char, _Traits > & _Ostr, unsigned char _Ch ) {

    return _Ostr << static_cast < char > ( _Ch );
}
#line 996 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_ostream.hpp"
template< class _Ostr, class _Ty, class  = void> 
#line 997
struct _Can_stream_out : public false_type { }; 
#line 999
template< class _Ostr, class _Ty> 
#line 1000
struct _Can_stream_out< _Ostr, _Ty, void_t< decltype(std::declval< _Ostr &> () << std::declval< const _Ty &> ())> >  : public true_type { 
#line 1001
}; 
#line 1003
template < class _Ostr, class _Ty,
    enable_if_t < conjunction_v < is_convertible < _Ostr *, ios_base * >, _Can_stream_out < _Ostr, _Ty > >, int > = 0 >
_Ostr && operator << ( _Ostr && _Os, const _Ty & _Val ) {
    _Os << _Val;
    return :: std :: move ( _Os );
}
#line 1010
template < class _Elem, class _Traits >
basic_ostream < _Elem, _Traits > & __cdecl endl (
    basic_ostream < _Elem, _Traits > & _Ostr ) {
    _Ostr . put ( _Ostr . widen ( '\n' ) );
    _Ostr . flush ( );
    return _Ostr;
}
#line 1018
template < class _Elem, class _Traits >
basic_ostream < _Elem, _Traits > & __cdecl ends ( basic_ostream < _Elem, _Traits > & _Ostr ) {
    _Ostr . put ( _Elem ( ) );
    return _Ostr;
}
#line 1024
template < class _Elem, class _Traits >
basic_ostream < _Elem, _Traits > & __cdecl flush ( basic_ostream < _Elem, _Traits > & _Ostr ) {
    _Ostr . flush ( );
    return _Ostr;
}
#line 1030
template < class _Elem, class _Traits >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr, const error_code & _Errcode ) {

    return _Ostr << _Errcode . category ( ) . name ( ) << ':' << _Errcode . value ( );
}
#line 1035
}
#line 1039
#pragma warning(pop)
#pragma pack ( pop )
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\istream"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 19
namespace std { 
#line 20
template < class _Elem >
struct [ [ nodiscard ] ] _Null_terminator_guard {
    _Elem * * _Str_ref;
    ~ _Null_terminator_guard ( ) {
        if ( _Str_ref ) {
            * * _Str_ref = _Elem ( );
        }
    }
};
#line 30
#pragma vtordisp(push, 2)
#line 32
template < class _Elem, class _Traits >
class basic_istream : virtual public basic_ios < _Elem, _Traits > {
public :
    using _Myios = basic_ios < _Elem, _Traits >;
    using _Mysb = basic_streambuf < _Elem, _Traits >;
    using _Iter = istreambuf_iterator < _Elem, _Traits >;
    using _Ctype = ctype < _Elem >;
    using _Nget = num_get < _Elem, _Iter >;









    explicit basic_istream ( _Mysb * _Strbuf, bool _Isstd = false ) : _Chcount ( 0 ) {
        _Myios :: init ( _Strbuf, _Isstd );
    }

     basic_istream ( _Uninitialized ) {
        this -> _Addstd ( this );
    }

protected :
     basic_istream ( basic_istream && _Right ) noexcept ( false ) : _Chcount ( _Right . _Chcount ) {
        _Myios :: init ( );
        _Myios :: move ( :: std :: move ( _Right ) );
        _Right . _Chcount = 0;
    }

    basic_istream & operator = ( basic_istream && _Right ) noexcept {
        this -> swap ( _Right );
        return * this;
    }

    void swap ( basic_istream & _Right ) noexcept {
        _Myios :: swap ( _Right );
        :: std :: swap ( _Chcount, _Right . _Chcount );
    }

public :
     basic_istream ( const basic_istream & ) = delete;
    basic_istream & operator = ( const basic_istream & ) = delete;

     ~ basic_istream ( ) noexcept override { }

    using int_type = typename _Traits :: int_type;
    using pos_type = typename _Traits :: pos_type;
    using off_type = typename _Traits :: off_type;

    class _Sentry_base {
    public :
         _Sentry_base ( basic_istream & _Istr ) : _Myistr ( _Istr ) {
            const auto _Rdbuf = _Myistr . rdbuf ( );
            if ( _Rdbuf ) {
                _Rdbuf -> _Lock ( );
            }
        }

         ~ _Sentry_base ( ) noexcept {
            const auto _Rdbuf = _Myistr . rdbuf ( );
            if ( _Rdbuf ) {
                _Rdbuf -> _Unlock ( );
            }
        }

        basic_istream & _Myistr;

        _Sentry_base & operator = ( const _Sentry_base & ) = delete;
    };

    class sentry : public _Sentry_base {
    public :
        explicit sentry ( basic_istream & _Istr, bool _Noskip = false )
            : _Sentry_base ( _Istr ), _Ok ( _Sentry_base :: _Myistr . _Ipfx ( _Noskip ) ) { }

        explicit operator bool ( ) const {
            return _Ok;
        }

         sentry ( const sentry & ) = delete;
        sentry & operator = ( const sentry & ) = delete;

    private :
        bool _Ok;
    };

    bool _Ipfx ( bool _Noskip = false ) {
        if ( ! this -> good ( ) ) {
            _Myios :: setstate ( ios_base :: failbit );
            return false;
        }


        const auto _Tied = _Myios :: tie ( );
        if ( _Tied ) {
            _Tied -> flush ( );
        }

        bool _Eof = false;
        if ( ! _Noskip && this -> flags ( ) & ios_base :: skipws ) {
            const _Ctype & _Ctype_fac = :: std :: use_facet < _Ctype > ( this -> getloc ( ) );

            try {
            int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

            for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                    _Eof = true;
                    break;
                } else if ( ! _Ctype_fac . is ( _Ctype :: space, _Traits :: to_char_type ( _Meta ) ) ) {
                    break;
                }
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        if ( _Eof ) {
            _Myios :: setstate ( ios_base :: eofbit | ios_base :: failbit );
        }

        return this -> good ( );
    }






    [ [ deprecated ( "warning STL4045: The ipfx(), isfx(), opfx(), and osfx() functions are removed before C++98 (see WG21-N0794) but kept as non-Stan" "dard extensions. They will be removed in the future, and the member classes sentry should be used instead. You can define _SILEN" "CE_IO_PFX_SFX_DEPRECATION_WARNING or _SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS to suppress this warning." ) ] ] bool ipfx ( bool _Noskip = false ) {

        return _Ipfx ( _Noskip );
    }


    [ [ deprecated ( "warning STL4045: The ipfx(), isfx(), opfx(), and osfx() functions are removed before C++98 (see WG21-N0794) but kept as non-Stan" "dard extensions. They will be removed in the future, and the member classes sentry should be used instead. You can define _SILEN" "CE_IO_PFX_SFX_DEPRECATION_WARNING or _SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS to suppress this warning." ) ] ] void isfx ( ) { }




















    basic_istream & operator >> ( basic_istream & ( __cdecl * _Pfn ) ( basic_istream & ) ) {

        return _Pfn ( * this );
    }

    basic_istream & operator >> ( _Myios & ( __cdecl * _Pfn ) ( _Myios & ) ) {
        _Pfn ( * this );
        return * this;
    }

    basic_istream & operator >> ( ios_base & ( __cdecl * _Pfn ) ( ios_base & ) ) {
        _Pfn ( * this );
        return * this;
    }

private :
    template < class _Ty >
    basic_istream & _Common_extract_with_num_get ( _Ty & _Val ) {
        ios_base :: iostate _Err = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            try {
            :: std :: use_facet < _Nget > ( this -> getloc ( ) ) . get ( * this, { }, * this, _Err, _Val );
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _Err );
        return * this;
    }

    template < class = void >
    void _Increment_gcount ( ) noexcept {
        if ( _Chcount != :: std :: _Max_limit < streamsize > ( ) ) {
            ++ _Chcount;
        }
    }

public :
    basic_istream & operator >> ( bool & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( short & _Val ) {
        ios_base :: iostate _Err = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            try {
            long _Lval;
            :: std :: use_facet < _Nget > ( this -> getloc ( ) ) . get ( * this, { }, * this, _Err, _Lval );
            if ( _Lval < ( - 32768 ) ) {
                _Err |= ios_base :: failbit;
                _Val = ( - 32768 );
            } else if ( _Lval > 32767 ) {
                _Err |= ios_base :: failbit;
                _Val = 32767;
            } else {
                _Val = static_cast < short > ( _Lval );
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _Err );
        return * this;
    }









    basic_istream & operator >> ( unsigned short & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( int & _Val ) {
        static_assert ( sizeof ( int ) == sizeof ( long ), "Bad overflow assumptions due to sizeof(int) != sizeof(long)" );
        long _Result = _Val;
        _Common_extract_with_num_get ( _Result );
        _Val = _Result;
        return * this;
    }

    basic_istream & operator >> ( unsigned int & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( long & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( unsigned long & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( long long & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( unsigned long long & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( float & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( double & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( long double & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( void * & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( _Mysb * _Strbuf ) {
        _Chcount = 0;
        const sentry _Ok ( * this, true );
        ios_base :: iostate _State = ios_base :: goodbit;
        if ( _Ok && _Strbuf ) {
            try {
            for ( int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                    _State |= ios_base :: eofbit;
                    break;
                }

                try {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Strbuf -> sputc ( _Traits :: to_char_type ( _Meta ) ) ) ) {
                    break;
                }

                } catch ( ... ) {
                break;
                }

                _Increment_gcount ( );
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        if ( _Chcount == 0 ) {
            _State |= ios_base :: failbit;
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    int_type get ( ) {
        int_type _Meta = 0;
        ios_base :: iostate _State = ios_base :: goodbit;
        _Chcount = 0;
        const sentry _Ok ( * this, true );

        if ( ! _Ok ) {
            _Meta = _Traits :: eof ( );
        } else {
            try {
            _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                _State |= ios_base :: eofbit | ios_base :: failbit;
            } else {
                _Myios :: rdbuf ( ) -> sbumpc ( );
                _Chcount = 1;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return _Meta;
    }

    basic_istream & get ( _Elem * _Str, streamsize _Count ) {
        return get ( _Str, _Count, _Myios :: widen ( '\n' ) );
    }

    basic_istream & get ( _Elem * _Str, streamsize _Count, _Elem _Delim ) {

        ios_base :: iostate _State = ios_base :: goodbit;
        _Chcount = 0;


        const _Null_terminator_guard < _Elem > _Guard { 0 < _Count ? & _Str : nullptr };

        const sentry _Ok ( * this, true );

        if ( _Ok && 0 < _Count ) {
            try {
            int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

            for (; 0 < -- _Count; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                    _State |= ios_base :: eofbit;
                    break;
                } else if ( _Traits :: to_char_type ( _Meta ) == _Delim ) {
                    break;
                } else {
                    * _Str ++ = _Traits :: to_char_type ( _Meta );
                    _Increment_gcount ( );
                }
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _Chcount == 0 ? _State | ios_base :: failbit : _State );
        return * this;
    }

    basic_istream & get ( _Elem & _Ch ) {
        int_type _Meta = get ( );
        if ( ! _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
            _Ch = _Traits :: to_char_type ( _Meta );
        }

        return * this;
    }

    basic_istream & get ( _Mysb & _Strbuf ) {
        return get ( _Strbuf, _Myios :: widen ( '\n' ) );
    }

    basic_istream & get ( _Mysb & _Strbuf, _Elem _Delim ) {

        ios_base :: iostate _State = ios_base :: goodbit;
        _Chcount = 0;
        const sentry _Ok ( * this, true );

        if ( _Ok ) {
            try {
            int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

            for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                    _State |= ios_base :: eofbit;
                    break;
                } else {
                    try {
                    _Elem _Ch = _Traits :: to_char_type ( _Meta );
                    if ( _Ch == _Delim || _Traits :: eq_int_type ( _Traits :: eof ( ), _Strbuf . sputc ( _Ch ) ) ) {
                        break;
                    }
                    } catch ( ... ) {
                    break;
                    }
                    _Increment_gcount ( );
                }
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        if ( _Chcount == 0 ) {
            _State |= ios_base :: failbit;
        }
        _Myios :: setstate ( _State );
        return * this;
    }

    basic_istream & getline ( _Elem * _Str, streamsize _Count ) {

        return getline ( _Str, _Count, _Myios :: widen ( '\n' ) );
    }

    basic_istream & getline ( _Elem * _Str, streamsize _Count, _Elem _Delim ) {

        ios_base :: iostate _State = ios_base :: goodbit;
        _Chcount = 0;


        const _Null_terminator_guard < _Elem > _Guard { 0 < _Count ? & _Str : nullptr };

        const sentry _Ok ( * this, true );

        if ( _Ok && 0 < _Count ) {
            int_type _Metadelim = _Traits :: to_int_type ( _Delim );

            try {
            int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

            for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                    _State |= ios_base :: eofbit;
                    break;
                } else if ( _Meta == _Metadelim ) {
                    _Increment_gcount ( );
                    _Myios :: rdbuf ( ) -> sbumpc ( );
                    break;
                } else if ( -- _Count <= 0 ) {
                    _State |= ios_base :: failbit;
                    break;
                } else {
                    * _Str ++ = _Traits :: to_char_type ( _Meta );
                    _Increment_gcount ( );
                }
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _Chcount == 0 ? _State | ios_base :: failbit : _State );
        return * this;
    }

    basic_istream & ignore ( streamsize _Count = 1, int_type _Metadelim = _Traits :: eof ( ) ) {

        ios_base :: iostate _State = ios_base :: goodbit;
        _Chcount = 0;
        const sentry _Ok ( * this, true );

        if ( _Ok && 0 < _Count ) {
            try {
            for (;; ) {
                int_type _Meta;
                if ( _Count != :: std :: _Max_limit < streamsize > ( ) && -- _Count < 0 ) {
                    break;
                } else if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
                               _Meta = _Myios :: rdbuf ( ) -> sbumpc ( ) ) ) {
                    _State |= ios_base :: eofbit;
                    break;
                } else {
                    _Increment_gcount ( );
                    if ( _Meta == _Metadelim ) {
                        break;
                    }
                }
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_istream & read ( _Elem * _Str, streamsize _Count ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        _Chcount = 0;
        const sentry _Ok ( * this, true );

        if ( _Ok && 0 < _Count ) {
            try {
            const streamsize _Num = _Myios :: rdbuf ( ) -> sgetn ( _Str, _Count );
            _Chcount = _Num;

            if ( _Num != _Count ) {
                _State |= ios_base :: eofbit | ios_base :: failbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    streamsize readsome ( _Elem * _Str, streamsize _Count ) {

        ios_base :: iostate _State = ios_base :: goodbit;
        _Chcount = 0;
        const sentry _Ok ( * this, true );
        streamsize _Num;

        if ( ! _Ok ) {
            _State |= ios_base :: failbit;
        } else if ( ( _Num = _Myios :: rdbuf ( ) -> in_avail ( ) ) < 0 ) {
            _State |= ios_base :: eofbit;
        } else if ( 0 < _Count && 0 < _Num ) {
            read ( _Str, _Num < _Count ? _Num : _Count );
        }

        _Myios :: setstate ( _State );
        return gcount ( );
    }

    int_type peek ( ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        _Chcount = 0;
        int_type _Meta = 0;
        const sentry _Ok ( * this, true );

        if ( ! _Ok ) {
            _Meta = _Traits :: eof ( );
        } else {
            try {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta = _Myios :: rdbuf ( ) -> sgetc ( ) ) ) {
                _State |= ios_base :: eofbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return _Meta;
    }

    basic_istream & putback ( _Elem _Ch ) {
        _Chcount = 0;
        ios_base :: iostate _State = ios_base :: goodbit;
        ios_base :: iostate _Oldstate = _Myios :: rdstate ( );
        _Myios :: clear ( _Oldstate & ~ ios_base :: eofbit );
        const sentry _Ok ( * this, true );

        if ( _Ok ) {
            try {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Myios :: rdbuf ( ) -> sputbackc ( _Ch ) ) ) {
                _State |= ios_base :: badbit | _Oldstate;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_istream & unget ( ) {
        _Chcount = 0;
        ios_base :: iostate _State = ios_base :: goodbit;
        ios_base :: iostate _Oldstate = _Myios :: rdstate ( );
        _Myios :: clear ( _Oldstate & ~ ios_base :: eofbit );
        const sentry _Ok ( * this, true );

        if ( _Ok ) {
            try {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Myios :: rdbuf ( ) -> sungetc ( ) ) ) {
                _State |= ios_base :: badbit | _Oldstate;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    [ [ nodiscard ] ] streamsize gcount ( ) const noexcept {

        return _Chcount;
    }

    int sync ( ) {
        const sentry _Ok ( * this, true );

        const auto _Rdbuf = _Myios :: rdbuf ( );
        if ( ! _Rdbuf ) {
            return - 1;
        }

        ios_base :: iostate _State = ios_base :: goodbit;
        try {
        if ( _Rdbuf -> pubsync ( ) == - 1 ) {
            _State |= ios_base :: badbit;
        }
        } catch ( ... ) {
        _Myios :: setstate ( ios_base :: badbit, true );
        return - 1;
        }

        if ( _State & ios_base :: badbit ) {
            _Myios :: setstate ( ios_base :: badbit );
            return - 1;
        }

        return 0;
    }

    basic_istream & seekg ( pos_type _Pos ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        ios_base :: iostate _Oldstate = _Myios :: rdstate ( );
        _Myios :: clear ( _Oldstate & ~ ios_base :: eofbit );
        const sentry _Ok ( * this, true );

        if ( ! this -> fail ( ) ) {
            try {
            if ( static_cast < off_type > ( _Myios :: rdbuf ( ) -> pubseekpos ( _Pos, ios_base :: in ) ) == - 1 ) {
                _State |= ios_base :: failbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_istream & seekg ( off_type _Off, ios_base :: seekdir _Way ) {

        ios_base :: iostate _State = ios_base :: goodbit;
        ios_base :: iostate _Oldstate = _Myios :: rdstate ( );
        _Myios :: clear ( _Oldstate & ~ ios_base :: eofbit );
        const sentry _Ok ( * this, true );

        if ( ! this -> fail ( ) ) {
            try {
            if ( static_cast < off_type > ( _Myios :: rdbuf ( ) -> pubseekoff ( _Off, _Way, ios_base :: in ) ) == - 1 ) {
                _State |= ios_base :: failbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    pos_type tellg ( ) {
        const sentry _Ok ( * this, true );

        if ( ! this -> fail ( ) ) {
            try {
            return _Myios :: rdbuf ( ) -> pubseekoff ( 0, ios_base :: cur, ios_base :: in );
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        return pos_type { off_type { - 1 } };
    }

private :
    streamsize _Chcount { };
};
#line 712 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\istream"
#pragma vtordisp(pop)
#line 745 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\istream"
template < class _Elem, class _Traits >
class basic_iostream : public basic_istream < _Elem, _Traits >,
                       public basic_ostream < _Elem, _Traits > {
public :
    using _Myis = basic_istream < _Elem, _Traits >;
    using _Myos = basic_ostream < _Elem, _Traits >;
    using _Myios = basic_ios < _Elem, _Traits >;
    using char_type = _Elem;
    using traits_type = _Traits;
    using int_type = typename _Traits :: int_type;
    using pos_type = typename _Traits :: pos_type;
    using off_type = typename _Traits :: off_type;

    explicit basic_iostream ( basic_streambuf < _Elem, _Traits > * _Strbuf )
        : _Myis ( _Strbuf, false ), _Myos ( _Noinit, false ) { }

protected :
     basic_iostream ( basic_iostream && _Right ) noexcept ( false )
        : _Myis ( _Right . rdbuf ( ), false ), _Myos ( _Noinit, false ) {
        _Myios :: init ( );
        _Myios :: move ( :: std :: move ( _Right ) );
    }

    basic_iostream & operator = ( basic_iostream && _Right ) noexcept {
        this -> swap ( _Right );
        return * this;
    }

    void swap ( basic_iostream & _Right ) noexcept {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Myios :: swap ( _Right );
        }
    }

public :
     basic_iostream ( const basic_iostream & ) = delete;
    basic_iostream & operator = ( const basic_iostream & ) = delete;

     ~ basic_iostream ( ) noexcept override { }
};
#line 798 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\istream"
template < class _Elem, class _Traits >
basic_istream < _Elem, _Traits > & _Istream_extract_into_buffer (
    basic_istream < _Elem, _Traits > & _Istr, size_t _Size, _Elem * _Str ) {
    using _Myis = basic_istream < _Elem, _Traits >;
    using _Ctype = ctype < _Elem >;
    ios_base :: iostate _State = ios_base :: goodbit;
    size_t _Current = 0;
    const typename _Myis :: sentry _Ok ( _Istr );

    if ( _Ok ) {
        const _Ctype & _Ctype_fac = :: std :: use_facet < _Ctype > ( _Istr . getloc ( ) );

        try {
        size_t _Count = _Size;
        const size_t _Width = static_cast < size_t > ( _Istr . width ( ) );
        if ( _Width > 0 && _Width < _Size ) {
            _Count = _Width;
        }

        typename _Myis :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );
        _Elem _Ch;

        for (; _Current < _Count - 1; _Meta = _Istr . rdbuf ( ) -> snextc ( ), ( void ) ++ _Current ) {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                _State |= ios_base :: eofbit;
                break;
            } else if ( _Ctype_fac . is ( _Ctype :: space, _Ch = _Traits :: to_char_type ( _Meta ) ) || _Ch == _Elem ( ) ) {
                break;
            } else {
                _Str [ _Current ] = _Traits :: to_char_type ( _Meta );
            }
        }
        } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
    }
    ;
    _Str [ _Current ] = _Elem ( );
    _Istr . width ( 0 );
    if ( _Current == 0 ) {
        _State |= ios_base :: failbit;
    }
    _Istr . setstate ( _State );
    return _Istr;
}
#line 864 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\istream"
template < class _Elem, class _Traits >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr, _Elem * _Str ) {
    return _Istream_extract_into_buffer ( _Istr, 18446744073709551615Ui64, _Str );
}
#line 869
template < class _Traits >
basic_istream < char, _Traits > & operator >> ( basic_istream < char, _Traits > & _Istr, signed char * _Str ) {
    return _Istream_extract_into_buffer ( _Istr, 18446744073709551615Ui64, reinterpret_cast < char * > ( _Str ) );
}
#line 874
template < class _Traits >
basic_istream < char, _Traits > & operator >> ( basic_istream < char, _Traits > & _Istr, unsigned char * _Str ) {
    return _Istream_extract_into_buffer ( _Istr, 18446744073709551615Ui64, reinterpret_cast < char * > ( _Str ) );
}
#line 880 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\istream"
template < class _Elem, class _Traits >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr, _Elem & _Ch ) {
    using _Myis = basic_istream < _Elem, _Traits >;

    typename _Myis :: int_type _Meta;
    ios_base :: iostate _State = ios_base :: goodbit;
    const typename _Myis :: sentry _Ok ( _Istr );

    if ( _Ok ) {
        try {
        _Meta = _Istr . rdbuf ( ) -> sbumpc ( );
        if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
            _State |= ios_base :: eofbit | ios_base :: failbit;
        } else {
            _Ch = _Traits :: to_char_type ( _Meta );
        }
        } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
    }

    _Istr . setstate ( _State );
    return _Istr;
}
#line 903
template < class _Traits >
basic_istream < char, _Traits > & operator >> ( basic_istream < char, _Traits > & _Istr, signed char & _Ch ) {

    return _Istr >> reinterpret_cast < char & > ( _Ch );
}
#line 909
template < class _Traits >
basic_istream < char, _Traits > & operator >> ( basic_istream < char, _Traits > & _Istr, unsigned char & _Ch ) {

    return _Istr >> reinterpret_cast < char & > ( _Ch );
}
#line 915
template< class _Istr, class _Ty, class  = void> 
#line 916
struct _Can_stream_in : public false_type { }; 
#line 918
template< class _Istr, class _Ty> 
#line 919
struct _Can_stream_in< _Istr, _Ty, void_t< decltype(std::declval< _Istr &> () >> std::declval< _Ty> ())> >  : public true_type { }; 
#line 921
template < class _Istr, class _Ty,
    enable_if_t < conjunction_v < is_convertible < _Istr *, ios_base * >, _Can_stream_in < _Istr, _Ty > >, int > = 0 >
_Istr && operator >> ( _Istr && _Is, _Ty && _Val ) {
    _Is >> :: std :: forward < _Ty > ( _Val );
    return :: std :: move ( _Is );
}
#line 928
template < class _Elem, class _Traits >
basic_istream < _Elem, _Traits > & __cdecl ws ( basic_istream < _Elem, _Traits > & _Istr ) {
    const typename basic_istream < _Elem, _Traits > :: sentry _Ok ( _Istr, true );

    if ( _Ok ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const auto & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Istr . getloc ( ) );

        try {
        for ( typename _Traits :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );; _Meta = _Istr . rdbuf ( ) -> snextc ( ) ) {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                _State |= ios_base :: eofbit;
                break;
            } else if ( ! _Ctype_fac . is ( ctype < _Elem > :: space, _Traits :: to_char_type ( _Meta ) ) ) {
                break;
            }
        }
        } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
        _Istr . setstate ( _State );
    }

    return _Istr;
}
#line 951
}
#line 955
#pragma warning(pop)
#pragma pack ( pop )
#line 18 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ostream"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 25
namespace std { 
#line 339 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ostream"
}
#line 343
#pragma warning(pop)
#pragma pack ( pop )
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iostream"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294 4984 5053 )
#line 19
namespace std { 
#line 39
extern istream cin; 
#line 40
extern ostream cout; 
#line 41
extern ostream cerr; 
#line 42
extern ostream clog; 
#line 43
extern istream *_Ptr_cin; 
#line 44
extern ostream *_Ptr_cout; 
#line 45
extern ostream *_Ptr_cerr; 
#line 46
extern ostream *_Ptr_clog; 
#line 48
extern wistream wcin; 
#line 49
extern wostream wcout; 
#line 50
extern wostream wcerr; 
#line 51
extern wostream wclog; 
#line 52
extern wistream *_Ptr_wcin; 
#line 53
extern wostream *_Ptr_wcout; 
#line 54
extern wostream *_Ptr_wcerr; 
#line 55
extern wostream *_Ptr_wclog; 
#line 69 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\iostream"
}
#line 72
#pragma warning(pop)
#pragma pack ( pop )
#line 5 "main.cu"
using namespace std;
#line 6
void multiplyGPU(int *a, int *b, int *c) ;
#if 0
#line 6
{ 
#line 7
int i = ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)) + (__device_builtin_variable_threadIdx.x); 
#line 8
int j = ((__device_builtin_variable_blockIdx.y) * (__device_builtin_variable_blockDim.y)) + (__device_builtin_variable_threadIdx.y); 
#line 9
if ((i < 289) && (j < 289)) { __int64 sum = (0); 
#line 10
for (int k = 0; k < 289; k++) { 
#line 11
sum += ((a[(i * 289) + k]) * (b[(k * 289) + j])); 
#line 12
}  
#line 13
(c[(i * 289) + j]) = sum; 
#line 14
}  
#line 16
} 
#endif
#line 17 "main.cu"
int random() { 
#line 19
int randomNumber = (rand() % 10) + 1; 
#line 20
return randomNumber; 
#line 21
} 
#line 22
void assignMatrix(int A[289][289]) { 
#line 23
for (int i = 0; i < 289; i++) { 
#line 24
for (int j = 0; j < 289; j++) { ((A[i])[j]) = random(); }  
#line 25
}  
#line 26
} 
#line 27
void multiplyCPU(int matrixA[289][289], int matrixB[289][289], int matrixC[289][289]) { 
#line 28
for (int i = 0; i < 289; i++) { 
#line 29
for (int j = 0; j < 289; j++) { 
#line 30
for (int k = 0; k < 289; k++) { 
#line 31
((matrixC[i])[j]) += (((matrixA[i])[k]) * ((matrixB[k])[j])); 
#line 32
}  
#line 33
}  ; 
#line 34
}  
#line 35
} 
#line 36
void printMatrix(int matrixA[289][289]) { 
#line 37
for (int i = 0; i < 289; i++) { 
#line 38
for (int j = 0; j < 289; j++) { (((cout << ((matrixA[i])[j]))) << (" ")); }  
#line 39
(cout << (endl)); 
#line 40
}  
#line 41
(cout << (endl)); 
#line 42
} 
#line 43
int main() { 
#line 45
cudaEvent_t start, startG, stop, stopG; 
#line 46
srand(time(0)); 
#line 47
int matrixA[289][289]; 
#line 48
int matrixB[289][289]; 
#line 49
int matrixC[289][289] = {0}; 
#line 50
int *d_a, *d_b, *d_c; 
#line 52
cudaEventCreate(&start); 
#line 53
cudaEventCreate(&stop); 
#line 56
assignMatrix(matrixA); 
#line 58
assignMatrix(matrixB); 
#line 62
cudaEventRecord(start, 0); 
#line 63
multiplyCPU(matrixA, matrixB, matrixC); 
#line 64
(cout << (endl)); 
#line 67
cudaEventRecord(stop, 0); 
#line 68
cudaEventSynchronize(stop); 
#line 69
float cpu = (0); 
#line 70
cudaEventElapsedTime(&cpu, start, stop); 
#line 72
cudaEventCreate(&startG); 
#line 73
cudaEventCreate(&stopG); 
#line 74
cudaEventRecord(startG, 0); 
#line 75
dim3 thread(16, 16); 
#line 76
dim3 blocks((289 + 15) / 16, (289 + 15) / 16); 
#line 77
if ((cudaMalloc((void **)(&d_a), (sizeof(int) * (289)) * (289))) != (cudaSuccess)) { (cout << ("No allocation of A")); }  
#line 78
if ((cudaMalloc((void **)(&d_b), (sizeof(int) * (289)) * (289))) != (cudaSuccess)) { (cout << ("No allocation of B")); }  
#line 79
if ((cudaMalloc((void **)(&d_c), (sizeof(int) * (289)) * (289))) != (cudaSuccess)) { (cout << ("No allocation of C")); }  
#line 80
if ((cudaMemcpy(d_a, matrixA, (sizeof(int) * (289)) * (289), cudaMemcpyHostToDevice)) != (cudaSuccess)) { (cout << ("No copy of A")); }  
#line 81
if ((cudaMemcpy(d_b, matrixB, (sizeof(int) * (289)) * (289), cudaMemcpyHostToDevice)) != (cudaSuccess)) { (cout << ("No copy of B")); }  
#line 82
(__cudaPushCallConfiguration(blocks, thread)) ? (void)0 : multiplyGPU(d_a, d_b, d_c); 
#line 83
cudaError_t err = cudaGetLastError(); 
#line 84
if (err != (cudaSuccess)) { 
#line 85
printf("CUDA kernel launch error: %s\n", cudaGetErrorString(err)); 
#line 86
}  
#line 88
cudaMemcpy(matrixC, d_c, (sizeof(int) * (289)) * (289), cudaMemcpyDeviceToHost); 
#line 89
cudaEventRecord(stopG, 0); 
#line 90
cudaEventSynchronize(stopG); 
#line 91
float gpu = (0); 
#line 92
cudaEventElapsedTime(&gpu, startG, stopG); 
#line 95
(((((((((((((((cout << ("CPU TIME: "))) << cpu)) << (" ms"))) << (endl))) << ("GPU TIME: "))) << gpu)) << (" ms"))) << (endl)); 
#line 96
cudaDeviceSynchronize(); 
#line 97
cudaFree(d_a); 
#line 98
cudaFree(d_b); 
#line 99
cudaFree(d_c); 
#line 100
return 0; 
#line 101
} 
#line 1 "main.cudafe1.stub.c"
#define _NV_ANON_NAMESPACE _GLOBAL__N__080bb685_7_main_cu_51f05d7f
#ifdef _NV_ANON_NAMESPACE
#endif
#pragma pack()
#line 1 "main.cudafe1.stub.c"
#include "main.cudafe1.stub.c"
#line 1 "main.cudafe1.stub.c"
#undef _NV_ANON_NAMESPACE
